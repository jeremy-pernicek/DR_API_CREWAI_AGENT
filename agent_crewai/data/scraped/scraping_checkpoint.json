{
  "visited_urls": [
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/key_values.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/training_predictions.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/sharing.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/predict_job.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/batch_predictions.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/prime.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html",
    "https://docs.datarobot.com/en/docs/api/reference/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/credentials.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/compliance-documentation.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/project.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/notebooks.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/blueprint.html",
    "https://docs.datarobot.com/en/docs/api/python-client/reference/",
    "https://docs.datarobot.com/en/docs/api/reference/sdk/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/deployment.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/model.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-connectivity.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/key_values.html",
    "https://docs.datarobot.com/en/docs/api/api-quickstart/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/model_recommendation.html",
    "https://docs.datarobot.com/en/docs/api/reference/sdk/CHANGES.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-exploration.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/use-cases.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/jobs.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/api-object.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/data_exports.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/binary_data_helpers.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
    "https://docs.datarobot.com/en/docs/api/guide/python/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
    "https://docs.datarobot.com/en/docs/feature-engineering/",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/automated_documentation.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/segmented_modeling.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-prompting.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/custom-metrics.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/custom_task.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-llm-generation.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/feature_discovery.html",
    "https://docs.datarobot.com/en/docs/model-management/",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/use_cases.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-monitoring.html",
    "https://docs.datarobot.com/en/docs/api/python-client/",
    "https://docs.datarobot.com/en/docs/api/guide/python/python-modeling.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/custom_model.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/model_registry.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/unsupervised_anomaly.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-vector-databases.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/client-setup.html",
    "https://docs.datarobot.com/en/docs/time-series/",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/dataset.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/unsupervised_clustering.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/shap_insights.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-wrangling.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/rating_table.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/job.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/features.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/external_testset.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/insights.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/datetime_partition.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/challenger-models.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/hosted_custom_metrics.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/visualai.html",
    "https://docs.datarobot.com/en/docs/api/python-client/examples/",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/mlops_event.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/custom-models.html",
    "https://docs.datarobot.com/en/docs/api/sdk/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/custom_metrics.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/applications.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-testing.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/database_connectivity.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/monotonic_constraints.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/binary_data.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/blueprints.html",
    "https://docs.datarobot.com/en/docs/predictions/",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/application-templates.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/prediction_explanations.html",
    "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-moderation.html"
  ],
  "failed_urls": [
    "https://docs.datarobot.com/en/docs/api/sdk/index.html",
    "https://docs.datarobot.com/en/docs/feature-engineering/",
    "https://docs.datarobot.com/en/docs/api/guide/python/python-modeling.html",
    "https://docs.datarobot.com/en/docs/predictions/",
    "https://docs.datarobot.com/en/docs/model-management/",
    "https://docs.datarobot.com/en/docs/api/python-client/reference/",
    "https://docs.datarobot.com/en/docs/time-series/",
    "https://docs.datarobot.com/en/docs/api/python-client/",
    "https://docs.datarobot.com/en/docs/api/python-client/examples/"
  ],
  "scraped_documents": [
    {
      "url": "https://docs.datarobot.com/en/docs/api/reference/sdk/index.html",
      "title": "Python API client\u00b6",
      "description": "",
      "content": "Skip to content\nDataRobot API resources\n>\nAPI reference documentation\n>\nPython API client\nPython API client\u00b6\nThe DataRobot Python client is a library for working with the DataRobot API. To access other clients and additional information about DataRobot\u2019s APIs, visit the API documentation home.\nThe reference documentation outlines the functionality supported by the Python client. For information about specific endpoints, select a topic from the table of contents on the left.\nTo get started with the Python client, reference DataRobot\u2019s API Quickstart guide. This guide outlines how to configure your environment to use the API.\nYou can learn about use cases and experiment with code examples using the Python client in the API user guide.\nIn addition to code examples and use cases, you can browse AI accelerators. AI accelerators are designed to help speed up model experimentation, development, and production readiness using the DataRobot API. They codify and package data science expertise in building and delivering successful machine learning projects into repeatable, code-first workflows and modular building blocks.\nBack to top",
      "links": [
        "https://docs.datarobot.com/en/docs/api/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/index.html",
        "https://docs.datarobot.com/en/docs/api/api-quickstart/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/index.html",
        "https://docs.datarobot.com/en/docs/api/accelerators/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://docs.datarobot.com/en/docs/api/guide/python/index.html",
      "title": "Python API client user guide\u00b6",
      "description": "",
      "content": "Skip to content\nDataRobot API resources\n>\nAPI user guide\n>\nPython API client user guide\nPython API client user guide\u00b6\nTopic\nDescription\nAdministration\nHow to manage DataRobot Self-Managed AI Platform deployments.\nData\nHow to manage data for machine learning, including importing and transforming data, and connecting to data sources.\nMLOps\nHow to deploy, monitor, manage, and govern your models in production.\nModeling\nHow to set modeling parameters before building, use the modeling workflow, and manage models and projects.\nPredictions\nHow to get predictions (\u201cscoring\u201d) on new data from a model.\nUse Cases\nHow to use Use Cases to group everything related to solving a specific business problem.\nBack to top",
      "links": [
        "https://docs.datarobot.com/en/docs/api/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/admin/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/data/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/mlops/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/modeling/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/predictions/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/use_cases/index.html"
      ],
      "page_type": "guide",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://docs.datarobot.com/en/docs/api/api-quickstart/index.html",
      "title": "API quickstart\u00b6",
      "description": "Learn how to begin using the DataRobot REST API to create projects and generate predictions.",
      "content": "Skip to content\nDataRobot API resources\n>\nAPI quickstart\nAPI quickstart\u00b6\nThe DataRobot API provides a programmatic alternative to the web interface for creating and managing DataRobot projects. The API can be used via REST, or DataRobot's Python or R clients in Windows, UNIX, and OS X environments. This guide walks you through setting up your environment and then you can follow a sample problem that outlines an end-to-end workflow for the API.\nNote\nThe API quickstart guide uses methods for 3.x versions of DataRobot's Python client. If you are a Self-Managed AI Platform user, consult the API resources page to verify which versions of DataRobot's clients are supported for your version of the DataRobot application.\nPrerequisites\u00b6\nBefore proceeding, access and install the DataRobot client package for Python or R (instructions are provided below). Review the API Reference documentation to familiarize yourself with the code-first resources available to you.\nPythonR\nThe following prerequisites are for 3.x versions of DataRobot's Python client:\nPython >=3.7\nA registered DataRobot account\npip\nR >= 3.2\nhttr (\u2265 1.2.0)\njsonlite (\u2265 1.0)\nyaml (\u2265 2.1.19)\nA registered DataRobot account\nInstall the client\u00b6\nNote\nSelf-Managed AI Platform users may want to install a previous version of the client in order to match their installed version of the DataRobot application. Reference the available versions to map your installation to the correct version of the API client.\nPythonR\npip install datarobot datarobot-predict\n(Optional) If you would like to build custom blueprints programmatically, install two additional packages: graphviz and blueprint-workshop.\nFor Windows users:\nDownload the graphviz installer\nFor Ubuntu users:\nsudo apt-get install graphviz\nFor Mac users:\nbrew install graphviz\nOnce graphviz is installed, install the workshop:\npip install datarobot-bp-workshop\ninstall.packages(\u201cdatarobot\u201d)\nConfigure your environment\u00b6\nThis section walks through how to execute a complete modeling workflow using the DataRobot API, from uploading a dataset to making predictions on a model deployed in a production environment.\nCreate a DataRobot API key\u00b6\nFrom the DataRobot UI, click the user icon in the top right corner and select API keys and tools.\nClick Create new key.\nName the new key, and click Create. The key is activated and ready for use.\nOnce created, each individual key has three pieces of information:\nLabel\nElement\nDescription\n1\nName\nThe name of the key, which you can edit.\n2\nKey\nThe key value.\n3\nDate created\nThe date the key was created. Newly created and not yet used keys display \u201c\u2014\u201d.\n4\nLast used\nThe date the key was last used.\nRetrieve the API endpoint\u00b6\nDataRobot provides several deployment options to meet your business requirements. Each deployment type has its own set of endpoints. Choose from the tabs below:\nAI Platform (US)AI Platform (EU)AI Platform (JP)Self-Managed AI Platform\nThe AI Platform (US) offering is primarily accessed by US users. It can be accessed at https://app.datarobot.com.\nAPI endpoint root: https://app.datarobot.com/api/v2\nThe AI Platform (EU) offering is primarily accessed by EMEA users. It can be accessed at https://app.eu.datarobot.com.\nAPI endpoint root: https://app.eu.datarobot.com/api/v2\nThe AI Platform (JP) offering is primarily accessed by users in Japan. It can be accessed at https://app.jp.datarobot.com.\nAPI endpoint root: https://app.jp.datarobot.com/api/v2\nFor Self-Managed AI Platform users, the API root will be the same as your DataRobot UI root. In the URL below, replace {datarobot.example.com} with your deployment endpoint.\nAPI endpoint root: https://{datarobot.example.com}/api/v2\nConfigure API authentication\u00b6\nTo authenticate with DataRobot's API, your code needs to have access to an endpoint and token from the previous steps. This can be done in three ways:\ndrconfig.yamlEnvironment variablesEmbed in your code\nDataRobot's recommended authentication method is to use a drconfig.yaml file. This is a file that the DataRobot Python and R clients automatically look for. You can instruct the API clients to look for the file in a specific location, ~/.config/datarobot/drconfig.yaml by default, or under a unique name. Therefore, you can leverage this to have multiple config files. The example below demonstrates the format of the .yaml:\nendpoint: 'https://app.datarobot.com/api/v2'\ntoken: 'NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G'\nOnce created, you can test your access to the API.\nFor Python:\nIf the config file is located at ~/.config/datarobot/drconfig.yaml, then all you need to do is import the library:\nimport datarobot as dr\nOtherwise, use the following command:\nimport datarobot as dr\ndr.Client(config_path = \"<file-path-to-drconfig.yaml>\")\nFor R:\nIf the config file is located at ~/.config/datarobot/drconfig.yaml, then all you need to do is load the library:\nlibrary(datarobot)\nOtherwise, use the following command:\nConnectToDataRobot(configPath = \"<file-path-to-drconfig.yaml>\"))\nFor Windows:\nFor Windows users, open the Command Prompt or PowerShell as an administrator and set the following environment variables:\nsetx DATAROBOT_ENDPOINT \"https://app.datarobot.com/api/v2\"\nsetx DATAROBOT_API_TOKEN \"your_api_token\"\nOnce set, close and reopen the Command Prompt or PowerShell for the changes to take effect.\nTo configure persisting environment variables on Windows, search for \"Environment Variables\" in the Start menu and select Edit the system environment variables.\nThen, click Environment Variables and, under System variables, click New to add the variables shown above.\nFor macOS and Linux:\nFor macOS and Linux users, open a terminal window and set the following environment variables:\nexport DATAROBOT_ENDPOINT=\"https://app.datarobot.com/api/v2\"\nexport DATAROBOT_API_TOKEN=\"your_api_token\"\nTo configure persisting environment variables on macOS or Linux, edit the shell configuration file (~/.bash_profile, ~/.bashrc, or ~/.zshrc) and add the environment variables shown above. Then, save the file and restart your terminal or run source ~/.bash_profile (or use any relevant file).\nOnce the environment variables are set, authenticate to connect to DataRobot.\nFor Python:\nimport datarobot as dr\ndr.Project.list()\nFor R:\nlibrary(datarobot)\nFor cURL:\ncurl --location -X GET \"${DATAROBOT_API_ENDPOINT}/projects\" --header \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\"\n(Optional) Be cautious to never commit your credentials to Git.\nFor Python:\nimport datarobot as dr\ndr.Client(endpoint='https://app.datarobot.com/api/v2', token='NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G')\nFor R:\nConnectToDataRobot(endpoint =\n\"https://app.datarobot.com/api/v2\",\ntoken =\n'NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G')\nFor cURL:\nGET https://app.datarobot.com/api/v2/ HTTP/1.1\nAuthorization: Bearer DnwzBUNTOtKBO6Sp1hoUByG4YgZwCCw4\nUse the API: Predicting fuel economy\u00b6\nOnce the API credentials, endpoints, and environment are configured, use the DataRobot API to follow this example.\nThe example uses the Python client and the REST API (using cURL), so a basic understanding of Python3 or cURL is required.\nIt progresses through a simple problem: predicting the miles-per-gallon fuel economy from known automobile data (e.g., vehicle weight, number of cylinders, etc.).\nFor additional code examples, reference DataRobot's AI accelerators.\nNote\nThe following workflow uses methods introduced in version 3.0 of the Python client. Ensure that the client is up-to-date before executing the code included in this example.\nThe following sections provide sample code for Python and cURL that will:\nUpload a dataset.\nTrain a model to learn from the dataset.\nTest prediction outcomes on the model with new data.\nDeploy the model.\nPredict outcomes on the deployed model using new data.\nUpload a dataset\u00b6\nThe first step to create a project is uploading a dataset. This example uses the dataset auto-mpg.csv and its supporting test dataset, auto-mpg-test.csv, both of which you can download here.\nPythoncURLR\nimport datarobot as dr\ndr.Client(config_path = \"./drconfig.yaml\")\n# Set to the location of your auto-mpg.csv and auto-mpg-test.csv data files\n# Example: dataset_file_path = '/Users/myuser/Downloads/auto-mpg.csv'\ntraining_dataset_file_path = './auto-mpg.csv'\ntest_dataset_file_path = './auto-mpg-test.csv'\nprint(\"--- Starting DataRobot Model Training Script ---\")\n# Load dataset\ntraining_dataset = dr.Dataset.create_from_file(training_dataset_file_path)\n# Create a new project based on dataset\nproject = dr.Project.create_from_dataset(training_dataset.id, project_name='Auto MPG DR-Client')\nDATAROBOT_API_TOKEN=${DATAROBOT_API_TOKEN}\nDATAROBOT_ENDPOINT=${DATAROBOT_ENDPOINT}\nlocation=$(curl -Lsi \\\n-X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-F 'projectName=\"Auto MPG\"' \\\n-F \"file=@${DATASET_FILE_PATH}\" \\\n\"${DATAROBOT_ENDPOINT}\"/projects/ | grep -i 'Location: .*$' | \\\ncut -d \" \" -f2 | tr -d '\\r')\necho \"Uploaded dataset. Checking status of project at: ${location}\"\nwhile true; do\nproject_id=$(curl -Ls \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${location}\" \\\n| grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nif [ \"${project_id}\" = \"\" ]\nthen\necho \"Setting up project...\"\nsleep 10\nelse\necho \"Project setup complete.\"\necho \"Project ID: ${project_id}\"\nbreak\nfi\ndone\n# Set to the location of your auto-mpg.csv and auto-mpg-test.csv data files\n# Example: dataset_file_path = '/Users/myuser/Downloads/auto-mpg.csv'\ntraining_dataset_file_path <- \"\"\ntest_dataset_file_path <- \"\"\ntraining_dataset <- utils::read.csv(training_dataset_file_path)\ntest_dataset <- utils::read.csv(test_dataset_file_path)\nhead(training_dataset)\nproject <- SetupProject(dataSource = training_dataset, projectName = \"Auto MPG DR-Client\", maxWait = 60 * 60)\nTrain models\u00b6\nNow that DataRobot has data, it can use the data to train and build models with Autopilot.\nAutopilot is DataRobot's \"survival of the fittest\" modeling mode that automatically selects the best predictive models for the specified target feature and runs them at increasing sample sizes.\nThe outcome of Autopilot is not only a selection of best-suited models, but also identification of a recommended model\u2014the model that best understands how to predict the target feature \"mpg\".\nChoosing the best model is a balance of accuracy, metric performance, and model simplicity.\nYou can read more about the model recommendation process in the UI documentation.\nNote\nThis code opens a browser window to display progress in the DataRobot classic UI. Once the window has opened, click the NextGen UI drop-down and select Console to view the deployment once it is complete.\nPythoncURLR\n# Use training data to build models\nfrom datarobot import AUTOPILOT_MODE\n# Set the project's target and initiate Autopilot (runs in Quick mode unless a different mode is specified)\nproject.analyze_and_model(target='mpg', worker_count=-1, mode=AUTOPILOT_MODE.QUICK)\nprint(\"\\nAutopilot is running. This may take some time...\")\nproject.wait_for_autopilot()\nprint(\"Autopilot has completed!\")\n# Open the project in a web browser to view progress\nprint(\"Opening the project in your default web browser to view real-time events...\")\nproject.open_in_browser()\n# Get the recommended model (the best model for deployment)\nprint(\"\\nRetrieving the best model from the Leaderboard...\")\nbest_model = project.recommended_model()\nprint(f\"Best Model Found:\")\nprint(f\"  - Model Type: {best_model.model_type}\")\nprint(f\"  - Blueprint ID: {best_model.blueprint_id}\")\nresponse=$(curl -Lsi \\\n-X PATCH \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-H \"Content-Type: application/json\" \\\n--data '{\"target\": \"mpg\", \"mode\": \"quick\"}' \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/aim\" | grep 'location: .*$' \\\n| cut -d \" \" | tr -d '\\r')\necho \"AI training initiated. Checking status of training at: ${response}\"\nwhile true; do\ninitial_project_status=$(curl -Ls \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${response}\" \\\n| grep -Eo 'stage\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nif [ \"${initial_project_status}\" = \"\" ]\nthen\necho \"Setting up AI training...\"\nsleep 10\nelse\necho \"Training AI.\"\necho \"Grab a coffee or catch up on email.\"\nbreak\nfi\ndone\nproject_status=$(curl -Lsi \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/status\" \\\n| grep -Eo 'autopilotDone\":\\strue'\n)\nif [ \"${project_status}\" = \"\" ]\nthen\necho \"Autopilot training in progress...\"\nsleep 60\nelse\necho \"Autopilot training complete. Model ready to deploy.\"\nbreak\nfi\ndone\n# Set the project target and initiate Autopilot\nSetTarget(project,\ntarget = \"mpg\")\n# Block execution until Autopilot is complete\nWaitForAutopilot(project)\nmodel <- GetRecommendedModel(project, type = RecommendedModelType$RecommendedForDeployment)\nDeploy the model\u00b6\nDeployment is the method by which you integrate a machine learning model into an existing production environment to make predictions with live data and generate insights. See the deployment overview for more information.\nPythoncURLR\n# Deploy the model to a serverless prediction environment\nprint(\"\\nDeploying the model to a serverless prediction environment...\")\n# Find or create a serverless prediction environment\nserverless_env = None\nfor env in dr.PredictionEnvironment.list():\nif env.platform == 'datarobotServerless':\nserverless_env = env\nbreak\nif serverless_env is None:\nprint(\"Creating a new serverless prediction environment...\")\nserverless_env = dr.PredictionEnvironment.create(\nname=\"Auto MPG Serverless Environment\",\nplatform='datarobotServerless'\n)\n# First, register the model to create a registered model version\nprint(\"Registering the model...\")\n# Check if the registered model already exists\nregistered_model_name = \"Auto MPG Registered Model\"\nexisting_models = [m for m in dr.RegisteredModel.list() if m.name == registered_model_name]\nif existing_models:\nprint(f\"Using existing registered model: {registered_model_name}\")\nregistered_model = existing_models[0]\n# Create a new version of the existing model\nregistered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\nbest_model.id,\nname=\"Auto MPG Model\",\nregistered_model_id=registered_model.id\n)\nelse:\nprint(f\"Creating new registered model: {registered_model_name}\")\n# Create a new registered model\nregistered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\nbest_model.id,\nname=\"Auto MPG Model\",\nregistered_model_name=registered_model_name\n)\n# Retrieve the newly created registered model object by ID\nregistered_model = dr.RegisteredModel.get(registered_model_version.registered_model_id)\n# Wait for the model build to complete\nprint(\"Waiting for model build to complete...\")\nwhile True:\ncurrent_version = registered_model.get_version(registered_model_version.id)\nif current_version.build_status in ('READY', 'complete'):\nprint(\"Model build completed successfully!\")\nregistered_model_version = current_version  # Update our reference\nbreak\nelif current_version.build_status == 'FAILED':\nraise Exception(\"Model build failed. Please check the model registration.\")\nelse:\nprint(f\"Build status: {current_version.build_status}. Waiting...\")\nimport time\ntime.sleep(30)  # Wait 30 seconds before checking again\n# Deploy the model to the serverless environment using the registered model version\ndeployment = dr.Deployment.create_from_registered_model_version(\nregistered_model_version.id,\nlabel=\"Auto MPG Predictions\",\ndescription=\"Deployed with DataRobot client for Auto MPG predictions\",\nprediction_environment_id=serverless_env.id\n)\nprint(f\"Model deployed successfully! Deployment ID: {deployment.id}\")\nrecommended_model_id=$(curl -s \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/recommendedModels\"\\\n\"/recommendedModel/\" \\\n| grep -Eo 'modelId\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nserver_data=$(curl -s -X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/predictionServers/\")\ndefault_server_id=$(echo $server_data \\\n| grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nserver_url=$(echo $server_data | grep -Eo 'url\":\\s\".*?\"' \\\n| cut -d '\"' -f3 | tr -d '\\r')\nserver_key=$(echo $server_data | grep -Eo 'datarobot-key\":\\s\".*?\"' \\\n| cut -d '\"' -f3 | tr -d '\\r')\nrequest_data=\"{\\\n\\\"defaultPredictionServerId\\\":\\\"${default_server_id}\\\",\\\n\\\"modelId\\\":\\\"${recommended_model_id}\\\",\\\n\\\"description\\\":\\\"Deployed with cURL\\\",\\\n\\\"label\\\":\\\"MPG Prediction Server\\\"\\\n}\"\ndeployment_response=$(curl -Lsi -X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-H \"Content-Type: application/json\" \\\n--data \"${request_data}\" \\\n\"${DATAROBOT_ENDPOINT}/deployments/fromLearningModel/\")\ndeploy_response_code_202=$(echo $deployment_response | grep -Eo 'HTTP/2 202')\nif [ \"${deploy_response_code_202}\" = \"\" ]\nthen\ndeployment_id=$(echo \"$deployment_response\" | grep -Eo 'id\":\\s\"\\w+' \\\n| cut -d '\"' -f3 | tr -d '\\r')\necho \"Prediction server ready.\"\nelse\ndeployment_status=$(echo \"$deployment_response\" | grep -Eo 'location: .*$' \\\n| cut -d \" \" | tr -d '\\r')\nwhile true; do\ndeployment_ready=$(curl -Ls \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${deployment_status}\" \\\n| grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nif [ \"${deployment_ready}\" = \"\" ]\nthen\necho \"Waiting for deployment...\"\nsleep 10\nelse\ndeployment_id=$deployment_ready\necho \"Prediction server ready.\"\nbreak\nfi\ndone\nfi\npredictionServer <- ListPredictionServers()[[1]]\ndeployment <- CreateDeployment(model,\nlabel = \"MPG Prediction Server\",\ndescription = \"Deployed with DataRobot client\",\ndefaultPredictionServerId = predictionServer)\nMake predictions against the deployed model\u00b6\nWhen you have successfully deployed a model, you can use the DataRobot Prediction API to further test the model by making predictions on new data. This allows you to access advanced model management features such as data drift, accuracy, and service health statistics.\nDataRobot offers several methods for making predictions on new data. You can read more about prediction methods in the UI documentation. You can also reference a Python prediction snippet from the UI. Navigate to the Deployments page, select your deployment, and go to Predictions > Prediction API to reference the snippet for making predictions.\nPythoncURLR\nThis code makes predictions on the model using the test set you identified in the first step (test_dataset_file_path), when you uploaded data.\n# Make predictions on test data\nprint(\"\\nMaking predictions on test data...\")\n# Read the test data directly\nimport pandas as pd\nfrom datarobot_predict.deployment import predict\ntest_data = pd.read_csv(test_dataset_file_path)\n# Use datarobot-predict for deployment predictions\npredictions, response_headers = predict(deployment, test_data)\n# Display the results\nprint(\"\\nPrediction Results:\")\nprint(predictions.head())\nprint(f\"\\nTotal predictions made: {len(predictions)}\")\nThis code makes predictions on the recommended model using the test set identified in the first step (test_dataset_file_path), when you uploaded data.\n# Test predictions on new data\n# shellcheck disable=SC2089\nprediction_location=$(curl -Lsi\\\n-X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-F \"file=@${TEST_DATASET_FILE_PATH}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/predictionDatasets/fileUploads/\"\\\n| grep -i 'location: .*$' | cut -d \" \" -f2 | tr -d '\\r')\necho \"Uploaded prediction dataset. Checking status of upload at: ${prediction_location}\"\nwhile true; do\nprediction_dataset_id=$(curl -Ls \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${prediction_location}\" \\\n| grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nif [ \"${prediction_dataset_id}\" = \"\" ]\nthen\necho \"Uploading predictions...\"\nsleep 10\nelse\necho \"Predictions upload complete.\"\necho \"Predictions dataset ID: ${prediction_dataset_id}\"\nbreak\nfi\ndone\nprediction_request_data=\"{\\\n\\\"modelId\\\":\\\"${recommended_model_id}\\\",\\\n\\\"datasetId\\\":\\\"${prediction_dataset_id}\\\"\\\n}\"\npredict_job=$(curl -Lsi \\\n-X POST \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n--data \"${prediction_request_data}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/predictions/\"\\\n| grep -i 'location: .*$' | cut -d \" \" -f2 | tr -d '\\r')\nwhile true; do\ninitial_job_response=$(curl -Ls \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${predict_job}\" \\\n| grep -Eo 'status\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nif [ \"${initial_job_status}\" = \"inprogress\" ]\nthen\necho \"Generating predictions...\"\nsleep 10\nelse\necho \"Predictions complete.\"\nbreak\nfi\ndone\ncurl -Ls \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${predict_job}\"\nThis code makes predictions on the recommended model using the test set you identified in the first step (test_dataset_file_path), when you uploaded data.\n# Uploading the testing dataset\nscoring <- UploadPredictionDataset(project, dataSource = test_dataset)\n# Requesting prediction\npredict_job_id <- RequestPredictions(project, modelId = model$modelId, datasetId = scoring$id)\n# Grabbing predictions\npredictions_prob <- GetPredictions(project, predictId = predict_job_id, type = \"probability\")\nhead(predictions_prob)\nLearn more\u00b6\nAfter getting started with DataRobot's APIs, navigate to the user guide for overviews, Jupyter notebooks, and task-based tutorials that help you find complete examples of common data science and machine learning workflows. Browse AI accelerators to try out repeatable, code-first workflows and modular building blocks. You can also read the reference documentation available for the REST API and Python API client.\nBack to top",
      "links": [
        "https://docs.datarobot.com/en/docs/api/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/index.html",
        "https://docs.datarobot.com/en/docs/images/api-key-4.png",
        "https://docs.datarobot.com/en/docs/images/api-key-3.png",
        "https://app.datarobot.com",
        "https://app.eu.datarobot.com",
        "https://app.jp.datarobot.com",
        "https://docs.datarobot.com/en/docs/api/accelerators/index.html",
        "https://docs.datarobot.com/en/docs/reference/pred-ai-ref/model-rec-process.html",
        "https://docs.datarobot.com/en/docs/images/access-nextgen-console.png",
        "https://docs.datarobot.com/en/docs/workbench/nxt-console/nxt-overview/nxt-overview.html",
        "https://docs.datarobot.com/en/docs/workbench/nxt-console/nxt-monitoring/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/python/predictions/index.html",
        "https://docs.datarobot.com/en/docs/api/guide/index.html"
      ],
      "page_type": "tutorial",
      "code_examples": [
        "pip install datarobot datarobot-predict",
        "pip install datarobot-bp-workshop",
        "install.packages(\u201cdatarobot\u201d)",
        "https://app.datarobot.com/api/v2",
        "https://app.eu.datarobot.com/api/v2",
        "https://app.jp.datarobot.com/api/v2",
        "{datarobot.example.com}",
        "https://{datarobot.example.com}/api/v2",
        "~/.config/datarobot/drconfig.yaml",
        "endpoint: 'https://app.datarobot.com/api/v2'\ntoken: 'NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G'",
        "endpoint: 'https://app.datarobot.com/api/v2'\ntoken: 'NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G'",
        "~/.config/datarobot/drconfig.yaml",
        "import datarobot as dr",
        "import datarobot as dr",
        "import datarobot as dr\ndr.Client(config_path = \"<file-path-to-drconfig.yaml>\")",
        "import datarobot as dr\ndr.Client(config_path = \"<file-path-to-drconfig.yaml>\")",
        "~/.config/datarobot/drconfig.yaml",
        "ConnectToDataRobot(configPath = \"<file-path-to-drconfig.yaml>\"))",
        "ConnectToDataRobot(configPath = \"<file-path-to-drconfig.yaml>\"))",
        "setx DATAROBOT_ENDPOINT \"https://app.datarobot.com/api/v2\"\nsetx DATAROBOT_API_TOKEN \"your_api_token\"",
        "setx DATAROBOT_ENDPOINT \"https://app.datarobot.com/api/v2\"\nsetx DATAROBOT_API_TOKEN \"your_api_token\"",
        "export DATAROBOT_ENDPOINT=\"https://app.datarobot.com/api/v2\"\nexport DATAROBOT_API_TOKEN=\"your_api_token\"",
        "export DATAROBOT_ENDPOINT=\"https://app.datarobot.com/api/v2\"\nexport DATAROBOT_API_TOKEN=\"your_api_token\"",
        "import datarobot as dr\ndr.Project.list()",
        "import datarobot as dr\ndr.Project.list()",
        "curl --location -X GET \"${DATAROBOT_API_ENDPOINT}/projects\" --header \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\"",
        "curl --location -X GET \"${DATAROBOT_API_ENDPOINT}/projects\" --header \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\"",
        "import datarobot as dr\ndr.Client(endpoint='https://app.datarobot.com/api/v2', token='NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G')",
        "import datarobot as dr\ndr.Client(endpoint='https://app.datarobot.com/api/v2', token='NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G')",
        "ConnectToDataRobot(endpoint =\n\"https://app.datarobot.com/api/v2\",\ntoken =\n'NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G')",
        "ConnectToDataRobot(endpoint =\n\"https://app.datarobot.com/api/v2\",\ntoken =\n'NjE3ZjA3Mzk0MmY0MDFmZGFiYjQ0MztergsgsQwOk9G')",
        "GET https://app.datarobot.com/api/v2/ HTTP/1.1\nAuthorization: Bearer DnwzBUNTOtKBO6Sp1hoUByG4YgZwCCw4",
        "GET https://app.datarobot.com/api/v2/ HTTP/1.1\nAuthorization: Bearer DnwzBUNTOtKBO6Sp1hoUByG4YgZwCCw4",
        "import datarobot as dr\ndr.Client(config_path = \"./drconfig.yaml\")\n\n# Set to the location of your auto-mpg.csv and auto-mpg-test.csv data files\n# Example: dataset_file_path = '/Users/myuser/Downloads/auto-mpg.csv'\ntraining_dataset_file_path = './auto-mpg.csv'\ntest_dataset_file_path = './auto-mpg-test.csv'\nprint(\"--- Starting DataRobot Model Training Script ---\")\n\n# Load dataset\ntraining_dataset = dr.Dataset.create_from_file(training_dataset_file_path)\n\n# Create a new project based on dataset\nproject = dr.Project.create_from_dataset(training_dataset.id, project_name='Auto MPG DR-Client')",
        "import datarobot as dr\ndr.Client(config_path = \"./drconfig.yaml\")\n\n# Set to the location of your auto-mpg.csv and auto-mpg-test.csv data files\n# Example: dataset_file_path = '/Users/myuser/Downloads/auto-mpg.csv'\ntraining_dataset_file_path = './auto-mpg.csv'\ntest_dataset_file_path = './auto-mpg-test.csv'\nprint(\"--- Starting DataRobot Model Training Script ---\")\n\n# Load dataset\ntraining_dataset = dr.Dataset.create_from_file(training_dataset_file_path)\n\n# Create a new project based on dataset\nproject = dr.Project.create_from_dataset(training_dataset.id, project_name='Auto MPG DR-Client')",
        "DATAROBOT_API_TOKEN=${DATAROBOT_API_TOKEN}\nDATAROBOT_ENDPOINT=${DATAROBOT_ENDPOINT}\nlocation=$(curl -Lsi \\\n  -X POST \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  -F 'projectName=\"Auto MPG\"' \\\n  -F \"file=@${DATASET_FILE_PATH}\" \\\n  \"${DATAROBOT_ENDPOINT}\"/projects/ | grep -i 'Location: .*$' | \\\n  cut -d \" \" -f2 | tr -d '\\r')\necho \"Uploaded dataset. Checking status of project at: ${location}\"\nwhile true; do\n  project_id=$(curl -Ls \\\n    -X GET \\\n    -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${location}\" \\\n    | grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${project_id}\" = \"\" ]\n  then\n    echo \"Setting up project...\"\n    sleep 10\n  else\n    echo \"Project setup complete.\"\n    echo \"Project ID: ${project_id}\"\n    break\n  fi\ndone",
        "DATAROBOT_API_TOKEN=${DATAROBOT_API_TOKEN}\nDATAROBOT_ENDPOINT=${DATAROBOT_ENDPOINT}\nlocation=$(curl -Lsi \\\n  -X POST \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  -F 'projectName=\"Auto MPG\"' \\\n  -F \"file=@${DATASET_FILE_PATH}\" \\\n  \"${DATAROBOT_ENDPOINT}\"/projects/ | grep -i 'Location: .*$' | \\\n  cut -d \" \" -f2 | tr -d '\\r')\necho \"Uploaded dataset. Checking status of project at: ${location}\"\nwhile true; do\n  project_id=$(curl -Ls \\\n    -X GET \\\n    -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${location}\" \\\n    | grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${project_id}\" = \"\" ]\n  then\n    echo \"Setting up project...\"\n    sleep 10\n  else\n    echo \"Project setup complete.\"\n    echo \"Project ID: ${project_id}\"\n    break\n  fi\ndone",
        "# Set to the location of your auto-mpg.csv and auto-mpg-test.csv data files\n# Example: dataset_file_path = '/Users/myuser/Downloads/auto-mpg.csv'\ntraining_dataset_file_path <- \"\"\ntest_dataset_file_path <- \"\"\ntraining_dataset <- utils::read.csv(training_dataset_file_path)\ntest_dataset <- utils::read.csv(test_dataset_file_path)\nhead(training_dataset)\nproject <- SetupProject(dataSource = training_dataset, projectName = \"Auto MPG DR-Client\", maxWait = 60 * 60)",
        "# Set to the location of your auto-mpg.csv and auto-mpg-test.csv data files\n# Example: dataset_file_path = '/Users/myuser/Downloads/auto-mpg.csv'\ntraining_dataset_file_path <- \"\"\ntest_dataset_file_path <- \"\"\ntraining_dataset <- utils::read.csv(training_dataset_file_path)\ntest_dataset <- utils::read.csv(test_dataset_file_path)\nhead(training_dataset)\nproject <- SetupProject(dataSource = training_dataset, projectName = \"Auto MPG DR-Client\", maxWait = 60 * 60)",
        "# Use training data to build models\nfrom datarobot import AUTOPILOT_MODE\n\n# Set the project's target and initiate Autopilot (runs in Quick mode unless a different mode is specified)\nproject.analyze_and_model(target='mpg', worker_count=-1, mode=AUTOPILOT_MODE.QUICK)\nprint(\"\\nAutopilot is running. This may take some time...\")\nproject.wait_for_autopilot()\nprint(\"Autopilot has completed!\")\n\n# Open the project in a web browser to view progress\nprint(\"Opening the project in your default web browser to view real-time events...\")\nproject.open_in_browser()\n\n# Get the recommended model (the best model for deployment)\nprint(\"\\nRetrieving the best model from the Leaderboard...\")\nbest_model = project.recommended_model()\nprint(f\"Best Model Found:\")\nprint(f\"  - Model Type: {best_model.model_type}\")\nprint(f\"  - Blueprint ID: {best_model.blueprint_id}\")",
        "# Use training data to build models\nfrom datarobot import AUTOPILOT_MODE\n\n# Set the project's target and initiate Autopilot (runs in Quick mode unless a different mode is specified)\nproject.analyze_and_model(target='mpg', worker_count=-1, mode=AUTOPILOT_MODE.QUICK)\nprint(\"\\nAutopilot is running. This may take some time...\")\nproject.wait_for_autopilot()\nprint(\"Autopilot has completed!\")\n\n# Open the project in a web browser to view progress\nprint(\"Opening the project in your default web browser to view real-time events...\")\nproject.open_in_browser()\n\n# Get the recommended model (the best model for deployment)\nprint(\"\\nRetrieving the best model from the Leaderboard...\")\nbest_model = project.recommended_model()\nprint(f\"Best Model Found:\")\nprint(f\"  - Model Type: {best_model.model_type}\")\nprint(f\"  - Blueprint ID: {best_model.blueprint_id}\")",
        "response=$(curl -Lsi \\\n  -X PATCH \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  --data '{\"target\": \"mpg\", \"mode\": \"quick\"}' \\\n  \"${DATAROBOT_ENDPOINT}/projects/${project_id}/aim\" | grep 'location: .*$' \\\n  | cut -d \" \" | tr -d '\\r')\necho \"AI training initiated. Checking status of training at: ${response}\"\nwhile true; do\n  initial_project_status=$(curl -Ls \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${response}\" \\\n  | grep -Eo 'stage\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${initial_project_status}\" = \"\" ]\n  then\n    echo \"Setting up AI training...\"\n    sleep 10\n  else\n    echo \"Training AI.\"\n    echo \"Grab a coffee or catch up on email.\"\n    break\n  fi\ndone\n\nproject_status=$(curl -Lsi \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  \"${DATAROBOT_ENDPOINT}/projects/${project_id}/status\" \\\n  | grep -Eo 'autopilotDone\":\\strue'\n  )\nif [ \"${project_status}\" = \"\" ]\nthen\n  echo \"Autopilot training in progress...\"\n  sleep 60\nelse\n  echo \"Autopilot training complete. Model ready to deploy.\"\n  break\nfi\ndone",
        "response=$(curl -Lsi \\\n  -X PATCH \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  --data '{\"target\": \"mpg\", \"mode\": \"quick\"}' \\\n  \"${DATAROBOT_ENDPOINT}/projects/${project_id}/aim\" | grep 'location: .*$' \\\n  | cut -d \" \" | tr -d '\\r')\necho \"AI training initiated. Checking status of training at: ${response}\"\nwhile true; do\n  initial_project_status=$(curl -Ls \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${response}\" \\\n  | grep -Eo 'stage\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${initial_project_status}\" = \"\" ]\n  then\n    echo \"Setting up AI training...\"\n    sleep 10\n  else\n    echo \"Training AI.\"\n    echo \"Grab a coffee or catch up on email.\"\n    break\n  fi\ndone\n\nproject_status=$(curl -Lsi \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  \"${DATAROBOT_ENDPOINT}/projects/${project_id}/status\" \\\n  | grep -Eo 'autopilotDone\":\\strue'\n  )\nif [ \"${project_status}\" = \"\" ]\nthen\n  echo \"Autopilot training in progress...\"\n  sleep 60\nelse\n  echo \"Autopilot training complete. Model ready to deploy.\"\n  break\nfi\ndone",
        "# Set the project target and initiate Autopilot\nSetTarget(project,\n  target = \"mpg\")\n# Block execution until Autopilot is complete\nWaitForAutopilot(project)\nmodel <- GetRecommendedModel(project, type = RecommendedModelType$RecommendedForDeployment)",
        "# Set the project target and initiate Autopilot\nSetTarget(project,\n  target = \"mpg\")\n# Block execution until Autopilot is complete\nWaitForAutopilot(project)\nmodel <- GetRecommendedModel(project, type = RecommendedModelType$RecommendedForDeployment)",
        "# Deploy the model to a serverless prediction environment\nprint(\"\\nDeploying the model to a serverless prediction environment...\")\n\n# Find or create a serverless prediction environment\nserverless_env = None\nfor env in dr.PredictionEnvironment.list():\n    if env.platform == 'datarobotServerless':\n        serverless_env = env\n        break\n\nif serverless_env is None:\n    print(\"Creating a new serverless prediction environment...\")\n    serverless_env = dr.PredictionEnvironment.create(\n        name=\"Auto MPG Serverless Environment\",\n        platform='datarobotServerless'\n    )\n\n# First, register the model to create a registered model version\nprint(\"Registering the model...\")\n\n# Check if the registered model already exists\nregistered_model_name = \"Auto MPG Registered Model\"\nexisting_models = [m for m in dr.RegisteredModel.list() if m.name == registered_model_name]\n\nif existing_models:\n    print(f\"Using existing registered model: {registered_model_name}\")\n    registered_model = existing_models[0]\n    # Create a new version of the existing model\n    registered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\n        best_model.id,\n        name=\"Auto MPG Model\",\n        registered_model_id=registered_model.id\n    )\nelse:\n    print(f\"Creating new registered model: {registered_model_name}\")\n    # Create a new registered model\n    registered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\n        best_model.id,\n        name=\"Auto MPG Model\",\n        registered_model_name=registered_model_name\n    )\n    # Retrieve the newly created registered model object by ID\n    registered_model = dr.RegisteredModel.get(registered_model_version.registered_model_id)\n\n# Wait for the model build to complete\nprint(\"Waiting for model build to complete...\")\nwhile True:\n    current_version = registered_model.get_version(registered_model_version.id)\n    if current_version.build_status in ('READY', 'complete'):\n        print(\"Model build completed successfully!\")\n        registered_model_version = current_version  # Update our reference\n        break\n    elif current_version.build_status == 'FAILED':\n        raise Exception(\"Model build failed. Please check the model registration.\")\n    else:\n        print(f\"Build status: {current_version.build_status}. Waiting...\")\n        import time\n        time.sleep(30)  # Wait 30 seconds before checking again\n\n# Deploy the model to the serverless environment using the registered model version\ndeployment = dr.Deployment.create_from_registered_model_version(\n    registered_model_version.id,\n    label=\"Auto MPG Predictions\",\n    description=\"Deployed with DataRobot client for Auto MPG predictions\",\n    prediction_environment_id=serverless_env.id\n)\n\nprint(f\"Model deployed successfully! Deployment ID: {deployment.id}\")",
        "# Deploy the model to a serverless prediction environment\nprint(\"\\nDeploying the model to a serverless prediction environment...\")\n\n# Find or create a serverless prediction environment\nserverless_env = None\nfor env in dr.PredictionEnvironment.list():\n    if env.platform == 'datarobotServerless':\n        serverless_env = env\n        break\n\nif serverless_env is None:\n    print(\"Creating a new serverless prediction environment...\")\n    serverless_env = dr.PredictionEnvironment.create(\n        name=\"Auto MPG Serverless Environment\",\n        platform='datarobotServerless'\n    )\n\n# First, register the model to create a registered model version\nprint(\"Registering the model...\")\n\n# Check if the registered model already exists\nregistered_model_name = \"Auto MPG Registered Model\"\nexisting_models = [m for m in dr.RegisteredModel.list() if m.name == registered_model_name]\n\nif existing_models:\n    print(f\"Using existing registered model: {registered_model_name}\")\n    registered_model = existing_models[0]\n    # Create a new version of the existing model\n    registered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\n        best_model.id,\n        name=\"Auto MPG Model\",\n        registered_model_id=registered_model.id\n    )\nelse:\n    print(f\"Creating new registered model: {registered_model_name}\")\n    # Create a new registered model\n    registered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\n        best_model.id,\n        name=\"Auto MPG Model\",\n        registered_model_name=registered_model_name\n    )\n    # Retrieve the newly created registered model object by ID\n    registered_model = dr.RegisteredModel.get(registered_model_version.registered_model_id)\n\n# Wait for the model build to complete\nprint(\"Waiting for model build to complete...\")\nwhile True:\n    current_version = registered_model.get_version(registered_model_version.id)\n    if current_version.build_status in ('READY', 'complete'):\n        print(\"Model build completed successfully!\")\n        registered_model_version = current_version  # Update our reference\n        break\n    elif current_version.build_status == 'FAILED':\n        raise Exception(\"Model build failed. Please check the model registration.\")\n    else:\n        print(f\"Build status: {current_version.build_status}. Waiting...\")\n        import time\n        time.sleep(30)  # Wait 30 seconds before checking again\n\n# Deploy the model to the serverless environment using the registered model version\ndeployment = dr.Deployment.create_from_registered_model_version(\n    registered_model_version.id,\n    label=\"Auto MPG Predictions\",\n    description=\"Deployed with DataRobot client for Auto MPG predictions\",\n    prediction_environment_id=serverless_env.id\n)\n\nprint(f\"Model deployed successfully! Deployment ID: {deployment.id}\")",
        "recommended_model_id=$(curl -s \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/recommendedModels\"\\\n\"/recommendedModel/\" \\\n| grep -Eo 'modelId\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nserver_data=$(curl -s -X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/predictionServers/\")\ndefault_server_id=$(echo $server_data \\\n| grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nserver_url=$(echo $server_data | grep -Eo 'url\":\\s\".*?\"' \\\n| cut -d '\"' -f3 | tr -d '\\r')\nserver_key=$(echo $server_data | grep -Eo 'datarobot-key\":\\s\".*?\"' \\\n| cut -d '\"' -f3 | tr -d '\\r')\nrequest_data=\"{\\\n    \\\"defaultPredictionServerId\\\":\\\"${default_server_id}\\\",\\\n    \\\"modelId\\\":\\\"${recommended_model_id}\\\",\\\n    \\\"description\\\":\\\"Deployed with cURL\\\",\\\n    \\\"label\\\":\\\"MPG Prediction Server\\\"\\\n}\"\ndeployment_response=$(curl -Lsi -X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-H \"Content-Type: application/json\" \\\n--data \"${request_data}\" \\\n\"${DATAROBOT_ENDPOINT}/deployments/fromLearningModel/\")\ndeploy_response_code_202=$(echo $deployment_response | grep -Eo 'HTTP/2 202')\nif [ \"${deploy_response_code_202}\" = \"\" ]\nthen\n  deployment_id=$(echo \"$deployment_response\" | grep -Eo 'id\":\\s\"\\w+' \\\n  | cut -d '\"' -f3 | tr -d '\\r')\n  echo \"Prediction server ready.\"\nelse\n  deployment_status=$(echo \"$deployment_response\" | grep -Eo 'location: .*$' \\\n  | cut -d \" \" | tr -d '\\r')\n  while true; do\n    deployment_ready=$(curl -Ls \\\n      -X GET \\\n      -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${deployment_status}\" \\\n      | grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n    if [ \"${deployment_ready}\" = \"\" ]\n    then\n      echo \"Waiting for deployment...\"\n      sleep 10\n    else\n      deployment_id=$deployment_ready\n      echo \"Prediction server ready.\"\n      break\n    fi\n  done\nfi",
        "recommended_model_id=$(curl -s \\\n-X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/recommendedModels\"\\\n\"/recommendedModel/\" \\\n| grep -Eo 'modelId\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nserver_data=$(curl -s -X GET \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n\"${DATAROBOT_ENDPOINT}/predictionServers/\")\ndefault_server_id=$(echo $server_data \\\n| grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\nserver_url=$(echo $server_data | grep -Eo 'url\":\\s\".*?\"' \\\n| cut -d '\"' -f3 | tr -d '\\r')\nserver_key=$(echo $server_data | grep -Eo 'datarobot-key\":\\s\".*?\"' \\\n| cut -d '\"' -f3 | tr -d '\\r')\nrequest_data=\"{\\\n    \\\"defaultPredictionServerId\\\":\\\"${default_server_id}\\\",\\\n    \\\"modelId\\\":\\\"${recommended_model_id}\\\",\\\n    \\\"description\\\":\\\"Deployed with cURL\\\",\\\n    \\\"label\\\":\\\"MPG Prediction Server\\\"\\\n}\"\ndeployment_response=$(curl -Lsi -X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-H \"Content-Type: application/json\" \\\n--data \"${request_data}\" \\\n\"${DATAROBOT_ENDPOINT}/deployments/fromLearningModel/\")\ndeploy_response_code_202=$(echo $deployment_response | grep -Eo 'HTTP/2 202')\nif [ \"${deploy_response_code_202}\" = \"\" ]\nthen\n  deployment_id=$(echo \"$deployment_response\" | grep -Eo 'id\":\\s\"\\w+' \\\n  | cut -d '\"' -f3 | tr -d '\\r')\n  echo \"Prediction server ready.\"\nelse\n  deployment_status=$(echo \"$deployment_response\" | grep -Eo 'location: .*$' \\\n  | cut -d \" \" | tr -d '\\r')\n  while true; do\n    deployment_ready=$(curl -Ls \\\n      -X GET \\\n      -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${deployment_status}\" \\\n      | grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n    if [ \"${deployment_ready}\" = \"\" ]\n    then\n      echo \"Waiting for deployment...\"\n      sleep 10\n    else\n      deployment_id=$deployment_ready\n      echo \"Prediction server ready.\"\n      break\n    fi\n  done\nfi",
        "predictionServer <- ListPredictionServers()[[1]]\ndeployment <- CreateDeployment(model,\n                               label = \"MPG Prediction Server\",\n                               description = \"Deployed with DataRobot client\",\n                               defaultPredictionServerId = predictionServer)",
        "predictionServer <- ListPredictionServers()[[1]]\ndeployment <- CreateDeployment(model,\n                               label = \"MPG Prediction Server\",\n                               description = \"Deployed with DataRobot client\",\n                               defaultPredictionServerId = predictionServer)",
        "# Make predictions on test data\nprint(\"\\nMaking predictions on test data...\")\n\n# Read the test data directly\nimport pandas as pd\nfrom datarobot_predict.deployment import predict\n\ntest_data = pd.read_csv(test_dataset_file_path)\n\n# Use datarobot-predict for deployment predictions\npredictions, response_headers = predict(deployment, test_data)\n\n# Display the results\nprint(\"\\nPrediction Results:\")\nprint(predictions.head())\nprint(f\"\\nTotal predictions made: {len(predictions)}\")",
        "# Make predictions on test data\nprint(\"\\nMaking predictions on test data...\")\n\n# Read the test data directly\nimport pandas as pd\nfrom datarobot_predict.deployment import predict\n\ntest_data = pd.read_csv(test_dataset_file_path)\n\n# Use datarobot-predict for deployment predictions\npredictions, response_headers = predict(deployment, test_data)\n\n# Display the results\nprint(\"\\nPrediction Results:\")\nprint(predictions.head())\nprint(f\"\\nTotal predictions made: {len(predictions)}\")",
        "# Test predictions on new data\n# shellcheck disable=SC2089\nprediction_location=$(curl -Lsi\\\n-X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-F \"file=@${TEST_DATASET_FILE_PATH}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/predictionDatasets/fileUploads/\"\\\n| grep -i 'location: .*$' | cut -d \" \" -f2 | tr -d '\\r')\necho \"Uploaded prediction dataset. Checking status of upload at: ${prediction_location}\"\nwhile true; do\n  prediction_dataset_id=$(curl -Ls \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${prediction_location}\" \\\n  | grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${prediction_dataset_id}\" = \"\" ]\n  then\n  echo \"Uploading predictions...\"\n  sleep 10\n  else\n  echo \"Predictions upload complete.\"\n  echo \"Predictions dataset ID: ${prediction_dataset_id}\"\n  break\n  fi\n  done\n  prediction_request_data=\"{\\\n      \\\"modelId\\\":\\\"${recommended_model_id}\\\",\\\n      \\\"datasetId\\\":\\\"${prediction_dataset_id}\\\"\\\n  }\"\n  predict_job=$(curl -Lsi \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  --data \"${prediction_request_data}\" \\\n  \"${DATAROBOT_ENDPOINT}/projects/${project_id}/predictions/\"\\\n  | grep -i 'location: .*$' | cut -d \" \" -f2 | tr -d '\\r')\nwhile true; do\n  initial_job_response=$(curl -Ls \\\n    -X GET \\\n    -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${predict_job}\" \\\n    | grep -Eo 'status\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${initial_job_status}\" = \"inprogress\" ]\n  then\n    echo \"Generating predictions...\"\n    sleep 10\n  else\n    echo \"Predictions complete.\"\n    break\n  fi\ndone\n\ncurl -Ls \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${predict_job}\"",
        "# Test predictions on new data\n# shellcheck disable=SC2089\nprediction_location=$(curl -Lsi\\\n-X POST \\\n-H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n-F \"file=@${TEST_DATASET_FILE_PATH}\" \\\n\"${DATAROBOT_ENDPOINT}/projects/${project_id}/predictionDatasets/fileUploads/\"\\\n| grep -i 'location: .*$' | cut -d \" \" -f2 | tr -d '\\r')\necho \"Uploaded prediction dataset. Checking status of upload at: ${prediction_location}\"\nwhile true; do\n  prediction_dataset_id=$(curl -Ls \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${prediction_location}\" \\\n  | grep -Eo 'id\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${prediction_dataset_id}\" = \"\" ]\n  then\n  echo \"Uploading predictions...\"\n  sleep 10\n  else\n  echo \"Predictions upload complete.\"\n  echo \"Predictions dataset ID: ${prediction_dataset_id}\"\n  break\n  fi\n  done\n  prediction_request_data=\"{\\\n      \\\"modelId\\\":\\\"${recommended_model_id}\\\",\\\n      \\\"datasetId\\\":\\\"${prediction_dataset_id}\\\"\\\n  }\"\n  predict_job=$(curl -Lsi \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \\\n  --data \"${prediction_request_data}\" \\\n  \"${DATAROBOT_ENDPOINT}/projects/${project_id}/predictions/\"\\\n  | grep -i 'location: .*$' | cut -d \" \" -f2 | tr -d '\\r')\nwhile true; do\n  initial_job_response=$(curl -Ls \\\n    -X GET \\\n    -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${predict_job}\" \\\n    | grep -Eo 'status\":\\s\"\\w+' | cut -d '\"' -f3 | tr -d '\\r')\n  if [ \"${initial_job_status}\" = \"inprogress\" ]\n  then\n    echo \"Generating predictions...\"\n    sleep 10\n  else\n    echo \"Predictions complete.\"\n    break\n  fi\ndone\n\ncurl -Ls \\\n  -X GET \\\n  -H \"Authorization: Bearer ${DATAROBOT_API_TOKEN}\" \"${predict_job}\"",
        "# Uploading the testing dataset\nscoring <- UploadPredictionDataset(project, dataSource = test_dataset)\n\n# Requesting prediction\npredict_job_id <- RequestPredictions(project, modelId = model$modelId, datasetId = scoring$id)\n\n# Grabbing predictions\npredictions_prob <- GetPredictions(project, predictId = predict_job_id, type = \"probability\")\nhead(predictions_prob)",
        "# Uploading the testing dataset\nscoring <- UploadPredictionDataset(project, dataSource = test_dataset)\n\n# Requesting prediction\npredict_job_id <- RequestPredictions(project, modelId = model$modelId, datasetId = scoring$id)\n\n# Grabbing predictions\npredictions_prob <- GetPredictions(project, predictId = predict_job_id, type = \"probability\")\nhead(predictions_prob)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://docs.datarobot.com/en/docs/api/reference/index.html",
      "title": "API reference documentation\u00b6",
      "description": "Review the reference documentation available for DataRobot's APIs.",
      "content": "Skip to content\nDataRobot API resources\n>\nAPI reference documentation\nAPI reference documentation\u00b6\nThe table below outlines the reference documentation available for DataRobot's API, SDKs, and code-first tools.\nResource\nDescription\nREST API\nThe DataRobot REST API provides a programmatic alternative to the UI for creating and managing DataRobot assets. It allows you to automate processes and iterate more quickly, and lets you use DataRobot with scripted control. The API provides an intuitive modeling and prediction interface.\nOpenAPI specification\nReference the OpenAPI specification for the DataRobot REST API, which helps automate the generation of a client for languages that DataRobot doesn't directly support. It also assists with the design, implementation, and testing integration with DataRobot's REST API using a variety of automated OpenAPI-compatible tools. Note that accessing the OpenAPI spec requires you to be logged into the DataRobot application.\nPython API client\nInstallation, configuration, and usage guidelines for working with the Python client library.\nR client\nInstallation, configuration, and reference documentation for working with the R client library.\nBlueprint workshop\nConstruct and modify DataRobot blueprints and their tasks using a programmatic interface.\nDataRobot Model Metrics\nThe DataRobot Model Metrics library provides the tools necessary to compute model metrics over time and produce aggregated metrics.\nPrediction API\nGenerate predictions with a deployment by submitting JSON or CSV input data via a POST request.\nBatch Prediction API\nScore large datasets with flexible options for intake and output using the prediction servers you have deployed via the Batch Prediction API.\nCode-first tools\nReview the various programmatic tools DataRobot has to offer in addition to the APIs.\nAPI changelogs\nChangelogs contain curated, ordered lists of notable changes for each versioned release for DataRobot's SDKs and REST API.\nCovalent\nA code-first solution that simplifies building and scaling complex AI and high-performance computing applications.\nDeclarative API\nA Terraform-native declarative API used to programmatically provision DataRobot entities such as models, deployments, applications, and more.\nTroubleshoot the Python client\nOutlines cases that can cause issues with using the Python client and provides known fixes.\nSelf-managed resources\nDetails the resources available for self-managed DataRobot deployments.\nBack to top",
      "links": [
        "https://docs.datarobot.com/en/docs/api/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/index.html",
        "https://app.datarobot.com/api/v2/openapi.yaml",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/bp-workshop/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/dr-model-metrics/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/predapi/dr-predapi.html",
        "https://docs.datarobot.com/en/docs/api/reference/batch-prediction-api/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/code-first-tools/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/changelogs/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/covalent.html",
        "https://docs.datarobot.com/en/docs/api/reference/declarative-api.html",
        "https://docs.datarobot.com/en/docs/api/reference/py-help.html",
        "https://docs.datarobot.com/en/docs/api/reference/self-managed.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://docs.datarobot.com/en/docs/api/reference/sdk/CHANGES.html",
      "title": "Python client changelog\u00b6",
      "description": "",
      "content": "Skip to content\nDataRobot API resources\n>\nAPI reference documentation\n>\nPython client changelog\nPython client changelog\u00b6\n3.8.2\u00b6\nFixes\u00b6\nRemove a broken link in the package description that pointed to the DataRobot documentation.\nFix error in URL generation for the AsyncOAuth class.\nFixed validator errors in EvaluationDatasetMetricAggregation.\n3.8.1\u00b6\nFixes\u00b6\nFixed a bug in client retries that caused the client to not retry requests when the server returned 502 and 503 errors.\n3.8.0\u00b6\nThis release adds support for unstructured data in the Data Registry, notebooks and Codespaces, and chunking service v2. There are improvements related to playgrounds, vector databases, agentic workflows, incremental learning, and datasets. This release focuses heavily on file management capabilities.\nThere are two new package extras: auth and auth-authlib. The auth extra provides OAuth2 support, while the auth-authlib extra provides OAuth2 support using the Authlib library.\nNew features\u00b6\nGenAI\u00b6\nAdded AGENTIC_WORKFLOW target type.\nAdded VectorDatabase.send_to_custom_model_workshop to create a new custom model from a vector database.\nAdded VectorDatabase.deploy to create a new deployment from a vector database.\nAdded optional parameters vector_database_default_prediction_server_id, vector_database_prediction_environment_id, vector_database_maximum_memory, vector_database_resource_bundle_id, vector_database_replicas, and vector_database_network_egress_policy to LLMBlueprint.register_custom_model to allow specifying resources in cases where we automatically deploy a vector database when this function is called.\nAdded ReferenceToolCall for creating tool calls in the evaluation dataset.\nAdded ReferenceToolCalls to represent a list of tool calls in the evaluation dataset.\nAdded VectorDatabase.update_connected to add a dataset and optional additional metadata to a connected vector database.\nNotebooks and Codespaces\u00b6\nThe notebook and Codespace APIs are now GA and the related classes have been promoted to the stable client.\nChanged name of the Notebook run() method to be Notebook.run_as_job.\nAdded support for Codespaces to the Notebook.is_finished_executing method.\nAdded the NotebookKernel.get method.\nAdded the NotebookScheduledJob.cancel method.\nAdded the NotebookScheduledJob.list method.\nAdded the Notebook.list_schedules method.\nUnstructured data\u00b6\nThe client now supports unstructured data in the Data Registry.\nAdded the Files class to manage files on the DataRobot platform. The class supports file metadata including the description, creation date, and creator information.\nUse Files.get to retrieve file information.\nUse Files.upload as a convenient facade method to upload files from URLs, file paths, or file objects (does not support DataFrames).\nUse Files.create_from_url to upload a new file from a URL.\nUse Files.create_from_file to upload a new file from a local file or file-like object.\nUse Files.create_from_data_source to create a new file from a DataSource.\nUse Files.list_files to retrieve all individual files contained within a Files object. This is useful for Files objects ingested from archives that contain multiple files.\nUse Files.download to download a file\u2019s contents.\nUse Files.modify to update a file\u2019s name, description, and/or tags.\nUse Files.update to refresh a file object with the latest information from the server.\nUse Files.delete to soft-delete a file.\nUse Files.un_delete to restore a previously deleted file.\nUse Files.search_catalog to search for files in the catalog based on name, tags, or other criteria.\nAdded the FilesCatalogSearch class to represent file catalog search results with metadata such as catalog name, creator, and tags.\nAdded the File class to represent individual files within a Files archive. The class provides information about individual files such as name, size, and path within the archive.\nOAuth\u00b6\nThe client provides better support for OAuth2 authorization workflows in applications using the DataRobot platform. These features are available in the datarobot.auth module.\nAdded the methods set_authorization_context and get_authorization_context to handle context needed for OAuth access token management.\nAdded the decorator datarobot_tool_auth to inject OAuth access tokens into the agent tool functions.\nOther features\u00b6\nIntroduced support for Chunking Service V2. The chunking_service_v2 classes have been moved out of the experimental directory and are now available to all users.\nAdded Model.continue_incremental_learning_from_incremental_model to continue training of the incremental learning model.\nAdded optional parameter chunk_definition_id in Model.start_incremental_learning_from_sample to begin training using new chunking service.\nAdded a new attribute snapshot_policy to datarobot.models.RecipeDatasetInput to specify the snapshot policy to use.\nAdded a new attribute dataset_id to datarobot.models.JDBCTableDataSourceInput to specify the exact dataset ID to use.\nAdded Dataset.create_version_from_recipe to create a new dataset version based on the Recipe.\nEnhancements\u00b6\nAdded the use_tcp_keepalive parameter to Client to enable TCP keep-alive packets when connections are timing out, enabled by default.\nEnabled Playground to create agentic playgrounds via input param playground_type=PlaygroundType.AGENTIC.\nExtended PlaygroundOOTBMetricConfiguration.create with additional reference column names for agentic metrics.\nUpdated CustomTemplate.list to return all custom templates when no offset is specified.\nExtended MetricInsights.list with the option to pass llm_blueprint_ids.\nExtended OOTBMetricConfigurationRequest and OOTBMetricConfigurationResponse with support for extra_metric_settings, which provides an additional configuration option for the Tool Call Accuracy metric.\nExtended VectorDatabase.create to support creation of connected vector databases via input param external_vector_database_connection.\nExtended VectorDatabase.create to support an additional metadata dataset via input params metadata_dataset_id and metadata_combination_strategy.\nExtended VectorDatabase.update to support updating the credential used to access a connected vector database via input param credential_id.\nExtended VectorDatabase.download_text_and_embeddings_asset to support downloading additional files via input param part.\nAdded docker_image_uri to datarobot.ExecutionEnvironmentVersion.\nAdded optional parameter docker_image_uri to ExecutionEnvironmentVersion.create.\nChanged parameter docker_context_path in ExecutionEnvironmentVersion.create to be optional.\nAdded a new attribute image_id to datarobot.ExecutionEnvironmentVersion.\nBugfixes\u00b6\nFixed PlaygroundOOTBMetricConfiguration.create by using the right payload for customModelLLMValidationId instead of customModelLlmValidationId.\nFixed datarobot.models.RecipeDatasetInput to use correct fields for to_api.\nFixed EvaluationDatasetConfiguration.create to use the correct payload for is_synthetic_dataset.\nDeprecation summary\u00b6\nRemove unreleased Insight configuration routes.  These were replaced with the new MetricInsights class, and insight specific configurations.\nDeployment.create_from_learning_model <datarobot.models.deployment.Deployment.create_from_learning_model> method is deprecated. Please first register the leaderboard model with RegisteredModelVersion.create_for_leaderboard_item <datarobot.models.model_registry.registered_model_version.RegisteredModelVersion.create_for_leaderboard_item>, then create a deployment with Deployment.create_from_registered_model_version <datarobot.models.deployment.Deployment.create_from_registered_model_version>.\nDocumentation changes\u00b6\nUpdated the example for GenAI to show creation of a metric aggregation job.\nExperimental changes\u00b6\nAdded attribute version to DatasetInfo to identify the analysis version.\nAdded attribute dataset_definition_info_version to ChunkDefinition to identify the analysis information version.\nAdded a version query parameter to the DatasetDefinition class, allowing users to specify the analysis version in the get method.\nAdded DatasetDefinitionInfoHistory with the DatasetDefinitionInfoHistory.list method to retrieve a list of dataset information history records.\nAdded the DatasetDefinitionInfoHistory.list_versions method to retrieve a list of dataset information records.\n3.7.0\u00b6\nNew features\u00b6\nThe DataRobot Python Client now supports Python 3.12 and Python 3.13.\nAdded Deployment.get_retraining_settings to retrieve retraining settings.\nAdded Deployment.update_retraining_settings to update retraining settings.\nUpdated RESTClientObject to retry requests when the server returns a 104 connection reset error.\nAdded support for datasphere as an intake and output type in batch predictions.\nAdded Deployment.get_accuracy_metrics_settings to retrieve accuracy metrics settings.\nAdded Deployment.update_accuracy_metrics_settings to update accuracy metrics settings.\nAdded CustomMetricValuesOverSpace to retrieve custom metric values over space.\nAdded CustomMetric.get_values_over_space to retrieve custom metric values over space.\nCreated ComplianceDocTemplateProjectType, an enum to define project type supported by the compliance documentation custom template.\nAdded attribute project_type to ComplianceDocTemplate to identify the template supported project type.\nAdded optional parameter project_type in ComplianceDocTemplate.get_default to retrieve the project type\u2019s default template.\nAdded optional parameter project_type in ComplianceDocTemplate.create to specify the project type supported by the template to create.\nAdded optional parameter project_type in ComplianceDocTemplate.create_from_json_file to specify the project type supported by the template to create.\nAdded optional parameter project_type in ComplianceDocTemplate.update to allow updating an existing template\u2019s project type.\nAdded optional parameter project_type in ComplianceDocTemplate.list to allow to filtering/searching by template\u2019s project type.\nAdded ShapMatrix.get_as_csv to retrieve SHAP matrix results as a CSV file.\nAdded ShapMatrix.get_as_dataframe to retrieve SHAP matrix results as a dataframe.\nAdded a new class LiftChart to interact with lift chart insights.\nAdded a new class RocCurve to interact with ROC curve insights.\nAdded a new class Residuals to interact with residuals insights.\nAdded Project.create_from_recipe to create Feature Discovery projects using recipes.\nAdded an optional parameter recipe_type to datarobot.models.Recipe.from_dataset() to create Wrangling recipes.\nAdded an optional parameter recipe_type to datarobot.models.Recipe.from_data_store() to create Wrangling recipes.\nAdded Recipe.set_recipe_metadata to update recipe metadata.\nAdded an optional parameter snapshot_policy to datarobot.models.Recipe.from_dataset() to specify the snapshot policy to use.\nAdded new attributes prediction_point, relationships_configuration_id and feature_discovery_supervised_feature_reduction to RecipeSettings.\nAdded several optional parameters to ExecutionEnvironment for list, create and update methods.\nAdded optional parameter metadata_filter to ComparisonPrompt.create.\nAdded CustomInferenceModel.share to update access control settings for a custom model.\nAdded CustomInferenceModel.get_access_list to retrieve access control settings for a custom model.\nAdded new attribute latest_successful_version to ExecutionEnvironment.\nAdded Dataset.create_from_project to create datasets from project data.\nAdded ExecutionEnvironment.share to update access control settings for an execution environment.\nAdded ExecutionEnvironment.get_access_list to retrieve access control settings an execution environment.\nCreated ModerationTemplate to interact with LLM moderation templates.\nCreated ModerationConfiguration to interact with LLM moderation configuration.\nCreated CustomTemplate to interact with custom-templates elements.\nExtended the advanced options available when setting a target to include parameter: \u2018feature_engineering_prediction_point\u2019(part of the AdvancedOptions object).\nAdded optional parameter substitute_url_parameters to DataStore <datarobot.models.DataStore for list and get methods.\nAdded Model.start_incremental_learning_from_sample to initialize the incremental learning model and begin training using the chunking service. Requires the \u201cProject Creation from a Dataset Sample\u201d feature flag.\nAdded NonChatAwareCustomModelValidation as the base class for CustomModelVectorDatabaseValidation and CustomModelEmbeddingValidation.\nIn contrast, CustomModelLLMValidation now implements the create and update methods differently to interact with the deployments that support the chat completion API.\nAdded optional parameter chat_model_id to CustomModelLLMValidation.create and CustomModelLLMValidation.update to allow adding deployed LLMs that support the chat completion API.\nFixed ComparisonPrompt not being able to load errored comparison prompt results.\nAdded optional parameters retirement_date, is_deprecated, and is_active to LLMDefinition and added an optional parameter llm_is_deprecated to the MetricMetadata to expose LLM deprecation and retirement-related information.\nEnhancements\u00b6\nAdded Deployment.share as an alias for Deployment.update_shared_roles.\nInternally use the existing input argument max_wait in CustomModelVersion.clean_create <datarobot.CustomModelVersion.create_clean>, to set the READ request timeout.\nBugfixes\u00b6\nMade user_id and username fields in management_meta optional for PredictionEnvironment to support API responses without these fields.\nFixed the enum values of ComplianceDocTemplateType.\nFixed the enum values of WranglingOperations.\nFixed the enum values of DataWranglingDialect.\nPlayground id parameter is no longer optional in EvaluationDatasetConfiguration.list\nCopy insights path fixed in MetricInsights.copy_to_playground\nMissing fields for prompt_type and warning were added to PromptTrace.\nFixed a query parameter name in SidecarModelMetricValidation.list.\nFix typo in attribute VectorDatabase: metadata_columns which was metada_columns\nDo not camelCase metadata_filter dict in ChatPrompt.create\nFixed a Use Case query parameter name in CustomModelLLMValidation.list, CustomModelEmbeddingValidation.list, and CustomModelVectorDatabaseValidation.list.\nFixed featureDiscoverySettings parameter name in RelationshipsConfiguration.create and RelationshipsConfiguration.replace.\nAPI changes\u00b6\nMethod CustomModelLLMValidation.create no longer requires the prompt_column_name and target_column_name parameters, and can accept an optional chat_model_id parameter. The parameter order has changed. If the custom model LLM deployment supports the chat completion API, it is recommended to use chat_model_id now instead of (or in addition to) specifying the column names.\nDeprecation summary\u00b6\nRemoved the deprecated capabilities attribute of Deployment.\nMethod Model.request_lift_chart is deprecated and will be removed in favor of LiftChart.compute.\nMethod Model.get_lift_chart is deprecated and will be removed in favor of LiftChart.get.\nMethod Model.get_all_lift_charts is deprecated and will be removed in favor of LiftChart.list.\nMethod Model.request_roc_curve is deprecated and will be removed in favor of RocCurve.compute.\nMethod Model.get_roc_curve is deprecated and will be removed in favor of RocCurve.get.\nMethod Model.get_all_roc_curves is deprecated and will be removed in favor of RocCurve.list.\nMethod Model.request_residuals_chart is deprecated and will be removed in favor of Residuals.compute.\nMethod Model.get_residuals_chart is deprecated and will be removed in favor of Residuals.get.\nMethod Model.get_all_residuals_charts is deprecated and will be removed in favor of Residuals.list.\nDocumentation changes\u00b6\nStarting with this release, Python client documentation will be available at https://docs.datarobot.com/ as well as on ReadTheDocs. Content has been reorganized to support this change.\nRemoved numpydoc as a dependency. Docstring parsing has been handled by sphinx.ext.napoleon since 3.6.0.\nFix issues with how the Table of Contents is rendered on ReadTheDocs. sphinx-external-toc is now a dev dependency.\nFix minor issues with formatting across the ReadTheDocs site.\nUpdated docs on Anomaly Assessment objects to remove duplicate information.\nExperimental changes\u00b6\nAdded use_case and deployment_id properties to RetrainingPolicy class.\nAdded create and update_use_case methods to RetrainingPolicy class.\nRenamed the method \u2018train_first_incremental_from_sample\u2019 to \u2018start_incremental_learning_from_sample\u2019.\nAdded new parameters : \u2018early_stopping_rounds\u2019 and \u2018first_iteration_only\u2019.\nAdded the credentials_id parameter to the create method in ChunkDefinition.\nBugfix the next_run_time property of the NotebookScheduledJob class to be nullable.\nAdded the highlight_whitespace property to the NotebookSettings.\nCreate new directory specifically for notebooks in the experimental portion of the client.\nAdded methods to the Notebook class to work with session: start_session(), stop_session(), get_session_status(), is_running().\nAdded methods to the Notebook in order to execute and check related execution status: execute(), get_execution_status(), is_finished_executing().\nAdded Notebook.create_revision to the Notebook class in order to create revisions.\nMoved ModerationTemplate class to ModerationTemplate.\nMoved ModerationConfiguration class to ModerationConfiguration to interact with LLM moderation configuration.\nUpdates to Notebook.run method in the Notebook class in order to encourage proper usage as well as add more descriptive TypedDict as annotation.\nAdded NotebookScheduledJob.get_most_recent_run to the NotebookScheduledJob class to aid in more idiomatic code when dealing with manual runs.\nUpdates to Notebook.run method in the Notebook class in order to support Codespace Notebook execution as well as multiple related new classes and methods to expand API coverage which is needed for the underlying execution.\nAdded ExecutionEnvironment.assign_environment to the ExecutionEnvironment class, which gives the ability to assign or update a notebook\u2019s environment.\nRemoved deprecated experimental method Model.get_incremental_learning_metadata.\nRemoved deprecated experimental method Model.start_incremental_learning.\n3.6.0\u00b6\nNew features\u00b6\nAdded OCRJobResource for running OCR jobs.\nAdded new Jina V2 embedding model in VectorDatabaseEmbeddingModel.\nAdded new Small MultiLingual Embedding Model in VectorDatabaseEmbeddingModel.\nAdded Deployment.get_segment_attributes to retrieve segment attributes.\nAdded Deployment.get_segment_values to retrieve segment values.\nAdded AutomatedDocument.list_all_available_document_types to return a list of document types.\nAdded Model.request_per_class_fairness_insights to return per-class bias & fairness insights.\nAdded MLOpsEvent to report MLOps Events.  Currently supporting moderation MLOps events only\nAdded Deployment.get_moderation_events to retrieve moderation events for that deployment.\nExtended the advanced options available when setting a target to include new\nparameter: \u2018number_of_incremental_learning_iterations_before_best_model_selection\u2019(part of the AdvancedOptions object).\nThis parameter allows you to specify how long top 5 models will run for prior to best model selection.\nAdd support for \u2018connector_type\u2019 in :meth:` Connector.create `.\nDeprecate file_path for :meth:` Connector.create ` and :meth:` Connector.update `.\nAdded DataQualityExport and Deployment.list_data_quality_exports to retrieve a list of data quality records.\nAdded secure config support for Azure Service Principal credentials.\nAdded support for categorical custom metrics in CustomMetric.\nAdded NemoConfiguration to manage Nemo configurations.\nAdded NemoConfiguration.create to create or update a Nemo configuration.\nAdded NemoConfiguration.get to retrieve a Nemo configuration.\nAdded a new class ShapDistributions to interact with SHAP distribution insights.\nAdded the MODEL_COMPLIANCE_GEN_AI value to the attribute document_type from DocumentOption to generate compliance documentation for LLMs in the Registry.\nAdded new attribute prompts_count to Chat.\nAdded Recipe modules for Data Wrangling.\nAdded :class: RecipeOperation <datarobot.models.recipe_operation.RecipeOperation> and a set of subclasses to represent a single Recipe.operations operation.\nAdded new attribute similarity_score to Citation.\nAdded new attributes retriever and add_neighbor_chunks to VectorDatabaseSettings.\nAdded new attribute metadata to Citation.\nAdded new attribute metadata_filter to ChatPrompt.\nAdded new attribute metadata_filter to ComparisonPrompt.\nAdded new attribute custom_chunking to ChunkingParameters.\nAdded new attribute custom_chunking to VectorDatabase.\nAdded a new class LLMTestConfiguration for LLM test configurations.\nLLMTestConfiguration.get to retrieve a hosted LLM test configuration.\nLLMTestConfiguration.list to list hosted LLM test configurations.\nLLMTestConfiguration.create to create an LLM test configuration.\nLLMTestConfiguration.update to update an LLM test configuration.\nLLMTestConfiguration.delete to delete an LLM test configuration.\nAdded a new class LLMTestConfigurationSupportedInsights for LLM test configuration supported insights.\nLLMTestConfigurationSupportedInsights.list to list hosted LLM test configuration supported insights.\nAdded a new class LLMTestResult for LLM test results.\nLLMTestResult.get to retrieve a hosted LLM test result.\nLLMTestResult.list to list hosted LLM test results.\nLLMTestResult.create to create an LLM test result.\nLLMTestResult.delete to delete an LLM test result.\nAdded new attribute dataset_name to OOTBDatasetDict.\nAdded new attribute rows_count to OOTBDatasetDict.\nAdded new attribute max_num_prompts to DatasetEvaluationDict.\nAdded new attribute prompt_sampling_strategy to DatasetEvaluationDict.\nAdded a new class DatasetEvaluationRequestDict for Dataset Evaluations in create/edit requests.\nAdded new attribute evaluation_dataset_name to InsightEvaluationResult.\nAdded new attribute chat_name to InsightEvaluationResult.\nAdded new attribute llm_test_configuration_name to LLMTestResult.\nAdded new attribute creation_user_name to LLMTestResult.\nAdded new attribute pass_percentage to LLMTestResult.\nAdded new attribute evaluation_dataset_name to DatasetEvaluation.\nAdded new attribute datasets_compatibility to LLMTestConfigurationSupportedInsights.\nAdded a new class NonOOTBDataset for non out-of-the-box (OOTB) dataset entities.\nNonOOTBDataset.list to retrieve non OOTB datasets for compliance testing.\nAdded a new class OOTBDataset for OOTB dataset entities.\nOOTBDataset.list to retrieve OOTB datasets for compliance testing.\nAdded a new class TraceMetadata to retrieve trace metadata.\nAdd new attributes to VectorDatabase: parent_id, family_id, metadata_columns, added_dataset_ids, added_dataset_names,  and`version`.\nVectorDatabase.get_supported_retrieval_settings to retrieve supported retrieval settings.\nVectorDatabase.submit_export_dataset_job to submit the vector database as dataset to the AI catalog.\nUpdated the method VectorDatabase.create to create a new vector database version.\nAdded a new class SupportedRetrievalSettings for supported vector database retrieval settings.\nAdded a new class SupportedRetrievalSetting for supported vector database retrieval setting.\nAdded a new class VectorDatabaseDatasetExportJob for vector database dataset export jobs.\nAdded new attribute playground_id to CostMetricConfiguration.\nAdded new attribute name to CostMetricConfiguration.\nAdded a new class SupportedInsights to support lists.\n: SupportedInsights.list to list supported insights.\nAdded a new class MetricInsights for the new metric insights routes.\n: MetricInsights.list to list metric insights.\nMetricInsights.copy_to_playground to copy metrics to another playground.\nAdded a new class PlaygroundOOTBMetricConfiguration for OOTB metric configurations.\nUpdated the schema for EvaluationDatasetMetricAggregation to include the new attributes ootb_dataset_name, dataset_id and dataset_name.\nUpdated the method EvaluationDatasetMetricAggregation.list with additional optional filter parameters.\nAdded new attribute warning to OOTBDataset.\nAdded new attribute warning to OOTBDatasetDict.\nAdded new attribute warnings to LLMTestConfiguration.\nAdded a new parameter playground_id to SidecarModelMetricValidation.create to support sidecar model metrics transition to playground.\nUpdated the schema for NemoConfiguration to include the new attributes prompt_pipeline_template_id and response_pipeline_template_id.\nAdded new attributes to EvaluationDatasetConfiguration: rows_count, playground_id.\nFix retrieving shap_remaining_total when requesting predictions with SHAP insights. This should return the remaining shap values when present.\nAPI changes\u00b6\nUpdated ServerError\u2019s exc_message to be constructed with a request ID to help with debugging.\nAdded method Deployment.get_capabilities to retrieve a list of :class: Capability <datarobot.models.deployment.Capability> objects containing capability details.\nAdvanced options parameters: modelGroupId, modelRegimeId, and modelBaselines were renamed into seriesId, forecastDistance, and forecastOffsets.\nAdded the parameter use_sample_from_dataset from Project.create_from_dataset. This parameter, when set, uses the EDA sample of the dataset to start the project.\nAdded the parameter quick_compute to functions in the classes ShapMatrix, ShapImpact, and ShapPreview.\nAdded the parameter copy_insights to Playground.create to copy the insights from existing Playground to the new one.\nAdded the parameter llm_test_configuration_ids, LLMBlueprint.register_custom_model, to run LLM compliance tests when a blueprint is sent to the custom model workshop.\nEnhancements\u00b6\nAdded standard pagination parameters (e.g. limit, offset) to Deployment.list, allowing you to get deployment data in smaller chunks.\nAdded the parameter base_path to get_encoded_file_contents_from_paths and get_encoded_image_contents_from_paths, allowing you to better control script behavior when using relative file paths.\nBugfixes\u00b6\nFixed field in CustomTaskVersion\nfor controlling network policies. This is changed from outgoing_network_policy to outbound_network_policy.\nWhen performing a GET action, this field was incorrect and always resolved to None. When attempting\na POST or PATCH action, the incorrect field would result in a 422.\nAlso changed the name of datarobot.enums.CustomTaskOutgoingNetworkPolicy to\ndatarobot.enums.CustomTaskOutboundNetworkPolicy to reflect the proper field name.\nFixed schema for DataSliceSizeInfo, so it\nnow allows an empty list for the messages field.\nDeprecation summary\u00b6\nRemoved the parameter in_use from ImageAugmentationList.create. This parameter was deprecated in v3.1.0.\nDeprecated AutomatedDocument.list_available_document_types. Please use AutomatedDocument.list_all_available_document_types instead.\nDeprecated Model.request_fairness_insights. Please use Model.request_per_class_fairness_insights instead, to return StatusCheckJob instead of status_id.\nDeprecated Model.get_prime_eligibility. Prime models are no longer supported.\neligibleForPrime field will no longer be returned from Model.get_supported_capabilities and will be removed after version 3.8 is released.\nDeprecated the property ShapImpact.row_count <datarobot.insights.ShapImpact.row_count> and it will be removed after version 3.7 is released.\nAdvanced options parameters: modelGroupId, modelRegimeId, and modelBaselines were renamed into seriesId, forecastDistance, and forecastOffsets and are deprecated and they will be removed after version 3.6 is released.\nRenamed datarobot.enums.CustomTaskOutgoingNetworkPolicy to datarobot.enums.CustomTaskOutboundNetworkPolicy to reflect bug fix changes. The original enum was unusable.\nRemoved parameter user_agent_suffix in datarobot.Client. Please use trace_context instead.\nRemoved deprecated method DataStore.get_access_list. Please use DataStore.get_shared_roles instead.\nRemoved support for SharingAccess instances in DataStore.update_access_list. Please use SharingRole instances instead.\nConfiguration changes\u00b6\nRemoved upper bound pin on urllib3 package to allow versions 2.0.2 and above.\nUpgraded the Pillow library to version 10.3.0. Users installing DataRobot with the \u201cimages\u201d extra (pip install datarobot[images]) should note that this is a required library.\nDocumentation changes\u00b6\nThe API Reference page has been split into multiple sections for better usability.\nFixed docs for Project.refresh to clarify that it does not return a value.\nFixed code example for ExternalScores.\nAdded copy button to code examples in ReadTheDocs documentation, for convenience.\nRemoved the outdated \u2018examples\u2019 section from the documentation. Please refer to DataRobot\u2019s API Documentation Home for more examples.\nRemoved the duplicate \u2018getting started\u2019 section from the documentation.\nUpdated to Sphinx RTD Theme v3.\nUpdated the description for the parameter: \u2018number_of_incremental_learning_iterations_before_best_model_selection\u2019 (part of the AdvancedOptions object).\nExperimental changes\u00b6\nAdded the force_update parameter to the update method in ChunkDefinition.\nRemoved attribute select_columns from ChunkDefinition\nAdded initial experimental support for Chunking Service V2\n-DatasetDefinition\n-DatasetProps\n-DatasetInfo\n-DynamicDatasetProps\n-RowsChunkDefinition\n-FeaturesChunkDefinition\n-ChunkDefinitionStats\n-ChunkDefinition\nAdded new method update to {class}`ChunkDefinition\nAdded experimental support for time series wrangling, including usage template:\ndatarobot._experimental.models.time_series_wrangling_template.user_flow_template\nExperimental changes offer automated time series feature engineering for the data in Snowflake or Postgres.\nAdded the ability to use the Spark dialect when creating a recipe, allowing data wrangling support for files.\nAdded new attribute warning to Chat.\nMoved all modules from datarobot._experimental.models.genai to datarobot.models.genai.\nAdded a new method \u2018Model.train_first_incremental_from_sample\u2019 that will train first incremental learning iteration from existing sample model. Requires \u201cProject Creation from a Dataset Sample\u201d feature flag.\n3.5.0\u00b6\nNew features\u00b6\nAdded support for BYO LLMs using serverless predictions in CustomModelLLMValidation.\nAdded attribute creation_user_name to LLMBlueprint.\nAdded a new class HostedCustomMetricTemplate for hosted custom metrics templates.\nHostedCustomMetricTemplate.get to retrieve a hosted custom metric template.\nHostedCustomMetricTemplate.list to list hosted custom metric templates.\nAdded Job.create_from_custom_metric_gallery_template to create a job from a custom metric gallery template.\nAdded a new class HostedCustomMetricTemplate for hosted custom metrics.\n: HostedCustomMetric.list to list hosted custom metrics.\nHostedCustomMetric.update to update a hosted custom metrics.\nHostedCustomMetric.delete to delete a hosted custom metric.\nHostedCustomMetric.create_from_custom_job to create a hosted custom metric from existing custom job.\nHostedCustomMetric.create_from_template to create hosted custom metric from template.\nAdded a new class datarobot.models.deployment.custom_metrics.HostedCustomMetricBlueprint for hosted custom metric blueprints.\n: HostedCustomMetricBlueprint.get to get a hosted custom metric blueprint.\nHostedCustomMetricBlueprint.create to create a hosted custom metric blueprint.\nHostedCustomMetricBlueprint.update to update a hosted custom metric blueprint.\nAdded Job.list_schedules to list job schedules.\nAdded a new class JobSchedule for the registry job schedule.\n: JobSchedule.create to create a job schedule.\nJobSchedule.update to update a job schedule.\nJobSchedule.delete to delete a job schedule.\nAdded attribute credential_type to RuntimeParameter.\nAdded a new class EvaluationDatasetConfiguration <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration> for configuration of evaluation datasets.\nEvaluationDatasetConfiguration.get <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.get> to get an evaluation dataset configuration.\nEvaluationDatasetConfiguration.list <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.list> to list the evaluation dataset configurations for a Use Case.\nEvaluationDatasetConfiguration.create <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.create> to create an evaluation dataset configuration.\nEvaluationDatasetConfiguration.update <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.update> to update an evaluation dataset configuration.\nEvaluationDatasetConfiguration.delete <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.delete> to delete an evaluation dataset configuration.\nAdded a new class EvaluationDatasetMetricAggregation <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation> for metric aggregation results.\nEvaluationDatasetMetricAggregation.list <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation.list> to get the metric aggregation results.\nEvaluationDatasetMetricAggregation.create <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation.create> to create the metric aggregation job.\nEvaluationDatasetMetricAggregation.delete <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation.delete> to delete metric aggregation results.\nAdded a new class SyntheticEvaluationDataset <datarobot._experimental.models.genai.synthetic_evaluation_dataset_generation.SyntheticEvaluationDataset> for synthetic dataset generation.\nUse SyntheticEvaluationDataset.create <datarobot._experimental.models.genai.synthetic_evaluation_dataset_generation.SyntheticEvaluationDataset.create> to create a synthetic evaluation dataset.\nAdded a new class SidecarModelMetricValidation <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation> for sidecar model metric validations.\nSidecarModelMetricValidation.create <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.create> to create a sidecar model metric validation.\nSidecarModelMetricValidation.list <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.list> to list sidecar model metric validations.\nSidecarModelMetricValidation.get <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.get> to get a sidecar model metric validation.\nSidecarModelMetricValidation.revalidate <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.revalidate> to rerun a sidecar model metric validation.\nSidecarModelMetricValidation.update <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.update> to update a sidecar model metric validation.\nSidecarModelMetricValidation.delete <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.delete> to delete a sidecar model metric validation.\nAdded experimental support for Chunking Service:\nAdded a new attribute, is_descending_order to:\nDatasourceDefinition\nDatasourceAICatalogInfo\nDatasourceDataWarehouseInfo\nBugfixes\u00b6\nUpdated the trafaret column prediction from TrainingPredictionsIterator for\nsupporting extra list of strings.\nConfiguration changes\u00b6\nUpdated black version to 23.1.0.\nRemoves dependency on package mock, since it is part of the standard library.\nDocumentation changes\u00b6\nRemoved incorrect can_share parameters in Use Case sharing example\nAdded usage of external_llm_context_size in llm_settings in genai_example.rst.\nUpdated doc string for llm_settings to include attribute external_llm_context_size for external LLMs.\nUpdated genai_example.rst to link to DataRobot doc pages for external vector database and external LLM deployment creation.\nAPI changes\u00b6\nRemove ImportedModel object since it was API for SSE (standalone scoring engine) which is not part of DataRobot anymore.\nAdded number_of_clusters parameter to Project.get_model_records\nto filter models by number of clusters in unsupervised clustering projects.\nRemove an unsupported NETWORK_EGRESS_POLICY.DR_API_ACCESS value for custom models. This value\nwas used by a feature that was never released as a GA and is not supported in the current API.\nImplemented support for dr-connector-v1 to DataStore <datarobot.models.DataStore> and DataSource <datarobot.models.DataStore>.\nAdded a new parameter name to DataStore.list for searching data stores by name.\nAdded a new parameter entity_type to the compute and create methods of the classes ShapMatrix, ShapImpact, ShapPreview. Insights can be computed for custom models if the parameter entity_type=\"customModel\" is passed. See also the User Guide: :ref:SHAP insights overview<shap_insights_overview>.\nExperimental changes\u00b6\nAdded experimental api support for Data Wrangling. See Recipe.\nRecipe.from_data_store to create a Recipe from data store.\nRecipe.retrieve_preview to get a sample of the data after recipe is applied.\nRecipe.set_inputs to set inputs to the recipe.\nRecipe.set_operations to set operations to the recipe.\nAdded new experimental DataStore that adds\nget_spark_session for Databricks databricks-v1 data stores to get a Spark session.\nAdded attribute chunking_type to DatasetChunkDefinition.\nAdded OTV attributes to DatasourceDefinition.\nAdded DatasetChunkDefinition.patch_validation_dates to patch validation dates of OTV datasource definitions after sampling job.\n3.4.1\u00b6\nNew features\u00b6\nEnhancements\u00b6\nBugfixes\u00b6\nUpdated the validation logic of RelationshipsConfiguration to work with native database connections\nAPI changes\u00b6\nDeprecation summary\u00b6\nConfiguration changes\u00b6\nDocumentation changes\u00b6\nExperimental changes\u00b6\n3.4.0\u00b6\nNew features\u00b6\nAdded the following classes for generative AI. Importing these from datarobot._experimental.models.genai is deprecated and will be removed by the release of DataRobot 10.1 and API Client 3.5.\nPlayground to manage generative AI playgrounds.\nLLMDefinition to get information about supported LLMs.\nLLMBlueprint to manage LLM blueprints.\nChat to manage chats for LLM blueprints.\nChatPrompt to submit prompts within a chat.\nComparisonChat to manage comparison chats across multiple LLM blueprints within a playground.\nComparisonPrompt to submit a prompt to multiple LLM blueprints within a comparison chat.\nVectorDatabase to create vector databases from datasets in the AI Catalog for retrieval augmented generation with an LLM blueprint.\nCustomModelVectorDatabaseValidation to validate a deployment for use as a vector database.\nCustomModelLLMValidation to validate a deployment for use as an LLM.\nUserLimits to get counts of vector databases and LLM requests for a user.\nExtended the advanced options available when setting a target to include new\nparameter: incrementalLearningEarlyStoppingRounds (part of the AdvancedOptions object).\nThis parameter allows you to specify when to stop for incremental learning automation.\nAdded experimental support for Chunking Service:\nDatasetChunkDefinition for defining how chunks are created from a data source.\nDatasetChunkDefinition.create to create a new dataset chunk definition.\nDatasetChunkDefinition.get to get a specific dataset chunk definition.\nDatasetChunkDefinition.list to list all dataset chunk definitions.\nDatasetChunkDefinition.get_datasource_definition to retrieve the data source definition.\nDatasetChunkDefinition.get_chunk to get specific chunk metadata belonging to a dataset chunk definition.\nDatasetChunkDefinition.list_chunks to list all chunk metadata belonging to a dataset chunk definition.\nDatasetChunkDefinition.create_chunk to submit a job to retrieve the data from the origin data source.\nDatasetChunkDefinition.create_chunk_by_index to submit a job to retrieve data from the origin data source by index.\nOriginStorageType\nChunk\nChunkStorageType\nChunkStorage\nDatasourceDefinition\nDatasourceAICatalogInfo to define the datasource AI catalog information to create a new dataset chunk definition.\nDatasourceDataWarehouseInfo to define the datasource data warehouse (snowflake, big query, etc) information to create a new dataset chunk definition.\nRuntimeParameter for retrieving runtime parameters assigned to CustomModelVersion.\nRuntimeParameterValue to define runtime parameter override value, to be assigned to CustomModelVersion.\nAdded Snowflake Key Pair authentication for uploading datasets from Snowflake or creating a project from Snowflake data\nAdded Project.get_model_records to retrieve models.\nMethod Project.get_models is deprecated and will be removed soon in favour of Project.get_model_records.\nExtended the advanced options available when setting a target to include new\nparameter: chunkDefinitionId (part of the AdvancedOptions object). This parameter allows you to specify the chunking definition needed for incremental learning automation.\nExtended the advanced options available when setting a target to include new Autopilot\nparameters: incrementalLearningOnlyMode and incrementalLearningOnBestModel (part of the AdvancedOptions object). These parameters allow you to specify how Autopilot is performed with the chunking service.\nAdded a new method DatetimeModel.request_lift_chart to support Lift Chart calculations for datetime partitioned projects with support of Sliced Insights.\nAdded a new method DatetimeModel.get_lift_chart to support Lift chart retrieval for datetime partitioned projects with support of Sliced Insights.\nAdded a new method DatetimeModel.request_roc_curve to support ROC curve calculation for datetime partitioned projects with support of Sliced Insights.\nAdded a new method DatetimeModel.get_roc_curve to support ROC curve retrieval for datetime partitioned projects with support of Sliced Insights.\nUpdate method DatetimeModel.request_feature_impact to support use of Sliced Insights.\nUpdate method DatetimeModel.get_feature_impact to support use of Sliced Insights.\nUpdate method DatetimeModel.get_or_request_feature_impact to support use of Sliced Insights.\nUpdate method DatetimeModel.request_feature_effect to support use of Sliced Insights.\nUpdate method DatetimeModel.get_feature_effect to support use of Sliced Insights.\nUpdate method DatetimeModel.get_or_request_feature_effect to support use of Sliced Insights.\nAdded a new method FeatureAssociationMatrix.create to support the creation of FeatureAssociationMatricies for Featurelists.\nIntroduced a new method Deployment.perform_model_replace as a replacement for Deployment.replace_model.\nIntroduced a new property, model_package, which provides an overview of the currently used model package in datarobot.models.Deployment.\nAdded new parameter prediction_threshold to BatchPredictionJob.score_with_leaderboard_model\nand BatchPredictionJob.score that automatically assigns the positive class label to any prediction exceeding the threshold.\nAdded two new enum values to  :class: datarobot.models.data_slice.DataSlicesOperators, \u201cBETWEEN\u201d and \u201cNOT_BETWEEN\u201d, which are used to allow slicing.\nAdded a new class Challenger for interacting with DataRobot challengers to support the following methods:\nChallenger.get to retrieve challenger objects by ID.\nChallenger.list to list all challengers.\nChallenger.create to create a new challenger.\nChallenger.update to update a challenger.\nChallenger.delete to delete a challenger.\nAdded a new method Deployment.get_challenger_replay_settings to retrieve the challenger replay settings of a deployment.\nAdded a new method Deployment.list_challengers to retrieve the challengers of a deployment.\nAdded a new method Deployment.get_champion_model_package to retrieve the champion model package from a deployment.\nAdded a new method Deployment.list_prediction_data_exports to retrieve deployment prediction data exports.\nAdded a new method Deployment.list_actuals_data_exports to retrieve deployment actuals data exports.\nAdded a new method Deployment.list_training_data_exports to retrieve deployment training data exports.\nManage deployment health settings with the following methods:\nGet health settings Deployment.get_health_settings\nUpdate health settings Deployment.update_health_settings\nGet default health settings Deployment.get_default_health_settings\nAdded new enum value to datarobot.enums._SHARED_TARGET_TYPE to support Text Generation use case.\nAdded new enum value datarobotServerless to datarobot.enums.PredictionEnvironmentPlatform to support DataRobot Serverless prediction environments.\nAdded new enum value notApplicable to datarobot.enums.PredictionEnvironmentHealthType to support new health status from DataRobot API.\nAdded new enum value to datarobot.enums.TARGET_TYPE and datarobot.enums.CUSTOM_MODEL_TARGET_TYPE to support text generation custom inference models.\nUpdated datarobot.CustomModel to support the creation of text generation custom models.\nAdded a new class CustomMetric for interacting with DataRobot custom metrics to support the following methods:\nCustomMetric.get to retrieve a custom metric object by ID from a given deployment.\nCustomMetric.list to list all custom metrics from a given deployment.\nCustomMetric.create to create a new custom metric for a given deployment.\nCustomMetric.update to update a custom metric for a given deployment.\nCustomMetric.delete to delete a custom metric for a given deployment.\nCustomMetric.unset_baseline to remove baseline for a given custom metric.\nCustomMetric.submit_values to submit aggregated custom metrics values from code. The provided data should be in the form of a dict or a Pandas DataFrame.\nCustomMetric.submit_single_value to submit a single custom metric value.\nCustomMetric.submit_values_from_catalog to submit aggregated custom metrics values from a dataset via the AI Catalog.\nCustomMetric.get_values_over_time to retrieve values of a custom metric over a time period.\nCustomMetric.get_summary to retrieve the summary of a custom metric over a time period.\nCustomMetric.get_values_over_batch to retrieve values of a custom metric over batches.\nCustomMetric.get_batch_summary to retrieve the summary of a custom metric over batches.\nAdded CustomMetricValuesOverTime to retrieve custom metric over time information.\nAdded CustomMetricSummary to retrieve custom metric over time summary.\nAdded CustomMetricValuesOverBatch to retrieve custom metric over batch information.\nAdded CustomMetricBatchSummary to retrieve custom metric batch summary.\nAdded Job and  JobRun  to create, read, update, run, and delete jobs in the Registry.\nAdded KeyValue to create, read, update, and delete key values.\nAdded a new class PredictionDataExport for interacting with DataRobot deployment data export to support the following methods:\nPredictionDataExport.get to retrieve a prediction data export object by ID from a given deployment.\nPredictionDataExport.list to list all prediction data exports from a given deployment.\nPredictionDataExport.create to create a new prediction data export for a given deployment.\nPredictionDataExport.fetch_data to retrieve a prediction export data as a DataRobot dataset.\nAdded a new class ActualsDataExport for interacting with DataRobot deployment data export to support the following methods:\nActualsDataExport.get to retrieve an actuals data export object by ID from a given deployment.\nActualsDataExport.list to list all actuals data exports from a given deployment.\nActualsDataExport.create to create a new actuals data export for a given deployment.\nActualsDataExport.fetch_data to retrieve an actuals export data  as a DataRobot dataset.\nAdded a new class TrainingDataExport for interacting with DataRobot deployment data export to support the following methods:\nTrainingDataExport.get to retrieve a training data export object by ID from a given deployment.\nTrainingDataExport.list to list all training data exports from a given deployment.\nTrainingDataExport.create to create a new training data export for a given deployment.\nTrainingDataExport.fetch_data to retrieve a training export data as a DataRobot dataset.\nAdded a new parameter base_environment_version_id to CustomModelVersion.create_clean for overriding the default environment version selection behavior.\nAdded a new parameter base_environment_version_id to CustomModelVersion.create_from_previous for overriding the default environment version selection behavior.\nAdded a new class PromptTrace <datarobot._experimental.models.genai.prompt_trace.PromptTrace> for interacting with DataRobot prompt trace to support the following methods:\nPromptTrace.list <datarobot._experimental.models.genai.prompt_trace.PromptTrace.list> to list all prompt traces from a given playground.\nPromptTrace.export_to_ai_catalog <datarobot._experimental.models.genai.prompt_trace.PromptTrace.export_to_ai_catalog> to export prompt traces for the playground to AI catalog.\nAdded a new class InsightsConfiguration <datarobot._experimental.models.genai.insights_configuration.InsightsConfiguration> for describing available insights and configured insights for a playground.\nInsightsConfiguration.list <datarobot._experimental.models.genai.insights_configuration.InsightsConfiguration.list> to list the insights that are available to be configured.\nAdded a new class Insights <datarobot._experimental.models.genai.insights_configuration.Insights> for configuring insights for a playground.\nInsights.get <datarobot._experimental.models.genai.insights_configuration.Insights.get> to get the current insights configuration for a playground.\nInsights.create <datarobot._experimental.models.genai.insights_configuration.Insights.create> to create or update the insights configuration for a playground.\nAdded a new class :class: CostMetricConfiguration <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration> for describing available cost metrics and configured cost metrics for a Use Case.\nCostMetricConfiguration.get <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.get> to get the cost metric configuration.\nCostMetricConfiguration.create <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.create> to create a cost metric configuration.\nCostMetricConfiguration.update <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.update> to update the cost metric configuration.\nCostMetricConfiguration.delete <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.delete> to delete the cost metric configuration.Key\nAdded a new class LLMCostConfiguration <datarobot._experimental.models.genai.cost_metric_configurations.LLMCostConfiguration> for the cost configuration of a specific llm within a Use Case.\nAdded new classes ShapMatrix, ShapImpact, ShapPreview to interact with SHAP-based insights. See also the User Guide: :ref:SHAP insights overview<shap_insights_overview>\nAPI changes\u00b6\nParameter Overrides: Users can now override most of the previously set configuration values directly through parameters when initializing the Client. Exceptions: The endpoint and token values must be initialized from one source (client params, environment, or config file) and cannot be overridden individually, for security and consistency reasons. The new configuration priority is as follows:\nClient Params\nClient config_path param\nEnvironment Variables\nDefault to reading YAML config file from ~/.config/datarobot/drconfig.yaml\nDATAROBOT_API_CONSUMER_TRACKING_ENABLED now always defaults to True.\nAdded Databricks personal access token and service principal (also shared credentials via secure config) authentication for uploading datasets from Databricks or creating a project from Databricks data.\nAdded secure config support for AWS long term credentials.\nImplemented support for dr-database-v1 to DataStore <datarobot.models.DataStore>, DataSource <datarobot.models.DataStore>, and  DataDriver <datarobot.models.DataDriver>. Added enum classes to support the changes.\nYou can retrieve the canonical URI for a Use Case using UseCase.get_uri.\nYou can open a Use Case in a browser using UseCase.open_in_browser.\nEnhancements\u00b6\nAdded a new parameter to Dataset.create_from_url to support fast dataset registration:\nsample_size\nAdded a new parameter to Dataset.create_from_data_source to support fast dataset registration:\nsample_size\nJob.get_result_when_complete\nreturns datarobot.models.DatetimeModel instead of the datarobot.models.Model\nif a datetime model was trained.\nDataset.get_as_dataframe can handle\ndownloading parquet files as well as csv files.\nImplement support for dr-database-v1 in DataStore <datarobot.models.DataStore>\nAdded two new parameters to BatchPredictionJobDefinition.list for paginating long job definitions lists:\noffset\nlimit\nAdded two new parameters to BatchPredictionJobDefinition.list for filtering the job definitions:\ndeployment_id\nsearch_name\nAdded new parameter to Deployment.validate_replacement_model to support replacement validation based on model package ID:\nnew_registered_model_version_id\nAdded support for Native Connectors to Connector <datarobot.models.Connector> for everything other than :meth:` Connector.create ` and :meth:` Connector.update `\nDeprecation summary\u00b6\nRemoved Model.get_leaderboard_ui_permalink and Model.open_model_browser\nDeprecated Project.get_models in favour of Project.get_model_records.\nBatchPredictionJobDefinition.list will no longer return all job definitions after version 3.6 is released.\nTo preserve current behavior please pass limit=0.\nnew_model_id parameter in Deployment.validate_replacement_model will be removed after version 3.6 is released.\nDeployment.replace_model will be removed after version 3.6 is released.\nMethod Deployment.perform_model_replace should be used instead.\nCustomInferenceModel.assign_training_data was marked as deprecated in v3.2. The deprecation period has been extended, and the feature will now be removed in v3.5.\nUse CustomModelVersion.create_clean and CustomModelVersion.create_from_previous instead.\nDocumentation changes\u00b6\nUpdated genai_example.rst to utilize latest genAI features and methods introduced most recently in the API client.\nExperimental changes\u00b6\nAdded new attribute, prediction_timeout to CustomModelValidation.\nAdded new attributes, feedback_result, metrics, and final_prompt to ResultMetadata <datarobot._experimental.models.genai.chat_prompt.ResultMetadata>.\nAdded use_case_id to CustomModelValidation.\nAdded llm_blueprints_count and user_name to Playground.\nAdded custom_model_embedding_validations to SupportedEmbeddings <datarobot._experimental.models.genai.vector_database.SupportedEmbeddings>.\nAdded embedding_validation_id and is_separator_regex to VectorDatabase <datarobot._experimental.models.genai.vector_database.VectorDatabase>.\nAdded optional parameters, use_case, name, and model to CustomModelValidation.create.\nAdded a method CustomModelValidation.list, to list custom model validations available to a user with several optional parameters to filter the results.\nAdded a method CustomModelValidation.update, to update a custom model validation.\nAdded an optional parameter, use_case, to LLMDefinition.list,\nto include in the returned LLMs the external LLMs available for the specified use_case as well.\nAdded optional parameter, playground to VectorDatabase.list\nto list vector databases by playground.\nAdded optional parameter, comparison_chat, to ComparisonPrompt.list, to list comparison prompts by comparison chat.\nAdded optional parameter, comparison_chat, to ComparisonPrompt.create, to specify the comparison chat to create the comparison prompt in.\nAdded optional parameter, feedback_result, to ComparisonPrompt.update <datarobot._experimental.models.genai.comparison_prompt.ComparisonPrompt.update>, to update a comparison prompt with feedback.\nAdded optional parameters, is_starred to LLMBlueprint.update\nto update the LLM blueprint\u2019s starred status.\nAdded optional parameters, is_starred to LLMBlueprint.list\nto filter the returned LLM blueprints to those matching is_starred.\nAdded a new enum PromptType, PromptType to identify the LLMBlueprint\u2019s prompting type.\nAdded optional parameters, prompt_type to LLMBlueprint.create,\nto specify the LLM blueprint\u2019s prompting type. This can be set with PromptType.\nAdded optional parameters, prompt_type to LLMBlueprint.update,\nto specify the updated LLM blueprint\u2019s prompting type. This can be set with PromptType.\nAdded a new class, ComparisonChat, for interacting with DataRobot generative AI comparison chats.\nComparisonChat.get retrieves a comparison chat object by ID.\nComparisonChat.list lists all comparison chats available to the user.\nComparisonChat.create creates a new comparison chat.\nComparisonChat.update updates the name of a comparison chat.\nComparisonChat.delete deletes a single comparison chat.\nAdded optional parameters, playground and chat to ChatPrompt.list, to list chat prompts by playground and chat.\nAdded optional parameter, chat to ChatPrompt.create, to specify the chat to create the chat prompt in.\nAdded a new method, ChatPrompt.update <datarobot._experimental.models.genai.chat_prompt.ChatPrompt.update>, to update a chat prompt with custom metrics and feedback.\nAdded a new class, Chat, for interacting with DataRobot generative AI chats.\nChat.get retrieves a chat object by ID.\nChat.list lists all chats available to the user.\nChat.create creates a new chat.\nChat.update updates the name of a chat.\nChat.delete deletes a single chat.\nRemoved the model_package module. Use RegisteredModelVersion instead.\nAdded new class UserLimits\nAdded support to get the count of users\u2019 LLM API requests. UserLimits.get_llm_requests_count\nAdded support to get the count of users\u2019 vector databases. UserLimits.get_vector_database_count\nAdded new methods to the class Notebook which includes Notebook.run and Notebook.download_revision. See the documentation for example usage.\nAdded new class NotebookScheduledJob.\nAdded new class NotebookScheduledRun.\nAdded a new method Model.get_incremental_learning_metadata that retrieves incremental learning metadata for a model.\nAdded a new method Model.start_incremental_learning that starts incremental learning for a model.\nUpdated the API endpoint prefix for all GenerativeAI routes to align with the publicly documented routes.\nBugfixes\u00b6\nFixed how async url is build in Model.get_or_request_feature_impact\nFixed setting ssl_verify by env variables.\nResolved a problem related to tilde-based paths in the Client\u2019s \u2018config_path\u2019 attribute.\nChanged the force_size default of ImageOptions to apply the same transformations by default, which are applied when image archive datasets are uploaded to DataRobot.\n3.3.0\u00b6\nNew features\u00b6\nAdded support for Python 3.11.\nAdded new library strenum to add StrEnum support while maintaining backwards compatibility with Python 3.7-3.10. DataRobot does not use the native StrEnum class in Python 3.11.\nAdded a new class PredictionEnvironment for interacting with DataRobot Prediction environments.\nExtended the advanced options available when setting a target to include new\nparameters: modelGroupId, modelRegimeId, and modelBaselines (part of the AdvancedOptions object). These parameters allow you to specify the user columns required to run time series models without feature derivation in OTV projects.\nAdded a new method PredictionExplanations.create_on_training_data, for computing prediction explanation on training data.\nAdded a new class RegisteredModel for interacting with DataRobot registered models to support the following methods:\nRegisteredModel.get to retrieve RegisteredModel object by ID.\nRegisteredModel.list to list all registered models.\nRegisteredModel.archive to permanently archive registered model.\nRegisteredModel.update to update registered model.\nRegisteredModel.get_shared_roles to retrieve access control information for registered model.\nRegisteredModel.share to share a registered model.\nRegisteredModel.get_version to retrieve RegisteredModelVersion object by ID.\nRegisteredModel.list_versions to list registered model versions.\nRegisteredModel.list_associated_deployments to list deployments associated with a registered model.\nAdded a new class RegisteredModelVersion for interacting with DataRobot registered model versions (also known as model packages) to support the following methods:\nRegisteredModelVersion.create_for_external to create a new registered model version from an external model.\nRegisteredModelVersion.list_associated_deployments to list deployments associated with a registered model version.\nRegisteredModelVersion.create_for_leaderboard_item to create a new registered model version from a Leaderboard model.\nRegisteredModelVersion.create_for_custom_model_version to create a new registered model version from a custom model version.\nAdded a new method Deployment.create_from_registered_model_version to support creating deployments from registered model version.\nAdded a new method Deployment.download_model_package_file to support downloading model package files (.mlpkg) of the currently deployed model.\nAdded support for retrieving document thumbnails:\nDocumentThumbnail\nDocumentPageFile\nAdded support to retrieve document text extraction samples using:\nDocumentTextExtractionSample\nDocumentTextExtractionSamplePage\nDocumentTextExtractionSampleDocument\nAdded new fields to CustomTaskVersion\nfor controlling network policies. The new fields were also added to the response. This can be set with\ndatarobot.enums.CustomTaskOutgoingNetworkPolicy.\nAdded a new method BatchPredictionJob.score_with_leaderboard_model to run batch predictions using a Leaderboard model instead of a deployment.\nSet IntakeSettings and OutputSettings to use IntakeAdapters and OutputAdapters enum values respectively for the property type.\nAdded method meth:Deployment.get_predictions_vs_actuals_over_time <datarobot.models.Deployment.get_predictions_vs_actuals_over_time> to retrieve a deployment\u2019s predictions vs actuals over time data.\nBugfixes\u00b6\nPayload property subset renamed to source in Model.request_feature_effect\nFixed an issue where Context.trace_context was not being set from environment variables or DR config files.\nProject.refresh no longer sets Project.advanced_options to a dictionary.\nFixed Dataset.modify to clarify behavior of when to preserve or clear categories.\nFixed an issue with enums in f-strings resulting in the enum class and property being printed instead of the enum property\u2019s value in Python 3.11 environments.\nDeprecation summary\u00b6\nProject.refresh will no longer set Project.advanced_options to a dictionary after version 3.5 is released.\n: All interactions with Project.advanced_options should be expected to be through the AdvancedOptions class.\nExperimental changes\u00b6\nAdded a new class, VectorDatabase, for interacting with DataRobot vector databases.\nVectorDatabase.get retrieves a VectorDatabase object by ID.\nVectorDatabase.list lists all VectorDatabases available to the user.\nVectorDatabase.create creates a new VectorDatabase.\nVectorDatabase.create allows you to use a validated deployment of a custom model as your own Vector Database.\nVectorDatabase.update updates the name of a VectorDatabase.\nVectorDatabase.delete deletes a single VectorDatabase.\nVectorDatabase.get_supported_embeddings retrieves all supported embedding models.\nVectorDatabase.get_supported_text_chunkings retrieves all supported text chunking configurations.\nVectorDatabase.download_text_and_embeddings_asset download a parquet file with internal vector database data.\nAdded a new class, CustomModelVectorDatabaseValidation, for validating custom model deployments for use as a vector database.\nCustomModelVectorDatabaseValidation.get retrieves a CustomModelVectorDatabaseValidation object by ID.\nCustomModelVectorDatabaseValidation.get_by_values retrieves a CustomModelVectorDatabaseValidation object by field values.\nCustomModelVectorDatabaseValidation.create starts validation of the deployment.\nCustomModelVectorDatabaseValidation.revalidate repairs an unlinked external vector database.\nAdded a new class, Playground, for interacting with DataRobot generative AI playgrounds.\nPlayground.get retrieves a playground object by ID.\nPlayground.list lists all playgrounds available to the user.\nPlayground.create creates a new playground.\nPlayground.update updates the name and description of a playground.\nPlayground.delete deletes a single playground.\nAdded a new class, LLMDefinition, for interacting with DataRobot generative AI LLMs.\nLLMDefinition.list lists all LLMs available to the user.\nAdded a new class, LLMBlueprint, for interacting with DataRobot generative AI LLM blueprints.\nLLMBlueprint.get retrieves an LLM blueprint object by ID.\nLLMBlueprint.list lists all LLM blueprints available to the user.\nLLMBlueprint.create creates a new LLM blueprint.\nLLMBlueprint.create_from_llm_blueprint creates a new LLM blueprint from an existing one.\nLLMBlueprint.update updates an LLM blueprint.\nLLMBlueprint.delete deletes a single LLM blueprint.\nAdded a new class, ChatPrompt, for interacting with DataRobot generative AI chat prompts.\nChatPrompt.get retrieves a chat prompt object by ID.\nChatPrompt.list lists all chat prompts available to the user.\nChatPrompt.create creates a new chat prompt.\nChatPrompt.delete deletes a single chat prompt.\nAdded a new class, CustomModelLLMValidation, for validating custom model deployments for use as a custom model LLM.\nCustomModelLLMValidation.get retrieves a CustomModelLLMValidation object by ID.\nCustomModelLLMValidation.get_by_values retrieves a CustomModelLLMValidation object by field values.\nCustomModelLLMValidation.create starts validation of the deployment.\nCustomModelLLMValidation.revalidate repairs an unlinked external custom model LLM.\nAdded a new class, ComparisonPrompt, for interacting with DataRobot generative AI comparison prompts.\nComparisonPrompt.get retrieves a comparison prompt object by ID.\nComparisonPrompt.list lists all comparison prompts available to the user.\nComparisonPrompt.create creates a new comparison prompt.\nComparisonPrompt.update updates a comparison prompt.\nComparisonPrompt.delete deletes a single comparison prompt.\nExtended UseCase, adding two new fields to represent the count of vector databases and playgrounds.\nAdded a new method, ChatPrompt.create_llm_blueprint, to create an LLM blueprint from a chat prompt.\nAdded a new method, CustomModelLLMValidation.delete, to delete a custom model LLM validation record.\nAdded a new method, LLMBlueprint.register_custom_model, for registering a custom model from a generative AI LLM blueprint.\n3.2.0\u00b6\nNew features\u00b6\nAdded new methods to trigger batch monitoring jobs without providing a job definition.\nBatchMonitoringJob.run\nBatchMonitoringJob.get_status\nBatchMonitoringJob.cancel\nBatchMonitoringJob.download\nAdded Deployment.submit_actuals_from_catalog_async to submit actuals from the AI Catalog.\nAdded a new class StatusCheckJob which represents a job for a status check of submitted async jobs.\nAdded a new class JobStatusResult represents the result for a status check job of a submitted async task.\nAdded DatetimePartitioning.datetime_partitioning_log_retrieve to download the datetime partitioning log.\nAdded method DatetimePartitioning.datetime_partitioning_log_list to list the datetime partitioning log.\nAdded DatetimePartitioning.get_input_data to retrieve the input data used to create an optimized datetime partitioning.\nAdded DatetimePartitioningId, which can be passed as a partitioning_method to Project.analyze_and_model.\nAdded the ability to share deployments. See :ref:deployment sharing <deployment_sharing> for more information on sharing deployments.\nAdded new methods get_bias_and_fairness_settings and update_bias_and_fairness_settings to retrieve or update bias and fairness settings.\nDeployment.get_bias_and_fairness_settings\nDeployment.update_bias_and_fairness_settings\nAdded a new class UseCase for interacting with the DataRobot Use Cases API.\nAdded a new class Application for retrieving DataRobot Applications available to the user.\nAdded a new class SharingRole to hold user or organization access rights.\nAdded a new class BatchMonitoringJob for interacting with batch monitoring jobs.\nAdded a new class BatchMonitoringJobDefinition for interacting with batch monitoring jobs definitions.\nAdded a new methods for handling monitoring job definitions: list, get, create, update, delete, run_on_schedule and run_once\nBatchMonitoringJobDefinition.list\nBatchMonitoringJobDefinition.get\nBatchMonitoringJobDefinition.create\nBatchMonitoringJobDefinition.update\nBatchMonitoringJobDefinition.delete\nBatchMonitoringJobDefinition.run_on_schedule\nBatchMonitoringJobDefinition.run_once\nAdded a new method to retrieve a monitoring job\nBatchMonitoringJob.get\nAdded the ability to filter return objects by a Use Case ID passed to the following methods:\nDataset.list\nProject.list\nAdded the ability to automatically add a newly created dataset or project to a Use Case by passing a UseCase, list of UseCase objects, UseCase ID or list of UseCase IDs using the keyword argument use_cases to the following methods:\nDataset.create_from_file\nDataset.create_from_in_memory_data\nDataset.create_from_url\nDataset.create_from_data_source\nDataset.create_from_query_generator\nDataset.create_project\nProject.create\nProject.create_from_data_source\nProject.create_from_dataset\nProject.create_segmented_project_from_clustering_model\nProject.start\nAdded the ability to set a default UseCase for requests. It can be set in several ways.\nIf the user configures the client via Client(...), then invoke Client(..., default_use_case = <id>).\nIf the user configures the client via dr.config.yaml, then add the property default_use_case: <id>.\nIf the user configures the client via env vars, then set the env var DATAROBOT_DEFAULT_USE_CASE.\nThe default use case can also be set programmatically as a context manager via with UseCase.get(<id>):.\nAdded the ability to configure the collection of client usage metrics to send to DataRobot. Note that this feature only tracks which DataRobot package methods are called and does not collect any user data. You can configure collection with the following settings:\nIf the user configures the client via Client(...), then invoke Client(..., enable_api_consumer_tracking = <True/False>).\nIf the user configures the client via dr.config.yaml, then add the property enable_api_consumer_tracking: <True/False>.\nIf the user configures the client via env vars, then set the env var DATAROBOT_API_CONSUMER_TRACKING_ENABLED.\nCurrently the default value for enable_api_consumer_tracking is True.\n- Added method meth:Deployment.get_predictions_over_time <datarobot.models.Deployment.get_predictions_over_time> to retrieve deployment predictions over time data.\n- Added a new class FairnessScoresOverTime to retrieve fairness over time information.\n- Added a new method Deployment.get_fairness_scores_over_time to retrieve fairness scores over time of a deployment.\n- Added a new use_gpu parameter to the method Project.analyze_and_model to set whether the project should allow usage of GPU\n- Added a new use_gpu parameter to the class Project with information whether project allows usage of GPU\n- Added a new class TrainingData for retrieving TrainingData assigned to CustomModelVersion.\n- Added a new class HoldoutData for retrieving HoldoutData assigned to CustomModelVersion.\n- Added the ability to retrieve the model and blueprint json using the following methods:\nModel.get_model_blueprint_json\nBlueprint.get_json\n- Added Credential.update which allows you to update existing credential resources.\n- Added a new optional parameter trace_context to datarobot.Client to provide additional information on the DataRobot code being run. This parameter defaults to None.\n- Updated methods in Model to support use of Sliced Insights:\nModel.get_feature_effect\nModel.request_feature_effect\nModel.get_or_request_feature_effect\nModel.get_lift_chart\nModel.get_all_lift_charts\nModel.get_residuals_chart\nModel.get_all_residuals_charts\nModel.request_lift_chart\nModel.request_residuals_chart\nModel.get_roc_curve\nModel.get_feature_impact\nModel.request_feature_impact\nModel.get_or_request_feature_impact\n- Added support for SharingRole to the following methods:\n- DataStore.share\n- Added new methods for retrieving SharingRole information for the following classes:\n- DataStore.get_shared_roles\n- Added new method for calculating sliced roc curve Model.request_roc_curve\n- Added new DataSlice to support the following slices methods:\nDataSlice.list to retrieve all data slices in a project.\nDataSlice.create to create a new data slice.\nDataSlice.delete to delete the data slice calling this method.\nDataSlice.request_size to submit a request to calculate a data slice size on a source.\nDataSlice.get_size_info to get the data slice\u2019s info when applied to a source.\nDataSlice.get to retrieve a specific data slice.\n- Added new DataSliceSizeInfo to define the result of a data slice applied to a source.\n- Added new method for retrieving all available feature impacts for the model Model.get_all_feature_impacts.\n- Added new method for StatusCheckJob to wait and return the completed object once it is generated datarobot.models.StatusCheckJob.get_result_when_complete()\nEnhancements\u00b6\nImprove error message of SampleImage.list\nto clarify that a selected parameter cannot be used when a project has not proceeded to the\ncorrect stage prior to calling this method.\nExtended SampleImage.list by two parameters\nto filter for a target value range in regression projects.\nAdded text explanations data to PredictionExplanations and made sure it is returned in both datarobot.PredictionExplanations.get_all_as_dataframe()  and datarobot.PredictionExplanations.get_rows() method.\nAdded two new parameters to Project.upload_dataset_from_catalog:\n: - credential_id\n- credential_data\nImplemented training and holdout data assignment for Custom Model Version creation APIs:\n: - CustomModelVersion.create_clean\n- CustomModelVersion.create_from_previous\nThe parameters added to both APIs are:\n: - training_dataset_id\n- partition_column\n- holdout_dataset_id\n- keep_training_holdout_data\n- max_wait\nExtended CustomInferenceModel.create and CustomInferenceModel.update\nwith the parameter is_training_data_for_versions_permanently_enabled.\nAdded value DR_API_ACCESS to the NETWORK_EGRESS_POLICY enum.\nAdded new parameter low_memory to Dataset.get_as_dataframe to allow a low memory mode for larger datasets\nAdded two new parameters to Project.list for paginating long project lists:\n: - offset\n- limit\nBugfixes\u00b6\nFixed incompatibilities with Pandas 2.0 in DatetimePartitioning.to_dataframe.\nFixed a crash when using non-\u201clatin-1\u201d characters in Panda\u2019s DataFrame used as prediction data in BatchPredictionJob.score.\nFixed an issue where failed authentication when invoking datarobot.client.Client() raises a misleading error about client-server compatibility.\nFixed incompatibilities with Pandas 2.0 in AccuracyOverTime.get_as_dataframe. The method will now throw a ValueError if an empty list is passed to the parameter metrics.\nAPI changes\u00b6\nAdded parameter unsupervised_type to the class DatetimePartitioning.\nThe sliced insight API endpoint GET: api/v2/insights/<insight_name>/ returns a paginated response. This means that it returns an empty response if no insights data is found, unlike GET: api/v2/projects/<pid>/models/<lid>/<insight_name>/, which returns 404 NOT FOUND in this case. To maintain backwards-compatibility, all methods that retrieve insights data raise 404 NOT FOUND if the insights API returns an empty response.\nDeprecation summary\u00b6\nModel.get_feature_fit_metadata has been removed.\nUse Model.get_feature_effect_metadata instead.\nDatetimeModel.get_feature_fit_metadata has been removed.\nUse DatetimeModel.get_feature_effect_metadata instead.\nModel.request_feature_fit has been removed.\nUse Model.request_feature_effect instead.\nDatetimeModel.request_feature_fit has been removed.\nUse DatetimeModel.request_feature_effect instead.\nModel.get_feature_fit has been removed.\nUse Model.get_feature_effect instead.\nDatetimeModel.get_feature_fit has been removed.\nUse DatetimeModel.get_feature_effect instead.\nModel.get_or_request_feature_fit has been removed.\nUse Model.get_or_request_feature_effect instead.\nDatetimeModel.get_or_request_feature_fit has been removed.\nUse DatetimeModel.get_or_request_feature_effect instead.\nDeprecated the use of SharingAccess in favor of SharingRole for sharing in the following classes:\nDataStore.share\nDeprecated the following methods for retrieving SharingAccess information.\nDataStore.get_access_list. Please use DataStore.get_shared_roles instead.\nCustomInferenceModel.assign_training_data was marked as deprecated and will be removed in v3.4.\nUse CustomModelVersion.create_clean and CustomModelVersion.create_from_previous instead.\nConfiguration changes\u00b6\nPins dependency on package urllib3  to be less than version 2.0.0.\nDeprecation summary\u00b6\nDeprecated parameter user_agent_suffix in datarobot.Client. user_agent_suffix will be removed in v3.4. Please use trace_context instead.\nDocumentation changes\u00b6\nFixed in-line documentation of DataRobotClientConfig.\nFixed documentation around client configuration from environment variables or config file.\nExperimental changes\u00b6\nAdded experimental support for data matching:\nDataMatching\nDataMatchingQuery\nAdded new method DataMatchingQuery.get_result for returning data matching query results as pandas dataframes to DataMatchingQuery .\nChanged behavior for returning results in the DataMatching. Instead of saving the results as a file, a pandas dataframe will be returned in the following methods:\n: - DataMatching.get_closest_data\n- DataMatching.get_closest_data_for_model\n- DataMatching.get_closest_data_for_featurelist\nAdded experimental support for model lineage: ModelLineage\nChanged behavior for methods that search for the closest data points in DataMatching. If the index is missing, instead of throwing the error, methods try to create the index and then query it. This is enabled by default, but if this is not the intended behavior it can be changed by passing False to the new build_index parameter added to the methods:\n: - DataMatching.get_closest_data\n- DataMatching.get_closest_data_for_model\n- DataMatching.get_closest_data_for_featurelist\nAdded a new class Notebook for retrieving DataRobot Notebooks available to the user.\nAdded experimental support for data wrangling:\nRecipe\n3.1.1\u00b6\nConfiguration changes\u00b6\nRemoves dependency on package contextlib2  since the package is Python 3.7+.\nUpdate typing-extensions to be inclusive of versions from 4.3.0 to < 5.0.0.\n3.1.0\u00b6\nEnhancements\u00b6\nAdded new methods BatchPredictionJob.apply_time_series_data_prep_and_score\nand BatchPredictionJob.apply_time_series_data_prep_and_score_to_file\nthat apply time series data prep to a file or dataset and make batch predictions with a deployment.\nAdded new methods DataEngineQueryGenerator.prepare_prediction_dataset\nand DataEngineQueryGenerator.prepare_prediction_dataset_from_catalog\nthat apply time series data prep to a file or catalog dataset and upload the prediction dataset to a\nproject.\nAdded new max_wait parameter to method Project.create_from_dataset.\nValues larger than the default can be specified to avoid timeouts when creating a project from Dataset.\nAdded new method for creating a segmented modeling project from an existing clustering project and model\nProject.create_segmented_project_from_clustering_model.\nPlease switch to this function if you are previously using ModelPackage for segmented modeling purposes.\nAdded new method is_unsupervised_clustering_or_multiclass for checking whether the clustering or multiclass parameters are used, quick and efficient without extra API calls.\nPredictionExplanations.is_unsupervised_clustering_or_multiclass\nRetry idempotent requests which result in HTTP 502 and HTTP 504 (in addition to the previous HTTP 413, HTTP 429 and HTTP 503)\nAdded value PREPARED_FOR_DEPLOYMENT to the RECOMMENDED_MODEL_TYPE enum\nAdded two new methods to the ImageAugmentationList class:\nImageAugmentationList.list,\nImageAugmentationList.update\nBugfixes\u00b6\nAdded format key to Batch Prediction intake and output settings for S3, GCP and Azure\nAPI changes\u00b6\nThe method PredictionExplanations.is_multiclass now adds an additional API call to check for multiclass target validity, which adds a small delay.\nAdvancedOptions parameter blend_best_models defaults to false\nAdvancedOptions parameter consider_blenders_in_recommendation defaults to false\nDatetimePartitioning has parameter unsupervised_mode\nDeprecation summary\u00b6\nDeprecated method Project.create_from_hdfs.\nDeprecated method DatetimePartitioning.generate.\nDeprecated parameter in_use from ImageAugmentationList.create as DataRobot will take care of it automatically.\nDeprecated property Deployment.capabilities from Deployment.\nImageAugmentationSample.compute was removed in v3.1. You\ncan get the same information with the method ImageAugmentationList.compute_samples.\nsample_id parameter removed from ImageAugmentationSample.list. Please use auglist_id instead.\nDocumentation changes\u00b6\nUpdate the documentation to suggest that setting use_backtest_start_end_format of DatetimePartitioning.to_specification to True will mirror the same behavior as the Web UI.\nUpdate the documentation to suggest setting use_start_end_format of Backtest.to_specification to True will mirror the same behavior as the Web UI.\n3.0.3\u00b6\nBugfixes\u00b6\nFixed an issue affecting backwards compatibility in datarobot.models.DatetimeModel, where an unexpected keyword from the DataRobot API would break class deserialization.\n3.0.2\u00b6\nBugfixes\u00b6\nRestored Model.get_leaderboard_ui_permalink, Model.open_model_browser,\nThese methods were accidentally removed instead of deprecated.\nFix for ipykernel < 6.0.0 which does not persist contextvars across cells\nDeprecation summary\u00b6\nDeprecated method Model.get_leaderboard_ui_permalink. Please use Model.get_uri instead.\nDeprecated method Model.open_model_browser. Please use Model.open_in_browser instead.\n3.0.1\u00b6\nBugfixes\u00b6\nAdded typing-extensions as a required dependency for the DataRobot Python API client.\n3.0.0\u00b6\nNew features\u00b6\nVersion 3.0 of the Python client does not support Python 3.6 and earlier versions. Version 3.0 currently supports Python 3.7+.\nThe default Autopilot mode for project.start_autopilot has changed to Quick mode.\nFor datetime-aware models, you can now calculate and retrieve feature impact for backtests other than zero and holdout:\nDatetimeModel.get_feature_impact\nDatetimeModel.request_feature_impact\nDatetimeModel.get_or_request_feature_impact\nAdded a backtest field to feature impact metadata: Model.get_or_request_feature_impact. This field is null for non-datetime-aware models and greater than or equal to zero for holdout in datetime-aware models.\nYou can use a new method to retrieve the canonical URI for a project, model, deployment, or dataset:\nProject.get_uri\nModel.get_uri\nDeployment.get_uri\nDataset.get_uri\nYou can use a new method to open a class in a browser based on their URI (project, model, deployment, or dataset):\nProject.open_in_browser\nModel.open_in_browser\nDeployment.open_in_browser\nDataset.open_in_browser\nAdded a new method for opening DataRobot in a browser: datarobot.rest.RESTClientObject.open_in_browser(). Invoke the method via dr.Client().open_in_browser().\nAltered method Project.create_featurelist to accept five new parameters (please see documentation for information about usage):\nstarting_featurelist\nstarting_featurelist_id\nstarting_featurelist_name\nfeatures_to_include\nfeatures_to_exclude\nAdded a new method to retrieve a feature list by name: Project.get_featurelist_by_name.\nAdded a new convenience method to create datasets: Dataset.upload.\nAltered the method Model.request_predictions to accept four new parameters:\ndataset\nfile\nfile_path\ndataframe\nNote that the method already supports the parameter dataset_id and all data source parameters are mutually exclusive.\nAdded a new method to datarobot.models.Dataset, Dataset.get_as_dataframe, which retrieves all the originally uploaded data in a pandas DataFrame.\nAdded a new method to datarobot.models.Dataset, Dataset.share, which allows the sharing of a dataset with another user.\nAdded new convenience methods to datarobot.models.Project for dealing with partition classes. Both methods should be called before Project.analyze_and_model.\nProject.set_partitioning_method intelligently creates the correct partition class for a regular project, based on input arguments.\nProject.set_datetime_partitioning creates the correct partition class for a time series project.\nAdded a new method to datarobot.models.Project Project.get_top_model which returns the highest scoring model for a metric of your choice.\nUse the new method Deployment.predict_batch to pass a file, file path, or DataFrame to datarobot.models.Deployment to easily make batch predictions and return the results as a DataFrame.\nAdded support for passing in a credentials ID or credentials data to Project.create_from_data_source as an alternative to providing a username and password.\nYou can now pass in a max_wait value to AutomatedDocument.generate.\nAdded a new method to datarobot.models.Project Project.get_dataset which retrieves the dataset used during creation of a project.\nAdded two new properties to datarobot.models.Project:\ncatalog_id\ncatalog_version_id\nAdded a new Autopilot method to datarobot.models.Project Project.analyze_and_model which allows you to initiate Autopilot or data analysis against data uploaded to DataRobot.\nAdded a new convenience method to datarobot.models.Project Project.set_options which allows you to save AdvancedOptions values for use in modeling.\nAdded a new convenience method to datarobot.models.Project Project.get_options which allows you to retrieve saved modeling options.\nEnhancements\u00b6\nRefactored the global singleton client connection (datarobot.client.Client()) to use ContextVar instead of a global variable for better concurrency support.\nAdded support for creating monotonic feature lists for time series projects. Set skip_datetime_partition_column to\nTrue to create monotonic feature list. For more information see datarobot.models.Project.create_modeling_featurelist().\nAdded information about vertex to advanced tuning parameters datarobot.models.Model.get_advanced_tuning_parameters().\nAdded the ability to automatically use saved AdvancedOptions set using Project.set_options in Project.analyze_and_model.\nBugfixes\u00b6\nDataset.list no longer throws errors when listing datasets with no owner.\nFixed an issue with the creation of BatchPredictionJobDefinitions containing a schedule.\nFixed error handling in datarobot.helpers.partitioning_methods.get_class.\nFixed issue with portions of the payload not using camelCasing in Project.upload_dataset_from_catalog.\nAPI changes\u00b6\nThe Python client now outputs a DataRobotProjectDeprecationWarning when you attempt to access certain resources (projects, models, deployments, etc.) that are deprecated or disabled as a result of the DataRobot platform\u2019s migration to Python 3.\nThe Python client now raises a TypeError when you try to retrieve a labelwise ROC on a binary model or a binary ROC on a multilabel model.\nThe method Dataset.create_from_data_source now raises InvalidUsageError if username and password are not passed as a pair together.\nDeprecation summary\u00b6\nModel.get_leaderboard_ui_permalink has been removed.\nUse Model.get_uri instead.\nModel.open_model_browser has been removed.\nUse Model.open_in_browser instead.\nProject.get_leaderboard_ui_permalink has been removed.\nUse Project.get_uri instead.\nProject.open_leaderboard_browser has been removed.\nUse Project.open_in_browser instead.\nEnum VARIABLE_TYPE_TRANSFORM.CATEGORICAL has been removed\nInstantiation of Blueprint using a dict has been removed. Use Blueprint.from_data instead.\nSpecifying an environment to use for testing with CustomModelTest has been removed.\nCustomModelVersion\u2019s required_metadata parameter has been removed. Use required_metadata_values instead.\nCustomTaskVersion\u2019s required_metadata parameter has been removed. Use required_metadata_values instead.\nInstantiation of Feature using a dict has been removed. Use Feature.from_data instead.\nInstantiation of Featurelist using a dict has been removed. Use Featurelist.from_data instead.\nInstantiation of Model using a dict, tuple, or the data parameter has been removed. Use Model.from_data instead.\nInstantiation of Project using a dict has been removed. Use Project.from_data instead.\nProject\u2019s quickrun parameter has been removed. Pass AUTOPILOT_MODE.QUICK as the mode instead.\nProject\u2019s scaleout_max_train_pct and scaleout_max_train_rows parameters have been removed.\nComplianceDocumentation has been removed. Use AutomatedDocument instead.\nThe Deployment method create_from_custom_model_image was removed. Use Deployment.create_from_custom_model_version instead.\nPredictJob.create has been removed. Use Model.request_predictions instead.\nModel.fetch_resource_data has been removed. Use Model.get instead.\nThe class CustomInferenceImage was removed. Use CustomModelVersion with base_environment_id instead.\nProject.set_target has been deprecated. Use Project.analyze_and_model instead.\nConfiguration changes\u00b6\nAdded a context manager client_configuration that can be used to change the connection configuration temporarily, for use in asynchronous or multithreaded code.\nUpgraded the Pillow library to version 9.2.0. Users installing DataRobot with the \u201cimages\u201d extra (pip install datarobot[images]) should note that this is a required library.\nExperimental changes\u00b6\nAdded experimental support for retrieving document thumbnails:\nDocumentThumbnail\nDocumentPageFile\nAdded experimental support to retrieve document text extraction samples using:\nDocumentTextExtractionSample\nDocumentTextExtractionSamplePage\nDocumentTextExtractionSampleDocument\nAdded experimental deployment improvements:\nRetrainingPolicy can be used to manage retraining policies associated with a deployment.\nAdded an experimental deployment improvement:\nUse RetrainingPolicyRun to manage retraining policies run for a retraining policy associated with a deployment.\nAdded new methods to RetrainingPolicy:\nUse RetrainingPolicy.get to get a retraining policy associated with a deployment.\nUse RetrainingPolicy.delete to delete a retraining policy associated with a deployment.\n2.29.0\u00b6\nNew features\u00b6\nAdded support to pass max_ngram_explanations parameter in batch predictions that will trigger the\ncompute of text prediction explanations.\nBatchPredictionJob.score\nAdded support to pass calculation mode to prediction explanations\n(mode parameter in PredictionExplanations.create)\nas well as batch scoring\n(explanations_mode in BatchPredictionJob.score)\nfor multiclass models. Supported modes:\nTopPredictionsMode\nClassListMode\nAdded method datarobot.CalendarFile.create_calendar_from_dataset() to the calendar file that allows us\nto create a calendar from a dataset.\nAdded experimental support for n_clusters parameter in\nModel.train_datetime and\nDatetimeModel.retrain\nthat allows to specify number of clusters when creating models in Time Series Clustering project.\nAdded new parameter clone to datarobot.CombinedModel.set_segment_champion() that allows to\nset a new champion model in a cloned model instead of the original one, leaving latter unmodified.\nAdded new property is_active_combined_model to datarobot.CombinedModel that indicates\nif the selected combined model is currently the active one in the segmented project.\nAdded new datarobot.models.Project.get_active_combined_model() that allows users to get\nthe currently active combined model in the segmented project.\nAdded new parameters read_timeout to method ShapMatrix.get_as_dataframe.\nValues larger than the default can be specified to avoid timeouts when requesting large files.\nShapMatrix.get_as_dataframe\nAdded support for bias mitigation with the following methods\nProject.get_bias_mitigated_models\nProject.apply_bias_mitigation\nProject.request_bias_mitigation_feature_info\nProject.get_bias_mitigation_feature_info\nand by adding new bias mitigation params\nbias_mitigation_feature_name\nbias_mitigation_technique\ninclude_bias_mitigation_feature_as_predictor_variable\nto the existing method\nProject.start\nand by adding this enum to supply params to some of the above functionality datarobot.enums.BiasMitigationTechnique\nAdded new property status to datarobot.models.Deployment that represents model deployment status.\nAdded new Deployment.activate\nand Deployment.deactivate\nthat allows deployment activation and deactivation\nAdded new Deployment.delete_monitoring_data to delete deployment monitoring data.\nEnhancements\u00b6\nAdded support for specifying custom endpoint URLs for S3 access in batch predictions:\nBatchPredictionJob.score\nBatchPredictionJob.score\nSee: endpoint_url parameter.\n- Added guide on :ref:working with binary data <binary_data>\n- Added multithreading support to binary data helper functions.\n- Binary data helpers image defaults aligned with application\u2019s image preprocessing.\n- Added the following accuracy metrics to be retrieved for a deployment - TPR, PPV, F1 and MCC :ref:Deployment monitoring <deployment_monitoring>\nBugfixes\u00b6\nDon\u2019t include holdout start date, end date, or duration in datetime partitioning payload when\nholdout is disabled.\nRemoved ICE Plot capabilities from Feature Fit.\nHandle undefined calendar_name in CalendarFile.create_calendar_from_dataset\nRaise ValueError for submitted calendar names that are not strings\nAPI changes\u00b6\nversion field is removed from ImportedModel object\nDeprecation summary\u00b6\nReason Codes objects deprecated in 2.13 version were removed.\nPlease use Prediction Explanations instead.\nConfiguration changes\u00b6\nThe upper version constraint on pandas has been removed.\nDocumentation changes\u00b6\nFixed a minor typo in the example for Dataset.create_from_data_source.\nUpdate the documentation to suggest that feature_derivation_window_end of datarobot.DatetimePartitioningSpecification class should be a negative or zero.\n2.28.0\u00b6\nNew features\u00b6\nAdded new parameter upload_read_timeout to BatchPredictionJob.score\nand BatchPredictionJob.score_to_file to indicate how many seconds to wait\nuntil intake dataset uploads to server. Default value 600s.\nAdded the ability to turn off supervised feature reduction for Time Series projects. Option\nuse_supervised_feature_reduction can be set in AdvancedOptions.\nAllow maximum_memory to be input for custom tasks versions. This will be used for setting the limit\nto which a custom task prediction container memory can grow.\nAdded method datarobot.models.Project.get_multiseries_names() to the project service which will\nreturn all the distinct entries in the multiseries column\nAdded new segmentation_task_id attribute to datarobot.models.Project.set_target() that allows to\nstart project as Segmented Modeling project.\nAdded new property is_segmented to datarobot.models.Project that indicates if project is a\nregular one or Segmented Modeling project.\nAdded method datarobot.models.Project.restart_segment() to the project service that allows to\nrestart single segment that hasn\u2019t reached modeling phase.\nAdded the ability to interact with Combined Models in Segmented Modeling projects.\nAvailable with new class: datarobot.CombinedModel.\nFunctionality:\n: - datarobot.CombinedModel.get()\n- datarobot.CombinedModel.get_segments_info()\n- datarobot.CombinedModel.get_segments_as_dataframe()\n- datarobot.CombinedModel.get_segments_as_csv()\n- datarobot.CombinedModel.set_segment_champion()\n- Added the ability to create and retrieve segmentation tasks used in Segmented Modeling projects.\nAvailable with new class: datarobot.SegmentationTask.\nFunctionality:\n: - datarobot.SegmentationTask.create()\n- datarobot.SegmentationTask.list()\n- datarobot.SegmentationTask.get()\n- Added new class: datarobot.SegmentInfo that allows to get information on all segments of\nSegmented modeling projects, i.e. segment project ID, model counts, autopilot status.\nFunctionality:\n: - datarobot.SegmentInfo.list()\n- Added new methods to base APIObject to assist with dictionary and json serialization of child objects.\nFunctionality:\n: - APIObject.to_dict\n- APIObject.to_json\n- Added new methods to ImageAugmentationList for interacting with image augmentation samples.\nFunctionality:\n: - ImageAugmentationList.compute_samples\n- ImageAugmentationList.retrieve_samples\n- Added the ability to set a prediction threshold when creating a deployment from a learning model.\n- Added support for governance, owners, predictionEnvironment, and fairnessHealth fields when querying for a Deployment object.\n- Added helper methods for working with files, images and documents. Methods support conversion of\nfile contents into base64 string representations. Methods for images provide also image resize and\ntransformation support.\nFunctionality:\n: - get_encoded_file_contents_from_urls\n- get_encoded_file_contents_from_paths\n- get_encoded_image_contents_from_paths\n- get_encoded_image_contents_from_urls\nEnhancements\u00b6\nRequesting metadata instead of actual data of datarobot.PredictionExplanations to reduce the amount of data transfer\nBugfixes\u00b6\nFix a bug in Job.get_result_when_complete for Prediction Explanations job type to\npopulate all attribute of of datarobot.PredictionExplanations instead of just one\nFix a bug in datarobot.models.ShapImpact where row_count was not optional\nAllow blank value for schema and catalog in RelationshipsConfiguration response data\nFix a bug where credentials were incorrectly formatted in\nProject.upload_dataset_from_catalog\nand\nProject.upload_dataset_from_data_source\nRejecting downloads of Batch Prediction data that was not written to the localfile output adapter\nFix a bug in datarobot.models.BatchPredictionJobDefinition.create() where schedule was not optional for all cases\nAPI changes\u00b6\nUser can include ICE plots data in the response when requesting Feature Effects/Feature Fit. Extended methods are\n: - Model.get_feature_effect,\n- Model.get_feature_fit <datarobot.models.Model.get_feature_fit>,\n- DatetimeModel.get_feature_effect and\n- DatetimeModel.get_feature_fit <datarobot.models.DatetimeModel.get_feature_fit>.\nDeprecation summary\u00b6\nattrs library is removed from library dependencies\nImageAugmentationSample.compute was marked as deprecated and will be removed in v2.30. You\ncan get the same information with newly introduced method ImageAugmentationList.compute_samples\nImageAugmentationSample.list using sample_id\nDeprecating scaleout parameters for projects / models. Includes scaleout_modeling_mode,\nscaleout_max_train_pct, and scaleout_max_train_rows\nConfiguration changes\u00b6\npandas upper version constraint is updated to include version 1.3.5.\nDocumentation changes\u00b6\nFixed \u201cfrom datarobot.enums\u201d import in Unsupervised Clustering example provided in docs.\n2.27.0\u00b6\nNew features\u00b6\ndatarobot.UserBlueprint is now mature with full support of functionality. Users\nare encouraged to use the Blueprint Workshop instead of\nthis class directly.\nAdded the arguments attribute in datarobot.CustomTaskVersion.\nAdded the ability to retrieve detected errors in the potentially multicategorical feature types that prevented the\nfeature to be identified as multicategorical.\nProject.download_multicategorical_data_format_errors\nAdded the support of listing/updating user roles on one custom task.\n: - datarobot.CustomTask.get_access_list()\n- datarobot.CustomTask.share()\nAdded a method datarobot.models.Dataset.create_from_query_generator(). This creates a dataset\nin the AI catalog from a datarobot.DataEngineQueryGenerator.\nAdded the new functionality of creating a user blueprint with a custom task version id.\ndatarobot.UserBlueprint.create_from_custom_task_version_id().\nThe DataRobot Python Client is no longer published under the Apache-2.0 software license, but rather under the terms\nof the DataRobot Tool and Utility Agreement.\nAdded a new class: datarobot.DataEngineQueryGenerator. This class generates a Spark\nSQL query to apply time series data prep to a dataset in the AI catalog.\nFunctionality:\n: - datarobot.DataEngineQueryGenerator.create()\n- datarobot.DataEngineQueryGenerator.get()\n- datarobot.DataEngineQueryGenerator.create_dataset()\nSee the :ref:time series data prep documentation <time_series_data_prep> for more information.\n- Added the ability to upload a prediction dataset into a project from the AI catalog\nProject.upload_dataset_from_catalog.\n- Added the ability to specify the number of training rows to use in SHAP based Feature Impact computation. Extended\nmethod:\nShapImpact.create\nAdded the ability to retrieve and restore features that have been reduced using the time series feature generation and\nreduction functionality. The functionality comes with a new\nclass: datarobot.models.restore_discarded_features.DiscardedFeaturesInfo.\nFunctionality:\n: - datarobot.models.restore_discarded_features.DiscardedFeaturesInfo.retrieve()\n- datarobot.models.restore_discarded_features.DiscardedFeaturesInfo.restore()\n- Added the ability to control class mapping aggregation in multiclass projects via\nClassMappingAggregationSettings passed as a parameter to\nProject.set_target\n- Added support for :ref:unsupervised clustering projects<unsupervised_clustering>\n- Added the ability to compute and retrieve Feature Effects for a Multiclass model using\ndatarobot.models.Model.request_feature_effects_multiclass(),\ndatarobot.models.Model.get_feature_effects_multiclass() or\ndatarobot.models.Model.get_or_request_feature_effects_multiclass() methods. For datetime models use following\nmethods datarobot.models.DatetimeModel.request_feature_effects_multiclass(),\ndatarobot.models.DatetimeModel.get_feature_effects_multiclass() or\ndatarobot.models.DatetimeModel.get_or_request_feature_effects_multiclass() with backtest_index specified\n- Added the ability to get and update challenger model settings for deployment\nclass: datarobot.models.Deployment\nFunctionality:\n: - datarobot.models.Deployment.get_challenger_models_settings()\n- datarobot.models.Deployment.update_challenger_models_settings()\n- Added the ability to get and update segment analysis settings for deployment\nclass: datarobot.models.Deployment\nFunctionality:\n: - datarobot.models.Deployment.get_segment_analysis_settings()\n- datarobot.models.Deployment.update_segment_analysis_settings()\n- Added the ability to get and update predictions by forecast date settings for deployment\nclass: datarobot.models.Deployment\nFunctionality:\n: - datarobot.models.Deployment.get_predictions_by_forecast_date_settings()\n- datarobot.models.Deployment.update_predictions_by_forecast_date_settings()\n- Added the ability to specify multiple feature derivation windows when creating a Relationships Configuration using\nRelationshipsConfiguration.create\n- Added the ability to manipulate a legacy conversion for a custom inference model, using the\nclass: CustomModelVersionConversion\nFunctionality:\n: - CustomModelVersionConversion.run_conversion\n- CustomModelVersionConversion.stop_conversion\n- CustomModelVersionConversion.get\n- CustomModelVersionConversion.get_latest\n- CustomModelVersionConversion.list\nEnhancements\u00b6\nProject.get returns the query_generator_id used for time series data prep when applicable.\nFeature Fit & Feature Effects can return datetime instead of numeric for feature_type field for\nnumeric features that are derived from dates.\nThese methods now provide additional field rowCount in SHAP based Feature Impact results.\nShapImpact.create\nShapImpact.get\nImproved performance when downloading prediction dataframes for Multilabel projects using:\n: - Predictions.get_all_as_dataframe\n- PredictJob.get_predictions\n- Job.get_result\nBugfixes\u00b6\nfix datarobot.CustomTaskVersion and datarobot.CustomModelVersion to correctly format required_metadata_values\nbefore sending them via API\nFixed response validation that could cause DataError when using datarobot.models.Dataset for a dataset with a description that is an empty string.\nAPI changes\u00b6\nRelationshipsConfiguration.create will include a\nnew key data_source_id in data_source field when applicable\nDeprecation summary\u00b6\nModel.get_all_labelwise_roc_curves has been removed.\nYou can get the same information with multiple calls of\nModel.get_labelwise_roc_curves, one per data source.\nModel.get_all_multilabel_lift_charts has been removed.\nYou can get the same information with multiple calls of\nModel.get_multilabel_lift_charts, one per data source.\nDocumentation changes\u00b6\nThis release introduces a new documentation organization. The organization has been modified to better reflect the end-to-end modeling workflow. The new \u201cTutorials\u201d section has 5 major topics that outline the major components of modeling: Data, Modeling, Predictions, MLOps, and Administration.\nThe Getting Started workflow is now hosted at DataRobot\u2019s API Documentation Home.\nAdded an example of how to set up optimized datetime partitioning for time series projects.\n2.26.0\u00b6\nNew features\u00b6\nAdded the ability to use external baseline predictions for time series project. External\ndataset can be validated using datarobot.models.Project.validate_external_time_series_baseline().\nOption can be set in AdvancedOptions to scale\ndatarobot models\u2019 accuracy performance using external dataset\u2019s accuracy performance.\nSee the :ref:external baseline predictions documentation <external_baseline_predictions>\nfor more information.\nAdded the ability to generate exponentially weighted moving average features for time series\nproject. Option can be set in AdvancedOptions\nand controls the alpha parameter used in exponentially weighted moving average operation.\nAdded the ability to request a specific model be prepared for deployment using\nProject.start_prepare_model_for_deployment.\nAdded a new class: datarobot.CustomTask. This class is a custom task that you can use\nas part (or all) of your blue print for training models. It needs\ndatarobot.CustomTaskVersion before it can properly be used.\nFunctionality:\n: - Create, copy, update or delete:\n: - datarobot.CustomTask.create()\n- datarobot.CustomTask.copy()\n- datarobot.CustomTask.update()\n- datarobot.CustomTask.delete()\n- list, get and refresh current tasks:\n: - datarobot.CustomTask.get()\n- datarobot.CustomTask.list()\n- datarobot.CustomTask.refresh()\n- Download the latest datarobot.CustomTaskVersion of the datarobot.CustomTask\n: - datarobot.CustomTask.download_latest_version()\n- Added a new class: datarobot.CustomTaskVersion. This class\nis for management of specific versions of a custom task.\nFunctionality:\n: - Create new custom task versions:\n: - datarobot.CustomTaskVersion.create_clean()\n- datarobot.CustomTaskVersion.create_from_previous()\n- list, get and refresh current available versions:\n: - datarobot.CustomTaskVersion.list()\n- datarobot.CustomTaskVersion.get()\n- datarobot.CustomTaskVersion.refresh()\n- datarobot.CustomTaskVersion.download()\nwill download a tarball of the files used to create the custom task\n- datarobot.CustomTaskVersion.update()\nupdates the metadata for a custom task.\n- Added the ability compute batch predictions for an in-memory DataFrame using\nBatchPredictionJob.score\n- Added the ability to specify feature discovery settings when creating a Relationships Configuration using\nRelationshipsConfiguration.create\nEnhancements\u00b6\nImproved performance when downloading prediction dataframes using:\n: - Predictions.get_all_as_dataframe\n- PredictJob.get_predictions\n- Job.get_result\nAdded new max_wait parameter to methods:\n: - Dataset.create_from_url\n- Dataset.create_from_in_memory_data\n- Dataset.create_from_data_source\n- Dataset.create_version_from_in_memory_data\n- Dataset.create_version_from_url\n- Dataset.create_version_from_data_source\nBugfixes\u00b6\nModel.get will return a DatetimeModel instead of Model\nwhenever the project is datetime partitioned. This enables the\nModelRecommendation.get_model to return\na DatetimeModel instead of Model whenever the project is datetime partitioned.\nTry to read Feature Impact result if existing jobId is None in\nModel.get_or_request_feature_impact.\nSet upper version constraints for pandas.\nRelationshipsConfiguration.create will return a catalog\nin data_source field\nArgument required_metadata_keys was not properly being sent in the update and create requests for\ndatarobot.ExecutionEnvironment.\nFix issue with datarobot.ExecutionEnvironment create method failing when used against older versions of the application\ndatarobot.CustomTaskVersion was not properly handling required_metadata_values from the API response\nAPI changes\u00b6\nUpdated Project.start to use AUTOPILOT_MODE.QUICK when the\nautopilot_on param is set to True. This brings it in line with Project.set_target.\nUpdated project.start_autopilot to accept\nthe following new GA parameters that are already in the public API: consider_blenders_in_recommendation,\nrun_leakage_removed_feature_list\nDeprecation summary\u00b6\nThe required_metadata property of datarobot.CustomModelVersion has been deprecated.\nrequired_metadata_values should be used instead.\nThe required_metadata property of datarobot.CustomTaskVersion has been deprecated.\nrequired_metadata_values should be used instead.\nConfiguration changes\u00b6\nNow requires dependency on package scikit-learn  rather than\nsklearn. Note: This dependency is only used in example code. See\nthis scikit-learn issue for more information.\nNow permits dependency on package attrs  to be less than version 21. This\nfixes compatibility with apache-airflow.\nAllow to setup Authorization: <type> <token> type header for OAuth2 Bearer tokens.\nDocumentation changes\u00b6\nUpdate the documentation with respect to the permission that controls AI Catalog dataset snapshot behavior.\n2.25.0\u00b6\nNew features\u00b6\nThere is a new AnomalyAssessmentRecord object that\nimplements public API routes to work with anomaly assessment insight. This also adds explanations\nand predictions preview classes. The insight is available for anomaly detection models in time\nseries unsupervised projects which also support calculation of Shapley values.\nAnomalyAssessmentPredictionsPreview\nAnomalyAssessmentExplanations\nFunctionality:\nInitialize an anomaly assessment insight for the specified subset.\nDatetimeModel.initialize_anomaly_assessment\nGet anomaly assessment records, shap explanations, predictions preview:\nDatetimeModel.get_anomaly_assessment_records list available records\nAnomalyAssessmentRecord.get_predictions_preview get predictions preview for the record\nAnomalyAssessmentRecord.get_latest_explanations get latest predictions along with shap explanations for the most anomalous records.\nAnomalyAssessmentRecord.get_explanations get predictions along with shap explanations for the most anomalous records for the specified range.\nDelete anomaly assessment record:\nAnomalyAssessmentRecord.delete delete record\nAdded an ability to calculate and retrieve Datetime trend plots for DatetimeModel.\nThis includes Accuracy over Time, Forecast vs Actual, and Anomaly over Time.\nPlots can be calculated using a common method:\nDatetimeModel.compute_datetime_trend_plots\nMetadata for plots can be retrieved using the following methods:\nDatetimeModel.get_accuracy_over_time_plots_metadata\nDatetimeModel.get_forecast_vs_actual_plots_metadata\nDatetimeModel.get_anomaly_over_time_plots_metadata\nPlots can be retrieved using the following methods:\nDatetimeModel.get_accuracy_over_time_plot\nDatetimeModel.get_forecast_vs_actual_plot\nDatetimeModel.get_anomaly_over_time_plot\nPreview plots can be retrieved using the following methods:\nDatetimeModel.get_accuracy_over_time_plot_preview\nDatetimeModel.get_forecast_vs_actual_plot_preview\nDatetimeModel.get_anomaly_over_time_plot_preview\nSupport for Batch Prediction Job Definitions has now been added through the following class:\nBatchPredictionJobDefinition.\nYou can create, update, list and delete definitions using the following methods:\nBatchPredictionJobDefinition.list\nBatchPredictionJobDefinition.create\nBatchPredictionJobDefinition.update\nBatchPredictionJobDefinition.delete\nEnhancements\u00b6\nAdded a new helper function to create Dataset Definition, Relationship and Secondary Dataset used by\nFeature Discovery Project. They are accessible via\nDatasetDefinition\nRelationship\nSecondaryDataset\nAdded new helper function to projects to retrieve the recommended model.\nProject.recommended_model\nAdded method to download feature discovery recipe SQLs (limited beta feature).\nProject.download_feature_discovery_recipe_sqls.\nAdded docker_context_size and docker_image_size to datarobot.ExecutionEnvironmentVersion\nBugfixes\u00b6\nRemove the deprecation warnings when using with latest versions of urllib3.\nFeatureAssociationMatrix.get is now using correct query param\nname when featurelist_id is specified.\nHandle scalar values in shapBaseValue while converting a predictions response to a data frame.\nEnsure that if a configured endpoint ends in a trailing slash, the resulting full URL does\nnot end up with double slashes in the path.\nModel.request_frozen_datetime_model is now implementing correct\nvalidation of input parameter training_start_date.\nAPI changes\u00b6\nArguments secondary_datasets now accept SecondaryDataset\nto create secondary dataset configurations\nSecondaryDatasetConfigurations.create\nArguments dataset_definitions and relationships now accept DatasetDefinition Relationship\nto create and replace relationships configuration\nRelationshipsConfiguration.create creates a new relationships configuration between datasets\nRelationshipsConfiguration.retrieve retrieve the requested relationships\nconfiguration\nArgument required_metadata_keys has been added to datarobot.ExecutionEnvironment.  This should be used to\ndefine a list of RequiredMetadataKey.\ndatarobot.CustomModelVersion that use a base environment with required_metadata_keys must define\nvalues for these fields in their respective required_metadata\nArgument required_metadata has been added to datarobot.CustomModelVersion.  This should be set with\nrelevant values defined by the base environment\u2019s required_metadata_keys\n2.24.0\u00b6\nNew features\u00b6\nPartial history predictions can be made with time series time series multiseries models using the\nallow_partial_history_time_series_predictions attribute of the\ndatarobot.DatetimePartitioningSpecification.\nSee the :ref:Time Series <time_series> documentation for more info.\nMulticategorical Histograms are now retrievable. They are accessible via\nMulticategoricalHistogram or\nFeature.get_multicategorical_histogram.\nAdd methods to retrieve per-class lift chart data for multilabel models:\nModel.get_multilabel_lift_charts and\nModel.get_all_multilabel_lift_charts.\nAdd methods to retrieve labelwise ROC curves for multilabel models:\nModel.get_labelwise_roc_curves and\nModel.get_all_labelwise_roc_curves.\nMulticategorical Pairwise Statistics are now retrievable. They are accessible via\nPairwiseCorrelations,\nPairwiseJointProbabilities and\nPairwiseConditionalProbabilities or\nFeature.get_pairwise_correlations,\nFeature.get_pairwise_joint_probabilities and\nFeature.get_pairwise_conditional_probabilities.\nAdd methods to retrieve prediction results of a deployment:\n: - Deployment.get_prediction_results\n- Deployment.download_prediction_results\nAdd method to download scoring code of a deployment using Deployment.download_scoring_code.\nAdded Automated Documentation: now you can automatically generate documentation about various\nentities within the platform, such as specific models or projects. Check out the\nref:\nAutomated Documentation overview<automated_documentation_overview> and also refer to\nthe :ref:API Reference<automated_documentation_api> for more details.\nCreate a new Dataset version for a given dataset by uploading from a file, URL or in-memory datasource.\n: - Dataset.create_version_from_file\n- Dataset.create_version_from_in_memory_data\n- Dataset.create_version_from_url\n- Dataset.create_version_from_data_source\nEnhancements\u00b6\nAdded a new status called FAILED to from BatchPredictionJob as\nthis is a new status coming to Batch Predictions in an upcoming version of DataRobot.\nAdded base_environment_version_id to datarobot.CustomModelVersion.\nSupport for downloading feature discovery training or prediction dataset using\nProject.download_feature_discovery_dataset.\nAdded datarobot.models.FeatureAssociationMatrix, datarobot.models.FeatureAssociationMatrixDetails\nand datarobot.models.FeatureAssociationFeaturelists that can be used to retrieve feature associations\ndata as an alternative to Project.get_associations,\nProject.get_association_matrix_details and\nProject.get_association_featurelists methods.\nBugfixes\u00b6\nFixed response validation that could cause DataError when using\nTrainingPredictions.list and\nTrainingPredictions.get_all_as_dataframe\nmethods if there are training predictions computed with explanation_algorithm.\nAPI changes\u00b6\nRemove desired_memory param from the following classes: datarobot.CustomInferenceModel,\ndatarobot.CustomModelVersion, datarobot.CustomModelTest\nRemove desired_memory param from the following methods:\nCustomInferenceModel.create,\nCustomModelVersion.create_clean,\nCustomModelVersion.create_from_previous,\nCustomModelTest.create and\nCustomModelTest.create\nDeprecation summary\u00b6\nclass ComplianceDocumentation\nwill be deprecated in v2.24 and will be removed entirely in v2.27. Use\nAutomatedDocument\ninstead. To start off, see the\nref:\nAutomated Documentation overview<automated_documentation_overview> for details.\nDocumentation changes\u00b6\nRemove reference to S3 for Project.upload_dataset since it is not supported by the server\n2.23.0\u00b6\nNew features\u00b6\nCalendars for time series projects can now be automatically generated by providing a country code to the method\nCalendarFile.create_calendar_from_country_code.\nA list of allowed country codes can be retrieved using CalendarFile.get_allowed_country_codes\nFor more information, see the :ref:calendar documentation <preloaded_calendar_files>.\nAdded calculate_all_series`` param to\n[DatetimeModel.compute_series_accuracy`](datarobot-models.md#datarobot.models.DatetimeModel.compute_series_accuracy).\nThis option allows users to compute series accuracy for all available series at once,\nwhile by default it is computed for first 1000 series only.\nAdded ability to specify sampling method when setting target of OTV project. Option can be set\nin AdvancedOptions and changes a way training data\nis defined in autopilot steps.\nAdd support for custom inference model k8s resources management. This new feature enables\nusers to control k8s resources allocation for their executed model in the k8s cluster.\nIt involves in adding the following new parameters: network_egress_policy, desired_memory,\nmaximum_memory, replicas to the following classes: datarobot.CustomInferenceModel,\ndatarobot.CustomModelVersion, datarobot.CustomModelTest\nAdd support for multiclass custom inference and training models. This enables users to create\nclassification custom models with more than two class labels. The datarobot.CustomInferenceModel\nclass can now use datarobot.TARGET_TYPE.MULTICLASS for their target_type parameter. Class labels for inference models\ncan be set/updated using either a file or as a list of labels.\nSupport for Listing all the secondary dataset configuration for a given project:\n: - SecondaryDatasetConfigurations.list\nAdd support for unstructured custom inference models. The datarobot.CustomInferenceModel\nclass can now use datarobot.TARGET_TYPE.UNSTRUCTURED for its target_type parameter.\ntarget_name parameter is optional for UNSTRUCTURED target type.\nAll per-class lift chart data is now available for multiclass models using\nModel.get_multiclass_lift_chart.\nAUTOPILOT_MODE.COMPREHENSIVE, a new mode, has been added to\nProject.set_target.\nAdd support for anomaly detection custom inference models. The datarobot.CustomInferenceModel\nclass can now use datarobot.TARGET_TYPE.ANOMALY for its target_type parameter.\ntarget_name parameter is optional for ANOMALY target type.\nSupport for Updating and retrieving the secondary dataset configuration for a Feature discovery deployment:\n: - Deployment.update_secondary_dataset_config\n- Deployment.get_secondary_dataset_config\nAdd support for starting and retrieving Feature Impact information for datarobot.CustomModelVersion\nSearch for interaction features and Supervised Feature reduction for feature discovery project can now be specified\n: in AdvancedOptions.\nFeature discovery projects can now be created using the Project.start\nmethod by providing relationships_configuration_id.\nActions applied to input data during automated feature discovery can now be retrieved using FeatureLineage.get\nCorresponding feature lineage id is available as a new datarobot.models.Feature field feature_lineage_id.\nLift charts and ROC curves are now calculated for backtests 2+ in time series and OTV models.\nThe data can be retrieved for individual backtests using Model.get_lift_chart\nand Model.get_roc_curve.\nThe following methods now accept a new argument called credential_data, the credentials to authenticate with the database, to use instead of user/password or credential ID:\n: - Dataset.create_from_data_source\n- Dataset.create_project\n- Project.create_from_dataset\nAdd support for DataRobot Connectors, datarobot.Connector provides a simple implementation to interface with connectors.\nEnhancements\u00b6\nRunning Autopilot on Leakage Removed feature list can now be specified in AdvancedOptions.\nBy default, Autopilot will always run on Informative Features - Leakage Removed feature list if it exists. If the parameter\nrun_leakage_removed_feature_list is set to False, then Autopilot will run on Informative Features or available custom feature list.\nMethod Project.upload_dataset\nand Project.upload_dataset_from_data_source\nsupport new optional parameter secondary_datasets_config_id for Feature discovery project.\nBugfixes\u00b6\nadded disable_holdout param in datarobot.DatetimePartitioning\nUsing Credential.create_gcp produced an incompatible credential\nSampleImage.list now supports Regression & Multilabel projects\nUsing BatchPredictionJob.score could in some circumstances\nresult in a crash from trying to abort the job if it fails to start\nUsing BatchPredictionJob.score or\nBatchPredictionJob.score would produce incomplete\nresults in case a job was aborted while downloading. This will now raise an exception.\nAPI changes\u00b6\nNew sampling_method param in Model.train_datetime,\nProject.train_datetime,\nModel.train_datetime and\nModel.train_datetime.\nNew target_type param in datarobot.CustomInferenceModel\nNew arguments secondary_datasets, name, creator_full_name, creator_user_id, created,\n: featurelist_id, credentials_ids, project_version and is_default in datarobot.models.SecondaryDatasetConfigurations\nNew arguments secondary_datasets, name, featurelist_id to\n: SecondaryDatasetConfigurations.create\nClass FeatureEngineeringGraph has been removed. Use datarobot.models.RelationshipsConfiguration instead.\nParam feature_engineering_graphs removed from Project.set_target.\nParam config removed from SecondaryDatasetConfigurations.create.\nDeprecation summary\u00b6\nsupports_binary_classification and  supports_regression are deprecated\n: for datarobot.CustomInferenceModel and will be removed in v2.24\nArgument config and  supports_regression are deprecated\n: for datarobot.models.SecondaryDatasetConfigurations and will be removed in v2.24\nCustomInferenceImage has been deprecated and will be removed in v2.24.\n: datarobot.CustomModelVersion with base_environment_id should be used in their place.\nenvironment_id and environment_version_id are deprecated for CustomModelTest.create\nDocumentation changes\u00b6\nfeature_lineage_id is added as a new parameter in the response for retrieval of a datarobot.models.Feature created by automated feature discovery or time series feature derivation.\nThis id is required to retrieve a datarobot.models.FeatureLineage instance.\n2.22.1\u00b6\nNew features\u00b6\nBatch Prediction jobs now support :ref:dataset <batch_predictions-intake-types-dataset> as intake settings for\nBatchPredictionJob.score.\nCreate a Dataset from DataSource:\nDataset.create_from_data_source\nDataSource.create_dataset\nAdded support for Custom Model Dependency Management.  Please see :ref:custom model documentation<custom_models>.\nNew features added:\nAdded new argument base_environment_id to methods\nCustomModelVersion.create_clean\nand CustomModelVersion.create_from_previous\nNew fields base_environment_id and dependencies to class\ndatarobot.CustomModelVersion\nNew class datarobot.CustomModelVersionDependencyBuild\nto prepare custom model versions with dependencies.\nMade argument environment_id of\nCustomModelTest.create optional to enable using\ncustom model versions with dependencies\nNew field image_type added to class\ndatarobot.CustomModelTest\nDeployment.create_from_custom_model_version can be used to create a deployment from a custom model version.\nAdded new parameters for starting and re-running Autopilot with customizable settings within\nProject.start_autopilot.\nAdded a new method to trigger Feature Impact calculation for a Custom Inference Image:\nCustomInferenceImage.calculate_feature_impact\nAdded new method to retrieve number of iterations trained for early stopping models. Currently supports only tree-based models.\nModel.get_num_iterations_trained.\nEnhancements\u00b6\nA description can now be added or updated for a project.\nProject.set_project_description.\nAdded new parameters read_timeout and max_wait to method Dataset.create_from_file.\nValues larger than the default can be specified for both to avoid timeouts when uploading large files.\nAdded new parameter metric to datarobot.models.deployment.TargetDrift, datarobot.models.deployment.FeatureDrift,\nDeployment.get_target_drift\nand Deployment.get_feature_drift.\nAdded new parameter timeout to BatchPredictionJob.download to indicate\nhow many seconds to wait for the download to start (in case the job doesn\u2019t start processing immediately).\nSet to -1 to disable.\nThis parameter can also be sent as download_timeout to BatchPredictionJob.score\nand BatchPredictionJob.score.\nIf the timeout occurs, the pending job will be aborted.\nAdded new parameter read_timeout to BatchPredictionJob.download to indicate\nhow many seconds to wait between each downloaded chunk.\nThis parameter can also be sent as download_read_timeout to BatchPredictionJob.score\nand BatchPredictionJob.score.\nAdded parameter catalog to BatchPredictionJob to both intake\nand output adapters for type jdbc.\nConsider blenders in recommendation can now be specified in AdvancedOptions.\nBlenders will be included when autopilot chooses a model to prepare and recommend for deployment.\nAdded optional parameter max_wait to Deployment.replace_model to indicate\nthe maximum time to wait for model replacement job to complete before erroring.\nBugfixes\u00b6\nHandle null values in predictionExplanationMetadata[\"shapRemainingTotal\"] while converting a predictions\nresponse to a data frame.\nHandle null values in customModel[\"latestVersion\"]\nRemoved an extra column status from BatchPredictionJob as\nit caused issues with never version of Trafaret validation.\nMake predicted_vs_actual optional in Feature Effects data because a feature may have insufficient qualified samples.\nMake jdbc_url optional in Data Store data because some data stores will not have it.\nThe method Project.get_datetime_models now correctly returns all\nDatetimeModel objects for the project, instead of just the first 100.\nFixed a documentation error related to snake_case vs camelCase in the JDBC settings payload.\nMake trafaret validator for datasets use a syntax that works properly with a wider range of trafaret versions.\nHandle extra keys in CustomModelTests and CustomModelVersions\nImageEmbedding and ImageActivationMap now supports regression projects.\nAPI changes\u00b6\nThe default value for the mode param in Project.set_target has been changed from AUTOPILOT_MODE.FULL_AUTO\nto AUTOPILOT_MODE.QUICK\nDocumentation changes\u00b6\nAdded links to classes with duration parameters such as validation_duration and holdout_duration to\nprovide duration string examples to users.\nThe :ref:models documentation <models> has been revised to include section on how to train a new model and how to run cross-validation\nor backtesting for a model.\n2.21.0\u00b6\nNew features\u00b6\nAdded new arguments explanation_algorithm and max_explanations to method\nModel.request_training_predictions.\nNew fields explanation_algorithm, max_explanations and shap_warnings have been added to class\nTrainingPredictions.\nNew fields prediction_explanations and shap_metadata have been added to class\nTrainingPredictionsIterator that is\nreturned by method\nTrainingPredictions.iterate_rows.\nAdded new arguments explanation_algorithm and max_explanations to method\nModel.request_predictions. New fields explanation_algorithm,\nmax_explanations and shap_warnings have been added to class\nPredictions. Method\nPredictions.get_all_as_dataframe has new argument\nserializer that specifies the retrieval and results validation method (json or csv) for the predictions.\nAdded possibility to compute ShapImpact.create and request\nShapImpact.get SHAP impact scores for features in a model.\nAdded support for accessing Visual AI images and insights. See the DataRobot\nPython Package documentation, Visual AI Projects, section for details.\nUser can specify custom row count when requesting Feature Effects. Extended methods are\nModel.request_feature_effect and\nModel.get_or_request_feature_effect.\nUsers can request SHAP based predictions explanations for a models that support SHAP scores using\nShapMatrix.create.\nAdded two new methods to Dataset to lazily retrieve paginated\nresponses.\nDataset.iterate returns an iterator of the datasets\nthat a user can view.\nDataset.iterate_all_features returns an\niterator of the features of a dataset.\nIt\u2019s possible to create an Interaction feature by combining two categorical features together using\nProject.create_interaction_feature.\nOperation result represented by models.InteractionFeature..\nSpecific information about an interaction feature may be retrieved by its name using\nmodels.InteractionFeature.get\nAdded the DatasetFeaturelist class to support featurelists\non datasets in the AI Catalog. DatasetFeaturelists can be updated or deleted. Two new methods were\nalso added to Dataset to interact with DatasetFeaturelists. These are\nDataset.get_featurelists and\nDataset.create_featurelist which list existing\nfeaturelists and create new featurelists on a dataset, respectively.\nAdded model_splits to DatetimePartitioningSpecification and\nto DatetimePartitioning. This will allow users to control the\njobs per model used when building models. A higher number of model_splits  will result in less downsampling,\nallowing the use of more post-processed data.\nAdded support for :ref:unsupervised projects<unsupervised_anomaly>.\nAdded support for external test set. Please see :ref:testset documentation<external_testset>\nA new workflow is available for assessing models on external test sets in time series unsupervised projects.\nMore information can be found in the :ref:documentation<unsupervised_external_dataset>.\nProject.upload_dataset and\nModel.request_predictions now accept\nactual_value_column - name of the actual value column, can be passed only with date range.\nPredictionDataset objects now contain the following\nnew fields:\nactual_value_column: Actual value column which was selected for this dataset.\ndetected_actual_value_column: A list of detected actual value column info.\nNew warning is added to data_quality_warnings of datarobot.models.PredictionDataset: single_class_actual_value_column.\nScores and insights on external test sets can be retrieved using\nExternalScores, ExternalLiftChart, ExternalRocCurve.\nUsers can create payoff matrices for generating profit curves for binary classification projects\nusing PayoffMatrix.create.\nDeployment Improvements:\ndatarobot.models.deployment.TargetDrift can be used to retrieve target drift information.\ndatarobot.models.deployment.FeatureDrift can be used to retrieve feature drift information.\nDeployment.submit_actuals will submit actuals in batches if the total number of actuals exceeds the limit of one single request.\nDeployment.create_from_custom_model_image can be used to create a deployment from a custom model image.\nDeployments now support predictions data collection that enables prediction requests and results to be saved in Predictions Data Storage. See\nDeployment.get_predictions_data_collection_settings\nand Deployment.update_predictions_data_collection_settings for usage.\nNew arguments send_notification and include_feature_discovery_entities are added to Project.share.\nNow it is possible to specify the number of training rows to use in feature impact computation on supported project\ntypes (that is everything except unsupervised, multi-class, time-series). This does not affect SHAP based feature\nimpact. Extended methods:\nModel.request_feature_impact\nModel.get_or_request_feature_impact\nA new class FeatureImpactJob is added to retrieve Feature Impact\nrecords with metadata. The regular Job still works as before.\nAdded support for custom models. Please see :ref:custom model documentation<custom_models>.\nClasses added:\ndatarobot.ExecutionEnvironment and datarobot.ExecutionEnvironmentVersion to create and manage\ncustom model executions environments\ndatarobot.CustomInferenceModel and datarobot.CustomModelVersion\nto create and manage custom inference models\ndatarobot.CustomModelTest to perform testing of custom models\nBatch Prediction jobs now support forecast and historical Time Series predictions using the new\nargument timeseries_settings for BatchPredictionJob.score.\nBatch Prediction jobs now support scoring to Azure and Google Cloud Storage with methods\nBatchPredictionJob.score_azure and\nBatchPredictionJob.score_gcp.\nNow it\u2019s possible to create Relationships Configurations to introduce secondary datasets to projects. A configuration specifies additional datasets to be included to a project and how these datasets are related to each other, and the primary dataset. When a relationships configuration is specified for a project, Feature Discovery will create features automatically from these datasets.\n: - RelationshipsConfiguration.create creates a new relationships configuration between datasets\n- RelationshipsConfiguration.retrieve retrieve the requested relationships configuration\n- RelationshipsConfiguration.replace replace the relationships configuration details with new one\n- RelationshipsConfiguration.delete delete the relationships configuration\nEnhancements\u00b6\nMade creating projects from a dataset easier through the new\nDataset.create_project.\nThese methods now provide additional metadata fields in Feature Impact results if called with\nwith_metadata=True. Fields added: rowCount, shapBased, ranRedundancyDetection,\ncount.\nModel.get_feature_impact\nModel.request_feature_impact\nModel.get_or_request_feature_impact\nSecondary dataset configuration retrieve and deletion is easier now though new\nSecondaryDatasetConfigurations.delete soft deletes a Secondary dataset configuration.\nSecondaryDatasetConfigurations.get retrieve a Secondary dataset configuration.\nRetrieve relationships configuration which is applied on the given feature discovery project using\nProject.get_relationships_configuration.\nBugfixes\u00b6\nAn issue with input validation of the Batch Prediction module\nparent_model_id was not visible for all frozen models\nBatch Prediction jobs that used other output types than local_file failed when using .wait_for_completion()\nA race condition in the Batch Prediction file scoring logic\nAPI changes\u00b6\nThree new fields were added to the Dataset object. This reflects the\nupdated fields in the public API routes at api/v2/datasets/. The added fields are:\nprocessing_state: Current ingestion process state of the dataset\nrow_count: The number of rows in the dataset.\nsize: The size of the dataset as a CSV in bytes.\nDeprecation summary\u00b6\ndatarobot.enums.VARIABLE_TYPE_TRANSFORM.CATEGORICAL for is deprecated for the following and will be removed in  v2.22.\n: - meth:Project.batch_features_type_transform\n- meth:Project.create_type_transform_feature\n2.20.0\u00b6\nNew features\u00b6\nThere is a new Dataset object that implements some of the\npublic API routes at api/v2/datasets/. This also adds two new feature classes and a details\nclass.\nDatasetFeature\nDatasetFeatureHistogram\nDatasetDetails\nFunctionality:\nCreate a Dataset by uploading from a file, URL or in-memory datasource.\nDataset.create_from_file\nDataset.create_from_in_memory_data\nDataset.create_from_url\nGet Datasets or elements of Dataset with:\nDataset.list lists available Datasets\nDataset.get gets a specified Dataset\nDataset.update updates the Dataset with the latest server information.\nDataset.get_details gets the DatasetDetails of the Dataset.\nDataset.get_all_features gets a list of the Dataset\u2019s Features.\nDataset.get_file downloads the Dataset as a csv file.\nDataset.get_projects gets a list of Projects that use the Dataset.\nModify, delete or un-delete a Dataset:\nDataset.modify Changes the name and categories of the Dataset\nDataset.delete soft deletes a Dataset.\nDataset.un_delete un-deletes the Dataset. You cannot retrieve the\nIDs of deleted Datasets, so if you want to un-delete a Dataset, you need to store its ID before deletion.\nYou can also create a Project using a Dataset with:\nProject.create_from_dataset\nIt is possible to create an alternative configuration for the secondary dataset which can be used during the prediction\nSecondaryDatasetConfigurations.create allow to create secondary dataset configuration\nYou can now filter the deployments returned by the Deployment.list command. You can do this by passing an instance of the DeploymentListFilters class to the filters keyword argument. The currently supported filters are:\nrole\nservice_health\nmodel_health\naccuracy_health\nexecution_environment_type\nmateriality\nA new workflow is available for making predictions in time series projects. To that end,\nPredictionDataset objects now contain the following\nnew fields:\nforecast_point_range: The start and end date of the range of dates available for use as the forecast point,\ndetected based on the uploaded prediction dataset\ndata_start_date: A datestring representing the minimum primary date of the prediction dataset\ndata_end_date: A datestring representing the maximum primary date of the prediction dataset\nmax_forecast_date: A datestring representing the maximum forecast date of this prediction dataset\nAdditionally, users no longer need to specify a forecast_point or predictions_start_date and\npredictions_end_date when uploading datasets for predictions in time series projects. More information can be\nfound in the :ref:time series predictions<new_pred_ux> documentation.\n- Per-class lift chart data is now available for multiclass models using\nModel.get_multiclass_lift_chart.\n- Unsupervised projects can now be created using the Project.start\nand Project.set_target methods by providing unsupervised_mode=True,\nprovided that the user has access to unsupervised machine learning functionality. Contact support for more information.\n- A new boolean attribute unsupervised_mode was added to datarobot.DatetimePartitioningSpecification.\nWhen it is set to True, datetime partitioning for unsupervised time series projects will be constructed for\nnowcasting: forecast_window_start=forecast_window_end=0.\n- Users can now configure the start and end of the training partition as well as the end of the validation partition for\nbacktests in a datetime-partitioned project. More information and example usage can be found in the\n* ref:\nbacktesting documentation <backtest_configuration>.\nEnhancements\u00b6\nUpdated the user agent header to show which python version.\nModel.get_frozen_child_models can be used to retrieve models that are frozen from a given model\nAdded datarobot.enums.TS_BLENDER_METHOD to make it clearer which blender methods are allowed for use in time\nseries projects.\nBugfixes\u00b6\nAn issue where uploaded CSV\u2019s would loose quotes during serialization causing issues when columns containing line terminators where loaded in a dataframe, has been fixed\nProject.get_association_featurelists is now using the correct endpoint name, but the old one will continue to work\nPython API PredictionServer supports now on-premise format of API response.\n2.19.0\u00b6\nNew features\u00b6\nProjects can be cloned using Project.clone_project\nCalendars used in time series projects now support having series-specific events, for instance if a holiday only affects some stores. This can be controlled by using new argument of the CalendarFile.create method.\nIf multiseries id columns are not provided, calendar is considered to be single series and all events are applied to all series.\nWe have expanded prediction intervals availability to the following use-cases:\nTime series model deployments now support prediction intervals. See\nDeployment.get_prediction_intervals_settings\nand Deployment.update_prediction_intervals_settings for usage.\nPrediction intervals are now supported for model exports for time series. To that end, a new optional parameter\nprediction_intervals_size has been added to Model.request_transferable_export <datarobot.models.Model.request_transferable_export>.\nMore details on prediction intervals can be found in the :ref:prediction intervals documentation <prediction_intervals>.\n- Allowed pairwise interaction groups can now be specified in AdvancedOptions.\nThey will be used in GAM models during training.\n- New deployments features:\nUpdate the label and description of a deployment using Deployment.update.\nref:\nAssociation ID setting<deployment_association_id> can be retrieved and updated.\nRegression deployments now support :ref:prediction warnings<deployment_prediction_warning>.\nFor multiclass models now it\u2019s possible to get feature impact for each individual target class using\nModel.get_multiclass_feature_impact\nAdded support for new :ref:Batch Prediction API <batch_predictions>.\nIt is now possible to create and retrieve basic, oauth and s3 credentials with\nCredential.\nIt\u2019s now possible to get feature association statuses for featurelists using\nProject.get_association_featurelists\nYou can also pass a specific featurelist_id into\nProject.get_associations\nEnhancements\u00b6\nAdded documentation to Project.get_metrics to detail the new ascending field that\nindicates how a metric should be sorted.\nRetraining of a model is processed asynchronously and returns a  ModelJob immediately.\nBlender models can be retrained on a different set of data or a different feature list.\nWord cloud ngrams now has variable field representing the source of the ngram.\nMethod WordCloud.ngrams_per_class can be used to\nsplit ngrams for better usability in multiclass projects.\nMethod Project.set_target support new optional parameters featureEngineeringGraphs and credentials.\nMethod Project.upload_dataset and Project.upload_dataset_from_data_source support new optional parameter credentials.\nSeries accuracy retrieval methods (DatetimeModel.get_series_accuracy_as_dataframe\nand DatetimeModel.download_series_accuracy_as_csv)\nfor multiseries time series projects now support additional parameters for specifying what data to retrieve, including:\nmetric: Which metric to retrieve scores for\nmultiseries_value: Only returns series with a matching multiseries ID\norder_by: An attribute by which to sort the results\nBugfixes\u00b6\nAn issue when using Feature.get and ModelingFeature.get to retrieve summarized categorical feature has been fixed.\nAPI changes\u00b6\nThe datarobot package is now no longer a\nnamespace package.\ndatarobot.enums.BLENDER_METHOD.FORECAST_DISTANCE is removed (deprecated in 2.18.0).\nDocumentation changes\u00b6\nUpdated :ref:Residuals charts <residuals_chart> documentation to reflect that the data rows include row numbers from the source dataset for projects\ncreated in DataRobot 5.3 and newer.\n2.18.0\u00b6\nNew features\u00b6\nref:\nResiduals charts <residuals_chart> can now be retrieved for non-time-aware regression models.\nref:\nDeployment monitoring <deployment_monitoring> can now be used to retrieve service stats, service health, accuracy info, permissions, and feature lists for deployments.\nref:\nTime series <time_series> projects now support the Average by Forecast Distance blender, configured with more than one Forecast Distance. The blender blends the selected models, selecting the best three models based on the backtesting score for each Forecast Distance and averaging their predictions. The new blender method FORECAST_DISTANCE_AVG has been added to datarobot.enums.BLENDER_METHOD.\nDeployment.submit_actuals can now be used to submit data about actual results from a deployed model, which can be used to calculate accuracy metrics.\nEnhancements\u00b6\nMonotonic constraints are now supported for OTV projects. To that end, the parameters monotonic_increasing_featurelist_id and monotonic_decreasing_featurelist_id can be specified in calls to Model.train_datetime or Project.train_datetime.\nWhen retrieving information about features, information about summarized categorical variables is now available in a new keySummary.\nFor Word Clouds in multiclass projects, values of the target class for corresponding word or ngram can now be passed using the new class parameter.\nListing deployments using Deployment.list now support sorting and searching the results using the new order_by and search parameters.\nYou can now get the model associated with a model job by getting the model variable on the model job object.\nThe Blueprint class can now retrieve the recommended_featurelist_id, which indicates which feature list is recommended for this blueprint. If the field is not present, then there is no recommended feature list for this blueprint.\nThe Model class now can be used to retrieve the model_number.\nThe method Model.get_supported_capabilities now has an extra field supportsCodeGeneration to explain whether the model supports code generation.\nCalls to Project.start and Project.upload_dataset now support uploading data via S3 URI and pathlib.Path objects.\nErrors upon connecting to DataRobot are now clearer when an incorrect API Token is used.\nThe datarobot package is now a namespace package.\nDeprecation summary\u00b6\ndatarobot.enums.BLENDER_METHOD.FORECAST_DISTANCE is deprecated and will be removed in 2.19. Use FORECAST_DISTANCE_ENET instead.\nDocumentation changes\u00b6\nVarious typo and wording issues have been addressed.\nA new notebook showing regression-specific features is now been added to the examples_index.\nDocumentation for :ref:Access lists <sharing> has been added.\n2.17.0\u00b6\nNew features\u00b6\nref:\nDeployments <deployments_overview> can now be managed via the API by using the new Deployment class.\nUsers can now list available prediction servers using PredictionServer.list.\nWhen specifying datetime partitioning settings , :ref:time series <time_series> projects can now mark individual features as excluded from feature derivation using the\nFeatureSettings.do_not_derive attribute. Any features not specified will be assigned according to the DatetimePartitioningSpecification.default_to_do_not_derive value.\nUsers can now submit multiple feature type transformations in a single batch request using Project.batch_features_type_transform.\nref:\nAdvanced Tuning <advanced_tuning> for non-Eureqa models (beta feature) is now enabled by default for all users.\nAs of v2.17, all models are now supported other than blenders, open source, prime, scaleout, baseline and user-created.\nInformation on feature clustering and the association strength between pairs of numeric or categorical features is now available.\nProject.get_associations can be used to retrieve pairwise feature association statistics and\nProject.get_association_matrix_details can be used to get a sample of the actual values used to measure association strength.\nEnhancements\u00b6\nnumber_of_do_not_derive_features has been added to the datarobot.DatetimePartitioning class to specify the number of features that are marked as excluded from derivation.\nUsers with PyYAML>=5.1 will no longer receive a warning when using the datarobot package\nIt is now possible to use files with unicode names for creating projects and prediction jobs.\nUsers can now embed DataRobot-generated content in a ComplianceDocTemplate using keyword tags. :ref:See here <automated_documentation_overview> for more details.\nThe field calendar_name has been added to datarobot.DatetimePartitioning to display the name of the calendar used for a project.\nref:\nPrediction intervals <prediction_intervals> are now supported for start-end retrained models in a time series project.\nPreviously, all backtests had to be run before :ref:prediction intervals <prediction_intervals> for a time series project could be requested with predictions.\nNow, backtests will be computed automatically if needed when prediction intervals are requested.\nBugfixes\u00b6\nAn issue affecting time series project creation for irregularly spaced dates has been fixed.\nComplianceDocTemplate now supports empty text blocks in user sections.\nAn issue when using Predictions.get to retrieve predictions metadata has been fixed.\nDocumentation changes\u00b6\nAn overview on working with class ComplianceDocumentation and ComplianceDocTemplate has been created. :ref:See here <automated_documentation_overview> for more details.\n2.16.0\u00b6\nNew features\u00b6\nThree new methods for Series Accuracy have been added to the DatetimeModel class.\nStart a request to calculate Series Accuracy with\nDatetimeModel.compute_series_accuracy\nOnce computed, Series Accuracy can be retrieved as a pandas.DataFrame using\nDatetimeModel.get_series_accuracy_as_dataframe\nOr saved as a CSV using\nDatetimeModel.download_series_accuracy_as_csv\nUsers can now access :ref:prediction intervals <prediction_intervals> data for each prediction with a DatetimeModel.\nFor each model, prediction intervals estimate the range of values DataRobot expects actual values of the target to fall within.\nThey are similar to a confidence interval of a prediction, but are based on the residual errors measured during the\nbacktesting for the selected model.\nEnhancements\u00b6\nInformation on the effective feature derivation window is now available for :ref:time series projects <time_series> to specify the full span of historical data\nrequired at prediction time. It may be longer than the feature derivation window of the project depending on the differencing settings used.\nAdditionally, more of the project partitioning settings are also available on the\nDatetimeModel class.  The new attributes are:\neffective_feature_derivation_window_start\neffective_feature_derivation_window_end\nforecast_window_start\nforecast_window_end\nwindows_basis_unit\nPrediction metadata is now included in the return of Predictions.get\nDocumentation changes\u00b6\nVarious typo and wording issues have been addressed.\nThe example data that was meant to accompany the Time Series examples has been added to the\nzip file of the download in the examples_index.\n2.15.1\u00b6\nEnhancements\u00b6\nCalendarFile.get_access_list has been added to the CalendarFile class to return a list of users with access to a calendar file.\nA role attribute has been added to the CalendarFile class to indicate the access level a current user has to a calendar file. For more information on the specific access levels, see the :ref:sharing <sharing> documentation.\nBugfixes\u00b6\nPreviously, attempting to retrieve the calendar_id of a project without a set target would result in an error.\nThis has been fixed to return None instead.\n2.15.0\u00b6\nNew features\u00b6\nPreviously available for only Eureqa models, Advanced Tuning methods and objects, including\nModel.start_advanced_tuning_session,\nModel.get_advanced_tuning_parameters,\nModel.advanced_tune, and\nAdvancedTuningSession,\nnow support all models other than blender, open source, and user-created models.  Use of\nAdvanced Tuning via API for non-Eureqa models is in beta and not available by default, but can be\nenabled.\nCalendar Files for time series projects can now be created and managed through the CalendarFile class.\nEnhancements\u00b6\nThe dataframe returned from\ndatarobot.PredictionExplanations.get_all_as_dataframe() will now have\neach class label class_X be the same from row to row.\nThe client is now more robust to networking issues by default. It will retry on more errors and respects Retry-After headers in HTTP 413, 429, and 503 responses.\nAdded Forecast Distance blender for Time-Series projects configured with more than one Forecast\nDistance. It blends the selected models creating separate linear models for each Forecast Distance.\nProject can now be :ref:shared <sharing> with other users.\nProject.upload_dataset and Project.upload_dataset_from_data_source will return a PredictionDataset with data_quality_warnings if potential problems exist around the uploaded dataset.\nrelax_known_in_advance_features_check has been added to Project.upload_dataset and Project.upload_dataset_from_data_source to allow missing values from the known in advance features in the forecast window at prediction time.\ncross_series_group_by_columns has been added to datarobot.DatetimePartitioning to allow users the ability to indicate how to further split series into related groups.\nInformation retrieval for ROC Curve has been extended to include fraction_predicted_as_positive, fraction_predicted_as_negative, lift_positive and lift_negative\nBugfixes\u00b6\nFixes an issue where the client would not be usable if it could not be sure it was compatible with the configured\nserver\nAPI changes\u00b6\nMethods for creating datarobot.models.Project: create_from_mysql, create_from_oracle, and create_from_postgresql, deprecated in 2.11, have now been removed.\nUse datarobot.models.Project.create_from_data_source() instead.\ndatarobot.FeatureSettings attribute apriori, deprecated in 2.11, has been removed.\nUse datarobot.FeatureSettings.known_in_advance instead.\ndatarobot.DatetimePartitioning attribute default_to_a_priori, deprecated in 2.11, has been removed. Use\ndatarobot.DatetimePartitioning.known_in_advance instead.\ndatarobot.DatetimePartitioningSpecification attribute default_to_a_priori, deprecated in 2.11, has been removed.\nUse datarobot.DatetimePartitioningSpecification.known_in_advance\ninstead.\nConfiguration changes\u00b6\nNow requires dependency on package requests  to be at least version 2.21.\nNow requires dependency on package urllib3  to be at least version 1.24.\nDocumentation changes\u00b6\nAdvanced model insights notebook extended to contain information on visualization of cumulative gains and lift charts.\n2.14.2\u00b6\nBugfixes\u00b6\nFixed an issue where searches of the HTML documentation would sometimes hang indefinitely\nDocumentation changes\u00b6\nPython3 is now the primary interpreter used to build the docs (this does not affect the ability to use the\npackage with Python2)\n2.14.1\u00b6\nDocumentation changes\u00b6\nDocumentation for the Model Deployment interface has been removed after the corresponding interface was removed in 2.13.0.\n2.14.0\u00b6\nNew features\u00b6\nThe new method Model.get_supported_capabilities\nretrieves a summary of the capabilities supported by a particular model,\nsuch as whether it is eligible for Prime and whether it has word cloud data available.\nNew class for working with model compliance documentation feature of DataRobot:\nclass ComplianceDocumentation\nNew class for working with compliance documentation templates:\nComplianceDocTemplate\nNew class FeatureHistogram has been added to\nretrieve feature histograms for a requested maximum bin count\nTime series projects now support binary classification targets.\nCross series features can now be created within time series multiseries projects using the\nuse_cross_series_features and aggregation_type attributes of the\ndatarobot.DatetimePartitioningSpecification.\nSee the :ref:Time Series <time_series> documentation for more info.\nEnhancements\u00b6\nClient instantiation now checks the endpoint configuration and provides more informative error messages.\nIt also automatically corrects HTTP to HTTPS if the server responds with a redirect to HTTPS.\nProject.upload_dataset and Project.create\nnow accept an optional parameter of dataset_filename to specify a file name for the dataset.\nThis is ignored for url and file path sources.\nNew optional parameter fallback_to_parent_insights has been added to Model.get_lift_chart,\nModel.get_all_lift_charts, Model.get_confusion_chart,\nModel.get_all_confusion_charts, Model.get_roc_curve,\nand Model.get_all_roc_curves.  When True, a frozen model with\nmissing insights will attempt to retrieve the missing insight data from its parent model.\nNew number_of_known_in_advance_features attribute has been added to the\ndatarobot.DatetimePartitioning class.\nThe attribute specifies number of features that are marked as known in advance.\nProject.set_worker_count can now update the worker count on\na project to the maximum number available to the user.\nref:\nRecommended Models API <recommended_models> can now be used to retrieve\nmodel recommendations for datetime partitioned projects\nTimeseries projects can now accept feature derivation and forecast windows intervals in terms of\nnumber of the rows rather than a fixed time unit. DatetimePartitioningSpecification\nand Project.set_target support new optional parameter windowsBasisUnit, either \u2018ROW\u2019 or detected time unit.\nTimeseries projects can now accept feature derivation intervals, forecast windows, forecast points and prediction start/end dates in milliseconds.\nDataSources and DataStores can now\nbe :ref:shared <sharing> with other users.\nTraining predictions for datetime partitioned projects now support the new data subset\ndr.enums.DATA_SUBSET.ALL_BACKTESTS for requesting the predictions for all backtest validation\nfolds.\nAPI changes\u00b6\nThe model recommendation type \u201cRecommended\u201d (deprecated in version 2.13.0) has been removed.\nDocumentation changes\u00b6\nExample notebooks have been updated:\n: - Notebooks now work in Python 2 and Python 3\n- A notebook illustrating time series capability has been added\n- The financial data example has been replaced with an updated introductory example.\nTo supplement the embedded Python notebooks in both the PDF and HTML docs bundles, the notebook files and supporting data can now be downloaded from the HTML docs bundle.\nFixed a minor typo in the code sample for get_or_request_feature_impact\n2.13.0\u00b6\nNew features\u00b6\nThe new method Model.get_or_request_feature_impact functionality will attempt to request feature impact\nand return the newly created feature impact object or the existing object so two calls are no longer required.\nNew methods and objects, including\nModel.start_advanced_tuning_session,\nModel.get_advanced_tuning_parameters,\nModel.advanced_tune, and\nAdvancedTuningSession,\nwere added to support the setting of Advanced Tuning parameters. This is currently supported for\nEureqa models only.\nNew is_starred attribute has been added to the Model class. The attribute\nspecifies whether a model has been marked as starred by user or not.\nModel can be marked as starred or being unstarred with Model.star_model and Model.unstar_model.\nWhen listing models with Project.get_models, the model list can now be filtered by the is_starred value.\nA custom prediction threshold may now be configured for each model via Model.set_prediction_threshold.  When making\npredictions in binary classification projects, this value will be used when deciding between the positive and negative classes.\nProject.check_blendable can be used to confirm if a particular group of models are eligible for blending as\nsome are not, e.g. scaleout models and datetime models with different training lengths.\nIndividual cross validation scores can be retrieved for new models using Model.get_cross_validation_scores.\nEnhancements\u00b6\nPython 3.7 is now supported.\nFeature impact now returns not only the impact score for the features but also whether they were\ndetected to be redundant with other high-impact features.\nA new is_blocked attribute has been added to the Job\nclass, specifying whether a job is blocked from execution because one or more dependencies are not\nyet met.\nThe Featurelist object now has new attributes reporting\nits creation time, whether it was created by a user or by DataRobot, and the number of models\nusing the featurelist, as well as a new description field.\nFeaturelists can now be renamed and have their descriptions updated with\nFeaturelist.update and\nModelingFeaturelist.update.\nFeaturelists can now be deleted with\nFeaturelist.delete\nand ModelingFeaturelist.delete.\nModelRecommendation.get now accepts an optional\nparameter of type datarobot.enums.RECOMMENDED_MODEL_TYPE which can be used to get a specific\nkind of recommendation.\nPreviously computed predictions can now be listed and retrieved with the\nPredictions class, without requiring a\nreference to the original PredictJob.\nBugfixes\u00b6\nThe Model Deployment interface which was previously visible in the client has been removed to\nallow the interface to mature, although the raw API is available as a \u201cbeta\u201d API without full\nbackwards compatibility support.\nAPI changes\u00b6\nAdded support for retrieving the Pareto Front of a Eureqa model. See\nParetoFront.\nA new recommendation type \u201cRecommended for Deployment\u201d has been added to\nModelRecommendation which is now returns as the\ndefault recommended model when available. See :ref:model_recommendation.\nDeprecation summary\u00b6\nThe feature previously referred to as \u201cReason Codes\u201d has been renamed to \u201cPrediction\nExplanations\u201d, to provide increased clarity and accessibility. The old\nReasonCodes interface has been deprecated and replaced with\nPredictionExplanations.\nThe recommendation type \u201cRecommended\u201d is deprecated and  will no longer be returned\nin v2.14 of the API.\nDocumentation changes\u00b6\nAdded a new documentation section :ref:model_recommendation.\nTime series projects support multiseries as well as single series data. They are now documented in\nthe :ref:Time Series Projects <time_series> documentation.\n2.12.0\u00b6\nNew features\u00b6\nSome models now have Missing Value reports allowing users with access to uncensored blueprints to\nretrieve a detailed breakdown of how numeric imputation and categorical converter tasks handled\nmissing values. See the :ref:documentation <missing_values_report> for more information on the\nreport.\n2.11.0\u00b6\nNew features\u00b6\nThe new ModelRecommendation class can be used to retrieve the recommended models for a\nproject.\nA new helper method cross_validate was added to class Model. This method can be used to request\nModel\u2019s Cross Validation score.\nTraining a model with monotonic constraints is now supported. Training with monotonic\nconstraints allows users to force models to learn monotonic relationships with respect to some features and the target. This helps users create accurate models that comply with regulations (e.g. insurance, banking). Currently, only certain blueprints (e.g. xgboost) support this feature, and it is only supported for regression and binary classification projects.\nDataRobot now supports \u201cDatabase Connectivity\u201d, allowing databases to be used\nas the source of data for projects and prediction datasets. The feature works\non top of the JDBC standard, so a variety of databases conforming to that standard are available;\na list of databases with tested support for DataRobot is available in the user guide\nin the web application. See :ref:Database Connectivity <database_connectivity_overview>\nfor details.\nAdded a new feature to retrieve feature logs for time series projects. Check\ndatarobot.DatetimePartitioning.feature_log_list() and\ndatarobot.DatetimePartitioning.feature_log_retrieve() for details.\nAPI changes\u00b6\nNew attributes supporting monotonic constraints have been added to the\nAdvancedOptions,\nProject,\nModel, and Blueprint\nclasses. See :ref:monotonic constraints<monotonic_constraints> for more information on how to\nconfigure monotonic constraints.\nNew parameters predictions_start_date and predictions_end_date added to\nProject.upload_dataset to support bulk\npredictions upload for time series projects.\nDeprecation summary\u00b6\nMethods for creating datarobot.models.Project: create_from_mysql, create_from_oracle, and create_from_postgresql, have been deprecated and will be removed in 2.14.\nUse datarobot.models.Project.create_from_data_source() instead.\ndatarobot.FeatureSettings attribute apriori, has been deprecated and will be removed in 2.14.\nUse datarobot.FeatureSettings.known_in_advance instead.\ndatarobot.DatetimePartitioning attribute default_to_a_priori, has been deprecated and will be removed in 2.14.\ndatarobot.DatetimePartitioning.known_in_advance instead.\ndatarobot.DatetimePartitioningSpecification attribute default_to_a_priori, has been deprecated and will be removed in 2.14.\nUse datarobot.DatetimePartitioningSpecification.known_in_advance\ninstead.\nConfiguration changes\u00b6\nRetry settings compatible with those offered by urllib3\u2019s Retry\ninterface can now be configured. By default, we will now retry connection errors that prevented requests from arriving at the server.\nDocumentation changes\u00b6\n\u201cAdvanced Model Insights\u201d example has been updated to properly handle bin weights when rebinning.\n2.9.0\u00b6\nNew features\u00b6\nNew ModelDeployment class can be used to track status and health of models deployed for\npredictions.\nEnhancements\u00b6\nDataRobot API now supports creating 3 new blender types - Random Forest, TensorFlow, LightGBM.\nMulticlass projects now support blenders creation for 3 new blender types as well as Average\nand ENET blenders.\nModels can be trained by requesting a particular row count using the new training_row_count\nargument with Project.train, Model.train and Model.request_frozen_model in non-datetime\npartitioned projects, as an alternative to the previous option of specifying a desired\npercentage of the project dataset. Specifying model size by row count is recommended when\nthe float precision of sample_pct could be problematic, e.g. when training on a small\npercentage of the dataset or when training up to partition boundaries.\nNew attributes max_train_rows, scaleout_max_train_pct, and scaleout_max_train_rows\nhave been added to Project. max_train_rows specified the equivalent\nvalue to the existing max_train_pct as a row count. The scaleout fields can be used to see how\nfar scaleout models can be trained on projects, which for projects taking advantage of scalable\ningest may exceed the limits on the data available to non-scaleout blueprints.\nIndividual features can now be marked as a priori or not a priori using the new feature_settings\nattribute when setting the target or specifying datetime partitioning settings on time\nseries projects. Any features not specified in the feature_settings parameter will be\nassigned according to the default_to_a_priori value.\nThree new options have been made available in the\ndatarobot.DatetimePartitioningSpecification class to fine-tune how time-series projects\nderive modeling features. treat_as_exponential can control whether data is analyzed as\nan exponential trend and transformations like log-transform are applied.\ndifferencing_method can control which differencing method to use for stationary data.\nperiodicities can be used to specify periodicities occurring within the data.\nAll are optional and defaults will be chosen automatically if they are unspecified.\nAPI changes\u00b6\nNow training_row_count is available on non-datetime models as well as rowCount based\ndatetime models. It reports the number of rows used to train the model (equivalent to\nsample_pct).\nFeatures retrieved from Feature.get now include target_leakage.\n2.8.1\u00b6\nBugfixes\u00b6\nThe documented default connect_timeout will now be correctly set for all configuration mechanisms,\nso that requests that fail to reach the DataRobot server in a reasonable amount of time will now\nerror instead of hanging indefinitely. If you observe that you have started seeing\nConnectTimeout errors, please configure your connect_timeout to a larger value.\nVersion of trafaret library this package depends on is now pinned to trafaret>=0.7,<1.1\nsince versions outside that range are known to be incompatible.\n2.8.0\u00b6\nNew features\u00b6\nThe DataRobot API supports the creation, training, and predicting of multiclass classification\nprojects. DataRobot, by default, handles a dataset with a numeric target column as regression.\nIf your data has a numeric cardinality of fewer than 11 classes, you can override this behavior to\ninstead create a multiclass classification project from the data. To do so, use the set_target\nfunction, setting target_type=\u2018Multiclass\u2019. If DataRobot recognizes your data as categorical, and\nit has fewer than 11 classes, using multiclass will create a project that classifies which label\nthe data belongs to.\nThe DataRobot API now includes Rating Tables. A rating table is an exportable csv representation\nof a model. Users can influence predictions by modifying them and creating a new model with the\nmodified table. See the :ref:documentation<rating_table> for more information on how to use\nrating tables.\nscaleout_modeling_mode has been added to the AdvancedOptions class\nused when setting a project target. It can be used to control whether\nscaleout models appear in the autopilot and/or available blueprints.\nScaleout models are only supported in the Hadoop environment with\nthe corresponding user permission set.\nA new premium add-on product, Time Series, is now available. New projects can be created as time series\nprojects which automatically derive features from past data and forecast the future. See the\nref:\ntime series documentation<time_series> for more information.\nThe Feature object now returns the EDA summary statistics (i.e., mean, median, minimum, maximum,\nand standard deviation) for features where this is available (e.g., numeric, date, time,\ncurrency, and length features). These summary statistics will be formatted in the same format\nas the data it summarizes.\nThe DataRobot API now supports Training Predictions workflow. Training predictions are made by a\nmodel for a subset of data from original dataset. User can start a job which will make those\npredictions and retrieve them. See the :ref:documentation<predictions>\nfor more information on how to use training predictions.\nDataRobot now supports retrieving a :ref:model blueprint chart<model_blueprint_chart> and a\nref:\nmodel blueprint docs<model_blueprint_doc>.\nWith the introduction of Multiclass Classification projects, DataRobot needed a better way to\nexplain the performance of a multiclass model so we created a new Confusion Chart. The API\nnow supports retrieving and interacting with confusion charts.\nEnhancements\u00b6\nDatetimePartitioningSpecification now includes the optional disable_holdout flag that can\nbe used to disable the holdout fold when creating a project with datetime partitioning.\nWhen retrieving reason codes on a project using an exposure column, predictions that are adjusted\nfor exposure can be retrieved.\nFile URIs can now be used as sourcedata when creating a project or uploading a prediction dataset.\nThe file URI must refer to an allowed location on the server, which is configured as described in\nthe user guide documentation.\nThe advanced options available when setting the target have been extended to include the new\nparameter \u2018events_count\u2019 as a part of the AdvancedOptions object to allow specifying the\nevents count column. See the user guide documentation in the webapp for more information\non events count.\nPredictJob.get_predictions now returns predicted probability for each class in the dataframe.\nPredictJob.get_predictions now accepts prefix parameter to prefix the classes name returned in the\npredictions dataframe.\nAPI changes\u00b6\nAdd target_type parameter to set_target() and start(), used to override the project default.\n2.7.2\u00b6\nDocumentation changes\u00b6\nUpdated link to the publicly hosted documentation.\n2.7.1\u00b6\nDocumentation changes\u00b6\nOnline documentation hosting has migrated from PythonHosted to Read The Docs. Minor code changes\nhave been made to support this.\n2.7.0\u00b6\nNew features\u00b6\nLift chart data for models can be retrieved using the Model.get_lift_chart and\nModel.get_all_lift_charts methods.\nROC curve data for models in classification projects can be retrieved using the\nModel.get_roc_curve and Model.get_all_roc_curves methods.\nSemi-automatic autopilot mode is removed.\nWord cloud data for text processing models can be retrieved using Model.get_word_cloud method.\nScoring code JAR file can be downloaded for models supporting code generation.\nEnhancements\u00b6\nA __repr__ method has been added to the PredictionDataset class to improve readability when\nusing the client interactively.\nModel.get_parameters now includes an additional key in the derived features it includes,\nshowing the coefficients for individual stages of multistage models (e.g. Frequency-Severity\nmodels).\nWhen training a DatetimeModel on a window of data, a time_window_sample_pct can be specified\nto take a uniform random sample of the training data instead of using all data within the window.\nInstalling of DataRobot package now has an \u201cExtra Requirements\u201d section that will install all of\nthe dependencies needed to run the example notebooks.\nDocumentation changes\u00b6\nA new example notebook describing how to visualize some of the newly available model insights\nincluding lift charts, ROC curves, and word clouds has been added to the examples section.\nA new section for Common Issues has been added to Getting Started to help debug issues related to client installation and usage.\n2.6.1\u00b6\nBugfixes\u00b6\nFixed a bug with Model.get_parameters raising an exception on some valid parameter values.\nDocumentation changes\u00b6\nFixed sorting order in Feature Impact example code snippet.\n2.6.0\u00b6\nNew features\u00b6\nA new partitioning method (datetime partitioning) has been added. The recommended workflow is to\npreview the partitioning by creating a DatetimePartitioningSpecification and passing it into\nDatetimePartitioning.generate, inspect the results and adjust as needed for the specific project\ndataset by adjusting the DatetimePartitioningSpecification and re-generating, and then set the\ntarget by passing the final DatetimePartitioningSpecification object to the partitioning_method\nparameter of Project.set_target.\nWhen interacting with datetime partitioned projects, DatetimeModel can be used to access more\ninformation specific to models in datetime partitioned projects. See\nref:\nthe documentation<datetime_modeling_workflow> for more information on differences in the\nmodeling workflow for datetime partitioned projects.\nThe advanced options available when setting the target have been extended to include the new\nparameters \u2018offset\u2019 and \u2018exposure\u2019 (part of the AdvancedOptions object) to allow specifying\noffset and exposure columns to apply to predictions generated by models within the project.\nSee the user guide documentation in the webapp for more information on offset\nand exposure columns.\nBlueprints can now be retrieved directly by project_id and blueprint_id via Blueprint.get.\nBlueprint charts can now be retrieved directly by project_id and blueprint_id via\nBlueprintChart.get. If you already have an instance of Blueprint you can retrieve its\nchart using Blueprint.get_chart.\nModel parameters can now be retrieved using ModelParameters.get. If you already have an\ninstance of Model you can retrieve its parameters using Model.get_parameters.\nBlueprint documentation can now be retrieved using Blueprint.get_documents. It will contain\ninformation about the task, its parameters and (when available) links and references to\nadditional sources.\nThe DataRobot API now includes Reason Codes. You can now compute reason codes for prediction\ndatasets. You are able to specify thresholds on which rows to compute reason codes for to speed\nup computation by skipping rows based on the predictions they generate. See the reason codes\nref:\ndocumentation<reason_codes> for more information.\nEnhancements\u00b6\nA new parameter has been added to the AdvancedOptions used with Project.set_target. By\nspecifying accuracyOptimizedMb=True when creating AdvancedOptions, longer-running models\nthat may have a high accuracy will be included in the autopilot and made available to run\nmanually.\nA new option for Project.create_type_transform_feature has been added which explicitly\ntruncates data when casting numerical data as categorical data.\nAdded 2 new blenders for projects that use MAD or Weighted MAD as a metric. The MAE blender uses\nBFGS optimization to find linear weights for the blender that minimize mean absolute error\n(compared to the GLM blender, which finds linear weights that minimize RMSE), and the MAEL1\nblender uses BFGS optimization to find linear weights that minimize MAE + a L1 penalty on the\ncoefficients (compared to the ENET blender, which minimizes RMSE + a combination of the L1 and L2\npenalty on the coefficients).\nBugfixes\u00b6\nFixed a bug (affecting Python 2 only) with printing any model (including frozen and prime models)\nwhose model_type is not ascii.\nFrozenModels were unable to correctly use methods inherited from Model. This has been fixed.\nWhen calling get_result for a Job, ModelJob, or PredictJob that has errored, AsyncProcessUnsuccessfulError will now be raised instead of JobNotFinished, consistently with the behavior of get_result_when_complete.\nDeprecation summary\u00b6\nSupport for the experimental Recommender Problems projects has been removed. Any code relying on\nRecommenderSettings or the recommender_settings argument of Project.set_target and\nProject.start will error.\nProject.update, deprecated in v2.2.32, has been removed in favor of specific updates:\nrename, unlock_holdout, set_worker_count.\nDocumentation changes\u00b6\nThe link to Configuration from the Quickstart page has been fixed.\n2.5.1\u00b6\nBugfixes\u00b6\nFixed a bug (affecting Python 2 only) with printing blueprints  whose names are\nnot ascii.\nFixed an issue where the weights column (for weighted projects) did not appear\nin the advanced_options of a Project.\n2.5.0\u00b6\nNew features\u00b6\nMethods to work with blender models have been added. Use Project.blend method to create new blenders,\nProject.get_blenders to get the list of existing blenders and BlenderModel.get to retrieve a model\nwith blender-specific information.\nProjects created via the API can now use smart downsampling when setting the target by passing\nsmart_downsampled and majority_downsampling_rate into the AdvancedOptions object used with\nProject.set_target. The smart sampling options used with an existing project will be available\nas part of Project.advanced_options.\nSupport for frozen models, which use tuning parameters from a parent model for more efficient\ntraining, has been added. Use Model.request_frozen_model to create a new frozen model,\nProject.get_frozen_models to get the list of existing frozen models and FrozenModel.get to\nretrieve a particular frozen model.\nEnhancements\u00b6\nThe inferred date format (e.g. \u201c%Y-%m-%d %H:%M:%S\u201d) is now included in the Feature object. For\nnon-date features, it will be None.\nWhen specifying the API endpoint in the configuration, the client will now behave correctly for\nendpoints with and without trailing slashes.\n2.4.0\u00b6\nNew features\u00b6\nThe premium add-on product DataRobot Prime has been added. You can now approximate a model\non the leaderboard and download executable code for it. See documentation for further details, or\ntalk to your account representative if the feature is not available on your account.\n(Only relevant for on-premise users with a Standalone Scoring cluster.) Methods\n(request_transferable_export and download_export) have been added to the Model class for exporting models (which will only work if model export is turned on). There is a new class ImportedModel for managing imported models on a Standalone\nScoring cluster.\nIt is now possible to create projects from a WebHDFS, PostgreSQL, Oracle or MySQL data source. For more information see the\ndocumentation for the relevant Project classmethods: create_from_hdfs, create_from_postgresql,\ncreate_from_oracle and create_from_mysql.\nJob.wait_for_completion, which waits for a job to complete without returning anything, has been added.\nEnhancements\u00b6\nThe client will now check the API version offered by the server specified in configuration, and\ngive a warning if the client version is newer than the server version. The DataRobot server is\nalways backwards compatible with old clients, but new clients may have functionality that is\nnot implemented on older server versions. This issue mainly affects users with on-premise deployments\nof DataRobot.\nBugfixes\u00b6\nFixed an issue where Model.request_predictions might raise an error when predictions finished\nvery quickly instead of returning the job.\nAPI changes\u00b6\nTo set the target with quickrun autopilot, call Project.set_target with mode=AUTOPILOT_MODE.QUICK instead of\nspecifying quickrun=True.\nDeprecation summary\u00b6\nSemi-automatic mode for autopilot has been deprecated and will be removed in 3.0.\nUse manual or fully automatic instead.\nUse of the quickrun argument in Project.set_target has been deprecated and will be removed in\n3.0. Use mode=AUTOPILOT_MODE.QUICK instead.\nConfiguration changes\u00b6\nIt is now possible to control the SSL certificate verification by setting the parameter\nssl_verify in the config file.\nDocumentation changes\u00b6\nThe \u201cModeling Airline Delay\u201d example notebook has been updated to work with the new 2.3\nenhancements.\nDocumentation for the generic Job class has been added.\nClass attributes are now documented in the API Reference section of the documentation.\nThe changelog now appears in the documentation.\nThere is a new section dedicated to configuration, which lists all of the configuration\noptions and their meanings.\n2.3.0\u00b6\nNew features\u00b6\nThe DataRobot API now includes Feature Impact, an approach to measuring the relevance of each feature\nthat can be applied to any model. The Model class now includes methods request_feature_impact\n(which creates and returns a feature impact job) and get_feature_impact (which can retrieve completed feature impact results).\nA new improved workflow for predictions now supports first uploading a dataset via Project.upload_dataset,\nthen requesting predictions via Model.request_predictions. This allows us to better support predictions on\nlarger datasets and non-ascii files.\nDatasets previously uploaded for predictions (represented by the PredictionDataset class) can be listed from\nProject.get_datasets and retrieve and deleted via PredictionDataset.get and PredictionDataset.delete.\nYou can now create a new feature by re-interpreting the type of an existing feature in a project by\nusing the Project.create_type_transform_feature method.\nThe Job class now includes a get method for retrieving a job and a cancel method for\ncanceling a job.\nAll of the jobs classes (Job, ModelJob, PredictJob) now include the following new methods:\nrefresh (for refreshing the data in the job object), get_result (for getting the\ncompleted resource resulting from the job), and get_result_when_complete (which waits until the job\nis complete and returns the results, or times out).\nA new method Project.refresh can be used to update\nProject objects with the latest state from the server.\nA new function datarobot.async.wait_for_async_resolution can be\nused to poll for the resolution of any generic asynchronous operation\non the server.\nEnhancements\u00b6\nThe JOB_TYPE enum now includes FEATURE_IMPACT.\nThe QUEUE_STATUS enum now includes ABORTED and COMPLETED.\nThe Project.create method now has a read_timeout parameter which can be used to\nkeep open the connection to DataRobot while an uploaded file is being processed.\nFor very large files this time can be substantial. Appropriately raising this value\ncan help avoid timeouts when uploading large files.\nThe method Project.wait_for_autopilot has been enhanced to error if\nthe project enters a state where autopilot may not finish. This avoids\na situation that existed previously where users could wait\nindefinitely on their project that was not going to finish. However,\nusers are still responsible to make sure a project has more than\nzero workers, and that the queue is not paused.\nFeature.get now supports retrieving features by feature name. (For backwards compatibility,\nfeature IDs are still supported until 3.0.)\nFile paths that have unicode directory names can now be used for\ncreating projects and PredictJobs. The filename itself must still\nbe ascii, but containing directory names can have other encodings.\nNow raises more specific JobAlreadyRequested exception when we refuse a model fitting request as a duplicate.\nUsers can explicitly catch this exception if they want it to be ignored.\nA file_name attribute has been added to the Project class, identifying the file name\nassociated with the original project dataset. Note that if the project was created from\na data frame, the file name may not be helpful.\nThe connect timeout for establishing a connection to the server can now be set directly. This can be done in the\nyaml configuration of the client, or directly in the code. The default timeout has been lowered from 60 seconds\nto 6 seconds, which will make detecting a bad connection happen much quicker.\nBugfixes\u00b6\nFixed a bug (affecting Python 2 only) with printing features and featurelists whose names are\nnot ascii.\nAPI changes\u00b6\nJob class hierarchy is rearranged to better express the relationship between these objects. See\ndocumentation for datarobot.models.job for details.\nFeaturelist objects now have a project_id attribute to indicate which project they belong\nto. Directly accessing the project attribute of a Featurelist object is now deprecated\nSupport INI-style configuration, which was deprecated in v2.1, has been removed. yaml is the only supported\nconfiguration format.\nThe method Project.get_jobs method, which was deprecated in v2.1, has been removed. Users should use\nthe Project.get_model_jobs method instead to get the list of model jobs.\nDeprecation summary\u00b6\nPredictJob.create has been deprecated in favor of the alternate workflow using Model.request_predictions.\nFeature.converter (used internally for object construction) has been made private.\nModel.fetch_resource_data has been deprecated and will be removed in 3.0. To fetch a model from\n: its ID, use Model.get.\nThe ability to use Feature.get with feature IDs (rather than names) is deprecated and will\nbe removed in 3.0.\nInstantiating a Project, Model, Blueprint, Featurelist, or Feature instance from a dict\nof data is now deprecated. Please use the from_data classmethod of these classes instead. Additionally,\ninstantiating a Model from a tuple or by using the keyword argument data is also deprecated.\nUse of the attribute Featurelist.project is now deprecated. You can use the project_id\nattribute of a Featurelist to instantiate a Project instance using Project.get.\nUse of the attributes Model.project, Model.blueprint, and Model.featurelist are all deprecated now\nto avoid use of partially instantiated objects. Please use the ids of these objects instead.\nUsing a Project instance as an argument in Featurelist.get is now deprecated.\nPlease use a project_id instead. Similarly, using a Project instance in Model.get is also deprecated,\nand a project_id should be used in its place.\nConfiguration changes\u00b6\nPreviously it was possible (though unintended) that the client configuration could be mixed through\nenvironment variables, configuration files, and arguments to datarobot.Client. This logic is now\nsimpler - please see the Getting Started section of the documentation for more information.\n2.2.33\u00b6\nBugfixes\u00b6\nFixed a bug with non-ascii project names using the package with Python 2.\nFixed an error that occurred when printing projects that had been constructed from an ID only or\nprinting printing models that had been constructed from a tuple (which impacted printing PredictJobs).\nFixed a bug with project creation from non-ascii file names. Project creation from non-ascii file names\nis not supported, so this now raises a more informative exception. The project name is no longer used as\nthe file name in cases where we do not have a file name, which prevents non-ascii project names from\ncausing problems in those circumstances.\nFixed a bug (affecting Python 2 only) with printing projects, features, and featurelists whose names are\nnot ascii.\n2.2.32\u00b6\nNew features\u00b6\nProject.get_features and Feature.get methods have been added for feature retrieval.\nA generic Job entity has been added for use in retrieving the entire queue at once. Calling\nProject.get_all_jobs will retrieve all (appropriately filtered) jobs from the queue. Those\ncan be cancelled directly as generic jobs, or transformed into instances of the specific\njob class using ModelJob.from_job and PredictJob.from_job, which allow all functionality\npreviously available via the ModelJob and PredictJob interfaces.\nModel.train now supports featurelist_id and scoring_type parameters, similar to\nProject.train.\nEnhancements\u00b6\nDeprecation warning filters have been updated. By default, a filter will be added ensuring that\nusage of deprecated features will display a warning once per new usage location. In order to\nhide deprecation warnings, a filter like\nwarnings.filterwarnings('ignore', category=DataRobotDeprecationWarning)\ncan be added to a script so no such warnings are shown. Watching for deprecation warnings\nto avoid reliance on deprecated features is recommended.\nIf your client is misconfigured and does not specify an endpoint, the cloud production server is\nno longer used as the default as in many cases this is not the correct default.\nThis changelog is now included in the distributable of the client.\nBugfixes\u00b6\nFixed an issue where updating the global client would not affect existing objects with cached clients.\nNow the global client is used for every API call.\nAn issue where mistyping a filepath for use in a file upload has been resolved. Now an error will be\nraised if it looks like the raw string content for modeling or predictions is just one single line.\nAPI changes\u00b6\nUse of username and password to authenticate is no longer supported - use an API token instead.\nUsage of start_time and finish_time parameters in Project.get_models is not\nsupported both in filtering and ordering of models\nDefault value of sample_pct parameter of Model.train method is now None instead of 100.\nIf the default value is used, models will be trained with all of the available training data based on\nproject configuration, rather than with entire dataset including holdout for the previous default value\nof 100.\norder_by parameter of Project.list which was deprecated in v2.0 has been removed.\nrecommendation_settings parameter of Project.start which was deprecated in v0.2 has been removed.\nProject.status method which was deprecated in v0.2 has been removed.\nProject.wait_for_aim_stage method which was deprecated in v0.2 has been removed.\nDelay, ConstantDelay, NoDelay, ExponentialBackoffDelay, RetryManager\nclasses from retry module which were deprecated in v2.1 were removed.\nPackage renamed to datarobot.\nDeprecation summary\u00b6\nProject.update deprecated in favor of specific updates:\nrename, unlock_holdout, set_worker_count.\nDocumentation changes\u00b6\nA new use case involving financial data has been added to the examples directory.\nAdded documentation for the partition methods.\n2.1.31\u00b6\nBugfixes\u00b6\nIn Python 2, using a unicode token to instantiate the client will\nnow work correctly.\n2.1.30\u00b6\nBugfixes\u00b6\nThe minimum required version of trafaret has been upgraded to 0.7.1\nto get around an incompatibility between it and setuptools.\n2.1.29\u00b6\nEnhancements\u00b6\nMinimal used version of requests_toolbelt package changed from 0.4 to 0.6\n2.1.28\u00b6\nNew features\u00b6\nDefault to reading YAML config file from ~/.config/datarobot/drconfig.yaml\nAllow config_path argument to client\nwait_for_autopilot method added to Project. This method can be used to\nblock execution until autopilot has finished running on the project.\nSupport for specifying which featurelist to use with initial autopilot in\nProject.set_target\nProject.get_predict_jobs method has been added, which looks up all prediction jobs for a\nproject\nProject.start_autopilot method has been added, which starts autopilot on\nspecified featurelist\nThe schema for PredictJob in DataRobot API v2.1 now includes a message. This attribute has\nbeen added to the PredictJob class.\nPredictJob.cancel now exists to cancel prediction jobs, mirroring ModelJob.cancel\nProject.from_async is a new classmethod that can be used to wait for an async resolution\nin project creation. Most users will not need to know about it as it is used behind the scenes\nin Project.create and Project.set_target, but power users who may run\ninto periodic connection errors will be able to catch the new ProjectAsyncFailureError\nand decide if they would like to resume waiting for async process to resolve\nEnhancements\u00b6\nAUTOPILOT_MODE enum now uses string names for autopilot modes instead of numbers\nDeprecation summary\u00b6\nConstantDelay, NoDelay, ExponentialBackoffDelay, and RetryManager utils are now deprecated\nINI-style config files are now deprecated (in favor of YAML config files)\nSeveral functions in the utils submodule are now deprecated (they are\nbeing moved elsewhere and are not considered part of the public interface)\nProject.get_jobs has been renamed Project.get_model_jobs for clarity and deprecated\nSupport for the experimental date partitioning has been removed in DataRobot API,\nso it is being removed from the client immediately.\nAPI changes\u00b6\nIn several places where AppPlatformError was being raised, now TypeError, ValueError or\nInputNotUnderstoodError are now used. With this change, one can now safely assume that when\ncatching an AppPlatformError it is because of an unexpected response from the server.\nAppPlatformError has gained a two new attributes, status_code which is the HTTP status code\nof the unexpected response from the server, and error_code which is a DataRobot-defined error\ncode. error_code is not used by any routes in DataRobot API 2.1, but will be in the future.\nIn cases where it is not provided, the instance of AppPlatformError will have the attribute\nerror_code set to None.\nTwo new subclasses of AppPlatformError have been introduced, ClientError (for 400-level\nresponse status codes) and ServerError (for 500-level response status codes). These will make\nit easier to build automated tooling that can recover from periodic connection issues while polling.\nIf a ClientError or ServerError occurs during a call to Project.from_async, then a\nProjectAsyncFailureError (a subclass of AsyncFailureError) will be raised. That exception will\nhave the status_code of the unexpected response from the server, and the location that was being\npolled to wait for the asynchronous process to resolve.\n2.0.27\u00b6\nNew features\u00b6\nPredictJob class was added to work with prediction jobs\nwait_for_async_predictions function added to predict_job module\nDeprecation summary\u00b6\nThe order_by parameter of the Project.list is now deprecated.\n0.2.26\u00b6\nEnhancements\u00b6\nProjet.set_target will re-fetch the project data after it succeeds,\nkeeping the client side in sync with the state of the project on the\nserver\nProject.create_featurelist now throws DuplicateFeaturesError\nexception if passed list of features contains duplicates\nProject.get_models now supports snake_case arguments to its\norder_by keyword\nDeprecation summary\u00b6\nProject.wait_for_aim_stage is now deprecated, as the REST Async\nflow is a more reliable method of determining that project creation has\ncompleted successfully\nProject.status is deprecated in favor of Project.get_status\nrecommendation_settings parameter of Project.start is\ndeprecated in favor of recommender_settings\nBugfixes\u00b6\nProject.wait_for_aim_stage changed to support Python 3\nFixed incorrect value of SCORING_TYPE.cross_validation\nModels returned by Project.get_models will now be correctly\nordered when the order_by keyword is used\n0.2.25\u00b6\nPinned versions of required libraries\n0.2.24\u00b6\nOfficial release of v0.2\n0.1.24\u00b6\nUpdated documentation\nRenamed parameter name of Project.create and Project.start to project_name\nRemoved Model.predict method\nwait_for_async_model_creation function added to modeljob module\nwait_for_async_status_service of Project class renamed to _wait_for_async_status_service\nCan now use auth_token in config file to configure API Client\n0.1.23\u00b6\nFixes a method that pointed to a removed route\n0.1.22\u00b6\nAdded featurelist_id attribute to ModelJob class\n0.1.21\u00b6\nRemoves model attribute from ModelJob class\n0.1.20\u00b6\nProject creation raises AsyncProjectCreationError if it was unsuccessful\nRemoved Model.list_prime_rulesets and Model.get_prime_ruleset methods\nRemoved Model.predict_batch method\nRemoved Project.create_prime_model method\nRemoved PrimeRuleSet model\nAdds backwards compatibility bridge for ModelJob async\nAdds ModelJob.get and ModelJob.get_model\n0.1.19\u00b6\nMinor bugfixes in wait_for_async_status_service\n0.1.18\u00b6\nRemoves submit_model from Project until server-side implementation is improved\nSwitches training URLs for new resource-based route at /projects//models/\nJob renamed to ModelJob, and using modelJobs route\nFixes an inconsistency in argument order for train methods\n0.1.17\u00b6\nwait_for_async_status_service timeout increased from 60s to 600s\n0.1.16\u00b6\nProject.create will now handle both async/sync project creation\n0.1.15\u00b6\nAll routes pluralized to sync with changes in API\nProject.get_jobs will request all jobs when no param specified\ndataframes from predict method will have pythonic names\nProject.get_status created, Project.status now deprecated\nProject.unlock_holdout created.\nAdded quickrun parameter to Project.set_target\nAdded modelCategory to Model schema\nAdd permalinks feature to Project and Model objects.\nProject.create_prime_model created\n0.1.14\u00b6\nProject.set_worker_count fix for compatibility with API change in project update.\n0.1.13\u00b6\nAdd positive class to set_target.\nChange attributes names of Project, Model, Job and Blueprint\n: - features in Model, Job and Blueprint are now processes\n- dataset_id and dataset_name migrated to featurelist_id and featurelist_name.\n- samplepct -> sample_pct\nModel has now blueprint, project, and featurlist attributes.\nMinor bugfixes.\n0.1.12\u00b6\nMinor fixes regarding rename Job attributes. features attributes now named processes, samplepct now is sample_pct.\n0.1.11\u00b6\n(May 27, 2015)\nMinor fixes regarding migrating API from under_score names to camelCase.\n0.1.10\u00b6\n(May 20, 2015)\nRemove Project.upload_file, Project.upload_file_from_url and Project.attach_file methods. Moved all logic that uploading file to Project.create method.\n0.1.9\u00b6\n(May 15, 2015)\nFix uploading file causing a lot of memory usage. Minor bugfixes.\nBack to top",
      "links": [
        "https://docs.datarobot.com/en/docs/api/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/gen-testing.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/gen-llm-generation.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/gen-vector-databases.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/notebooks.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/datarobot-models.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/data-registry.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/client-setup.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/gen-prompting.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/custom-models.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/deployment-management.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/custom-metrics.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/compliance-documentation.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/projects.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/gen-moderation.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/application-templates.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/features.html",
        "https://docs.datarobot.com/",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/mlops_event.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/data-exploration.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/insights.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/data-wrangling.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/binary_data_helpers.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/blueprints.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/data-connectivity.html",
        "https://docs.datarobot.com/en/docs/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/training_predictions.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/batch-predictions.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/challenger-models.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/key_values.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/use-cases.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/jobs.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/batch-monitoring.html",
        "https://docs.datarobot.com/en/docs/api/reference/sdk/applications.html",
        "https://docs.datarobot.com/en/docs/api/reference/public-api/credentials.html",
        "https://blueprint-workshop.datarobot.com"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "VectorDatabase.send_to_custom_model_workshop",
        "LLMBlueprint.register_custom_model",
        "Model.continue_incremental_learning_from_incremental_model",
        "Model.start_incremental_learning_from_sample",
        "datarobot.models.RecipeDatasetInput",
        "datarobot.models.JDBCTableDataSourceInput",
        "datarobot.ExecutionEnvironmentVersion",
        "datarobot.ExecutionEnvironmentVersion",
        "customModelLLMValidationId",
        "customModelLlmValidationId",
        "datarobot.models.RecipeDatasetInput",
        "Deployment.create_from_learning_model <datarobot.models.deployment.Deployment.create_from_learning_model>",
        "RegisteredModelVersion.create_for_leaderboard_item <datarobot.models.model_registry.registered_model_version.RegisteredModelVersion.create_for_leaderboard_item>",
        "Deployment.create_from_registered_model_version <datarobot.models.deployment.Deployment.create_from_registered_model_version>",
        "ComplianceDocTemplateProjectType",
        "Project.create_from_recipe",
        "datarobot.models.Recipe.from_dataset()",
        "datarobot.models.Recipe.from_data_store()",
        "datarobot.models.Recipe.from_dataset()",
        "CustomInferenceModel.share",
        "CustomInferenceModel.get_access_list",
        "Dataset.create_from_project",
        "DataStore <datarobot.models.DataStore",
        "Model.start_incremental_learning_from_sample",
        "NonChatAwareCustomModelValidation",
        "CustomModelVectorDatabaseValidation",
        "CustomModelEmbeddingValidation",
        "CustomModelLLMValidation",
        "CustomModelLLMValidation.create",
        "CustomModelLLMValidation.update",
        "CustomModelVersion.clean_create <datarobot.CustomModelVersion.create_clean>",
        "SidecarModelMetricValidation.list",
        "CustomModelLLMValidation.list",
        "CustomModelEmbeddingValidation.list",
        "CustomModelVectorDatabaseValidation.list",
        "CustomModelLLMValidation.create",
        "Model.request_lift_chart",
        "Model.get_all_lift_charts",
        "Model.request_roc_curve",
        "Model.get_all_roc_curves",
        "Model.request_residuals_chart",
        "Model.get_residuals_chart",
        "Model.get_all_residuals_charts",
        "Model.get_incremental_learning_metadata",
        "Model.start_incremental_learning",
        "Model.request_per_class_fairness_insights",
        "MODEL_COMPLIANCE_GEN_AI",
        "RecipeOperation <datarobot.models.recipe_operation.RecipeOperation>",
        "SidecarModelMetricValidation.create",
        "Capability <datarobot.models.deployment.Capability>",
        "Project.create_from_dataset",
        "LLMBlueprint.register_custom_model",
        "datarobot.enums.CustomTaskOutgoingNetworkPolicy",
        "datarobot.enums.CustomTaskOutboundNetworkPolicy",
        "Model.request_fairness_insights",
        "Model.request_per_class_fairness_insights",
        "Model.get_prime_eligibility",
        "Model.get_supported_capabilities",
        "ShapImpact.row_count <datarobot.insights.ShapImpact.row_count>",
        "datarobot.enums.CustomTaskOutgoingNetworkPolicy",
        "datarobot.enums.CustomTaskOutboundNetworkPolicy",
        "pip install datarobot[images]",
        "datarobot._experimental.models.time_series_wrangling_template.user_flow_template",
        "datarobot._experimental.models.genai",
        "datarobot.models.genai",
        "CustomModelLLMValidation",
        "datarobot.models.deployment.custom_metrics.HostedCustomMetricBlueprint",
        "EvaluationDatasetConfiguration <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration>",
        "EvaluationDatasetConfiguration.get <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.get>",
        "EvaluationDatasetConfiguration.list <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.list>",
        "EvaluationDatasetConfiguration.create <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.create>",
        "EvaluationDatasetConfiguration.update <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.update>",
        "EvaluationDatasetConfiguration.delete <datarobot._experimental.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration.delete>",
        "EvaluationDatasetMetricAggregation <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation>",
        "EvaluationDatasetMetricAggregation.list <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation.list>",
        "EvaluationDatasetMetricAggregation.create <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation.create>",
        "EvaluationDatasetMetricAggregation.delete <datarobot._experimental.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation.delete>",
        "SyntheticEvaluationDataset <datarobot._experimental.models.genai.synthetic_evaluation_dataset_generation.SyntheticEvaluationDataset>",
        "SyntheticEvaluationDataset.create <datarobot._experimental.models.genai.synthetic_evaluation_dataset_generation.SyntheticEvaluationDataset.create>",
        "SidecarModelMetricValidation <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation>",
        "SidecarModelMetricValidation.create <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.create>",
        "SidecarModelMetricValidation.list <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.list>",
        "SidecarModelMetricValidation.get <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.get>",
        "SidecarModelMetricValidation.revalidate <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.revalidate>",
        "SidecarModelMetricValidation.update <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.update>",
        "SidecarModelMetricValidation.delete <datarobot._experimental.models.genai.sidecar_model_metric.SidecarModelMetricValidation.delete>",
        "Project.get_model_records",
        "DataStore <datarobot.models.DataStore>",
        "DataSource <datarobot.models.DataStore>",
        "entity_type=\"customModel\"",
        "datarobot._experimental.models.genai",
        "CustomModelVectorDatabaseValidation",
        "CustomModelLLMValidation",
        "Project.get_model_records",
        "Project.get_model_records",
        "incrementalLearningOnBestModel",
        "DatetimeModel.request_lift_chart",
        "DatetimeModel.get_lift_chart",
        "DatetimeModel.request_roc_curve",
        "DatetimeModel.get_roc_curve",
        "DatetimeModel.request_feature_impact",
        "DatetimeModel.get_feature_impact",
        "DatetimeModel.get_or_request_feature_impact",
        "DatetimeModel.request_feature_effect",
        "DatetimeModel.get_feature_effect",
        "DatetimeModel.get_or_request_feature_effect",
        "Deployment.perform_model_replace",
        "Deployment.replace_model",
        "datarobot.models.Deployment",
        "BatchPredictionJob.score_with_leaderboard_model",
        "datarobot.models.data_slice.DataSlicesOperators",
        "Deployment.get_champion_model_package",
        "datarobot.enums._SHARED_TARGET_TYPE",
        "datarobot.enums.PredictionEnvironmentPlatform",
        "datarobot.enums.PredictionEnvironmentHealthType",
        "datarobot.enums.TARGET_TYPE",
        "datarobot.enums.CUSTOM_MODEL_TARGET_TYPE",
        "datarobot.CustomModel",
        "CustomModelVersion.create_clean",
        "CustomModelVersion.create_from_previous",
        "PromptTrace <datarobot._experimental.models.genai.prompt_trace.PromptTrace>",
        "PromptTrace.list <datarobot._experimental.models.genai.prompt_trace.PromptTrace.list>",
        "PromptTrace.export_to_ai_catalog <datarobot._experimental.models.genai.prompt_trace.PromptTrace.export_to_ai_catalog>",
        "InsightsConfiguration <datarobot._experimental.models.genai.insights_configuration.InsightsConfiguration>",
        "InsightsConfiguration.list <datarobot._experimental.models.genai.insights_configuration.InsightsConfiguration.list>",
        "Insights <datarobot._experimental.models.genai.insights_configuration.Insights>",
        "Insights.get <datarobot._experimental.models.genai.insights_configuration.Insights.get>",
        "Insights.create <datarobot._experimental.models.genai.insights_configuration.Insights.create>",
        "CostMetricConfiguration <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration>",
        "CostMetricConfiguration.get <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.get>",
        "CostMetricConfiguration.create <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.create>",
        "CostMetricConfiguration.update <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.update>",
        "CostMetricConfiguration.delete <datarobot._experimental.models.genai.cost_metric_configurations.CostMetricConfiguration.delete>",
        "LLMCostConfiguration <datarobot._experimental.models.genai.cost_metric_configurations.LLMCostConfiguration>",
        "~/.config/datarobot/drconfig.yaml",
        "DATAROBOT_API_CONSUMER_TRACKING_ENABLED",
        "DataStore <datarobot.models.DataStore>",
        "DataSource <datarobot.models.DataStore>",
        "DataDriver <datarobot.models.DataDriver>.",
        "datarobot.models.DatetimeModel",
        "datarobot.models.Model",
        "DataStore <datarobot.models.DataStore>",
        "Deployment.validate_replacement_model",
        "new_registered_model_version_id",
        "Connector <datarobot.models.Connector>",
        "Model.get_leaderboard_ui_permalink",
        "Model.open_model_browser",
        "Project.get_model_records",
        "Deployment.validate_replacement_model",
        "Deployment.replace_model",
        "Deployment.perform_model_replace",
        "CustomInferenceModel.assign_training_data",
        "CustomModelVersion.create_clean",
        "CustomModelVersion.create_from_previous",
        "CustomModelValidation",
        "ResultMetadata <datarobot._experimental.models.genai.chat_prompt.ResultMetadata>",
        "CustomModelValidation",
        "custom_model_embedding_validations",
        "SupportedEmbeddings <datarobot._experimental.models.genai.vector_database.SupportedEmbeddings>",
        "VectorDatabase <datarobot._experimental.models.genai.vector_database.VectorDatabase>",
        "CustomModelValidation.create",
        "CustomModelValidation.list",
        "CustomModelValidation.update",
        "ComparisonPrompt.update <datarobot._experimental.models.genai.comparison_prompt.ComparisonPrompt.update>",
        "ChatPrompt.update <datarobot._experimental.models.genai.chat_prompt.ChatPrompt.update>",
        "RegisteredModelVersion",
        "Model.get_incremental_learning_metadata",
        "Model.start_incremental_learning",
        "Model.get_or_request_feature_impact",
        "RegisteredModel.archive",
        "RegisteredModel.update",
        "RegisteredModel.get_shared_roles",
        "RegisteredModel.share",
        "RegisteredModel.get_version",
        "RegisteredModel.list_versions",
        "RegisteredModel.list_associated_deployments",
        "RegisteredModelVersion",
        "RegisteredModelVersion.create_for_external",
        "RegisteredModelVersion.list_associated_deployments",
        "RegisteredModelVersion.create_for_leaderboard_item",
        "RegisteredModelVersion.create_for_custom_model_version",
        "Deployment.create_from_registered_model_version",
        "Deployment.download_model_package_file",
        "datarobot.enums.CustomTaskOutgoingNetworkPolicy",
        "BatchPredictionJob.score_with_leaderboard_model",
        "Deployment.get_predictions_vs_actuals_over_time <datarobot.models.Deployment.get_predictions_vs_actuals_over_time>",
        "Model.request_feature_effect",
        "Project.advanced_options",
        "Project.advanced_options",
        "Project.advanced_options",
        "CustomModelVectorDatabaseValidation",
        "CustomModelVectorDatabaseValidation.get",
        "CustomModelVectorDatabaseValidation.get_by_values",
        "CustomModelVectorDatabaseValidation.create",
        "CustomModelVectorDatabaseValidation.revalidate",
        "CustomModelLLMValidation",
        "CustomModelLLMValidation.get",
        "CustomModelLLMValidation.get_by_values",
        "CustomModelLLMValidation.create",
        "CustomModelLLMValidation.revalidate",
        "CustomModelLLMValidation.delete",
        "LLMBlueprint.register_custom_model",
        "Project.analyze_and_model",
        "Dataset.create_project",
        "Project.create_from_data_source",
        "Project.create_from_dataset",
        "Project.create_segmented_project_from_clustering_model",
        "DATAROBOT_DEFAULT_USE_CASE",
        "DATAROBOT_API_CONSUMER_TRACKING_ENABLED",
        "Deployment.get_predictions_over_time <datarobot.models.Deployment.get_predictions_over_time>",
        "Project.analyze_and_model",
        "Model.get_model_blueprint_json",
        "Model.get_feature_effect",
        "Model.request_feature_effect",
        "Model.get_or_request_feature_effect",
        "Model.get_all_lift_charts",
        "Model.get_residuals_chart",
        "Model.get_all_residuals_charts",
        "Model.request_lift_chart",
        "Model.request_residuals_chart",
        "Model.get_feature_impact",
        "Model.request_feature_impact",
        "Model.get_or_request_feature_impact",
        "Model.request_roc_curve",
        "Model.get_all_feature_impacts",
        "datarobot.models.StatusCheckJob.get_result_when_complete()",
        "datarobot.PredictionExplanations.get_all_as_dataframe()",
        "datarobot.PredictionExplanations.get_rows()",
        "Project.upload_dataset_from_catalog",
        "CustomModelVersion.create_clean",
        "CustomModelVersion.create_from_previous",
        "CustomInferenceModel.create",
        "CustomInferenceModel.update",
        "datarobot.client.Client()",
        "GET: api/v2/projects/<pid>/models/<lid>/<insight_name>/",
        "Model.get_feature_fit_metadata",
        "Model.get_feature_effect_metadata",
        "DatetimeModel.get_feature_fit_metadata",
        "DatetimeModel.get_feature_effect_metadata",
        "Model.request_feature_fit",
        "Model.request_feature_effect",
        "DatetimeModel.request_feature_fit",
        "DatetimeModel.request_feature_effect",
        "Model.get_feature_fit",
        "Model.get_feature_effect",
        "DatetimeModel.get_feature_fit",
        "DatetimeModel.get_feature_effect",
        "Model.get_or_request_feature_fit",
        "Model.get_or_request_feature_effect",
        "DatetimeModel.get_or_request_feature_fit",
        "DatetimeModel.get_or_request_feature_effect",
        "CustomInferenceModel.assign_training_data",
        "CustomModelVersion.create_clean",
        "CustomModelVersion.create_from_previous",
        "DataRobotClientConfig",
        "DataMatching.get_closest_data_for_model",
        "DataMatching.get_closest_data_for_model",
        "Project.create_from_dataset",
        "Project.create_segmented_project_from_clustering_model",
        "Project.create_from_hdfs",
        "datarobot.models.DatetimeModel",
        "Model.get_leaderboard_ui_permalink",
        "Model.open_model_browser",
        "Model.get_leaderboard_ui_permalink",
        "Model.open_model_browser",
        "Model.open_in_browser",
        "project.start_autopilot",
        "DatetimeModel.get_feature_impact",
        "DatetimeModel.request_feature_impact",
        "DatetimeModel.get_or_request_feature_impact",
        "Model.get_or_request_feature_impact",
        "Project.open_in_browser",
        "Model.open_in_browser",
        "datarobot.rest.RESTClientObject.open_in_browser()",
        "dr.Client().open_in_browser()",
        "Project.create_featurelist",
        "Project.get_featurelist_by_name",
        "Model.request_predictions",
        "datarobot.models.Dataset",
        "datarobot.models.Dataset",
        "datarobot.models.Project",
        "Project.analyze_and_model",
        "Project.set_partitioning_method",
        "Project.set_datetime_partitioning",
        "datarobot.models.Project",
        "Project.get_top_model",
        "datarobot.models.Deployment",
        "Project.create_from_data_source",
        "datarobot.models.Project",
        "datarobot.models.Project",
        "datarobot.models.Project",
        "Project.analyze_and_model",
        "datarobot.models.Project",
        "datarobot.models.Project",
        "datarobot.client.Client()",
        "datarobot.models.Project.create_modeling_featurelist()",
        "datarobot.models.Model.get_advanced_tuning_parameters()",
        "Project.analyze_and_model",
        "datarobot.helpers.partitioning_methods.get_class",
        "Project.upload_dataset_from_catalog",
        "DataRobotProjectDeprecationWarning",
        "Model.get_leaderboard_ui_permalink",
        "Model.open_model_browser",
        "Model.open_in_browser",
        "Project.get_leaderboard_ui_permalink",
        "Project.open_leaderboard_browser",
        "Project.open_in_browser",
        "create_from_custom_model_image",
        "Deployment.create_from_custom_model_version",
        "Model.request_predictions",
        "Model.fetch_resource_data",
        "Project.analyze_and_model",
        "pip install datarobot[images]",
        "datarobot.CalendarFile.create_calendar_from_dataset()",
        "DatetimeModel.retrain",
        "datarobot.CombinedModel.set_segment_champion()",
        "is_active_combined_model",
        "datarobot.CombinedModel",
        "datarobot.models.Project.get_active_combined_model()",
        "Project.get_bias_mitigated_models",
        "Project.apply_bias_mitigation",
        "Project.request_bias_mitigation_feature_info",
        "Project.get_bias_mitigation_feature_info",
        "datarobot.enums.BiasMitigationTechnique",
        "datarobot.models.Deployment",
        "datarobot.DatetimePartitioningSpecification",
        "datarobot.models.Project.get_multiseries_names()",
        "datarobot.models.Project.set_target()",
        "datarobot.models.Project",
        "datarobot.models.Project.restart_segment()",
        "datarobot.CombinedModel",
        "datarobot.CombinedModel.get()",
        "datarobot.CombinedModel.get_segments_info()",
        "datarobot.CombinedModel.get_segments_as_dataframe()",
        "datarobot.CombinedModel.get_segments_as_csv()",
        "datarobot.CombinedModel.set_segment_champion()",
        "datarobot.SegmentationTask",
        "datarobot.SegmentationTask.create()",
        "datarobot.SegmentationTask.list()",
        "datarobot.SegmentationTask.get()",
        "datarobot.SegmentInfo",
        "datarobot.SegmentInfo.list()",
        "datarobot.PredictionExplanations",
        "datarobot.PredictionExplanations",
        "datarobot.models.ShapImpact",
        "Project.upload_dataset_from_catalog",
        "Project.upload_dataset_from_data_source",
        "datarobot.models.BatchPredictionJobDefinition.create()",
        "Model.get_feature_effect",
        "Model.get_feature_fit <datarobot.models.Model.get_feature_fit>",
        "DatetimeModel.get_feature_effect",
        "DatetimeModel.get_feature_fit <datarobot.models.DatetimeModel.get_feature_fit>",
        "scaleout_modeling_mode",
        "datarobot.UserBlueprint",
        "datarobot.CustomTaskVersion",
        "Project.download_multicategorical_data_format_errors",
        "datarobot.CustomTask.get_access_list()",
        "datarobot.CustomTask.share()",
        "datarobot.models.Dataset.create_from_query_generator()",
        "datarobot.DataEngineQueryGenerator",
        "datarobot.UserBlueprint.create_from_custom_task_version_id()",
        "datarobot.DataEngineQueryGenerator",
        "datarobot.DataEngineQueryGenerator.create()",
        "datarobot.DataEngineQueryGenerator.get()",
        "datarobot.DataEngineQueryGenerator.create_dataset()",
        "Project.upload_dataset_from_catalog",
        "datarobot.models.restore_discarded_features.DiscardedFeaturesInfo",
        "datarobot.models.restore_discarded_features.DiscardedFeaturesInfo.retrieve()",
        "datarobot.models.restore_discarded_features.DiscardedFeaturesInfo.restore()",
        "unsupervised clustering projects<unsupervised_clustering>",
        "datarobot.models.Model.request_feature_effects_multiclass()",
        "datarobot.models.Model.get_feature_effects_multiclass()",
        "datarobot.models.Model.get_or_request_feature_effects_multiclass()",
        "datarobot.models.DatetimeModel.request_feature_effects_multiclass()",
        "datarobot.models.DatetimeModel.get_feature_effects_multiclass()",
        "datarobot.models.DatetimeModel.get_or_request_feature_effects_multiclass()",
        "datarobot.models.Deployment",
        "datarobot.models.Deployment.get_challenger_models_settings()",
        "datarobot.models.Deployment.update_challenger_models_settings()",
        "datarobot.models.Deployment",
        "datarobot.models.Deployment.get_segment_analysis_settings()",
        "datarobot.models.Deployment.update_segment_analysis_settings()",
        "datarobot.models.Deployment",
        "datarobot.models.Deployment.get_predictions_by_forecast_date_settings()",
        "datarobot.models.Deployment.update_predictions_by_forecast_date_settings()",
        "CustomModelVersionConversion",
        "CustomModelVersionConversion.run_conversion",
        "CustomModelVersionConversion.stop_conversion",
        "CustomModelVersionConversion.get",
        "CustomModelVersionConversion.get_latest",
        "CustomModelVersionConversion.list",
        "datarobot.CustomTaskVersion",
        "datarobot.CustomModelVersion",
        "datarobot.models.Dataset",
        "Model.get_all_labelwise_roc_curves",
        "Model.get_labelwise_roc_curves",
        "Model.get_all_multilabel_lift_charts",
        "Model.get_multilabel_lift_charts",
        "datarobot.models.Project.validate_external_time_series_baseline()",
        "Project.start_prepare_model_for_deployment",
        "datarobot.CustomTaskVersion",
        "datarobot.CustomTask.create()",
        "datarobot.CustomTask.copy()",
        "datarobot.CustomTask.update()",
        "datarobot.CustomTask.delete()",
        "datarobot.CustomTask.get()",
        "datarobot.CustomTask.list()",
        "datarobot.CustomTask.refresh()",
        "datarobot.CustomTaskVersion",
        "datarobot.CustomTask.download_latest_version()",
        "datarobot.CustomTaskVersion",
        "datarobot.CustomTaskVersion.create_clean()",
        "datarobot.CustomTaskVersion.create_from_previous()",
        "datarobot.CustomTaskVersion.list()",
        "datarobot.CustomTaskVersion.get()",
        "datarobot.CustomTaskVersion.refresh()",
        "datarobot.CustomTaskVersion.download()",
        "datarobot.CustomTaskVersion.update()",
        "ModelRecommendation.get_model",
        "Model.get_or_request_feature_impact",
        "datarobot.ExecutionEnvironment",
        "datarobot.ExecutionEnvironment",
        "datarobot.CustomTaskVersion",
        "project.start_autopilot",
        "datarobot.CustomModelVersion",
        "datarobot.CustomTaskVersion",
        "DatetimeModel.initialize_anomaly_assessment",
        "DatetimeModel.get_anomaly_assessment_records",
        "DatetimeModel.compute_datetime_trend_plots",
        "DatetimeModel.get_accuracy_over_time_plots_metadata",
        "DatetimeModel.get_forecast_vs_actual_plots_metadata",
        "DatetimeModel.get_anomaly_over_time_plots_metadata",
        "DatetimeModel.get_accuracy_over_time_plot",
        "DatetimeModel.get_forecast_vs_actual_plot",
        "DatetimeModel.get_anomaly_over_time_plot",
        "DatetimeModel.get_accuracy_over_time_plot_preview",
        "DatetimeModel.get_forecast_vs_actual_plot_preview",
        "DatetimeModel.get_anomaly_over_time_plot_preview",
        "Project.recommended_model",
        "Project.download_feature_discovery_recipe_sqls",
        "datarobot.ExecutionEnvironmentVersion",
        "Model.request_frozen_datetime_model",
        "datarobot.ExecutionEnvironment",
        "datarobot.CustomModelVersion",
        "datarobot.CustomModelVersion",
        "datarobot.DatetimePartitioningSpecification",
        "Model.get_multilabel_lift_charts",
        "Model.get_all_multilabel_lift_charts",
        "Model.get_labelwise_roc_curves",
        "Model.get_all_labelwise_roc_curves",
        "datarobot.CustomModelVersion",
        "Project.download_feature_discovery_dataset",
        "datarobot.models.FeatureAssociationMatrix",
        "datarobot.models.FeatureAssociationMatrixDetails",
        "datarobot.models.FeatureAssociationFeaturelists",
        "Project.get_associations",
        "Project.get_association_matrix_details",
        "Project.get_association_featurelists",
        "datarobot.CustomInferenceModel",
        "datarobot.CustomModelVersion",
        "datarobot.CustomModelTest",
        "CustomInferenceModel.create",
        "CustomModelVersion.create_clean",
        "CustomModelVersion.create_from_previous",
        "CustomModelTest.create",
        "CustomModelTest.create",
        "Project.upload_dataset",
        "datarobot.CustomInferenceModel",
        "datarobot.CustomModelVersion",
        "datarobot.CustomModelTest",
        "datarobot.CustomInferenceModel",
        "datarobot.TARGET_TYPE.MULTICLASS",
        "datarobot.CustomInferenceModel",
        "datarobot.TARGET_TYPE.UNSTRUCTURED",
        "Model.get_multiclass_lift_chart",
        "datarobot.CustomInferenceModel",
        "datarobot.TARGET_TYPE.ANOMALY",
        "datarobot.CustomModelVersion",
        "datarobot.models.Feature",
        "Dataset.create_project",
        "Project.create_from_dataset",
        "Project.upload_dataset",
        "Project.upload_dataset_from_data_source",
        "datarobot.DatetimePartitioning",
        "Project.train_datetime",
        "datarobot.CustomInferenceModel",
        "datarobot.models.SecondaryDatasetConfigurations",
        "datarobot.models.RelationshipsConfiguration",
        "datarobot.CustomInferenceModel",
        "datarobot.models.SecondaryDatasetConfigurations",
        "datarobot.CustomModelVersion",
        "CustomModelTest.create",
        "datarobot.models.Feature",
        "datarobot.models.FeatureLineage",
        "custom model documentation<custom_models>",
        "CustomModelVersion.create_clean",
        "CustomModelVersion.create_from_previous",
        "datarobot.CustomModelVersion",
        "datarobot.CustomModelVersionDependencyBuild",
        "CustomModelTest.create",
        "datarobot.CustomModelTest",
        "Deployment.create_from_custom_model_version",
        "Project.start_autopilot",
        "Model.get_num_iterations_trained",
        "Project.set_project_description",
        "datarobot.models.deployment.TargetDrift",
        "datarobot.models.deployment.FeatureDrift",
        "Deployment.replace_model",
        "customModel[\"latestVersion\"]",
        "Project.get_datetime_models",
        "models documentation <models>",
        "Model.request_training_predictions",
        "Model.request_predictions",
        "Model.request_feature_effect",
        "Model.get_or_request_feature_effect",
        "Project.create_interaction_feature",
        "models.InteractionFeature.",
        "models.InteractionFeature.get",
        "unsupervised projects<unsupervised_anomaly>",
        "Project.upload_dataset",
        "Model.request_predictions",
        "datarobot.models.PredictionDataset",
        "datarobot.models.deployment.TargetDrift",
        "datarobot.models.deployment.FeatureDrift",
        "Deployment.create_from_custom_model_image",
        "Model.request_feature_impact",
        "Model.get_or_request_feature_impact",
        "custom model documentation<custom_models>",
        "datarobot.ExecutionEnvironment",
        "datarobot.ExecutionEnvironmentVersion",
        "datarobot.CustomInferenceModel",
        "datarobot.CustomModelVersion",
        "datarobot.CustomModelTest",
        "Dataset.create_project",
        "Model.get_feature_impact",
        "Model.request_feature_impact",
        "Model.get_or_request_feature_impact",
        "Project.get_relationships_configuration",
        "datarobot.enums.VARIABLE_TYPE_TRANSFORM.CATEGORICAL",
        "Project.batch_features_type_transform",
        "Project.create_type_transform_feature",
        "Project.create_from_dataset",
        "Model.get_multiclass_lift_chart",
        "datarobot.DatetimePartitioningSpecification",
        "Model.get_frozen_child_models",
        "datarobot.enums.TS_BLENDER_METHOD",
        "Project.get_association_featurelists",
        "Project.clone_project",
        "Model.request_transferable_export <datarobot.models.Model.request_transferable_export>",
        "Model.get_multiclass_feature_impact",
        "Project.get_association_featurelists",
        "Project.get_associations",
        "Project.upload_dataset",
        "Project.upload_dataset_from_data_source",
        "DatetimeModel.get_series_accuracy_as_dataframe",
        "DatetimeModel.download_series_accuracy_as_csv",
        "datarobot.enums.BLENDER_METHOD.FORECAST_DISTANCE",
        "datarobot.enums.BLENDER_METHOD",
        "Project.train_datetime",
        "Model.get_supported_capabilities",
        "Project.upload_dataset",
        "datarobot.enums.BLENDER_METHOD.FORECAST_DISTANCE",
        "Project.batch_features_type_transform",
        "Project.get_associations",
        "Project.get_association_matrix_details",
        "datarobot.DatetimePartitioning",
        "datarobot.DatetimePartitioning",
        "DatetimeModel.compute_series_accuracy",
        "DatetimeModel.get_series_accuracy_as_dataframe",
        "DatetimeModel.download_series_accuracy_as_csv",
        "time series projects <time_series>",
        "Model.start_advanced_tuning_session",
        "Model.get_advanced_tuning_parameters",
        "datarobot.PredictionExplanations.get_all_as_dataframe()",
        "Project.upload_dataset",
        "Project.upload_dataset_from_data_source",
        "Project.upload_dataset",
        "Project.upload_dataset_from_data_source",
        "datarobot.DatetimePartitioning",
        "datarobot.models.Project",
        "datarobot.models.Project.create_from_data_source()",
        "datarobot.FeatureSettings",
        "datarobot.FeatureSettings.known_in_advance",
        "datarobot.DatetimePartitioning",
        "datarobot.DatetimePartitioning.known_in_advance",
        "datarobot.DatetimePartitioningSpecification",
        "datarobot.DatetimePartitioningSpecification.known_in_advance",
        "Model.get_supported_capabilities",
        "datarobot.DatetimePartitioningSpecification",
        "Project.upload_dataset",
        "Model.get_all_lift_charts",
        "Model.get_confusion_chart",
        "Model.get_all_confusion_charts",
        "Model.get_all_roc_curves",
        "datarobot.DatetimePartitioning",
        "Project.set_worker_count",
        "Recommended Models API <recommended_models>",
        "dr.enums.DATA_SUBSET.ALL_BACKTESTS",
        "Model.get_or_request_feature_impact",
        "Model.start_advanced_tuning_session",
        "Model.get_advanced_tuning_parameters",
        "Model.set_prediction_threshold",
        "Project.check_blendable",
        "Model.get_cross_validation_scores",
        "ModelingFeaturelist.update",
        "ModelingFeaturelist.delete",
        "ModelRecommendation.get",
        "datarobot.enums.RECOMMENDED_MODEL_TYPE",
        "Time Series Projects <time_series>",
        "datarobot.DatetimePartitioning.feature_log_list()",
        "datarobot.DatetimePartitioning.feature_log_retrieve()",
        "Project.upload_dataset",
        "datarobot.models.Project",
        "datarobot.models.Project.create_from_data_source()",
        "datarobot.FeatureSettings",
        "datarobot.FeatureSettings.known_in_advance",
        "datarobot.DatetimePartitioning",
        "datarobot.DatetimePartitioning.known_in_advance",
        "datarobot.DatetimePartitioningSpecification",
        "datarobot.DatetimePartitioningSpecification.known_in_advance",
        "Model.request_frozen_model",
        "datarobot.DatetimePartitioningSpecification",
        "scaleout_modeling_mode",
        "model blueprint chart<model_blueprint_chart>",
        "model blueprint docs<model_blueprint_doc>",
        "Model.get_all_lift_charts",
        "Model.get_all_roc_curves",
        "the documentation<datetime_modeling_workflow>",
        "Project.create_type_transform_feature",
        "Project.advanced_options",
        "Model.request_frozen_model",
        "Project.get_frozen_models",
        "Model.request_predictions",
        "Project.upload_dataset",
        "Model.request_predictions",
        "Project.create_type_transform_feature",
        "datarobot.async.wait_for_async_resolution",
        "Project.wait_for_autopilot",
        "Project.get_model_jobs",
        "Model.request_predictions",
        "warnings.filterwarnings('ignore', category=DataRobotDeprecationWarning)",
        "Project.wait_for_aim_stage",
        "~/.config/datarobot/drconfig.yaml",
        "Project.get_predict_jobs",
        "Project.start_autopilot",
        "Project.get_model_jobs",
        "ProjectAsyncFailureError",
        "Project.create_featurelist",
        "Project.wait_for_aim_stage",
        "Project.wait_for_aim_stage",
        "wait_for_async_model_creation",
        "AsyncProjectCreationError",
        "Model.list_prime_rulesets",
        "Model.get_prime_ruleset",
        "Project.create_prime_model",
        "Project.unlock_holdout",
        "Project.create_prime_model",
        "Project.set_worker_count",
        "Project.upload_file_from_url"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/applications.html",
      "title": "Applications\uf0c1",
      "description": "",
      "content": "Applications\uf0c1\nclass datarobot.Application\uf0c1\nAn entity associated with a DataRobot Application.\nVariables:\nid (str) \u2013 The ID of the created application.\napplication_type_id (str) \u2013 The ID of the type of the application.\nuser_id (str) \u2013 The ID of the user which created the application.\nmodel_deployment_id (str) \u2013 The ID of the associated model deployment.\ndeactivation_status_id (str or None) \u2013 The ID of the status object to track the asynchronous app deactivation process status.\nWill be None if the app was never deactivated.\nname (str) \u2013 The name of the application.\ncreated_by (str) \u2013 The username of the user created the application.\ncreated_at (str) \u2013 The timestamp when the application was created.\nupdated_at (str) \u2013 The timestamp when the application was updated.\ndatasets (List[str]) \u2013 The list of datasets IDs associated with the application.\ncreator_first_name (Optional[str]) \u2013 Application creator first name. Optional.\ncreator_last_name (Optional[str]) \u2013 Application creator last name. Optional.\ncreator_userhash (Optional[str]) \u2013 Application creator userhash. Optional.\ndeployment_status_id (str) \u2013 The ID of the status object to track the asynchronous deployment process status.\ndescription (str) \u2013 A description of the application.\ncloud_provider (str) \u2013 The host of this application.\ndeployments (Optional[List[ApplicationDeployment]]) \u2013 A list of deployment details. Optional.\ndeployment_ids (List[str]) \u2013 A list of deployment IDs for this app.\ndeployment_name (Optional[str]) \u2013 Name of the deployment. Optional.\napplication_template_type (Optional[str]) \u2013 Application template type, purpose. Optional.\npool_used (bool) \u2013 Whether the pool where used for last app deployment.\npermissions (List[str]) \u2013 The list of permitted actions, which the authenticated user can perform on this application.\nPermissions should be ApplicationPermission options.\nhas_custom_logo (bool) \u2013 Whether the app has a custom logo.\nrelated_entities (Optional[ApplcationRelatedEntity]) \u2013 IDs of entities, related to app for easy search.\norg_id (str) \u2013 ID of the app\u2019s organization.\nclassmethod list(offset=None, limit=None, use_cases=None)\uf0c1\nRetrieve a list of user applications.\nParameters:\noffset (Optional[int]) \u2013 Optional. Retrieve applications in a list after this number.\nlimit (Optional[int]) \u2013 Optional. Retrieve only this number of applications.\nuse_cases (Optional[Union[UseCase, List[UseCase], str, List[str]]]) \u2013 Optional. Filter available Applications by a specific Use Case or Use Cases.\nAccepts either the entity or the ID.\nIf set to [None], the method filters the application\u2019s datasets by those not linked to a UseCase.\nReturns:\napplications \u2013 The requested list of user applications.\nReturn type:\nList[Application]\nclassmethod get(application_id)\uf0c1\nRetrieve a single application.\nParameters:\napplication_id (str) \u2013 The ID of the application to retrieve.\nReturns:\napplication \u2013 The requested application.\nReturn type:\nApplication",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/api-object.html",
      "title": "APIObject\uf0c1",
      "description": "",
      "content": "APIObject\uf0c1\nclass datarobot.models.api_object.APIObject\uf0c1\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/application-templates.html",
      "title": "Custom templates\uf0c1",
      "description": "Template for custom activity (e.g. custom-metrics, applications).",
      "content": "Custom templates\uf0c1\nclass datarobot.models.custom_templates.CustomTemplate\uf0c1\nTemplate for custom activity (e.g. custom-metrics, applications).\nclassmethod list(search=None, order_by=None, tag=None, template_type=None, template_sub_type=None, offset=None, limit=None)\uf0c1\nList all custom templates.\nAdded in version v3.7.\nParameters:\nsearch (Optional[str]) \u2013 Search string.\norder_by (Optional[ListCustomTemplatesSortQueryParams]) \u2013 Ordering field.\ntag (Optional[str]) \u2013 Tag associated with the template.\ntemplate_type (Optional[str]) \u2013 Type of the template.\ntemplate_type \u2013 Sub-type of the template.\noffset (Optional[int]) \u2013 Offset for pagination.\nlimit (Optional[int]) \u2013 Limit for pagination.\nReturns:\ntemplates\nReturn type:\nList[CustomTemplate]\nclassmethod get(template_id)\uf0c1\nGet a custom template by ID.\nAdded in version v3.7.\nParameters:\ntemplate_id (str) \u2013 ID of the template.\nReturns:\ntemplate\nReturn type:\nCustomTemplate\nupdate(name=None, description=None, default_resource_bundle_id=None, template_type=None, template_sub_type=None, template_metadata=None, default_environment=None)\uf0c1\nUpdate the custom template.\nAdded in version v3.7.\nParameters:\nname (Optional[str]) \u2013 The template name.\ndescription (Optional[str]) \u2013 A description of the template.\ndefault_resource_bundle_id (Optional[str]) \u2013 The default resource bundle ID.\ntemplate_type (Optional[str]) \u2013 The template type.\ntemplate_sub_type (Optional[str]) \u2013 The template sub-type.\ntemplate_metadata (Optional[TemplateMetadata|str]) \u2013 The metadata associated with the template, provided as TemplateMetadata or a JSON encoded string.\ndefault_environment (Optional[DefaultEnvironment|str]) \u2013 The default environment associated with the template, provided as DefaultEnvironment or a JSON encoded\nstring.\nReturn type:\nNone\nExamples\nfrom datarobot import CustomTemplate\nfrom datarobot.models.custom_templates import DefaultEnvironment\nnew_env = DefaultEnvironment(\nenvironment_id='679d47c8ce1ecd17326f3fdf',\nenvironment_version_id='679d47c8ce1ecd17326f3fe3',\n)\ntemplate = CustomTemplate.get(template_id='5c939e08962d741e34f609f0')\ntemplate.update(default_environment=new_env, description='Updated template with environment v17')\ndelete()\uf0c1\nDelete this custom template.\nAdded in version v3.7.\nReturn type:\nNone\nclass datarobot.models.custom_templates.DefaultEnvironment\uf0c1\nDefault execution environment.\nclass datarobot.models.custom_templates.CustomMetricMetadata\uf0c1\nMetadata for custom metrics.\nclass datarobot.models.custom_templates.TemplateMetadata\uf0c1\nMetadata for the custom templates.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot import CustomTemplate\nfrom datarobot.models.custom_templates import DefaultEnvironment\nnew_env = DefaultEnvironment(\n    environment_id='679d47c8ce1ecd17326f3fdf',\n    environment_version_id='679d47c8ce1ecd17326f3fe3',\n)\ntemplate = CustomTemplate.get(template_id='5c939e08962d741e34f609f0')\ntemplate.update(default_environment=new_env, description='Updated template with environment v17')"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/binary_data_helpers.html",
      "title": "Binary data helpers\uf0c1",
      "description": "Returns base64 encoded string of images located in addresses passed in input collection.\nInput collection should hold data of valid image url addresses reachable from\nlocation where code is being executed. Method will retrieve image, apply specified\nreformatting before converting contents to base64 string. Results will in same\norder as specified in input collection.",
      "content": "Binary data helpers\uf0c1\ndatarobot.helpers.binary_data_utils.get_encoded_image_contents_from_urls(urls, custom_headers=None, image_options=None, continue_on_error=False, n_threads=None)\uf0c1\nReturns base64 encoded string of images located in addresses passed in input collection.\nInput collection should hold data of valid image url addresses reachable from\nlocation where code is being executed. Method will retrieve image, apply specified\nreformatting before converting contents to base64 string. Results will in same\norder as specified in input collection.\nParameters:\nurls (Iterable) \u2013 Iterable with url addresses to download images from\ncustom_headers (dict) \u2013 Dictionary containing custom headers to use when downloading files using a URL. Detailed\ndata related to supported Headers in HTTP  can be found in the RFC specification for\nheaders: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\nWhen used, specified passed values will overwrite default header values.\nimage_options (ImageOptions class) \u2013 Class holding parameters for use in image transformation and formatting.\ncontinue_on_error (bool) \u2013 If one of rows encounters error while retrieving content (i.e. file does not exist) should\nthis error terminate process of downloading consecutive files or should process continue\nskipping this file.\nn_threads (int or None) \u2013 Number of threads to use for processing. If \u201cNone\u201d is passed, the number of threads is\ndetermined automatically based on the number of available CPU cores. If this is not\npossible, 4 threads are used.\nRaises:\nContentRetrievalTerminatedError: \u2013 The error is raised when the flag continue_on_error is set to` False` and processing has\nbeen terminated due to an exception while loading the contents of the file.\nReturn type:\nList of base64 encoded strings representing reformatted images.\ndatarobot.helpers.binary_data_utils.get_encoded_image_contents_from_paths(paths, image_options=None, continue_on_error=False, n_threads=None, base_path=None)\uf0c1\nReturns base64 encoded string of images located in paths passed in input collection.\nInput collection should hold data of valid image paths reachable from location\nwhere code is being executed. Method will retrieve image, apply specified\nreformatting before converting contents to base64 string. Results will in same\norder as specified in input collection.\nParameters:\npaths (Iterable) \u2013 Iterable with path locations to open images from\nimage_options (ImageOptions class) \u2013 Class holding parameters for image transformation and formatting\ncontinue_on_error (bool) \u2013 If one of rows encounters error while retrieving content (i.e. file does not exist) should\nthis error terminate process of downloading consecutive files or should process continue\nskipping this file.\nn_threads (int or None) \u2013 Number of threads to use for processing. If \u201cNone\u201d is passed, the number of threads is\ndetermined automatically based on the number of available CPU cores. If this is not\npossible, 4 threads are used.\nbase_path (Optional[str]) \u2013 Base path to use when opening files. If specified, this path will be used as a base\ndirectory against which all relative paths will be evaluated. If not specified, the path\nwill be evaluated against the directory where this script is running.\nRaises:\nContentRetrievalTerminatedError: \u2013 The error is raised when the flag continue_on_error is set to` False` and processing has\nbeen terminated due to an exception while loading the contents of the file.\nReturn type:\nList of base64 encoded strings representing reformatted images.\ndatarobot.helpers.binary_data_utils.get_encoded_file_contents_from_paths(paths, continue_on_error=False, n_threads=None, base_path=None)\uf0c1\nReturns base64 encoded string for files located under paths passed in input collection.\nInput collection should hold data of valid file paths locations reachable from\nlocation where code is being executed. Method will retrieve file and convert its contents\nto base64 string. Results will be returned in same order as specified in input collection.\nParameters:\npaths (Iterable) \u2013 Iterable with path locations to open images from\ncontinue_on_error (bool) \u2013 If one of rows encounters error while retrieving content (i.e. file does not exist) should\nthis error terminate process of downloading consecutive files or should process continue\nskipping this file.\nn_threads (int or None) \u2013 Number of threads to use for processing. If \u201cNone\u201d is passed, the number of threads is\ndetermined automatically based on the number of available CPU cores. If this is not\npossible, 4 threads are used.\nbase_path (Optional[str]) \u2013 Base path to use when opening files. If specified, this path will be used as a base\ndirectory against which all relative paths will be evaluated. If not specified, the path\nwill be evaluated against the directory where this script is running.\nRaises:\nContentRetrievalTerminatedError: \u2013 The error is raised when the flag continue_on_error is set to` False` and processing has\nbeen terminated due to an exception while loading the contents of the file.\nReturn type:\nList of base64 encoded strings representing files.\ndatarobot.helpers.binary_data_utils.get_encoded_file_contents_from_urls(urls, custom_headers=None, continue_on_error=False, n_threads=None)\uf0c1\nReturns base64-encoded string for files located in the URL addresses passed on input. Input\ncollection holds data of valid file URL addresses reachable from location where code is being\nexecuted. Method will retrieve file and convert its contents to base64 string. Results will\nbe returned in same order as specified in input collection.\nParameters:\nurls (Iterable) \u2013 Iterable containing URL addresses to download images from.\ncustom_headers (dict) \u2013 Dictionary with headers to use when downloading files using a URL. Detailed data\nrelated to supported Headers in HTTP  can be found in the RFC specification:\nhttps://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html. When specified,\npassed values will overwrite default header values.\ncontinue_on_error (bool) \u2013 If a row encounters an error while retrieving content (i.e., file does not exist),\nspecifies whether the error results in terminating the process of downloading\nconsecutive files or the process continues. Skipped files will be marked as missing.\nn_threads (int or None) \u2013 Number of threads to use for processing. If \u201cNone\u201d is passed, the number of threads is\ndetermined automatically based on the number of available CPU cores. If this is not\npossible, 4 threads are used.\nRaises:\nContentRetrievalTerminatedError: \u2013 The error is raised when the flag continue_on_error is set to` False` and processing has\nbeen terminated due to an exception while loading the contents of the file.\nReturn type:\nList of base64 encoded strings representing files.\nclass datarobot.helpers.image_utils.ImageOptions\uf0c1\nImage options class. Class holds image options related to image resizing and image reformatting.\nshould_resize: boolWhether input image should be resized to new dimensions.\nforce_size: boolWhether the image size should fully match the new requested size. If the original\nand new image sizes have different aspect ratios, specifying True will force a resize\nto exactly match the requested size. This may break the aspect ratio of the original\nimage. If False, the resize method modifies the image to contain a thumbnail version\nof itself, no larger than the given size, that preserves the image\u2019s aspect ratio.\nimage_size: Tuple[int, int]New image size (width, height). Both values (width, height) should be specified and contain\na positive value. Depending on the value of force_size, the image will be resized exactly\nto the given image size or will be resized into a thumbnail version of itself, no larger\nthan the given size.\nimage_format: ImageFormat | strWhat image format will be used to save result image after transformations. For example\n(ImageFormat.JPEG, ImageFormat.PNG). Values supported are in line with values supported\nby DataRobot. If no format is specified by passing None value original image format\nwill be preserved.\nimage_quality: int or NoneThe image quality used when saving image. When None is specified, a value will\nnot be passed and Pillow library will use its default.\nresample_method: ImageResampleMethodWhat resampling method should be used when resizing image.\nkeep_quality: boolWhether the image quality is kept (when possible). If True, for JPEG images quality will\nbe preserved. For other types, the value specified in image_quality will be used.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-monitoring.html",
      "title": "Batch monitoring\uf0c1",
      "description": "A Batch Monitoring Job is used to monitor data sets outside DataRobot app.",
      "content": "Batch monitoring\uf0c1\nclass datarobot.models.BatchMonitoringJob\uf0c1\nA Batch Monitoring Job is used to monitor data sets outside DataRobot app.\nVariables:\nid (str) \u2013 the id of the job\nclassmethod get(project_id, job_id)\uf0c1\nGet batch monitoring job\nVariables:\njob_id (str) \u2013 ID of batch job\nReturns:\nInstance of BatchMonitoringJob\nReturn type:\nBatchMonitoringJob\ndownload(fileobj, timeout=120, read_timeout=660)\uf0c1\nDownloads the results of a monitoring job as a CSV.\nVariables:\nfileobj (A file-like object where the CSV monitoring results will be) \u2013 written to. Examples include an in-memory buffer\n(e.g., io.BytesIO) or a file on disk (opened for binary writing).\ntimeout (int (optional, default 120)) \u2013 Seconds to wait for the download to become available.\nThe download will not be available before the job has started processing.\nIn case other jobs are occupying the queue, processing may not start\nimmediately.\nIf the timeout is reached, the job will be aborted and RuntimeError\nis raised.\nSet to -1 to wait infinitely.\nread_timeout (int (optional, default 660)) \u2013 Seconds to wait for the server to respond between chunks.\nReturn type:\nNone\nclassmethod run(deployment, intake_settings=None, output_settings=None, csv_settings=None, num_concurrent=None, chunk_size=None, abort_on_error=True, monitoring_aggregation=None, monitoring_columns=None, monitoring_output_settings=None, download_timeout=120, download_read_timeout=660, upload_read_timeout=600)\uf0c1\nCreate new batch monitoring job, upload the dataset, and\nreturn a batch monitoring job.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for monitoring.\nintake_settings (dict) \u2013 A dict configuring how data is coming from. Supported options:\ntype : string, either localFile, s3, azure, gcp, dataset, jdbc\nsnowflake, synapse, bigquery, or datasphere\nNote that to pass a dataset, you not only need to specify the type parameter\nas dataset, but you must also set the dataset parameter as a\ndr.Dataset object.\nTo monitor from a local file, add this parameter to the\nsettings:\nfile : A file-like object, string path to a file or a\npandas.DataFrame of scoring data.\nTo monitor from S3, add the next parameters to the settings:\nurl : string, the URL to score (e.g.: s3://bucket/key).\ncredential_id : string (optional).\nendpoint_url : string (optional), any non-default endpoint\nURL for S3 access (omit to use the default).\n(batch_monitoring_jdbc_creds_usage)=\nTo monitor from JDBC, add the next parameters to the settings:\ndata_store_id : string, the ID of the external data store connected\nto the JDBC data source (see\nDatabase Connectivity).\nquery : string (optional if table, schema and/or catalog is specified),\na self-supplied SELECT statement of the data set you wish to predict.\ntable : string (optional if query is specified),\nthe name of specified database table.\nschema : string (optional if query is specified),\nthe name of specified database schema.\ncatalog : string  (optional if query is specified),\n(new in v2.22) the name of specified database catalog.\nfetch_size : int (optional),\nChanging the fetchSize can be used to balance throughput and memory\nusage.\ncredential_id : string (optional) the ID of the credentials holding\ninformation about a user with read-access to the JDBC data source (see\nCredentials).\nTo monitor from Datasphere, add the following parameters to the settings:\ndata_store_id : string, the ID of the external data store connected to\nthe Datasphere data source (see\nDatabase Connectivity).\ntable : string,  the name of specified database table.\nschema : string, the name of specified database schema.\ncredential_id : string, the ID of the credentials holding information about\na user with read-access to the Datasphere data source (see\nCredentials).\noutput_settings (dict (optional)) \u2013 A dict configuring how monitored data is to be saved. Supported\noptions:\ntype : string, either localFile, s3, azure, gcp, jdbc,\nsnowflake, synapse, bigquery, or datasphere\nTo save monitored data to a local file, add parameters to the\nsettings:\npath : string (optional), path to save the scored data\nas CSV. If a path is not specified, you must download\nthe scored data yourself with job.download().\nIf a path is specified, the call will block until the\njob is done. if there are no other jobs currently\nprocessing for the targeted prediction instance,\nuploading, scoring, downloading will happen in parallel\nwithout waiting for a full job to complete. Otherwise,\nit will still block, but start downloading the scored\ndata as soon as it starts generating data. This is the\nfastest method to get predictions.\nTo save monitored data to S3, add the next parameters to the settings:\nurl : string, the URL for storing the results\n(e.g.: s3://bucket/key).\ncredential_id : string (optional).\nendpoint_url : string (optional), any non-default endpoint\nURL for S3 access (omit to use the default).\nTo save monitored data to JDBC, add the next parameters to the settings:\ndata_store_id : string, the ID of the external data store connected to\nthe JDBC data source (see\nDatabase Connectivity).\ntable : string,  the name of specified database table.\nschema : string (optional), the name of specified database schema.\ncatalog : string (optional), (new in v2.22) the name of specified database\ncatalog.\nstatement_type : string, the type of insertion statement to create,\none of datarobot.enums.AVAILABLE_STATEMENT_TYPES.\nupdate_columns : list(string) (optional),  a list of strings containing\nthose column names to be updated in case statement_type is set to a\nvalue related to update or upsert.\nwhere_columns : list(string) (optional), a list of strings containing\nthose column names to be selected in case statement_type is set to a\nvalue related to insert or update.\ncredential_id : string, the ID of the credentials holding information about\na user with write-access to the JDBC data source (see\nCredentials).\ncreate_table_if_not_exists : bool (optional), If no existing table is detected,\nattempt to create it before writing data with the strategy defined in the\nstatementType parameter.\nTo save monitored data to Datasphere, add the next parameters to the settings:\ndata_store_id : string, the ID of the external data store connected to\nthe Datasphere data source (see\nDatabase Connectivity).\ntable : string,  the name of specified database table.\nschema : string, the name of specified database schema.\ncredential_id : string, the ID of the credentials holding information about\na user with write-access to the Datasphere data source (see\nCredentials).\ncsv_settings (dict (optional)) \u2013 CSV intake and output settings. Supported options:\ndelimiter : string (optional, default ,), fields are delimited by\nthis character. Use the string tab to denote TSV (TAB separated values).\nMust be either a one-character string or the string tab.\nquotechar : string (optional, default \u201c), fields containing the\ndelimiter must be quoted using this character.\nencoding : string (optional, default utf-8), encoding for the CSV\nfiles. For example (but not limited to): shift_jis, latin_1 or\nmskanji.\nnum_concurrent (int (optional)) \u2013 Number of concurrent chunks to score simultaneously. Defaults to\nthe available number of cores of the deployment. Lower it to leave\nresources for real-time scoring.\nchunk_size (string or int (optional)) \u2013 Which strategy should be used to determine the chunk size.\nCan be either a named strategy or a fixed size in bytes.\n- auto: use fixed or dynamic based on flipper.\n- fixed: use 1MB for explanations, 5MB for regular requests.\n- dynamic: use dynamic chunk sizes.\n- int: use this many bytes per chunk.\nabort_on_error (boolean (optional)) \u2013 Default behavior is to abort the job if too many rows fail scoring. This will free\nup resources for other jobs that may score successfully. Set to false to\nunconditionally score every row no matter how many errors are encountered.\nDefaults to True.\ndownload_timeout (int (optional)) \u2013\nAdded in version 2.22.\nIf using localFile output, wait this many seconds for the download to become\navailable. See download().\ndownload_read_timeout (int (optional, default 660)) \u2013\nAdded in version 2.22.\nIf using localFile output, wait this many seconds for the server to respond\nbetween chunks.\nupload_read_timeout (int (optional, default 600)) \u2013\nAdded in version 2.28.\nIf using localFile intake, wait this many seconds for the server to respond\nafter whole dataset upload.\nReturns:\nInstance of BatchMonitoringJob\nReturn type:\nBatchMonitoringJob\nExamples\n>>> import datarobot as dr\n>>> job_spec = {\n...     \"intake_settings\": {\n...         \"type\": \"jdbc\",\n...         \"data_store_id\": \"645043933d4fbc3215f17e34\",\n...         \"catalog\": \"SANDBOX\",\n...         \"table\": \"10kDiabetes_output_actuals\",\n...         \"schema\": \"SCORING_CODE_UDF_SCHEMA\",\n...         \"credential_id\": \"645043b61a158045f66fb329\"\n...     },\n>>>     \"monitoring_columns\": {\n...         \"predictions_columns\": [\n...             {\n...                 \"class_name\": \"True\",\n...                 \"column_name\": \"readmitted_True_PREDICTION\"\n...             },\n...             {\n...                 \"class_name\": \"False\",\n...                 \"column_name\": \"readmitted_False_PREDICTION\"\n...             }\n...         ],\n...         \"association_id_column\": \"rowID\",\n...         \"actuals_value_column\": \"ACTUALS\"\n...     }\n... }\n>>> deployment_id = \"foobar\"\n>>> job = dr.BatchMonitoringJob.run(deployment_id, **job_spec)\n>>> job.wait_for_completion()\ncancel(ignore_404_errors=False)\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nReturn type:\nNone\nget_status()\uf0c1\nGet status of batch monitoring job\nReturns:\nDict with job status\nReturn type:\nBatchMonitoringJob status data\nclass datarobot.models.BatchMonitoringJobDefinition\uf0c1\nclassmethod get(batch_monitoring_job_definition_id)\uf0c1\nGet batch monitoring job definition\nVariables:\nbatch_monitoring_job_definition_id (str) \u2013 ID of batch monitoring job definition\nReturns:\nInstance of BatchMonitoringJobDefinition\nReturn type:\nBatchMonitoringJobDefinition\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)\nclassmethod list()\uf0c1\nGet job all monitoring job definitions\nReturns:\nList of job definitions the user has access to see\nReturn type:\nList[BatchMonitoringJobDefinition]\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.list()\n>>> definition\n[\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1),\nBatchMonitoringJobDefinition(6086ba053f3ef731e81af3ca)\n]\nclassmethod create(enabled, batch_monitoring_job, name=None, schedule=None)\uf0c1\nCreates a new batch monitoring job definition to be run either at scheduled interval or as\na manual run.\nVariables:\nenabled (bool (default False)) \u2013 Whether the definition should be active on a scheduled basis. If True,\nschedule is required.\nbatch_monitoring_job (dict) \u2013 The job specifications for your batch monitoring job.\nIt requires the same job input parameters as used with BatchMonitoringJob\nname (string (optional)) \u2013 The name you want your job to be identified with. Must be unique across the\norganization\u2019s existing jobs.\nIf you don\u2019t supply a name, a random one will be generated for you.\nschedule (dict (optional)) \u2013 The schedule payload defines at what intervals the job should run, which can be\ncombined in various ways to construct complex scheduling terms if needed. In all\nthe elements in the objects, you can supply either an asterisk [\"*\"] denoting\n\u201cevery\u201d time denomination or an array of integers (e.g. [1, 2, 3]) to define\na specific interval.\nThe schedule payload is split up in the following items:\nMinute:\nThe minute(s) of the day that the job will run. Allowed values are either [\"*\"]\nmeaning every minute of the day or [0 ... 59]\nHour:\nThe hour(s) of the day that the job will run. Allowed values are either [\"*\"]\nmeaning every hour of the day or [0 ... 23].\nDay of Month:\nThe date(s) of the month that the job will run. Allowed values are either\n[1 ... 31] or [\"*\"] for all days of the month. This field is additive with\ndayOfWeek, meaning the job will run both on the date(s) defined in this field\nand the day specified by dayOfWeek (for example, dates 1st, 2nd, 3rd, plus every\nTuesday). If dayOfMonth is set to [\"*\"] and dayOfWeek is defined,\nthe scheduler will trigger on every day of the month that matches dayOfWeek\n(for example, Tuesday the 2nd, 9th, 16th, 23rd, 30th).\nInvalid dates such as February 31st are ignored.\nMonth:\nThe month(s) of the year that the job will run. Allowed values are either\n[1 ... 12] or [\"*\"] for all months of the year. Strings, either\n3-letter abbreviations or the full name of the month, can be used\ninterchangeably (e.g., \u201cjan\u201d or \u201coctober\u201d).\nMonths that are not compatible with dayOfMonth are ignored, for example\n{\"dayOfMonth\": [31], \"month\":[\"feb\"]}\nDay of Week:\nThe day(s) of the week that the job will run. Allowed values are [0 .. 6],\nwhere (Sunday=0), or [\"*\"], for all days of the week. Strings, either 3-letter\nabbreviations or the full name of the day, can be used interchangeably\n(e.g., \u201csunday\u201d, \u201cSunday\u201d, \u201csun\u201d, or \u201cSun\u201d, all map to [0].\nThis field is additive with dayOfMonth, meaning the job will run both on the\ndate specified by dayOfMonth and the day defined in this field.\nReturns:\nInstance of BatchMonitoringJobDefinition\nReturn type:\nBatchMonitoringJobDefinition\nExamples\n>>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 4,\n...    \"deployment_id\": \"foobar\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        16\n...    ],\n...    \"minute\": [\n...        0\n...    ],\n...    \"day_of_month\": [\n...        1\n...    ]\n...}\n>>> definition = BatchMonitoringJobDefinition.create(\n...    enabled=False,\n...    batch_monitoring_job=job_spec,\n...    name=\"some_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)\nupdate(enabled, batch_monitoring_job=None, name=None, schedule=None)\uf0c1\nUpdates a job definition with the changed specs.\nTakes the same input as create()\nVariables:\nenabled (bool (default False)) \u2013 Same as enabled in create().\nbatch_monitoring_job (dict) \u2013 Same as batch_monitoring_job in create().\nname (string (optional)) \u2013 Same as name in create().\nschedule (dict) \u2013 Same as schedule in create().\nReturns:\nInstance of the updated BatchMonitoringJobDefinition\nReturn type:\nBatchMonitoringJobDefinition\nExamples\n>>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 5,\n...    \"deployment_id\": \"foobar_new\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition = BatchMonitoringJobDefinition.create(\n...    enabled=False,\n...    batch_monitoring_job=job_spec,\n...    name=\"updated_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)\nrun_on_schedule(schedule)\uf0c1\nSets the run schedule of an already created job definition.\nIf the job was previously not enabled, this will also set the job to enabled.\nVariables:\nschedule (dict) \u2013 Same as schedule in create().\nReturns:\nInstance of the updated BatchMonitoringJobDefinition with the new / updated schedule.\nReturn type:\nBatchMonitoringJobDefinition\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.create('...')\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition.run_on_schedule(schedule)\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)\nrun_once()\uf0c1\nManually submits a batch monitoring job to the queue, based off of an already\ncreated job definition.\nReturns:\nInstance of BatchMonitoringJob\nReturn type:\nBatchMonitoringJob\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.create('...')\n>>> job = definition.run_once()\n>>> job.wait_for_completion()\ndelete()\uf0c1\nDeletes the job definition and disables any future schedules of this job if any.\nIf a scheduled job is currently running, this will not be cancelled.\n:rtype: None\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition.delete()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/database_connectivity.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.AVAILABLE_STATEMENT_TYPES",
        ">>> import datarobot as dr\n>>> job_spec = {\n...     \"intake_settings\": {\n...         \"type\": \"jdbc\",\n...         \"data_store_id\": \"645043933d4fbc3215f17e34\",\n...         \"catalog\": \"SANDBOX\",\n...         \"table\": \"10kDiabetes_output_actuals\",\n...         \"schema\": \"SCORING_CODE_UDF_SCHEMA\",\n...         \"credential_id\": \"645043b61a158045f66fb329\"\n...     },\n>>>     \"monitoring_columns\": {\n...         \"predictions_columns\": [\n...             {\n...                 \"class_name\": \"True\",\n...                 \"column_name\": \"readmitted_True_PREDICTION\"\n...             },\n...             {\n...                 \"class_name\": \"False\",\n...                 \"column_name\": \"readmitted_False_PREDICTION\"\n...             }\n...         ],\n...         \"association_id_column\": \"rowID\",\n...         \"actuals_value_column\": \"ACTUALS\"\n...     }\n... }\n>>> deployment_id = \"foobar\"\n>>> job = dr.BatchMonitoringJob.run(deployment_id, **job_spec)\n>>> job.wait_for_completion()",
        ">>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.list()\n>>> definition\n[\n    BatchMonitoringJobDefinition(60912e09fd1f04e832a575c1),\n    BatchMonitoringJobDefinition(6086ba053f3ef731e81af3ca)\n]",
        ">>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 4,\n...    \"deployment_id\": \"foobar\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        16\n...    ],\n...    \"minute\": [\n...        0\n...    ],\n...    \"day_of_month\": [\n...        1\n...    ]\n...}\n>>> definition = BatchMonitoringJobDefinition.create(\n...    enabled=False,\n...    batch_monitoring_job=job_spec,\n...    name=\"some_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 5,\n...    \"deployment_id\": \"foobar_new\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition = BatchMonitoringJobDefinition.create(\n...    enabled=False,\n...    batch_monitoring_job=job_spec,\n...    name=\"updated_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.create('...')\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition.run_on_schedule(schedule)\nBatchMonitoringJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.create('...')\n>>> job = definition.run_once()\n>>> job.wait_for_completion()",
        ">>> import datarobot as dr\n>>> definition = dr.BatchMonitoringJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition.delete()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
      "title": "Batch predictions\uf0c1",
      "description": "A Batch Prediction Job is used to score large data sets on\nprediction servers using the Batch Prediction API.",
      "content": "Batch predictions\uf0c1\nclass datarobot.models.BatchPredictionJob\uf0c1\nA Batch Prediction Job is used to score large data sets on\nprediction servers using the Batch Prediction API.\nVariables:\nid (str) \u2013 the id of the job\nclassmethod score(deployment, intake_settings=None, output_settings=None, csv_settings=None, timeseries_settings=None, num_concurrent=None, chunk_size=None, passthrough_columns=None, passthrough_columns_set=None, max_explanations=None, max_ngram_explanations=None, explanation_algorithm=None, threshold_high=None, threshold_low=None, prediction_threshold=None, prediction_warning_enabled=None, include_prediction_status=False, skip_drift_tracking=False, prediction_instance=None, abort_on_error=True, column_names_remapping=None, include_probabilities=True, include_probabilities_classes=None, download_timeout=120, download_read_timeout=660, upload_read_timeout=600, explanations_mode=None)\uf0c1\nCreate new batch prediction job, upload the scoring dataset and\nreturn a batch prediction job.\nThe default intake and output options are both localFile which\nrequires the caller to pass the file parameter and either\ndownload the results using the download() method afterwards or\npass a path to a file where the scored data will be downloaded to\nafterwards.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for scoring.\nintake_settings (Optional[IntakeSettings]) \u2013 A dict configuring how data is coming from. Supported options:\ntype : str, either localFile, s3, azure, gcp, dataset, jdbc\nsnowflake, synapse, bigquery, or datasphere\nNote that to pass a dataset, you not only need to specify the type parameter\nas dataset, but you must also set the dataset parameter as a\ndr.Dataset object.\nTo score from a local file, add the this parameter to the\nsettings:\nfile : file-like object, string path to file or a\npandas.DataFrame of scoring data\nTo score from S3, add the next parameters to the settings:\nurl : str, the URL to score (e.g.: s3://bucket/key)\ncredential_id : Optional[str]\nendpoint_url : Optional[str], any non-default endpoint\nURL for S3 access (omit to use the default)\nTo score from JDBC, add the next parameters to the settings:\ndata_store_id : str, the ID of the external data store connected\nto the JDBC data source (see\nDatabase Connectivity).\nquery : str (optional if table, schema and/or catalog is specified),\na self-supplied SELECT statement of the data set you wish to predict.\ntable : str (optional if query is specified),\nthe name of specified database table.\nschema : str (optional if query is specified),\nthe name of specified database schema.\ncatalog : str  (optional if query is specified),\n(new in v2.22) the name of specified database catalog.\nfetch_size : Optional[int],\nChanging the fetchSize can be used to balance throughput and memory\nusage.\ncredential_id : Optional[str] the ID of the credentials holding\ninformation about a user with read-access to the JDBC data source (see\nCredentials).\nTo score from Datasphere, add the next parameters to the settings:\ndata_store_id : str, the ID of the external data store connected to\nthe Datasphere data source (see\nDatabase Connectivity).\ntable : str,  the name of specified database table.\nschema : str, the name of specified database schema.\ncredential_id : str, the ID of the credentials holding information about\na user with read-access to the Datasphere data source (see\nCredentials).\noutput_settings (Optional[OutputSettings]) \u2013 A dict configuring how scored data is to be saved. Supported\noptions:\ntype : str, either localFile, s3, azure, gcp, jdbc,\nsnowflake, synapse, bigquery, or datasphere\nTo save scored data to a local file, add this parameters to the\nsettings:\npath : Optional[str], path to save the scored data\nas CSV. If a path is not specified, you must download\nthe scored data yourself with job.download().\nIf a path is specified, the call will block until the\njob is done. if there are no other jobs currently\nprocessing for the targeted prediction instance,\nuploading, scoring, downloading will happen in parallel\nwithout waiting for a full job to complete. Otherwise,\nit will still block, but start downloading the scored\ndata as soon as it starts generating data. This is the\nfastest method to get predictions.\nTo save scored data to S3, add the next parameters to the settings:\nurl : str, the URL for storing the results\n(e.g.: s3://bucket/key)\ncredential_id : Optional[str]\nendpoint_url : Optional[str], any non-default endpoint\nURL for S3 access (omit to use the default)\nTo save scored data to JDBC, add the next parameters to the settings:\ndata_store_id : str, the ID of the external data store connected to\nthe JDBC data source (see\nDatabase Connectivity).\ntable : str,  the name of specified database table.\nschema : Optional[str], the name of specified database schema.\ncatalog : Optional[str], (new in v2.22) the name of specified database\ncatalog.\nstatement_type : str, the type of insertion statement to create,\none of datarobot.enums.AVAILABLE_STATEMENT_TYPES.\nupdate_columns : list(string) (optional),  a list of strings containing\nthose column names to be updated in case statement_type is set to a\nvalue related to update or upsert.\nwhere_columns : list(string) (optional), a list of strings containing\nthose column names to be selected in case statement_type is set to a\nvalue related to insert or update.\ncredential_id : str, the ID of the credentials holding information about\na user with write-access to the JDBC data source (see\nCredentials).\nTo save scored data to Datasphere, add the following parameters to the settings:\ndata_store_id : str, the ID of the external data store connected to\nthe Datasphere data source (see\nDatabase Connectivity).\ntable : str,  the name of specified database table.\nschema : str, the name of specified database schema.\ncredential_id : str, the ID of the credentials holding information about\na user with write-access to the Datasphere data source (see\nCredentials).\ncsv_settings (Optional[CsvSettings]) \u2013 CSV intake and output settings. Supported options:\ndelimiter : str (optional, default ,), fields are delimited by\nthis character. Use the string tab to denote TSV (TAB separated values).\nMust be either a one-character string or the string tab.\nquotechar : str (optional, default \u201c), fields containing the\ndelimiter must be quoted using this character.\nencoding : str (optional, default utf-8), encoding for the CSV\nfiles. For example (but not limited to): shift_jis, latin_1 or\nmskanji.\ntimeseries_settings (Optional[TimeSeriesSettings]) \u2013 Configuration for time-series scoring. Supported options:\ntype : str, must be forecast or historical (default if\nnot passed is forecast). forecast mode makes predictions using\nforecast_point or rows in the dataset without target. historical\nenables bulk prediction mode which calculates predictions for all\npossible forecast points and forecast distances in the dataset within\npredictions_start_date/predictions_end_date range.\nforecast_point : Optional[datetime.datetime], forecast point for the dataset,\nused for the forecast predictions, by default value will be inferred\nfrom the dataset. May be passed if timeseries_settings.type=forecast.\npredictions_start_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\npredictions_end_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\nrelax_known_in_advance_features_check : bool, (default False).\nIf True, missing values in the known in advance features are allowed\nin the forecast window at the prediction time. If omitted or False,\nmissing values are not allowed.\nnum_concurrent (Optional[int]) \u2013 Number of concurrent chunks to score simultaneously. Defaults to\nthe available number of cores of the deployment. Lower it to leave\nresources for real-time scoring.\nchunk_size (str or Optional[int]) \u2013 Which strategy should be used to determine the chunk size.\nCan be either a named strategy or a fixed size in bytes.\n- auto: use fixed or dynamic based on flipper\n- fixed: use 1MB for explanations, 5MB for regular requests\n- dynamic: use dynamic chunk sizes\n- int: use this many bytes per chunk\npassthrough_columns (list[string] (optional)) \u2013 Keep these columns from the scoring dataset in the scored dataset.\nThis is useful for correlating predictions with source data.\npassthrough_columns_set (Optional[str]) \u2013 To pass through every column from the scoring dataset, set this to\nall. Takes precedence over passthrough_columns if set.\nmax_explanations (Optional[int]) \u2013 Compute prediction explanations for this amount of features.\nmax_ngram_explanations (int or str (optional)) \u2013 Compute text explanations for this amount of ngrams. Set to all to return all ngram\nexplanations, or set to a positive integer value to limit the amount of ngram\nexplanations returned. By default no ngram explanations will be computed and returned.\nthreshold_high (Optional[float]) \u2013 Only compute prediction explanations for predictions above this\nthreshold. Can be combined with threshold_low.\nthreshold_low (Optional[float]) \u2013 Only compute prediction explanations for predictions below this\nthreshold. Can be combined with threshold_high.\nexplanations_mode (PredictionExplanationsMode, optional) \u2013 Mode of prediction explanations calculation for multiclass and clustering models, if not\nspecified - server default is to explain only the predicted class, identical to passing\nTopPredictionsMode(1).\nprediction_warning_enabled (Optional[bool]) \u2013 Add prediction warnings to the scored data. Currently only\nsupported for regression models.\ninclude_prediction_status (Optional[bool]) \u2013 Include the prediction_status column in the output, defaults to False.\nskip_drift_tracking (Optional[bool]) \u2013 Skips drift tracking on any predictions made from this job. This is useful when running\nnon-production workloads to not affect drift tracking and cause unnecessary alerts.\nDefaults to False.\nprediction_instance (Optional[PredictionInstance]) \u2013 Defaults to instance specified by deployment or system configuration.\nSupported options:\nhostName : str\nsslEnabled : boolean (optional, default true). Set to false to\nrun prediction requests from the batch prediction job without SSL.\ndatarobotKey : Optional[str], if running a job against a prediction\ninstance in the Managed AI Cloud, you must provide the organization level\nDataRobot-Key\napiKey : Optional[str], by default, prediction requests will use the\nAPI key of the user that created the job. This allows you to make requests\non behalf of other users.\nabort_on_error (Optional[bool]) \u2013 Default behavior is to abort the job if too many rows fail scoring. This will free\nup resources for other jobs that may score successfully. Set to false to\nunconditionally score every row no matter how many errors are encountered.\nDefaults to True.\ncolumn_names_remapping (Optional[Dict[str, str]]) \u2013 Mapping with column renaming for output table. Defaults to {}.\ninclude_probabilities (Optional[bool]) \u2013 Flag that enables returning of all probability columns. Defaults to True.\ninclude_probabilities_classes (list (optional)) \u2013 List the subset of classes if a user doesn\u2019t want all the classes. Defaults to [].\ndownload_timeout (Optional[int]) \u2013\nAdded in version 2.22.\nIf using localFile output, wait this many seconds for the download to become\navailable. See download().\ndownload_read_timeout (Optional[int], default 660) \u2013\nAdded in version 2.22.\nIf using localFile output, wait this many seconds for the server to respond\nbetween chunks.\nupload_read_timeout (Optional[int], default 600) \u2013\nAdded in version 2.28.\nIf using localFile intake, wait this many seconds for the server to respond\nafter whole dataset upload.\nprediction_threshold (Optional[float]) \u2013\nAdded in version 3.4.0.\nThreshold is the point that sets the class boundary for a predicted value. The model\nclassifies an observation below the threshold as FALSE, and an observation above the\nthreshold as TRUE. In other words, DataRobot automatically assigns the positive class\nlabel to any prediction exceeding the threshold.\nThis value can be set between 0.0 and 1.0.\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod apply_time_series_data_prep_and_score(deployment, intake_settings, timeseries_settings, **kwargs)\uf0c1\nPrepare the dataset with time series data prep, create new batch prediction job,\nupload the scoring dataset, and return a batch prediction job.\nThe supported intake_settings are of type localFile or dataset.\nFor timeseries_settings of type forecast the forecast_point must be specified.\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nAdded in version v3.1.\nVariables:\ndeployment (Deployment) \u2013 Deployment which will be used for scoring.\nintake_settings (dict) \u2013 A dict configuring where data is coming from. Supported options:\ntype : str, either localFile, dataset\nNote that to pass a dataset, you not only need to specify the type parameter\nas dataset, but you must also set the dataset parameter as a\nDataset object.\nTo score from a local file, add this parameter to the\nsettings:\nfile : file-like object, string path to file or a\npandas.DataFrame of scoring data.\ntimeseries_settings (dict) \u2013 Configuration for time-series scoring. Supported options:\ntype : str, must be forecast or historical (default if\nnot passed is forecast). forecast mode makes predictions using\nforecast_point. historical enables bulk prediction mode which\ncalculates predictions for all possible forecast points and forecast\ndistances in the dataset within predictions_start_date/predictions_end_date\nrange.\nforecast_point : Optional[datetime.datetime], forecast point for the dataset,\nused for the forecast predictions. Must be passed if\ntimeseries_settings.type=forecast.\npredictions_start_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\npredictions_end_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\nrelax_known_in_advance_features_check : bool, (default False).\nIf True, missing values in the known in advance features are allowed\nin the forecast window at the prediction time. If omitted or False,\nmissing values are not allowed.\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nRaises:\nInvalidUsageError \u2013 If the deployment does not support time series data prep.\nIf the intake type is not supported for time series data prep.\nclassmethod score_to_file(deployment, intake_path, output_path, **kwargs)\uf0c1\nCreate new batch prediction job, upload the scoring dataset and\ndownload the scored CSV file concurrently.\nWill block until the entire file is scored.\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for scoring.\nintake_path (file-like object/string path to file/pandas.DataFrame) \u2013 Scoring data\noutput_path (str) \u2013 Filename to save the result under\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod apply_time_series_data_prep_and_score_to_file(deployment, intake_path, output_path, timeseries_settings, **kwargs)\uf0c1\nPrepare the input dataset with time series data prep. Then, create a new batch prediction\njob using the prepared AI catalog item as input and concurrently download the scored CSV\nfile.\nThe function call will return when the entire file is scored.\nFor timeseries_settings of type forecast the forecast_point must be specified.\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nAdded in version v3.1.\nVariables:\ndeployment (Deployment) \u2013 The deployment which will be used for scoring.\nintake_path (file-like object/string path to file/pandas.DataFrame) \u2013 The scoring data.\noutput_path (str) \u2013 The filename under which you save the result.\ntimeseries_settings (dict) \u2013 Configuration for time-series scoring. Supported options:\ntype : str, must be forecast or historical (default if\nnot passed is forecast). forecast mode makes predictions using\nforecast_point. historical enables bulk prediction mode which\ncalculates predictions for all possible forecast points and forecast\ndistances in the dataset within predictions_start_date/predictions_end_date\nrange.\nforecast_point : Optional[datetime.datetime], forecast point for the dataset,\nused for the forecast predictions. Must be passed if\ntimeseries_settings.type=forecast.\npredictions_start_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\npredictions_end_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\nrelax_known_in_advance_features_check : bool, (default False).\nIf True, missing values in the known in advance features are allowed\nin the forecast window at the prediction time. If omitted or False,\nmissing values are not allowed.\nReturns:\nInstance of BatchPredictionJob.\nReturn type:\nBatchPredictionJob\nRaises:\nInvalidUsageError \u2013 If the deployment does not support time series data prep.\nclassmethod score_s3(deployment, source_url, destination_url, credential=None, endpoint_url=None, **kwargs)\uf0c1\nCreate new batch prediction job, with a scoring dataset from S3\nand writing the result back to S3.\nThis returns immediately after the job has been created. You\nmust poll for job completion using get_status() or\nwait_for_completion() (see datarobot.models.Job)\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for scoring.\nsource_url (str) \u2013 The URL for the prediction dataset (e.g.: s3://bucket/key)\ndestination_url (str) \u2013 The URL for the scored dataset (e.g.: s3://bucket/key)\ncredential (str or Credential (optional)) \u2013 The AWS Credential object or credential id\nendpoint_url (Optional[str]) \u2013 Any non-default endpoint URL for S3 access (omit to use the default)\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod score_azure(deployment, source_url, destination_url, credential=None, **kwargs)\uf0c1\nCreate new batch prediction job, with a scoring dataset from Azure blob\nstorage and writing the result back to Azure blob storage.\nThis returns immediately after the job has been created. You\nmust poll for job completion using get_status() or\nwait_for_completion() (see datarobot.models.Job).\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for scoring.\nsource_url (str) \u2013 The URL for the prediction dataset\n(e.g.: https://storage_account.blob.endpoint/container/blob_name)\ndestination_url (str) \u2013 The URL for the scored dataset\n(e.g.: https://storage_account.blob.endpoint/container/blob_name)\ncredential (str or Credential (optional)) \u2013 The Azure Credential object or credential id\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod score_gcp(deployment, source_url, destination_url, credential=None, **kwargs)\uf0c1\nCreate new batch prediction job, with a scoring dataset from Google Cloud Storage\nand writing the result back to one.\nThis returns immediately after the job has been created. You\nmust poll for job completion using get_status() or\nwait_for_completion() (see datarobot.models.Job).\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for scoring.\nsource_url (str) \u2013 The URL for the prediction dataset\n(e.g.: http(s)://storage.googleapis.com/[bucket]/[object])\ndestination_url (str) \u2013 The URL for the scored dataset\n(e.g.: http(s)://storage.googleapis.com/[bucket]/[object])\ncredential (str or Credential (optional)) \u2013 The GCP Credential object or credential id\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod score_from_existing(batch_prediction_job_id)\uf0c1\nCreate a new batch prediction job based on the settings from a previously created one\nVariables:\nbatch_prediction_job_id (str) \u2013 ID of the previous batch prediction job\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod score_pandas(deployment, df, read_timeout=660, **kwargs)\uf0c1\nRun a batch prediction job, with a scoring dataset from a\npandas dataframe. The output from the prediction will be joined\nto the passed DataFrame and returned.\nUse columnNamesRemapping to drop or rename columns in the\noutput\nThis method blocks until the job has completed or raises an\nexception on errors.\nRefer to the datarobot.models.BatchPredictionJob.score() method for details on the other\nkwargs parameters.\nVariables:\ndeployment (Deployment or string ID) \u2013 Deployment which will be used for scoring.\ndf (pandas.DataFrame) \u2013 The dataframe to score\nReturn type:\nTuple[BatchPredictionJob, DataFrame]\nReturns:\nBatchPredictionJob \u2013 Instance of BatchPredictonJob\npandas.DataFrame \u2013 The original dataframe merged with the predictions\nclassmethod score_with_leaderboard_model(model, intake_settings=None, output_settings=None, csv_settings=None, timeseries_settings=None, passthrough_columns=None, passthrough_columns_set=None, max_explanations=None, max_ngram_explanations=None, explanation_algorithm=None, threshold_high=None, threshold_low=None, prediction_threshold=None, prediction_warning_enabled=None, include_prediction_status=False, abort_on_error=True, column_names_remapping=None, include_probabilities=True, include_probabilities_classes=None, download_timeout=120, download_read_timeout=660, upload_read_timeout=600, explanations_mode=None)\uf0c1\nCreates a new batch prediction job for a Leaderboard model by\nuploading the scoring dataset. Returns a batch prediction job.\nThe default intake and output options are both localFile, which\nrequires the caller to pass the file parameter and either\ndownload the results using the download() method afterwards or\npass a path to a file where the scored data will be downloaded to.\nVariables:\nmodel (Model or DatetimeModel or string ID) \u2013 Model which will be used for scoring.\nintake_settings (Optional[IntakeSettings]) \u2013 A dict configuring how data is coming from. Supported options:\ntype : str, either localFile, dataset, or dss.\nNote that to pass a dataset, you not only need to specify the type parameter\nas dataset, but you must also set the dataset parameter as a\ndr.Dataset object.\nTo score from a local file, add the this parameter to the\nsettings:\nfile : file-like object, string path to file or a\npandas.DataFrame of scoring data.\nTo score subset of training data, use dss intake type and specify\nfollowing parameters:\nproject_id : project to fetch training data from. Access to project is required.\npartition : subset of training data to score,\none of datarobot.enums.TrainingDataSubsets.\noutput_settings (Optional[OutputSettings]) \u2013 A dict configuring how scored data is to be saved. Supported\noptions:\ntype : str, localFile\nTo save scored data to a local file, add this parameters to the\nsettings:\npath : Optional[str] The path to save the scored data\nas a CSV file. If a path is not specified, you must download\nthe scored data yourself with job.download().\nIf a path is specified, the call is blocked until the\njob is done. If there are no other jobs currently\nprocessing for the targeted prediction instance,\nuploading, scoring, and downloading will happen in parallel\nwithout waiting for a full job to complete. Otherwise,\nit will still block, but start downloading the scored\ndata as soon as it starts generating data. This is the\nfastest method to get predictions.\ncsv_settings (Optional[CsvSettings]) \u2013 CSV intake and output settings. Supported options:\ndelimiter : str (optional, default ,), fields are delimited by\nthis character. Use the string tab to denote TSV (TAB separated values).\nMust be either a one-character string or the string tab.\nquotechar : str (optional, default \u201c), fields containing the\ndelimiter must be quoted using this character.\nencoding : str (optional, default utf-8), encoding for the CSV\nfiles. For example (but not limited to): shift_jis, latin_1 or\nmskanji.\ntimeseries_settings (Optional[TimeSeriesSettings]) \u2013 Configuration for time-series scoring. Supported options:\ntype : str, must be forecast, historical (default if\nnot passed is forecast), or training. forecast mode makes predictions using\nforecast_point or rows in the dataset without target. historical\nenables bulk prediction mode which calculates predictions for all\npossible forecast points and forecast distances in the dataset within\npredictions_start_date/predictions_end_date range. training mode is\na special case for predictions on subsets of training data. Note, that it must\nbe used in conjunction with dss intake type only.\nforecast_point : Optional[datetime.datetime], forecast point for the dataset,\nused for the forecast predictions, by default value will be inferred\nfrom the dataset. May be passed if timeseries_settings.type=forecast.\npredictions_start_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\npredictions_end_date : Optional[datetime.datetime], used for historical\npredictions in order to override date from which predictions should be\ncalculated. By default value will be inferred automatically from the\ndataset. May be passed if timeseries_settings.type=historical.\nrelax_known_in_advance_features_check : bool, (default False).\nIf True, missing values in the known in advance features are allowed\nin the forecast window at the prediction time. If omitted or False,\nmissing values are not allowed.\npassthrough_columns (list[string] (optional)) \u2013 Keep these columns from the scoring dataset in the scored dataset.\nThis is useful for correlating predictions with source data.\npassthrough_columns_set (Optional[str]) \u2013 To pass through every column from the scoring dataset, set this to\nall. Takes precedence over passthrough_columns if set.\nmax_explanations (Optional[int]) \u2013 Compute prediction explanations for this amount of features.\nmax_ngram_explanations (int or str (optional)) \u2013 Compute text explanations for this amount of ngrams. Set to all to return all ngram\nexplanations, or set to a positive integer value to limit the amount of ngram\nexplanations returned. By default no ngram explanations will be computed and returned.\nthreshold_high (Optional[float]) \u2013 Only compute prediction explanations for predictions above this\nthreshold. Can be combined with threshold_low.\nthreshold_low (Optional[float]) \u2013 Only compute prediction explanations for predictions below this\nthreshold. Can be combined with threshold_high.\nexplanations_mode (PredictionExplanationsMode, optional) \u2013 Mode of prediction explanations calculation for multiclass and clustering models, if not\nspecified - server default is to explain only the predicted class, identical to passing\nTopPredictionsMode(1).\nprediction_warning_enabled (Optional[bool]) \u2013 Add prediction warnings to the scored data. Currently only\nsupported for regression models.\ninclude_prediction_status (Optional[bool]) \u2013 Include the prediction_status column in the output, defaults to False.\nabort_on_error (Optional[bool]) \u2013 Default behavior is to abort the job if too many rows fail scoring. This will free\nup resources for other jobs that may score successfully. Set to false to\nunconditionally score every row no matter how many errors are encountered.\nDefaults to True.\ncolumn_names_remapping (Optional[Dict]) \u2013 Mapping with column renaming for output table. Defaults to {}.\ninclude_probabilities (Optional[bool]) \u2013 Flag that enables returning of all probability columns. Defaults to True.\ninclude_probabilities_classes (list (optional)) \u2013 List the subset of classes if you do not want all the classes. Defaults to [].\ndownload_timeout (Optional[int]) \u2013\nAdded in version 2.22.\nIf using localFile output, wait this many seconds for the download to become\navailable. See download().\ndownload_read_timeout (int (optional, default 660)) \u2013\nAdded in version 2.22.\nIf using localFile output, wait this many seconds for the server to respond\nbetween chunks.\nupload_read_timeout (int (optional, default 600)) \u2013\nAdded in version 2.28.\nIf using localFile intake, wait this many seconds for the server to respond\nafter whole dataset upload.\nprediction_threshold (Optional[float]) \u2013\nAdded in version 3.4.0.\nThreshold is the point that sets the class boundary for a predicted value. The model\nclassifies an observation below the threshold as FALSE, and an observation above the\nthreshold as TRUE. In other words, DataRobot automatically assigns the positive class\nlabel to any prediction exceeding the threshold.\nThis value can be set between 0.0 and 1.0.\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nclassmethod get(batch_prediction_job_id)\uf0c1\nGet batch prediction job\nVariables:\nbatch_prediction_job_id (str) \u2013 ID of batch prediction job\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\ndownload(fileobj, timeout=120, read_timeout=660)\uf0c1\nDownloads the CSV result of a prediction job\nVariables:\nfileobj (A file-like object where the CSV prediction results will be) \u2013 written to. Examples include an in-memory buffer\n(e.g., io.BytesIO) or a file on disk (opened for binary writing).\ntimeout (int (optional, default 120)) \u2013\nAdded in version 2.22.\nSeconds to wait for the download to become available.\nThe download will not be available before the job has started processing.\nIn case other jobs are occupying the queue, processing may not start\nimmediately.\nIf the timeout is reached, the job will be aborted and RuntimeError\nis raised.\nSet to -1 to wait infinitely.\nread_timeout (int (optional, default 660)) \u2013\nAdded in version 2.22.\nSeconds to wait for the server to respond between chunks.\nReturn type:\nNone\ndelete(ignore_404_errors=False)\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nReturn type:\nNone\nget_status()\uf0c1\nGet status of batch prediction job\nReturns:\nDict with job status\nReturn type:\nBatchPredictionJob status data\nclassmethod list_by_status(statuses=None)\uf0c1\nGet jobs collection for specific set of statuses\nVariables:\nstatuses \u2013 List of statuses to filter jobs ([ABORTED|COMPLETED\u2026])\nif statuses is not provided, returns all jobs for user\nReturns:\nList of job statuses dicts with specific statuses\nReturn type:\nBatchPredictionJob statuses\nclass datarobot.models.BatchPredictionJobDefinition\uf0c1\nclassmethod get(batch_prediction_job_definition_id)\uf0c1\nGet batch prediction job definition\nVariables:\nbatch_prediction_job_definition_id (str) \u2013 ID of batch prediction job definition\nReturns:\nInstance of BatchPredictionJobDefinition\nReturn type:\nBatchPredictionJobDefinition\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)\nclassmethod list(search_name=None, deployment_id=None, limit=<datarobot.models.batch_prediction_job.MissingType object>, offset=0)\uf0c1\nGet job all definitions\nParameters:\nsearch_name (Optional[str]) \u2013 String for filtering job definitions\nJob definitions that contain the string in name will be returned.\nIf not specified, all available job definitions will be returned.\ndeployment_id (str) \u2013 The ID of the deployment record belongs to.\nlimit (Optional[int]) \u2013 0 by default. At most this many results are returned.\noffset (Optional[int]) \u2013 This many results will be skipped.\nReturns:\nList of job definitions the user has access to see\nReturn type:\nList[BatchPredictionJobDefinition]\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.list()\n>>> definition\n[\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1),\nBatchPredictionJobDefinition(6086ba053f3ef731e81af3ca)\n]\nclassmethod create(enabled, batch_prediction_job, name=None, schedule=None)\uf0c1\nCreates a new batch prediction job definition to be run either at scheduled interval or as\na manual run.\nVariables:\nenabled (bool (default False)) \u2013 Whether or not the definition should be active on a scheduled basis. If True,\nschedule is required.\nbatch_prediction_job (dict) \u2013 The job specifications for your batch prediction job.\nIt requires the same job input parameters as used with\nscore(), only it will not initialize a job scoring,\nonly store it as a definition for later use.\nname (Optional[str]) \u2013 The name you want your job to be identified with. Must be unique across the\norganization\u2019s existing jobs.\nIf you don\u2019t supply a name, a random one will be generated for you.\nschedule (Optional[Dict]) \u2013 The schedule payload defines at what intervals the job should run, which can be\ncombined in various ways to construct complex scheduling terms if needed. In all of\nthe elements in the objects, you can supply either an asterisk [\"*\"] denoting\n\u201cevery\u201d time denomination or an array of integers (e.g. [1, 2, 3]) to define\na specific interval.\nThe schedule payload is split up in the following items:\nMinute:\nThe minute(s) of the day that the job will run. Allowed values are either [\"*\"]\nmeaning every minute of the day or [0 ... 59]\nHour:\nThe hour(s) of the day that the job will run. Allowed values are either [\"*\"]\nmeaning every hour of the day or [0 ... 23].\nDay of Month:\nThe date(s) of the month that the job will run. Allowed values are either\n[1 ... 31] or [\"*\"] for all days of the month. This field is additive with\ndayOfWeek, meaning the job will run both on the date(s) defined in this field\nand the day specified by dayOfWeek (for example, dates 1st, 2nd, 3rd, plus every\nTuesday). If dayOfMonth is set to [\"*\"] and dayOfWeek is defined,\nthe scheduler will trigger on every day of the month that matches dayOfWeek\n(for example, Tuesday the 2nd, 9th, 16th, 23rd, 30th).\nInvalid dates such as February 31st are ignored.\nMonth:\nThe month(s) of the year that the job will run. Allowed values are either\n[1 ... 12] or [\"*\"] for all months of the year. Strings, either\n3-letter abbreviations or the full name of the month, can be used\ninterchangeably (e.g., \u201cjan\u201d or \u201coctober\u201d).\nMonths that are not compatible with dayOfMonth are ignored, for example\n{\"dayOfMonth\": [31], \"month\":[\"feb\"]}\nDay of Week:\nThe day(s) of the week that the job will run. Allowed values are [0 .. 6],\nwhere (Sunday=0), or [\"*\"], for all days of the week. Strings, either 3-letter\nabbreviations or the full name of the day, can be used interchangeably\n(e.g., \u201csunday\u201d, \u201cSunday\u201d, \u201csun\u201d, or \u201cSun\u201d, all map to [0].\nThis field is additive with dayOfMonth, meaning the job will run both on the\ndate specified by dayOfMonth and the day defined in this field.\nReturns:\nInstance of BatchPredictionJobDefinition\nReturn type:\nBatchPredictionJobDefinition\nExamples\n>>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 4,\n...    \"deployment_id\": \"foobar\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        16\n...    ],\n...    \"minute\": [\n...        0\n...    ],\n...    \"day_of_month\": [\n...        1\n...    ]\n...}\n>>> definition = BatchPredictionJobDefinition.create(\n...    enabled=False,\n...    batch_prediction_job=job_spec,\n...    name=\"some_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)\nupdate(enabled, batch_prediction_job=None, name=None, schedule=None)\uf0c1\nUpdates a job definition with the changed specs.\nTakes the same input as create()\nVariables:\nenabled (bool (default False)) \u2013 Same as enabled in create().\nbatch_prediction_job (dict) \u2013 Same as batch_prediction_job in create().\nname (Optional[str]) \u2013 Same as name in create().\nschedule (dict) \u2013 Same as schedule in create().\nReturns:\nInstance of the updated BatchPredictionJobDefinition\nReturn type:\nBatchPredictionJobDefinition\nExamples\n>>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 5,\n...    \"deployment_id\": \"foobar_new\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition = BatchPredictionJobDefinition.create(\n...    enabled=False,\n...    batch_prediction_job=job_spec,\n...    name=\"updated_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)\nrun_on_schedule(schedule)\uf0c1\nSets the run schedule of an already created job definition.\nIf the job was previously not enabled, this will also set the job to enabled.\nVariables:\nschedule (dict) \u2013 Same as schedule in create().\nReturns:\nInstance of the updated BatchPredictionJobDefinition with the new / updated schedule.\nReturn type:\nBatchPredictionJobDefinition\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.create('...')\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition.run_on_schedule(schedule)\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)\nrun_once()\uf0c1\nManually submits a batch prediction job to the queue, based off of an already\ncreated job definition.\nReturns:\nInstance of BatchPredictionJob\nReturn type:\nBatchPredictionJob\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.create('...')\n>>> job = definition.run_once()\n>>> job.wait_for_completion()\ndelete()\uf0c1\nDeletes the job definition and disables any future schedules of this job if any.\nIf a scheduled job is currently running, this will not be cancelled.\n:rtype: None\nExamples\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition.delete()\nBatch job\uf0c1\nclass datarobot.models.batch_job.IntakeSettings\uf0c1\nIntake settings typed dict\nclass datarobot.models.batch_job.OutputSettings\uf0c1\nOutput settings typed dict\nPredict job\uf0c1\ndatarobot.models.predict_job.wait_for_async_predictions(project_id, predict_job_id, max_wait=600)\uf0c1\nGiven a Project id and PredictJob id poll for status of process\nresponsible for predictions generation until it\u2019s finished\nParameters:\nproject_id (str) \u2013 The identifier of the project\npredict_job_id (str) \u2013 The identifier of the PredictJob\nmax_wait (Optional[int]) \u2013 Time in seconds after which predictions creation is considered\nunsuccessful\nReturns:\npredictions \u2013 Generated predictions.\nReturn type:\npandas.DataFrame\nRaises:\nAsyncPredictionsGenerationError \u2013 Raised if status of fetched PredictJob object is error\nAsyncTimeoutError \u2013 Predictions weren\u2019t generated in time, specified by max_wait\nparameter\nclass datarobot.models.PredictJob\uf0c1\nTracks asynchronous work being done within a project\nVariables:\nid (int) \u2013 the id of the job\nproject_id (str) \u2013 the id of the project the job belongs to\nstatus (str) \u2013 the status of the job - will be one of datarobot.enums.QUEUE_STATUS\njob_type (str) \u2013 what kind of work the job is doing - will be \u2018predict\u2019 for predict jobs\nis_blocked (bool) \u2013 if true, the job is blocked (cannot be executed) until its dependencies are resolved\nmessage (str) \u2013 a message about the state of the job, typically explaining why an error occurred\nclassmethod from_job(job)\uf0c1\nTransforms a generic Job into a PredictJob\nParameters:\njob (Job) \u2013 A generic job representing a PredictJob\nReturns:\npredict_job \u2013 A fully populated PredictJob with all the details of the job\nReturn type:\nPredictJob\nRaises:\nValueError: \u2013 If the generic Job was not a predict job, e.g. job_type != JOB_TYPE.PREDICT\nclassmethod get(project_id, predict_job_id)\uf0c1\nFetches one PredictJob. If the job finished, raises PendingJobFinished\nexception.\nParameters:\nproject_id (str) \u2013 The identifier of the project the model on which prediction\nwas started belongs to\npredict_job_id (str) \u2013 The identifier of the predict_job\nReturns:\npredict_job \u2013 The pending PredictJob\nReturn type:\nPredictJob\nRaises:\nPendingJobFinished \u2013 If the job being queried already finished, and the server is\nre-routing to the finished predictions.\nAsyncFailureError \u2013 Querying this resource gave a status code other than 200 or 303\nclassmethod get_predictions(project_id, predict_job_id, class_prefix='class_')\uf0c1\nFetches finished predictions from the job used to generate them.\nNotes\nThe prediction API for classifications now returns an additional prediction_values\ndictionary that is converted into a series of class_prefixed columns in the final\ndataframe. For example, <label> = 1.0 is converted to \u2018class_1.0\u2019. If you are on an\nolder version of the client (prior to v2.8), you must update to v2.8 to correctly pivot\nthis data.\nParameters:\nproject_id (str) \u2013 The identifier of the project to which belongs the model used\nfor predictions generation\npredict_job_id (str) \u2013 The identifier of the predict_job\nclass_prefix (str) \u2013 The prefix to append to labels in the final dataframe (e.g., apple -> class_apple)\nReturns:\npredictions \u2013 Generated predictions\nReturn type:\npandas.DataFrame\nRaises:\nJobNotFinished \u2013 If the job has not finished yet\nAsyncFailureError \u2013 Querying the predict_job in question gave a status code other than 200 or 303\ncancel()\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nget_result(params=None)\uf0c1\nParameters:\nparams (dict or None) \u2013 Query parameters to be added to request to get results.\nNotes\nFor featureEffects, source param is required to define source,\notherwise the default is training.\nReturns:\nresult \u2013\nReturn type depends on the job type\nfor model jobs, a Model is returned\nfor predict jobs, a pandas.DataFrame (with predictions) is returned\nfor featureImpact jobs, a list of dicts by default (see with_metadata\nparameter of the FeatureImpactJob class and its get() method).\nfor primeRulesets jobs, a list of Rulesets\nfor primeModel jobs, a PrimeModel\nfor primeDownloadValidation jobs, a PrimeFile\nfor predictionExplanationInitialization jobs, a PredictionExplanationsInitialization\nfor predictionExplanations jobs, a PredictionExplanations\nfor featureEffects, a FeatureEffects.\nReturn type:\nobject\nRaises:\nJobNotFinished \u2013 If the job is not finished, the result is not available.\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nget_result_when_complete(max_wait=600, params=None)\uf0c1\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nparams (dict, optional) \u2013 Query parameters to be added to request.\nReturns:\nresult \u2013 Return type is the same as would be returned by Job.get_result.\nReturn type:\nobject\nRaises:\nAsyncTimeoutError \u2013 If the job does not finish in time\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nrefresh()\uf0c1\nUpdate this object with the latest job data from the server.\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nReturn type:\nNone\nPrediction dataset\uf0c1\nclass datarobot.models.PredictionDataset\uf0c1\nA dataset uploaded to make predictions\nTypically created via project.upload_dataset\nVariables:\nid (str) \u2013 the id of the dataset\nproject_id (str) \u2013 the id of the project the dataset belongs to\ncreated (str) \u2013 the time the dataset was created\nname (str) \u2013 the name of the dataset\nnum_rows (int) \u2013 the number of rows in the dataset\nnum_columns (int) \u2013 the number of columns in the dataset\nforecast_point (datetime.datetime or None) \u2013 For time series projects only. This is the default point relative to which predictions will\nbe generated, based on the forecast window of the project.  See the time series\npredictions documentation for more information.\npredictions_start_date (datetime.datetime or None, optional) \u2013 For time series projects only. The start date for bulk predictions. Note that this\nparameter is for generating historical predictions using the training data. This parameter\nshould be provided in conjunction with predictions_end_date. Can\u2019t be provided with the\nforecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 For time series projects only. The end date for bulk predictions, exclusive. Note that this\nparameter is for generating historical predictions using the training data. This parameter\nshould be provided in conjunction with predictions_start_date. Can\u2019t be provided with\nthe forecast_point parameter.\nrelax_known_in_advance_features_check (Optional[bool]) \u2013 (New in version v2.15) For time series projects only. If True, missing values in the\nknown in advance features are allowed in the forecast window at the prediction time.\nIf omitted or False, missing values are not allowed.\ndata_quality_warnings (dict, optional) \u2013 (New in version v2.15) A dictionary that contains available warnings about potential\nproblems in this prediction dataset. Available warnings include:\nhas_kia_missing_values_in_forecast_window (bool)Applicable for time series projects. If True, known in advance features\nhave missing values in forecast window which may decrease prediction accuracy.\ninsufficient_rows_for_evaluating_models  (bool)Applicable for datasets which are used as external test sets. If True, there is not\nenough rows in dataset to calculate insights.\nsingle_class_actual_value_column (bool)Applicable for datasets which are used as external test sets. If True, actual value\ncolumn has only one class and such insights as ROC curve can not be calculated.\nOnly applies for binary classification projects or unsupervised projects.\nforecast_point_range (list[datetime.datetime] or None, optional) \u2013 (New in version v2.20) For time series projects only. Specifies the range of dates available\nfor use as a forecast point.\ndata_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The minimum primary date of this\nprediction dataset.\ndata_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The maximum primary date of this\nprediction dataset.\nmax_forecast_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The maximum forecast date of this\nprediction dataset.\nactual_value_column (string, optional) \u2013 (New in version v2.21) Optional, only available for unsupervised projects,\nin case dataset was uploaded with actual value column specified. Name of the\ncolumn which will be used to calculate the classification metrics and insights.\ndetected_actual_value_columns (list of dict, optional) \u2013 (New in version v2.21) For unsupervised projects only, list of detected actual value\ncolumns information containing missing count and name for each column.\ncontains_target_values (Optional[bool]) \u2013 (New in version v2.21)  Only for supervised projects. If True, dataset contains target\nvalues and can be used to calculate the classification metrics and insights.\nsecondary_datasets_config_id (string or None, optional) \u2013 (New in version v2.23) The Id of the alternative secondary dataset config\nto use during prediction for Feature discovery project.\nclassmethod get(project_id, dataset_id)\uf0c1\nRetrieve information about a dataset uploaded for predictions\nParameters:\nproject_id (str) \u2013 the id of the project to query\ndataset_id (str) \u2013 the id of the dataset to retrieve\nReturns:\ndataset \u2013 A dataset uploaded to make predictions\nReturn type:\nPredictionDataset\ndelete()\uf0c1\nDelete a dataset uploaded for predictions\nWill also delete predictions made using this dataset and cancel any predict jobs using\nthis dataset.\nReturn type:\nNone",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/database_connectivity.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.AVAILABLE_STATEMENT_TYPES",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.enums.TrainingDataSubsets",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.list()\n>>> definition\n[\n    BatchPredictionJobDefinition(60912e09fd1f04e832a575c1),\n    BatchPredictionJobDefinition(6086ba053f3ef731e81af3ca)\n]",
        ">>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 4,\n...    \"deployment_id\": \"foobar\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        16\n...    ],\n...    \"minute\": [\n...        0\n...    ],\n...    \"day_of_month\": [\n...        1\n...    ]\n...}\n>>> definition = BatchPredictionJobDefinition.create(\n...    enabled=False,\n...    batch_prediction_job=job_spec,\n...    name=\"some_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 5,\n...    \"deployment_id\": \"foobar_new\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\"\n...    },\n...}\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition = BatchPredictionJobDefinition.create(\n...    enabled=False,\n...    batch_prediction_job=job_spec,\n...    name=\"updated_definition_name\",\n...    schedule=schedule\n... )\n>>> definition\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.create('...')\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        \"*\"\n...    ],\n...    \"minute\": [\n...        30, 59\n...    ],\n...    \"day_of_month\": [\n...        1, 2, 6\n...    ]\n...}\n>>> definition.run_on_schedule(schedule)\nBatchPredictionJobDefinition(60912e09fd1f04e832a575c1)",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.create('...')\n>>> job = definition.run_once()\n>>> job.wait_for_completion()",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get('5a8ac9ab07a57a0001be501f')\n>>> definition.delete()",
        "datarobot.enums.QUEUE_STATUS"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/challenger-models.html",
      "title": "Challenger\uf0c1",
      "description": "A challenger is an alternative model being compared to the model currently deployed",
      "content": "Challenger\uf0c1\nclass datarobot.models.deployment.challenger.Challenger\uf0c1\nA challenger is an alternative model being compared to the model currently deployed\nVariables:\nid (str) \u2013 The ID of the challenger.\ndeployment_id (str) \u2013 The ID of the deployment.\nname (str) \u2013 The name of the challenger.\nmodel (dict) \u2013 The model of the challenger.\nmodel_package (dict) \u2013 The model package of the challenger.\nprediction_environment (dict) \u2013 The prediction environment of the challenger.\nclassmethod create(deployment_id, model_package_id, prediction_environment_id, name, max_wait=600)\uf0c1\nCreate a challenger for a deployment\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment\nmodel_package_id (str) \u2013 The model package id of the challenger model\nprediction_environment_id (str) \u2013 The prediction environment id of the challenger model\nname (str) \u2013 The name of the challenger model\nmax_wait (Optional[int]) \u2013 The amount of seconds to wait for successful resolution of a challenger creation job.\nReturn type:\nChallenger\nExamples\nfrom datarobot import Challenger\nchallenger = Challenger.create(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"Elastic-Net Classifier\",\nmodel_package_id=\"5c0a969859b00004ba52e41b\",\nprediction_environment_id=\"60b012436635fc00909df555\"\n)\nclassmethod get(deployment_id, challenger_id)\uf0c1\nGet a challenger for a deployment\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment\nchallenger_id (str) \u2013 The ID of the challenger\nReturns:\nThe challenger object\nReturn type:\nChallenger\nExamples\nfrom datarobot import Challenger\nchallenger = Challenger.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nchallenger_id=\"5c939e08962d741e34f609f0\"\n)\nchallenger.id\n>>>'5c939e08962d741e34f609f0'\nchallenger.model_package['name']\n>>> 'Elastic-Net Classifier'\nclassmethod list(deployment_id)\uf0c1\nList all challengers for a deployment\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment\nReturns:\nchallengers \u2013 A list of challenger objects\nReturn type:\nlist\nExamples\nfrom datarobot import Challenger\nchallengers = Challenger.list(deployment_id=\"5c939e08962d741e34f609f0\")\nchallengers[0].id\n>>>'5c939e08962d741e34f609f0'\nchallengers[0].model_package['name']\n>>> 'Elastic-Net Classifier'\ndelete()\uf0c1\nDelete a challenger for a deployment\nReturn type:\nNone\nupdate(name=None, prediction_environment_id=None)\uf0c1\nUpdate name and prediction environment of a challenger\nParameters:\nname (Optional[str]) \u2013 The name of the challenger model\nprediction_environment_id (Optional[str]) \u2013 The prediction environment id of the challenger model\nReturn type:\nNone\nclass datarobot.models.deployment.champion_model_package.ChampionModelPackage\uf0c1\nRepresents a champion model package.\nParameters:\nid (str) \u2013 The ID of the registered model version.\nregistered_model_id (str) \u2013 The ID of the parent registered model.\nregistered_model_version (int) \u2013 The version of the registered model.\nname (str) \u2013 The name of the registered model version.\nmodel_id (str) \u2013 The ID of the model.\nmodel_execution_type (str) \u2013 The type of model package (version). dedicated (native DataRobot models) and\ncustom_inference_model` (user added inference models) both execute on DataRobot\nprediction servers, while external does not.\nis_archived (bool) \u2013 Whether the model package (version) is permanently archived\n(cannot be used in deployment or replacement).\nimport_meta (ImportMeta) \u2013 Information from when this model package (version) was first saved.\nsource_meta (SourceMeta) \u2013 Meta information from where the model was generated.\nmodel_kind (ModelKind) \u2013 Model attribute information.\ntarget (Target) \u2013 Target information for the registered model version.\nmodel_description (ModelDescription) \u2013 Model description information.\ndatasets (Dataset) \u2013 Dataset information for the registered model version.\ntimeseries (Timeseries) \u2013 Time series information for the registered model version.\nbias_and_fairness (BiasAndFairness) \u2013 Bias and fairness information for the registered model version.\nis_deprecated (bool) \u2013 Whether the model package (version) is deprecated\n(cannot be used in deployment or replacement).\nbuild_status (str or None) \u2013 Model package (version) build status. One of complete, inProgress, failed.\nuser_provided_id (str or None) \u2013 User provided ID for the registered model version.\nupdated_at (str or None) \u2013 The time the registered model version was last updated.\nupdated_by (UserMetadata or None) \u2013 The user who last updated the registered model version.\ntags (List[TagWithId] or None) \u2013 The tags associated with the registered model version.\nmlpkg_file_contents (str or None) \u2013 The contents of the model package file.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot import Challenger\nchallenger = Challenger.create(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"Elastic-Net Classifier\",\n    model_package_id=\"5c0a969859b00004ba52e41b\",\n    prediction_environment_id=\"60b012436635fc00909df555\"\n)",
        "from datarobot import Challenger\nchallenger = Challenger.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    challenger_id=\"5c939e08962d741e34f609f0\"\n)\n\nchallenger.id\n>>>'5c939e08962d741e34f609f0'\nchallenger.model_package['name']\n>>> 'Elastic-Net Classifier'",
        "from datarobot import Challenger\nchallengers = Challenger.list(deployment_id=\"5c939e08962d741e34f609f0\")\n\nchallengers[0].id\n>>>'5c939e08962d741e34f609f0'\nchallengers[0].model_package['name']\n>>> 'Elastic-Net Classifier'"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/client-setup.html",
      "title": "Client setup\uf0c1",
      "description": "Configures the global API client for the Python SDK. The client will be configured in one of\nthe following ways, in order of priority.",
      "content": "Client setup\uf0c1\ndatarobot.client.Client(token=None, endpoint=None, config_path=None, connect_timeout=None, ssl_verify=None, max_retries=None, use_tcp_keepalive=None, token_type=None, default_use_case=None, enable_api_consumer_tracking=None, trace_context=None)\uf0c1\nConfigures the global API client for the Python SDK. The client will be configured in one of\nthe following ways, in order of priority.\nNotes\nToken and endpoint must be specified from one source only. This is a restriction\nto prevent token leakage if environment variables or config file are used.\nThe DataRobotClientConfig params will be looking up to find the configuration parameters\nin one of the following ways,\nFrom call kwargs if specified;\nFrom a YAML file at the path specified in the config_path kwarg;\nFrom a YAML file at the path specified in the environment variables DATAROBOT_CONFIG_FILE;\nFrom environment variables;\nFrom the default values in the default YAML file\nat the path $HOME/.config/datarobot/drconfig.yaml.\nThis can also have the side effect of setting a default Use Case for client API requests.\nParameters:\ntoken (Optional[str]) \u2013 API token.\nendpoint (Optional[str]) \u2013 Base URL of API.\nconfig_path (Optional[str]) \u2013 An alternate location of the config file.\nconnect_timeout (Optional[int]) \u2013 How long the client should be willing to wait before giving up on establishing\na connection with the server.\nssl_verify (bool or Optional[str]) \u2013 Whether to check SSL certificate.\nCould be set to path with certificates of trusted certification authorities. Default: True.\nmax_retries (int or urllib3.util.retry.Retry, optional) \u2013 Either an integer number of times to retry connection errors,\nor a urllib3.util.retry.Retry object to configure retries.\nuse_tcp_keepalive (Optional[bool]) \u2013 Enable TCP keepalive for the client. If None is set to True. Default: None.\ntoken_type (Optional[str]) \u2013 Authentication token type: Token, Bearer.\n\u201cBearer\u201d is for DataRobot OAuth2 token, \u201cToken\u201d for token generated in Developer Tools.\nDefault: \u201cToken\u201d.\ndefault_use_case (Optional[str]) \u2013 The entity ID of the default Use Case to use with any requests made by the client.\nenable_api_consumer_tracking (Optional[bool]) \u2013 Enable and disable user metrics tracking within the datarobot module. Default: False.\ntrace_context (Optional[str]) \u2013 An ID or other string for identifying which code template or AI Accelerator was used to make\na request.\nReturn type:\nRESTClientObject\nReturns:\nThe RESTClientObject instance created.\ndatarobot.client.get_client()\uf0c1\nReturns the global HTTP client for the Python SDK, instantiating it\nif necessary.\nReturn type:\nRESTClientObject\ndatarobot.client.set_client(client)\uf0c1\nConfigure the global HTTP client for the Python SDK.\nReturns previous instance.\nReturn type:\nOptional[RESTClientObject]\ndatarobot.client.client_configuration(*args, **kwargs)\uf0c1\nThis context manager can be used to temporarily change the global HTTP client.\nIn multithreaded scenarios, it is highly recommended to use a fresh manager object\nper thread.\nDataRobot does not recommend nesting these contexts.\nParameters:\nargs (Parameters passed to datarobot.client.Client())\nkwargs (Keyword arguments passed to datarobot.client.Client())\nExamples\nfrom datarobot.client import client_configuration\nfrom datarobot.models import Project\nwith client_configuration(default_use_case=[]):\n# Interact with all accessible projects, not just those associated\n# with the current use case.\nProject.list()\nwith client_configuration(token=\"api-key-here\", endpoint=\"https://host-name.com\"):\n# Interact with projects on a different DataRobot instance.\nProject.list()\nfrom datarobot.client import Client, client_configuration\nfrom datarobot.models import Project\nClient()  # Interact with DataRobot using the default configuration.\nProject.list()\nwith client_configuration(config_path=\"/path/to/a/drconfig.yaml\"):\n# Interact with DataRobot using a different configuration.\nProject.list()\nclass datarobot.rest.RESTClientObject\uf0c1\nParameters:\nconnect_timeout (Optional[int]) \u2013 timeout for http request and connection\nheaders \u2013 headers for outgoing requests\nopen_in_browser()\uf0c1\nOpens the DataRobot app in a web browser, or logs the\nURL if a browser is not available.\nReturn type:\nNone",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "DATAROBOT_CONFIG_FILE",
        "datarobot.client.Client()",
        "datarobot.client.Client()",
        "from datarobot.client import client_configuration\nfrom datarobot.models import Project\n\nwith client_configuration(default_use_case=[]):\n    # Interact with all accessible projects, not just those associated\n    # with the current use case.\n    Project.list()\n\nwith client_configuration(token=\"api-key-here\", endpoint=\"https://host-name.com\"):\n    # Interact with projects on a different DataRobot instance.\n    Project.list()",
        "from datarobot.client import Client, client_configuration\nfrom datarobot.models import Project\n\nClient()  # Interact with DataRobot using the default configuration.\nProject.list()\n\nwith client_configuration(config_path=\"/path/to/a/drconfig.yaml\"):\n    # Interact with DataRobot using a different configuration.\n    Project.list()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/blueprints.html",
      "title": "Blueprints\uf0c1",
      "description": "",
      "content": "Blueprints\uf0c1\nBlueprint\uf0c1\nclass datarobot.models.Blueprint\uf0c1\nA Blueprint which can be used to fit models\nVariables:\nid (str) \u2013 the id of the blueprint\nprocesses (List[str]) \u2013 the processes used by the blueprint\nmodel_type (str) \u2013 the model produced by the blueprint\nproject_id (str) \u2013 the project the blueprint belongs to\nblueprint_category (str) \u2013 (New in version v2.6) Describes the category of the blueprint and the kind of model it\nproduces.\nrecommended_featurelist_id (str or null) \u2013 (New in v2.18) The ID of the feature list recommended for this blueprint.\nIf this field is not present, then there is no recommended feature list.\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nwhether this blueprint is supported in the Composable ML.\nsupports_incremental_learning (bool or None) \u2013 (New in version v3.3)\nwhether this blueprint supports incremental learning.\nclassmethod get(project_id, blueprint_id)\uf0c1\nRetrieve a blueprint.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nblueprint_id (str) \u2013 Id of blueprint to retrieve.\nReturns:\nblueprint \u2013 The queried blueprint.\nReturn type:\nBlueprint\nget_json()\uf0c1\nGet the blueprint json representation used by this model.\nReturns:\nJson representation of the blueprint stages.\nReturn type:\nBlueprintJson\nget_chart()\uf0c1\nRetrieve a chart.\nReturns:\nThe current blueprint chart.\nReturn type:\nBlueprintChart\nget_documents()\uf0c1\nGet documentation for tasks used in the blueprint.\nReturns:\nAll documents available for blueprint.\nReturn type:\nlist of BlueprintTaskDocument\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nclass datarobot.models.BlueprintTaskDocument\uf0c1\nDocument describing a task from a blueprint.\nVariables:\ntitle (str) \u2013 Title of document.\ntask (str) \u2013 Name of the task described in document.\ndescription (str) \u2013 Task description.\nparameters (list of dict(name, type, description)) \u2013 Parameters that task can receive in human-readable format.\nlinks (list of dict(name, url)) \u2013 External links used in document\nreferences (list of dict(name, url)) \u2013 References used in document. When no link available url equals None.\nclass datarobot.models.BlueprintChart\uf0c1\nA Blueprint chart that can be used to understand data flow in blueprint.\nVariables:\nnodes (list of dict (id, label)) \u2013 Chart nodes, id unique in chart.\nedges (list of tuple (id1, id2)) \u2013 Directions of data flow between blueprint chart nodes.\nclassmethod get(project_id, blueprint_id)\uf0c1\nRetrieve a blueprint chart.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nblueprint_id (str) \u2013 Id of blueprint to retrieve chart.\nReturns:\nThe queried blueprint chart.\nReturn type:\nBlueprintChart\nto_graphviz()\uf0c1\nGet blueprint chart in graphviz DOT format.\nReturns:\nString representation of chart in graphviz DOT language.\nReturn type:\nunicode\nclass datarobot.models.ModelBlueprintChart\uf0c1\nA Blueprint chart that can be used to understand data flow in model.\nModel blueprint chart represents reduced repository blueprint chart with\nonly elements that used to build this particular model.\nVariables:\nnodes (list of dict (id, label)) \u2013 Chart nodes, id unique in chart.\nedges (list of tuple (id1, id2)) \u2013 Directions of data flow between blueprint chart nodes.\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve a model blueprint chart.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nmodel_id (str) \u2013 Id of model to retrieve model blueprint chart.\nReturns:\nThe queried model blueprint chart.\nReturn type:\nModelBlueprintChart\nto_graphviz()\uf0c1\nGet blueprint chart in graphviz DOT format.\nReturns:\nString representation of chart in graphviz DOT language.\nReturn type:\nunicode\nUser blueprints\uf0c1\nclass datarobot.UserBlueprint\uf0c1\nA representation of a blueprint which may be modified by the user,\nsaved to a user\u2019s AI Catalog, trained on projects, and shared with others.\nIt is recommended to install the python library called datarobot_bp_workshop,\navailable via pip, for the best experience when building blueprints.\nPlease refer to http://blueprint-workshop.datarobot.com for tutorials,\nexamples, and other documentation.\nParameters:\nblender (bool) \u2013 Whether the blueprint is a blender.\nblueprint_id (string) \u2013 The deterministic id of the blueprint, based on its content.\ncustom_task_version_metadata (list[list[string]], Optional) \u2013 An association of custom entity ids and task ids.\ndiagram (string) \u2013 The diagram used by the UI to display the blueprint.\nfeatures (list[string]) \u2013 A list of the names of tasks used in the blueprint.\nfeatures_text (string) \u2013 A description of the blueprint via the names of tasks used.\nhex_column_name_lookup (list[UserBlueprintsHexColumnNameLookupEntry], Optional) \u2013 A lookup between hex values and data column names used in the blueprint.\nicons (list[int]) \u2013 The icon(s) associated with the blueprint.\ninsights (string) \u2013 An indication of the insights generated by the blueprint.\nis_time_series (bool (Default=False)) \u2013 Whether the blueprint contains time-series tasks.\nmodel_type (string) \u2013 The generated or provided title of the blueprint.\nproject_id (string, Optional) \u2013 The id of the project the blueprint was originally created with, if applicable.\nreference_model (bool (Default=False)) \u2013 Whether the blueprint is a reference model.\nshap_support (bool (Default=False)) \u2013 Whether the blueprint supports shapley additive explanations.\nsupported_target_types (list[enum(``\u2019binary\u2019, ``'multiclass', 'multilabel', 'nonnegative',)\n'regression' \u2013 The list of supported targets of the current blueprint.\n'unsupervised' \u2013 The list of supported targets of the current blueprint.\n'unsupervisedclustering')] \u2013 The list of supported targets of the current blueprint.\nsupports_gpu (bool (Default=False)) \u2013 Whether the blueprint supports execution on the GPU.\nuser_blueprint_id (string) \u2013 The unique id associated with the user blueprint.\nuser_id (string) \u2013 The id of the user who owns the blueprint.\nblueprint (list[dict] or list[UserBlueprintTask], Optional) \u2013 The representation of a directed acyclic graph defining a pipeline of data through tasks\nand a final estimator.\nvertex_context (list[VertexContextItem], Optional) \u2013 Info about, warnings about, and errors with a specific vertex in the blueprint.\nblueprint_context (VertexContextItemMessages) \u2013 Warnings and errors which may describe or summarize warnings or errors in the blueprint\u2019s\nvertices\nclassmethod list(limit=100, offset=0, project_id=None)\uf0c1\nFetch a list of the user blueprints the current user created\nParameters:\nlimit (int (Default=100)) \u2013 The max number of results to return.\noffset (int (Default=0)) \u2013 The number of results to skip (for pagination).\nproject_id (string, Optional) \u2013 The id of the project, used to filter for original project_id.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nlist[UserBlueprint]\nclassmethod get(user_blueprint_id, project_id=None)\uf0c1\nRetrieve a user blueprint\nParameters:\nuser_blueprint_id (string) \u2013 Used to identify a specific user-owned blueprint.\nproject_id (string (optional, default is None)) \u2013 String representation of ObjectId for a given project. Used to validate selected\ncolumns in the user blueprint.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprint\nclassmethod create(blueprint, model_type=None, project_id=None, save_to_catalog=True)\uf0c1\nCreate a user blueprint\nParameters:\nblueprint (list[dict] or list[UserBlueprintTask]) \u2013 A list of tasks in the form of dictionaries which define a blueprint.\nmodel_type (string, Optional) \u2013 The title to give to the blueprint.\nproject_id (string, Optional) \u2013 The project associated with the blueprint. Necessary in the event of project specific\ntasks, such as column selection tasks.\nsave_to_catalog (bool, (Default=True)) \u2013 Whether the blueprint being created should be saved to the catalog.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprint\nclassmethod create_from_custom_task_version_id(custom_task_version_id, save_to_catalog=True, description=None)\uf0c1\nCreate a user blueprint with a single custom task version\nParameters:\ncustom_task_version_id (string) \u2013 Id of custom task version from which the user blueprint is created\nsave_to_catalog (bool, (Default=True)) \u2013 Whether the blueprint being created should be saved to the catalog\ndescription (string (Default=None)) \u2013 The description for the user blueprint that will be created from the\ncustom task version.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprint\nclassmethod clone_project_blueprint(blueprint_id, project_id, model_type=None, save_to_catalog=True)\uf0c1\nClone a blueprint from a project.\nParameters:\nblueprint_id (string) \u2013 The id associated with the blueprint to create the user blueprint from.\nmodel_type (string, Optional) \u2013 The title to give to the blueprint.\nproject_id (string) \u2013 The id of the project which the blueprint to copy comes from.\nsave_to_catalog (bool, (Default=True)) \u2013 Whether the blueprint being created should be saved to the catalog.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprint\nclassmethod clone_user_blueprint(user_blueprint_id, model_type=None, project_id=None, save_to_catalog=True)\uf0c1\nClone a user blueprint.\nParameters:\nmodel_type (string, Optional) \u2013 The title to give to the blueprint.\nproject_id (string, Optional) \u2013 String representation of ObjectId for a given project. Used to validate selected\ncolumns in the user blueprint.\nuser_blueprint_id (string) \u2013 The id of the existing user blueprint to copy.\nsave_to_catalog (bool, (Default=True)) \u2013 Whether the blueprint being created should be saved to the catalog.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprint\nclassmethod update(blueprint, user_blueprint_id, model_type=None, project_id=None, include_project_id_if_none=False)\uf0c1\nUpdate a user blueprint\nParameters:\nblueprint (list(dict) or list(UserBlueprintTask)) \u2013 A list of tasks in the form of dictionaries which define a blueprint.\nIf None, will not be passed.\nmodel_type (string, Optional) \u2013 The title to give to the blueprint. If None, will not be passed.\nproject_id (string, Optional) \u2013 The project associated with the blueprint. Necessary in the event of project specific\ntasks, such as column selection tasks.\nIf None, will not be passed. To explicitly pass None, pass True to\ninclude_project_id_if_none (useful if unlinking a blueprint from a project)\nuser_blueprint_id (string) \u2013 Used to identify a specific user-owned blueprint.\ninclude_project_id_if_none (bool (Default=False)) \u2013 Allows project_id to be passed as None, instead of ignored.\nIf set to False, will not pass project_id in the API request if it is set to None.\nIf True, the project id will be passed even if it is set to None.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprint\nclassmethod delete(user_blueprint_id)\uf0c1\nDelete a user blueprint, specified by the userBlueprintId.\nParameters:\nuser_blueprint_id (string) \u2013 Used to identify a specific user-owned blueprint.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nrequests.models.Response\nclassmethod get_input_types()\uf0c1\nRetrieve the input types which can be used with User Blueprints.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintAvailableInput\nclassmethod add_to_project(project_id, user_blueprint_ids)\uf0c1\nAdd a list of user blueprints, by id, to a specified (by id) project\u2019s repository.\nParameters:\nproject_id (string) \u2013 The projectId of the project for the repository to add the specified user blueprints\nto.\nuser_blueprint_ids (list(string) or string) \u2013 The ids of the user blueprints to add to the specified project\u2019s repository.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintAddToProjectMenu\nclassmethod get_available_tasks(project_id=None, user_blueprint_id=None)\uf0c1\nRetrieve the available tasks, organized into categories, which can be used to create or\nmodify User Blueprints.\nParameters:\nproject_id (string, Optional)\nuser_blueprint_id (string, Optional)\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintAvailableTasks\nclassmethod validate_task_parameters(output_method, task_code, task_parameters, project_id=None)\uf0c1\nValidate that each value assigned to specified task parameters are valid.\nParameters:\noutput_method (enum(``\u2019P\u2019, ``'Pm', 'S', 'Sm', 'T', 'TS')) \u2013 The method representing how the task will output data.\ntask_code (string) \u2013 The task code representing the task to validate parameter values.\ntask_parameters (list(UserBlueprintTaskParameterValidationRequestParamItem)) \u2013 A list of task parameters and proposed values to be validated.\nproject_id (string (optional, default is None)) \u2013 The projectId representing the project where this user blueprint is edited.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintValidateTaskParameters\nclassmethod list_shared_roles(user_blueprint_id, limit=100, offset=0, id=None, name=None, share_recipient_type=None)\uf0c1\nGet a list of users, groups and organizations that have an access to this user blueprint\nParameters:\nid (Optional[str]) \u2013 Only return the access control information for a organization, group or user with this\nID.\nlimit (int (Default=100)) \u2013 At most this many results are returned.\nname (string, Optional) \u2013 Only return the access control information for a organization, group or user with this\nname.\noffset (int (Default=0)) \u2013 This many results will be skipped.\nshare_recipient_type (enum(``\u2019user\u2019, ``'group', 'organization'), Optional) \u2013 Describes the recipient type, either user, group, or organization.\nuser_blueprint_id (str) \u2013 Used to identify a specific user-owned blueprint.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nlist[UserBlueprintSharedRolesResponseValidator]\nclassmethod validate_blueprint(blueprint, project_id=None)\uf0c1\nValidate a user blueprint and return information about the inputs expected and outputs\nprovided by each task.\nParameters:\nblueprint (list(dict) or list(UserBlueprintTask)) \u2013 The representation of a directed acyclic graph defining a pipeline of data through tasks\nand a final estimator.\nproject_id (string (optional, default is None)) \u2013 The projectId representing the project where this user blueprint is edited.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nlist[VertexContextItem]\nclassmethod update_shared_roles(user_blueprint_id, roles)\uf0c1\nShare a user blueprint with a user, group, or organization\nParameters:\nuser_blueprint_id (str) \u2013 Used to identify a specific user-owned blueprint.\nroles (list(or(GrantAccessControlWithUsernameValidator, GrantAccessControlWithIdValidator))) \u2013 Array of GrantAccessControl objects., up to maximum 100 objects.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nrequests.models.Response\nclassmethod search_catalog(search=None, tag=None, limit=100, offset=0, owner_user_id=None, owner_username=None, order_by='-created')\uf0c1\nFetch a list of the user blueprint catalog entries the current user has access to\nbased on an optional search term, tags, owner user info, or sort order.\nParameters:\nsearch (string, Optional.) \u2013 A value to search for in the dataset\u2019s name, description, tags, column names,\ncategories, and latest error. The search is case insensitive. If no value is provided\nfor this parameter, or if the empty string is used, or if the string contains only\nwhitespace, no filtering will be done. Partial matching is performed on dataset name\nand description fields while all other fields will only match if the search matches the\nwhole value exactly.\ntag (string, Optional.) \u2013 If provided, the results will be filtered to include only items with the specified tag.\nlimit (int, Optional. (default: 0), at most this many results are returned. To specify no) \u2013 limit, use 0. The default may change and a maximum limit may be imposed without notice.\noffset (int, Optional. (default: 0), this many results will be skipped.)\nowner_user_id (string, Optional.) \u2013 Filter results to those owned by one or more owner identified by UID.\nowner_username (string,  Optional.) \u2013 Filter results to those owned by one or more owner identified by username.\norder_by (string, Optional. Defaults to '-created') \u2013 Sort order which will be applied to catalog list, valid options are \u201ccatalogName\u201d,\n\u201coriginalName\u201d, \u201cdescription\u201d, \u201ccreated\u201d, and \u201crelevance\u201d. For all options other\nthan relevance, you may prefix the attribute name with a dash to sort\nin descending order. e.g. orderBy=\u2019-catalogName\u2019.\nReturn type:\nUserBlueprintCatalogSearch\nclass datarobot.models.user_blueprints.models.UserBlueprintAvailableInput\uf0c1\nRetrieve the input types which can be used with User Blueprints.\nParameters:\ninput_types (list(UserBlueprintsInputType)) \u2013 A list of associated pairs of an input types and their human-readable names.\nclassmethod get_input_types()\uf0c1\nRetrieve the input types which can be used with User Blueprints.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintAvailableInput\nclass datarobot.models.user_blueprints.models.UserBlueprintAddToProjectMenu\uf0c1\nAdd a list of user blueprints, by id, to a specified (by id) project\u2019s repository.\nParameters:\nadded_to_menu (list(UserBlueprintAddedToMenuItem)) \u2013 The list of userBlueprintId and blueprintId pairs representing blueprints successfully\nadded to the project repository.\nnot_added_to_menu (list(UserBlueprintNotAddedToMenuItem)) \u2013 The list of userBlueprintId and error message representing blueprints which failed to be\nadded to the project repository.\nmessage (string) \u2013 A success message or a list of reasons why the list of blueprints could not be added\nto the project repository.\nclassmethod add_to_project(project_id, user_blueprint_ids)\uf0c1\nAdd a list of user blueprints, by id, to a specified (by id) project\u2019s repository.\nParameters:\nproject_id (string) \u2013 The projectId of the project for the repository to add the specified user blueprints\nto.\nuser_blueprint_ids (list(string)) \u2013 The ids of the user blueprints to add to the specified project\u2019s repository.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintAddToProjectMenu\nclass datarobot.models.user_blueprints.models.UserBlueprintAvailableTasks\uf0c1\nRetrieve the available tasks, organized into categories, which can be used to create or modify\nUser Blueprints.\nParameters:\ncategories (list(UserBlueprintTaskCategoryItem)) \u2013 A list of the available task categories, sub-categories, and tasks.\ntasks (list(UserBlueprintTaskLookupEntry)) \u2013 A list of task codes and their task definitions.\nclassmethod get_available_tasks(project_id=None, user_blueprint_id=None)\uf0c1\nRetrieve the available tasks, organized into categories, which can be used to create or\nmodify User Blueprints.\nParameters:\nproject_id (string, Optional)\nuser_blueprint_id (string, Optional)\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintAvailableTasks\nclass datarobot.models.user_blueprints.models.UserBlueprintValidateTaskParameters\uf0c1\nValidate that each value assigned to specified task parameters are valid.\nParameters:\nerrors (list(UserBlueprintsValidateTaskParameter)) \u2013 A list of the task parameters, their proposed values, and messages describing why each is\nnot valid.\nclassmethod validate_task_parameters(output_method, task_code, task_parameters, project_id=None)\uf0c1\nValidate that each value assigned to specified task parameters are valid.\nParameters:\noutput_method (enum(``\u2019P\u2019, ``'Pm', 'S', 'Sm', 'T', 'TS')) \u2013 The method representing how the task will output data.\ntask_code (string) \u2013 The task code representing the task to validate parameter values.\ntask_parameters (list(UserBlueprintTaskParameterValidationRequestParamItem)) \u2013 A list of task parameters and proposed values to be validated.\nproject_id (string (optional, default is None)) \u2013 The projectId representing the project where this user blueprint is edited.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nUserBlueprintValidateTaskParameters\nclass datarobot.models.user_blueprints.models.UserBlueprintSharedRolesResponseValidator\uf0c1\nA list of SharedRoles objects.\nParameters:\nshare_recipient_type (enum(``\u2019user\u2019, ``'group', 'organization')) \u2013 Describes the recipient type, either user, group, or organization.\nrole (str, one of enum(``\u2019CONSUMER\u2019, ``'EDITOR', 'OWNER')) \u2013 The role of the org/group/user on this dataset or \u201cNO_ROLE\u201d for removing access when used\nwith route to modify access.\nid (str) \u2013 The ID of the recipient organization, group or user.\nname (string) \u2013 The name of the recipient organization, group or user.\nclass datarobot.models.user_blueprints.models.VertexContextItem\uf0c1\nInfo about, warnings about, and errors with a specific vertex in the blueprint.\nParameters:\ntask_id (string) \u2013 The id associated with a specific vertex in the blueprint.\ninformation (VertexContextItemInfo)\nmessages (VertexContextItemMessages)\nclass datarobot.models.user_blueprints.models.UserBlueprintCatalogSearch\uf0c1\nAn APIObject representing a user blueprint catalog entry the current\nuser has access to based on an optional search term and/or tags.\nParameters:\nid (str) \u2013 The ID of the catalog entry linked to the user blueprint.\ncatalog_name (str) \u2013 The name of the user blueprint.\ncreator (str) \u2013 The name of the user that created the user blueprint.\nuser_blueprint_id (str) \u2013 The ID of the user blueprint.\ndescription (Optional[str] (Default=None)) \u2013 The description of the user blueprint.\nlast_modifier_name (Optional[str] (Default=None)) \u2013 The name of the user that last modified the user blueprint.\nclassmethod search_catalog(search=None, tag=None, limit=100, offset=0, owner_user_id=None, owner_username=None, order_by='-created')\uf0c1\nFetch a list of the user blueprint catalog entries the current user has access to\nbased on an optional search term, tags, owner user info, or sort order.\nParameters:\nsearch (string, Optional.) \u2013 A value to search for in the dataset\u2019s name, description, tags, column names,\ncategories, and latest error. The search is case insensitive. If no value is provided\nfor this parameter, or if the empty string is used, or if the string contains only\nwhitespace, no filtering will be done. Partial matching is performed on dataset name\nand description fields while all other fields will only match if the search matches the\nwhole value exactly.\ntag (string, Optional.) \u2013 If provided, the results will be filtered to include only items with the specified tag.\nlimit (int, Optional. (default: 0), at most this many results are returned. To specify no) \u2013 limit, use 0. The default may change and a maximum limit may be imposed without notice.\noffset (int, Optional. (default: 0), this many results will be skipped.)\nowner_user_id (string, Optional.) \u2013 Filter results to those owned by one or more owner identified by UID.\nowner_username (string,  Optional.) \u2013 Filter results to those owned by one or more owner identified by username.\norder_by (string, Optional. Defaults to '-created') \u2013 Sort order which will be applied to catalog list, valid options are \u201ccatalogName\u201d,\n\u201coriginalName\u201d, \u201cdescription\u201d, \u201ccreated\u201d, and \u201crelevance\u201d. For all options other\nthan relevance, you may prefix the attribute name with a dash to sort\nin descending order. e.g. orderBy=\u2019-catalogName\u2019.\nReturn type:\nList[UserBlueprintCatalogSearch]\nCustom tasks\uf0c1\nclass datarobot.CustomTask\uf0c1\nA custom task. This can be in a partial state or a complete state.\nWhen the latest_version is None, the empty task has been initialized with\nsome metadata.  It is not yet use-able for actual training.  Once the first\nCustomTaskVersion has been created, you can put the CustomTask in UserBlueprints to\ntrain Models in Projects\nAdded in version v2.26.\nVariables:\nid (str) \u2013 id of the custom task\nname (str) \u2013 name of the custom task\nlanguage (str) \u2013 programming language of the custom task.\nCan be \u201cpython\u201d, \u201cr\u201d, \u201cjava\u201d or \u201cother\u201d\ndescription (str) \u2013 description of the custom task\ntarget_type (datarobot.enums.CUSTOM_TASK_TARGET_TYPE) \u2013 the target type of the custom task. One of:\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.BINARY\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.REGRESSION\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.MULTICLASS\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.ANOMALY\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.TRANSFORM\nlatest_version (datarobot.CustomTaskVersion or None) \u2013 latest version of the custom task if the task has a latest version. If the\nlatest version is None, the custom task is not ready for use in user blueprints.\nYou must create its first CustomTaskVersion before you can use the CustomTask\ncreated_by (str) \u2013 The username of the user who created the custom task.\nupdated_at (str) \u2013 An ISO-8601 formatted timestamp of when the custom task was updated.\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the custom task was created\ncalibrate_predictions (bool) \u2013 whether anomaly predictions should be calibrated to be between 0 and 1 by DR.\nonly applies to custom estimators with target type\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.ANOMALY\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nCustomTask\nclassmethod list(order_by=None, search_for=None)\uf0c1\nList custom tasks available to the user.\nAdded in version v2.26.\nParameters:\nsearch_for (Optional[str]) \u2013 string for filtering custom tasks - only tasks that contain the\nstring in name or description will be returned.\nIf not specified, all custom task will be returned\norder_by (Optional[str]) \u2013 property to sort custom tasks by.\nSupported properties are \u201ccreated\u201d and \u201cupdated\u201d.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. order_by=\u2019-created\u2019.\nBy default, the order_by parameter is None which will result in\ncustom tasks being returned in order of creation time descending\nReturns:\na list of custom tasks.\nReturn type:\nList[CustomTask]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(custom_task_id)\uf0c1\nGet custom task by id.\nAdded in version v2.26.\nParameters:\ncustom_task_id (str) \u2013 id of the custom task\nReturns:\nretrieved custom task\nReturn type:\nCustomTask\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nclassmethod copy(custom_task_id)\uf0c1\nCreate a custom task by copying existing one.\nAdded in version v2.26.\nParameters:\ncustom_task_id (str) \u2013 id of the custom task to copy\nReturn type:\nCustomTask\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create(name, target_type, language=None, description=None, calibrate_predictions=None, **kwargs)\uf0c1\nCreates only the metadata for a custom task.  This task will\nnot be use-able until you have created a CustomTaskVersion attached to this task.\nAdded in version v2.26.\nParameters:\nname (str) \u2013 name of the custom task\ntarget_type (datarobot.enums.CUSTOM_TASK_TARGET_TYPE) \u2013 the target typed based on the following values. Anything else will raise an error\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.BINARY\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.REGRESSION\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.MULTICLASS\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.ANOMALY\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.TRANSFORM\nlanguage (Optional[str]) \u2013 programming language of the custom task.\nCan be \u201cpython\u201d, \u201cr\u201d, \u201cjava\u201d or \u201cother\u201d\ndescription (Optional[str]) \u2013 description of the custom task\ncalibrate_predictions (Optional[bool]) \u2013 whether anomaly predictions should be calibrated to be between 0 and 1 by DR.\nif None, uses default value from DR app (True).\nonly applies to custom estimators with target type\ndatarobot.enums.CUSTOM_TASK_TARGET_TYPE.ANOMALY\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nCustomTask\nupdate(name=None, language=None, description=None, **kwargs)\uf0c1\nUpdate custom task properties.\nAdded in version v2.26.\nParameters:\nname (Optional[str]) \u2013 new custom task name\nlanguage (Optional[str]) \u2013 new custom task programming language\ndescription (Optional[str]) \u2013 new custom task description\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\nrefresh()\uf0c1\nUpdate custom task with the latest data from server.\n:rtype: None\nAdded in version v2.26.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndelete()\uf0c1\nDelete custom task.\n:rtype: None\nAdded in version v2.26.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndownload_latest_version(file_path)\uf0c1\nDownload the latest custom task version.\nAdded in version v2.26.\nParameters:\nfile_path (str) \u2013 the full path of the target zip file\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\nget_access_list()\uf0c1\nRetrieve access control settings of this custom task.\nAdded in version v2.27.\nReturn type:\nlist of SharingAccess\nshare(access_list)\uf0c1\nUpdate the access control settings of this custom task.\nAdded in version v2.27.\nParameters:\naccess_list (list of SharingAccess) \u2013 A list of SharingAccess to update.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nNone\nExamples\nTransfer access to the custom task from old_user@datarobot.com to new_user@datarobot.com\nimport datarobot as dr\nnew_access = dr.SharingAccess(new_user@datarobot.com,\ndr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\ndr.CustomTask.get('custom-task-id').share(access_list)\nclass datarobot.models.custom_task_version.CustomTaskFileItem\uf0c1\nA file item attached to a DataRobot custom task version.\nAdded in version v2.26.\nVariables:\nid (str) \u2013 id of the file item\nfile_name (str) \u2013 name of the file item\nfile_path (str) \u2013 path of the file item\nfile_source (str) \u2013 source of the file item\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the version was created\nclass datarobot.enums.CustomTaskOutboundNetworkPolicy\uf0c1\nThe way to set and view a CustomTaskVersions outbound network policy.\nclass datarobot.CustomTaskVersion\uf0c1\nA version of a DataRobot custom task.\nAdded in version v2.26.\nVariables:\nid (str) \u2013 id of the custom task version\ncustom_task_id (str) \u2013 id of the custom task\nversion_minor (int) \u2013 a minor version number of custom task version\nversion_major (int) \u2013 a major version number of custom task version\nlabel (str) \u2013 short human readable string to label the version\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the version was created\nis_frozen (bool) \u2013 a flag if the custom task version is frozen\nitems (List[CustomTaskFileItem]) \u2013 a list of file items attached to the custom task version\ndescription (Optional[str]) \u2013 custom task version description\nbase_environment_id (Optional[str]) \u2013 id of the environment to use with the task\nbase_environment_version_id (Optional[str]) \u2013 id of the environment version to use with the task\ndependencies (List[CustomDependency]) \u2013 the parsed dependencies of the custom task version if the\nversion has a valid requirements.txt file\nrequired_metadata_values (List[RequiredMetadataValue]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\narguments (List[UserBlueprintTaskArgument]) \u2013 A list of custom task version arguments.\noutbound_network_policy (CustomTaskOutboundNetworkPolicy)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nclassmethod create_clean(custom_task_id, base_environment_id, maximum_memory=None, is_major_update=True, folder_path=None, required_metadata_values=None, outbound_network_policy=None)\uf0c1\nCreate a custom task version without files from previous versions.\nAdded in version v2.26.\nParameters:\ncustom_task_id (str) \u2013 the id of the custom task\nbase_environment_id (str) \u2013 the id of the base environment to use with the custom task version\nmaximum_memory (Optional[int]) \u2013 A number in bytes about how much memory custom tasks\u2019 inference containers can run with.\nis_major_update (bool) \u2013 If the current version is 2.3, True would set the new version at 3.0.\nFalse would set the new version at 2.4.\nDefaults to True.\nfolder_path (Optional[str]) \u2013 The path to a folder containing files to be uploaded.\nEach file in the folder is uploaded under path relative\nto a folder path.\nrequired_metadata_values (Optional[List[RequiredMetadataValue]]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\noutbound_network_policy (Optional[CustomTaskOutboundNetworkPolicy]) \u2013 You must enable custom task network access permissions to pass any value other than None!\nSpecifies if you custom task version is able to make network calls. None will set the value\nto DataRobot\u2019s default.\nReturns:\ncreated custom task version\nReturn type:\nCustomTaskVersion\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create_from_previous(custom_task_id, base_environment_id, maximum_memory=None, is_major_update=True, folder_path=None, files_to_delete=None, required_metadata_values=None, outbound_network_policy=None)\uf0c1\nCreate a custom task version containing files from a previous version.\nAdded in version v2.26.\nParameters:\ncustom_task_id (str) \u2013 the id of the custom task\nbase_environment_id (str) \u2013 the id of the base environment to use with the custom task version\nmaximum_memory (Optional[int]) \u2013 A number in bytes about how much memory custom tasks\u2019 inference containers can run with.\nis_major_update (bool) \u2013 If the current version is 2.3, True would set the new version at 3.0.\nFalse would set the new version at 2.4.\nDefaults to True.\nfolder_path (Optional[str]) \u2013 The path to a folder containing files to be uploaded.\nEach file in the folder is uploaded under path relative\nto a folder path.\nfiles_to_delete (Optional[List[str]]) \u2013 the list of a file items ids to be deleted\nExample: [\u201c5ea95f7a4024030aba48e4f9\u201d, \u201c5ea6b5da402403181895cc51\u201d]\nrequired_metadata_values (Optional[List[RequiredMetadataValue]]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\noutbound_network_policy (Optional[CustomTaskOutboundNetworkPolicy]) \u2013 You must enable custom task network access permissions to pass any value other than None!\nSpecifies if you custom task version is able to make network calls. None will get the value\nfrom the previous version if you have the proper permissions or use DataRobot\u2019s default.\nReturns:\ncreated custom task version\nReturn type:\nCustomTaskVersion\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod list(custom_task_id)\uf0c1\nList custom task versions.\nAdded in version v2.26.\nParameters:\ncustom_task_id (str) \u2013 the id of the custom task\nReturns:\na list of custom task versions\nReturn type:\nList[CustomTaskVersion]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(custom_task_id, custom_task_version_id)\uf0c1\nGet custom task version by id.\nAdded in version v2.26.\nParameters:\ncustom_task_id (str) \u2013 the id of the custom task\ncustom_task_version_id (str) \u2013 the id of the custom task version to retrieve\nReturns:\nretrieved custom task version\nReturn type:\nCustomTaskVersion\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\ndownload(file_path)\uf0c1\nDownload custom task version.\nAdded in version v2.26.\nParameters:\nfile_path (str) \u2013 path to create a file with custom task version content\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(description=None, required_metadata_values=None)\uf0c1\nUpdate custom task version properties.\nAdded in version v2.26.\nParameters:\ndescription (str) \u2013 new custom task version description\nrequired_metadata_values (List[RequiredMetadataValue]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nrefresh()\uf0c1\nUpdate custom task version with the latest data from server.\nAdded in version v2.26.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nstart_dependency_build()\uf0c1\nStart the dependency build for a custom task version and return build status.\n.. versionadded:: v2.27\nReturns:\nDTO of custom task version dependency build.\nReturn type:\nCustomTaskVersionDependencyBuild\nstart_dependency_build_and_wait(max_wait)\uf0c1\nStart the dependency build for a custom task version and wait while pulling status.\n.. versionadded:: v2.27\nParameters:\nmax_wait (int) \u2013 max time to wait for a build completion\nReturns:\nDTO of custom task version dependency build.\nReturn type:\nCustomTaskVersionDependencyBuild\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndatarobot.errors.AsyncTimeoutError \u2013 Raised if the dependency build is not finished after max_wait.\ncancel_dependency_build()\uf0c1\nCancel custom task version dependency build that is in progress.\n.. versionadded:: v2.27\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nget_dependency_build()\uf0c1\nRetrieve information about a custom task version\u2019s dependency build.\n.. versionadded:: v2.27\nReturns:\nDTO of custom task version dependency build.\nReturn type:\nCustomTaskVersionDependencyBuild\ndownload_dependency_build_log(file_directory='.')\uf0c1\nGet log of a custom task version dependency build.\n.. versionadded:: v2.27\nParameters:\nfile_directory (str (optional, default is \".\")) \u2013 Directory path where downloaded file is to save.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nVisual AI\uf0c1\nclass datarobot.models.visualai.images.Image\uf0c1\nAn image stored in a project\u2019s dataset.\nVariables:\nid (str) \u2013 Image ID for this image.\nimage_type (str) \u2013 Image media type. Accessing this may require a server request\nand an associated delay in returning.\nimage_bytes (bytes) \u2013 Raw bytes of this image. Accessing this may require a server request\nand an associated delay in returning.\nheight (int) \u2013 Height of the image in pixels.\nwidth (int) \u2013 Width of the image in pixels.\nclassmethod get(project_id, image_id)\uf0c1\nGet a single image object from project.\nParameters:\nproject_id (str) \u2013 Id of the project that contains the images.\nimage_id (str) \u2013 ID of image to load from the project.\nReturn type:\nImage\nclass datarobot.models.visualai.images.SampleImage\uf0c1\nA sample image in a project\u2019s dataset.\nIf Project.stage is datarobot.enums.PROJECT_STAGE.EDA2 then\nthe target_* attributes of this class will have values, otherwise\nthe values will all be None.\nVariables:\nimage (Image) \u2013 Image object.\ntarget_value (TargetValue) \u2013 Value associated with the feature_name.\nproject_id (str) \u2013 Id of the project that contains the images.\nclassmethod list(project_id, feature_name, target_value=None, target_bin_start=None, target_bin_end=None, offset=None, limit=None)\uf0c1\nGet sample images from a project.\nParameters:\nproject_id (str) \u2013 Project that contains the images.\nfeature_name (str) \u2013 Name of feature column that contains images.\ntarget_value (TargetValue) \u2013 For classification projects - target value to filter images.\nPlease note that you can only use this parameter when the project has finished the EDA2\nstage.\ntarget_bin_start (Optional[Union[int, float]]) \u2013 For regression projects - only images corresponding to the target values above\n(inclusive) this value will be returned. Must be specified together with target_bin_end.\nPlease note that you can only use this parameter when the project has finished the EDA2\nstage.\ntarget_bin_end (Optional[Union[int, float]]) \u2013 For regression projects - only images corresponding to the target values below\n(exclusive) this value will be returned. Must be specified together with\ntarget_bin_start.\nPlease note that you can only use this parameter when the project has finished the EDA2\nstage.\noffset (Optional[int]) \u2013 Number of images to be skipped.\nlimit (Optional[int]) \u2013 Number of images to be returned.\nReturn type:\nList[SampleImage]\nclass datarobot.models.visualai.images.DuplicateImage\uf0c1\nAn image that was duplicated in the project dataset.\nVariables:\nimage (Image) \u2013 Image object.\ncount (int) \u2013 Number of times the image was duplicated.\nclassmethod list(project_id, feature_name, offset=None, limit=None)\uf0c1\nGet all duplicate images in a project.\nParameters:\nproject_id (str) \u2013 Project that contains the images.\nfeature_name (str) \u2013 Name of feature column that contains images.\noffset (Optional[int]) \u2013 Number of images to be skipped.\nlimit (Optional[int]) \u2013 Number of images to be returned.\nReturn type:\nList[DuplicateImage]\nclass datarobot.models.visualai.insights.ImageEmbedding\uf0c1\nVector representation of an image in an embedding space.\nA vector in an embedding space will allow linear computations to\nbe carried out between images: for example computing the Euclidean\ndistance of the images.\nVariables:\nimage (Image) \u2013 Image object used to create this map.\nfeature_name (str) \u2013 Name of the feature column this embedding is associated with.\nposition_x (int) \u2013 X coordinate of the image in the embedding space.\nposition_y (int) \u2013 Y coordinate of the image in the embedding space.\nactual_target_value (object) \u2013 Actual target value of the dataset row.\ntarget_values (Optional[List[str]]) \u2013 For classification projects, a list of target values of this project.\ntarget_bins (Optional[List[Dict[str, float]]]) \u2013 For regression projects, a list of target bins of this project.\nproject_id (str) \u2013 Id of the project this Image Embedding belongs to.\nmodel_id (str) \u2013 Id of the model this Image Embedding belongs to.\nclassmethod compute(project_id, model_id)\uf0c1\nStart the computation of image embeddings for the model.\nParameters:\nproject_id (str) \u2013 Project to start creation in.\nmodel_id (str) \u2013 Project\u2019s model to start creation in.\nReturns:\nURL to check for image embeddings progress.\nReturn type:\nstr\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected creation due to client error. Most likely\ncause is bad project_id or model_id.\nclassmethod models(project_id)\uf0c1\nFor a given project_id, list all model_id - feature_name pairs with available\nImage Embeddings.\nParameters:\nproject_id (str) \u2013 Id of the project to list model_id - feature_name pairs with available Image Embeddings\nfor.\nReturns:\nList of model and feature name pairs.\nReturn type:\nlist( tuple(model_id, feature_name) )\nclassmethod list(project_id, model_id, feature_name)\uf0c1\nReturn a list of ImageEmbedding objects.\nParameters:\nproject_id (str) \u2013 Id of the project the model belongs to.\nmodel_id (str) \u2013 Id of the model to list Image Embeddings for.\nfeature_name (str) \u2013 Name of feature column to list Image Embeddings for.\nReturn type:\nList[ImageEmbedding]\nclass datarobot.models.visualai.insights.ImageActivationMap\uf0c1\nMark areas of image with weight of impact on training.\nThis is a technique to display how various areas of the region were\nused in training, and their effect on predictions. Larger values in\nactivation_values indicates a larger impact.\nVariables:\nimage (Image) \u2013 Image object used to create this map.\noverlay_image (Image) \u2013 Image object containing the original image overlaid by the activation heatmap.\nfeature_name (str) \u2013 Name of the feature column that contains the value this map is based on.\nactivation_values (List[List[int]]) \u2013 A row-column matrix that contains the activation strengths for\nimage regions. Values are integers in the range [0, 255].\nactual_target_value (TargetValue) \u2013 Actual target value of the dataset row.\npredicted_target_value (TargetValue) \u2013 Predicted target value of the dataset row that contains this image.\ntarget_values (Optional[List[str]]) \u2013 For classification projects a list of target values of this project.\ntarget_bins (Optional[List[Dict[str, float]]]) \u2013 For regression projects a list of target bins.\nproject_id (str) \u2013 Id of the project this Activation Map belongs to.\nmodel_id (str) \u2013 Id of the model this Activation Map belongs to.\nclassmethod compute(project_id, model_id)\uf0c1\nStart the computation of activation maps for the given model.\nParameters:\nproject_id (str) \u2013 Project to start creation in.\nmodel_id (str) \u2013 Project\u2019s model to start creation in.\nReturns:\nURL to check for image embeddings progress.\nReturn type:\nstr\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected creation due to client error. Most likely\ncause is bad project_id or model_id.\nclassmethod models(project_id)\uf0c1\nFor a given project_id, list all model_id - feature_name pairs with available\nImage Activation Maps.\nParameters:\nproject_id (str) \u2013 Id of the project to list model_id - feature_name pairs with available\nImage Activation Maps for.\nReturns:\nList of model and feature name pairs.\nReturn type:\nlist( tuple(model_id, feature_name) )\nclassmethod list(project_id, model_id, feature_name, offset=None, limit=None)\uf0c1\nReturn a list of ImageActivationMap objects.\nParameters:\nproject_id (str) \u2013 Project that contains the images.\nmodel_id (str) \u2013 Model that contains the images.\nfeature_name (str) \u2013 Name of feature column that contains images.\noffset (Optional[int]) \u2013 Number of images to be skipped.\nlimit (Optional[int]) \u2013 Number of images to be returned.\nReturn type:\nList[ImageActivationMap]\nclass datarobot.models.visualai.augmentation.ImageAugmentationOptions\uf0c1\nA List of all supported Image Augmentation Transformations for a project.\nIncludes additional information about minimum, maximum, and default values\nfor a transformation.\nVariables:\nname (str) \u2013 The name of the augmentation list\nproject_id (str) \u2013 The project containing the image data to be augmented\nmin_transformation_probability (float) \u2013 The minimum allowed value for transformation probability.\ncurrent_transformation_probability (float) \u2013 Default setting for probability that each transformation will be applied to an image.\nmax_transformation_probability (float) \u2013 The maximum allowed value for transformation probability.\nmin_number_of_new_images (int) \u2013 The minimum allowed number of new rows to add for each existing row\ncurrent_number_of_new_images (int) \u2013 The default number of new rows to add for each existing row\nmax_number_of_new_images (int) \u2013 The maximum allowed number of new rows to add for each existing row\ntransformations (list[dict]) \u2013 List of transformations to possibly apply to each image\nclassmethod get(project_id)\uf0c1\nReturns a list of all supported transformations for the given\nproject\nParameters:\nproject_id (str) \u2013 sting\nThe id of the project for which to return the list of supported transformations.\nReturn type:\nImageAugmentationOptions\nReturns:\nImageAugmentationOptionsA list containing all the supported transformations for the project.\nclass datarobot.models.visualai.augmentation.ImageAugmentationList\uf0c1\nA List of Image Augmentation Transformations\nVariables:\nname (str) \u2013 The name of the augmentation list\nproject_id (str) \u2013 The project containing the image data to be augmented\nfeature_name (Optional[str]) \u2013 name of the feature that the augmentation list is associated with\nin_use (bool) \u2013 Whether this is the list that will passed in to every blueprint during blueprint generation\nbefore autopilot\ninitial_list (bool) \u2013 True if this is the list to be used during training to produce augmentations\ntransformation_probability (float) \u2013 Probability that each transformation will be applied to an image.  Value should be\nbetween 0.01 - 1.0.\nnumber_of_new_images (int) \u2013 Number of new rows to add for each existing row\ntransformations (List[Dict]) \u2013 List of transformations to possibly apply to each image\nsamples_id (str) \u2013 Id of last image augmentation sample generated for image augmentation list.\nclassmethod create(name, project_id, feature_name=None, initial_list=False, transformation_probability=0.0, number_of_new_images=1, transformations=None, samples_id=None)\uf0c1\ncreate a new image augmentation list\nReturn type:\nImageAugmentationList\nclassmethod list(project_id, feature_name=None)\uf0c1\nList Image Augmentation Lists present in a project.\nParameters:\nproject_id (str) \u2013 Project Id to retrieve augmentation lists for.\nfeature_name (Optional[str]) \u2013 If passed, the response will only include Image Augmentation Lists active for the\nprovided feature name.\nReturn type:\nlist[ImageAugmentationList]\nupdate(name=None, feature_name=None, initial_list=None, transformation_probability=None, number_of_new_images=None, transformations=None)\uf0c1\nUpdate one or multiple attributes of the Image Augmentation List in the DataRobot backend\nas well on this object.\nParameters:\nname (Optional[str]) \u2013 New name of the feature list.\nfeature_name (Optional[str]) \u2013 The new feature name for which the Image Augmentation List is effective.\ninitial_list (Optional[bool]) \u2013 New flag that indicates whether this list will be used during Autopilot to perform\nimage augmentation.\ntransformation_probability (Optional[float]) \u2013 New probability that each enabled transformation will be applied to an image.\nThis does not apply to Horizontal or Vertical Flip, which are always set to 50%.\nnumber_of_new_images (Optional[int]) \u2013 New number of new rows to add for each existing row, updating the existing augmentation\nlist.\ntransformations (Optional[list]) \u2013 New list of Transformations to possibly apply to each image.\nReturns:\nReference to self. The passed values will be updated in place.\nReturn type:\nImageAugmentationList\nretrieve_samples()\uf0c1\nLists already computed image augmentation sample for image augmentation list.\nReturns samples only if they have been already computed. It does not initialize computation.\nReturn type:\nList of class ImageAugmentationSample\ncompute_samples(max_wait=600)\uf0c1\nInitializes computation and retrieves list of image augmentation samples\nfor image augmentation list. If samples exited prior to this call method,\nthis will compute fresh samples and return latest version of samples.\nReturn type:\nList of class ImageAugmentationSample\nclass datarobot.models.visualai.augmentation.ImageAugmentationSample\uf0c1\nA preview of the type of images that augmentations will create during training.\nVariables:\nsample_id (ObjectId) \u2013 The id of the augmentation sample, used to group related images together\nimage_id (ObjectId) \u2013 A reference to the Image which can be used to retrieve the image binary\nproject_id (ObjectId) \u2013 A reference to the project containing the image\noriginal_image_id (ObjectId) \u2013 A reference to the original image that generated this image in the case of an augmented\nimage.  If this is None it signifies this is an original image\nheight (int) \u2013 Image height in pixels\nwidth (int) \u2013 Image width in pixels\nclassmethod list(auglist_id=None)\uf0c1\nReturn a list of ImageAugmentationSample objects.\nParameters:\nauglist_id (str) \u2013 ID for augmentation list to retrieve samples for\nReturn type:\nList of class ImageAugmentationSample",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot_bp_workshop",
        "http://blueprint-workshop.datarobot.com",
        "requests.models.Response",
        "UserBlueprintAddToProjectMenu",
        "requests.models.Response",
        "UserBlueprintAddToProjectMenu",
        "datarobot.enums.CUSTOM_TASK_TARGET_TYPE",
        "datarobot.CustomTaskVersion",
        "datarobot.enums.CUSTOM_TASK_TARGET_TYPE",
        "import datarobot as dr\n\nnew_access = dr.SharingAccess(new_user@datarobot.com,\n                              dr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\n\ndr.CustomTask.get('custom-task-id').share(access_list)",
        "datarobot.enums.PROJECT_STAGE.EDA2",
        "class ImageAugmentationSample",
        "class ImageAugmentationSample",
        "class ImageAugmentationSample"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/compliance-documentation.html",
      "title": "Compliance Documentation\uf0c1",
      "description": "",
      "content": "Compliance Documentation\uf0c1\nAutomated documentation\uf0c1\nclass datarobot.models.automated_documentation.AutomatedDocument\uf0c1\nAn automated documentation object.\nAdded in version v2.24.\nVariables:\ndocument_type (str or None) \u2013 Type of automated document. You can specify: MODEL_COMPLIANCE, AUTOPILOT_SUMMARY\ndepending on your account settings. Required for document generation.\nentity_id (str or None) \u2013 ID of the entity to generate the document for. It can be model ID or project ID.\nRequired for document generation.\noutput_format (str or None) \u2013 Format of the generate document, either docx or html.\nRequired for document generation.\nlocale (str or None) \u2013 Localization of the document, dependent on your account settings.\nDefault setting is EN_US.\ntemplate_id (str or None) \u2013 Template ID to use for the document outline. Defaults to standard DataRobot template.\nSee the documentation for ComplianceDocTemplate for more information.\nid (str or None) \u2013 ID of the document. Required to download or delete a document.\nfilepath (str or None) \u2013 Path to save a downloaded document to. Either include a file path and name or the file\nwill be saved to the directory from which the script is launched.\ncreated_at (datetime or None) \u2013 Document creation timestamp.\nclassmethod list_available_document_types(cls)\uf0c1\nGet a list of all available document types and locales. This method is deprecated.\nReturns:\n{\u201cdata\u201d: List of dicts}\nReturn type:\nList[DocumentOption]\nExamples\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc_types = dr.AutomatedDocument.list_available_document_types()\nclassmethod list_all_available_document_types()\uf0c1\nGet a list of all available document types and locales.\nThis method is direct replacement of list_available_document_types().\nReturn type:\nList of dicts\nExamples\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc_types = dr.AutomatedDocument.list_all_available_document_types()\nproperty is_model_compliance_initialized: Tuple[bool, str]\uf0c1\nCheck if model compliance documentation pre-processing is initialized.\nModel compliance documentation pre-processing must be initialized before\ngenerating documentation for a custom model.\nReturns:\nboolean flag is whether model compliance documentation pre-processing is initialized\nstring value is the initialization status\nReturn type:\nTuple of (boolean, string)\ninitialize_model_compliance()\uf0c1\nInitialize model compliance documentation pre-processing.\nMust be called before generating documentation for a custom model.\nReturns:\nboolean flag is whether model compliance documentation pre-processing is initialized\nstring value is the initialization status\nReturn type:\nTuple of (boolean, string)\nExamples\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\n# NOTE: entity_id is either a model id or a model package (version) id\ndoc = dr.AutomatedDocument(\ndocument_type=\"MODEL_COMPLIANCE\",\nentity_id=\"6f50cdb77cc4f8d1560c3ed5\",\noutput_format=\"docx\",\nlocale=\"EN_US\")\ndoc.initialize_model_compliance()\ngenerate(max_wait=600)\uf0c1\nRequest generation of an automated document.\nRequired attributes to request document generation: document_type, entity_id,\nand output_format.\nReturn type:\nrequests.models.Response\nExamples\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(\ndocument_type=\"MODEL_COMPLIANCE\",\nentity_id=\"6f50cdb77cc4f8d1560c3ed5\",\noutput_format=\"docx\",\nlocale=\"EN_US\",\ntemplate_id=\"50efc9db8aff6c81a374aeec\",\nfilepath=\"/Users/username/Documents/example.docx\"\n)\ndoc.generate()\ndoc.download()\ndownload()\uf0c1\nDownload a generated Automated Document.\nDocument ID is required to download a file.\nReturn type:\nrequests.models.Response\nExamples\nGenerating and downloading the generated document:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(\ndocument_type=\"AUTOPILOT_SUMMARY\",\nentity_id=\"6050d07d9da9053ebb002ef7\",\noutput_format=\"docx\",\nfilepath=\"/Users/username/Documents/Project_Report_1.docx\"\n)\ndoc.generate()\ndoc.download()\nDownloading an earlier generated document when you know the document ID:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(id='5e8b6a34d2426053ab9a39ed')\ndoc.download()\nNotice that filepath was not set for this document. In this case, the file is saved\nto the directory from which the script was launched.\nDownloading a document chosen from a list of earlier generated documents:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nmodel_id = \"6f5ed3de855962e0a72a96fe\"\ndocs = dr.AutomatedDocument.list_generated_documents(entity_ids=[model_id])\ndoc = docs[0]\ndoc.filepath = \"/Users/me/Desktop/Recommended_model_doc.docx\"\ndoc.download()\ndelete()\uf0c1\nDelete a document using its ID.\nReturn type:\nrequests.models.Response\nExamples\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(id=\"5e8b6a34d2426053ab9a39ed\")\ndoc.delete()\nIf you don\u2019t know the document ID, you can follow the same workflow to get the ID as in\nthe examples for the AutomatedDocument.download method.\nclassmethod list_generated_documents(document_types=None, entity_ids=None, output_formats=None, locales=None, offset=None, limit=None)\uf0c1\nGet information about all previously generated documents available for your account. The\ninformation includes document ID and type, ID of the entity it was generated for, time of\ncreation, and other information.\nParameters:\ndocument_types (List of str or None) \u2013 Query for one or more document types.\nentity_ids (List of str or None) \u2013 Query generated documents by one or more entity IDs.\noutput_formats (List of str or None) \u2013 Query for one or more output formats.\nlocales (List of str or None) \u2013 Query generated documents by one or more locales.\noffset (int or None) \u2013 Number of items to skip. Defaults to 0 if not provided.\nlimit (int or None) \u2013 Number of items to return, maximum number of items is 1000.\nReturn type:\nList[AutomatedDocument]\nReturns:\nList of AutomatedDocument objects, where each object contains attributes described in\nAutomatedDocument\nExamples\nTo get a list of all generated documents:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents()\nTo get a list of all AUTOPILOT_SUMMARY documents:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents(document_types=[\"AUTOPILOT_SUMMARY\"])\nTo get a list of 5 recently created automated documents in html format:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents(output_formats=[\"html\"], limit=5)\nTo get a list of automated documents created for specific entities (projects or models):\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents(\nentity_ids=[\"6051d3dbef875eb3be1be036\",\n\"6051d3e1fbe65cd7a5f6fde6\",\n\"6051d3e7f86c04486c2f9584\"]\n)\nNote, that the list of results contains AutomatedDocument objects, which means that you\ncan execute class-related methods on them. Here\u2019s how you can list, download, and then\ndelete from the server all automated documents related to a certain entity:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nids = [\"6051d3dbef875eb3be1be036\", \"5fe1d3d55cd810ebdb60c517f\"]\ndocs = AutomatedDocument.list_generated_documents(entity_ids=ids)\nfor doc in docs:\ndoc.download()\ndoc.delete()\nclass datarobot.models.automated_documentation.DocumentOption\uf0c1\nCompliance documentation templates\uf0c1\nclass datarobot.models.compliance_doc_template.ComplianceDocTemplate\uf0c1\nA compliance documentation template. Templates\nare used to customize contents of AutomatedDocument.\nAdded in version v2.14.\nNotes\nEach section dictionary has the following schema:\ntitle : title of the section\ntype : type of section. Must be one of \u201cdatarobot\u201d, \u201cuser\u201d or \u201ctable_of_contents\u201d.\nEach type of section has a different set of attributes described bellow.\nSection of type \"datarobot\" represent a section owned by DataRobot. DataRobot\nsections have the following additional attributes:\ncontent_id : The identifier of the content in this section.\nYou can get the default template with get_default\nfor a complete list of possible DataRobot section content ids.\nsections :  list of sub-section dicts nested under the parent section.\nSection of type \"user\" represent a section with user-defined content.\nThose sections may contain text generated by user and have the following additional fields:\nregularText : regular text of the section, optionally separated by\n\\n to split paragraphs.\nhighlightedText : highlighted text of the section, optionally separated\nby \\n to split paragraphs.\nsections :  list of sub-section dicts nested under the parent section.\nSection of type \"table_of_contents\" represent a table of contents and has\nno additional attributes.\nVariables:\nid (str) \u2013 The ID of the template.\nname (str) \u2013 The name of the template.\ncreator_id (str) \u2013 The ID of the user who created the template.\ncreator_username (str) \u2013 The username of the user who created the template.\norg_id (str) \u2013 The ID of the organization the template belongs to.\nsections (list of dicts) \u2013 The sections of the template describing the structure of the document. The section schema\nis described in Notes section, above.\nproject_type (ComplianceDocTemplateProjectType) \u2013 The project type of the template.\nclassmethod get_default(template_type=None)\uf0c1\nGet a default DataRobot template. This template is used for generating\ncompliance documentation when no template is specified.\nParameters:\ntemplate_type (str or None) \u2013 Type of the template. Currently supported values are \u201cnormal\u201d and \u201ctime_series\u201d\nReturns:\ntemplate \u2013 the default template object with sections attribute populated with default sections.\nReturn type:\nComplianceDocTemplate\nclassmethod create_from_json_file(name, path, project_type=None)\uf0c1\nCreate a template with the specified name and sections in a JSON file.\nThis is useful when working with sections in a JSON file. Example:\ndefault_template = ComplianceDocTemplate.get_default()\ndefault_template.sections_to_json_file('path/to/example.json')\n# ... edit example.json in your editor\nmy_template = ComplianceDocTemplate.create_from_json_file(\nname='my template',\npath='path/to/example.json'\n)\nParameters:\nname (str) \u2013 the name of the template, which must be unique.\npath (str) \u2013 the path to find the JSON file at\nproject_type (ComplianceDocTemplateProjectType) \u2013 The project type of the template.\nReturns:\ntemplate \u2013 The created template.\nReturn type:\nComplianceDocTemplate\nclassmethod create(name, sections, project_type=None)\uf0c1\nCreate a template with the specified name and sections.\nParameters:\nname (str) \u2013 The name of the template, which must be unique.\nsections (list) \u2013 List of section objects\nproject_type (ComplianceDocTemplateProjectType) \u2013 The project type of the template.\nReturns:\ntemplate \u2013 The created template.\nReturn type:\nComplianceDocTemplate\nclassmethod get(template_id)\uf0c1\nRetrieve a specific template.\nParameters:\ntemplate_id (str) \u2013 the id of the template to retrieve\nReturns:\ntemplate \u2013 the retrieved template\nReturn type:\nComplianceDocTemplate\nclassmethod list(name_part=None, limit=None, offset=None, project_type=None)\uf0c1\nGet a paginated list of compliance documentation template objects.\nParameters:\nname_part (str or None) \u2013 Return only the templates with names matching specified string. The matching is\ncase-insensitive.\nlimit (int) \u2013 The number of records to return. The server will use a (possibly finite) default if not\nspecified.\noffset (int) \u2013 The number of records to skip.\nproject_type (ComplianceDocTemplateProjectType) \u2013 The project type of the template.\nReturns:\ntemplates \u2013 The list of template objects.\nReturn type:\nlist of ComplianceDocTemplate\nsections_to_json_file(path, indent=2)\uf0c1\nSave sections of the template to a json file at the specified path\nParameters:\npath (str) \u2013 the path to save the file to\nindent (int) \u2013 indentation to use in the json file.\nReturn type:\nNone\nupdate(name=None, sections=None, project_type=None)\uf0c1\nUpdate the name or sections of an existing doc template.\nNote that default or non-existent templates can not be updated.\nParameters:\nname (Optional[str]) \u2013 the new name for the template\nsections (list of dicts) \u2013 The list of sections within the template.\nproject_type (ComplianceDocTemplateProjectType) \u2013 The project type of the template\nReturn type:\nNone\ndelete()\uf0c1\nDelete the compliance documentation template.\nReturn type:\nNone\nclass datarobot.enums.ComplianceDocTemplateProjectType\uf0c1\nThe project type supported by the template.\nclass datarobot.enums.ComplianceDocTemplateType\uf0c1\nThe type of default template and sections to create a template.\nclassmethod to_project_type(template_type)\uf0c1\nMap from template type to project type supported by the template.\nReturn type:\nOptional[ComplianceDocTemplateProjectType]",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/automated_documentation.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndoc_types = dr.AutomatedDocument.list_available_document_types()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndoc_types = dr.AutomatedDocument.list_all_available_document_types()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\n# NOTE: entity_id is either a model id or a model package (version) id\ndoc = dr.AutomatedDocument(\n        document_type=\"MODEL_COMPLIANCE\",\n        entity_id=\"6f50cdb77cc4f8d1560c3ed5\",\n        output_format=\"docx\",\n        locale=\"EN_US\")\n\ndoc.initialize_model_compliance()",
        "requests.models.Response",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ndoc = dr.AutomatedDocument(\n        document_type=\"MODEL_COMPLIANCE\",\n        entity_id=\"6f50cdb77cc4f8d1560c3ed5\",\n        output_format=\"docx\",\n        locale=\"EN_US\",\n        template_id=\"50efc9db8aff6c81a374aeec\",\n        filepath=\"/Users/username/Documents/example.docx\"\n        )\n\ndoc.generate()\ndoc.download()",
        "requests.models.Response",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ndoc = dr.AutomatedDocument(\n        document_type=\"AUTOPILOT_SUMMARY\",\n        entity_id=\"6050d07d9da9053ebb002ef7\",\n        output_format=\"docx\",\n        filepath=\"/Users/username/Documents/Project_Report_1.docx\"\n        )\n\ndoc.generate()\ndoc.download()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(id='5e8b6a34d2426053ab9a39ed')\ndoc.download()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nmodel_id = \"6f5ed3de855962e0a72a96fe\"\ndocs = dr.AutomatedDocument.list_generated_documents(entity_ids=[model_id])\ndoc = docs[0]\ndoc.filepath = \"/Users/me/Desktop/Recommended_model_doc.docx\"\ndoc.download()",
        "requests.models.Response",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(id=\"5e8b6a34d2426053ab9a39ed\")\ndoc.delete()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents(document_types=[\"AUTOPILOT_SUMMARY\"])",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents(output_formats=[\"html\"], limit=5)",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = AutomatedDocument.list_generated_documents(\n    entity_ids=[\"6051d3dbef875eb3be1be036\",\n                \"6051d3e1fbe65cd7a5f6fde6\",\n                \"6051d3e7f86c04486c2f9584\"]\n    )",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nids = [\"6051d3dbef875eb3be1be036\", \"5fe1d3d55cd810ebdb60c517f\"]\ndocs = AutomatedDocument.list_generated_documents(entity_ids=ids)\nfor doc in docs:\n    doc.download()\n    doc.delete()",
        "ComplianceDocTemplateProjectType",
        "ComplianceDocTemplateProjectType",
        "ComplianceDocTemplateProjectType",
        "ComplianceDocTemplateProjectType",
        "ComplianceDocTemplateProjectType",
        "ComplianceDocTemplateProjectType"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/credentials.html",
      "title": "Credentials\uf0c1",
      "description": "",
      "content": "Credentials\uf0c1\nclass datarobot.models.Credential\uf0c1\nclassmethod list()\uf0c1\nReturns list of available credentials.\nReturns:\ncredentials \u2013 contains a list of available credentials.\nReturn type:\nlist of Credential instances\nExamples\n>>> import datarobot as dr\n>>> data_sources = dr.Credential.list()\n>>> data_sources\n[\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),\nCredential('5e42cc4dcf8a5f3256865840', 'my_jdbc_cred', 'jdbc'),\n]\nclassmethod get(credential_id)\uf0c1\nGets the Credential.\nParameters:\ncredential_id (str) \u2013 the identifier of the credential.\nReturns:\ncredential \u2013 the requested credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),\ndelete()\uf0c1\nDeletes the Credential the store.\nParameters:\ncredential_id (str) \u2013 the identifier of the credential.\nReturns:\ncredential \u2013 the requested credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n>>> cred.delete()\nclassmethod create_basic(name, user, password, description=None)\uf0c1\nCreates the credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\nuser (str) \u2013 the username to store for this set of credentials.\npassword (str) \u2013 the password to store for this set of credentials.\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_basic(\n...     name='my_basic_cred',\n...     user='username',\n...     password='password',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_basic_cred', 'basic'),\nclassmethod create_oauth(name, token, refresh_token, description=None)\uf0c1\nCreates the OAUTH credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\ntoken (str) \u2013 the OAUTH token\nrefresh_token (str) \u2013 The OAUTH token\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_oauth(\n...     name='my_oauth_cred',\n...     token='XXX',\n...     refresh_token='YYY',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_oauth_cred', 'oauth'),\nclassmethod create_s3(name, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None, config_id=None, description=None)\uf0c1\nCreates the S3 credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\naws_access_key_id (Optional[str]) \u2013 the AWS access key id.\naws_secret_access_key (Optional[str]) \u2013 the AWS secret access key.\naws_session_token (Optional[str]) \u2013 the AWS session token.\nconfig_id (Optional[str]) \u2013 The ID of the saved shared secure configuration. If specified, cannot include awsAccessKeyId,\nawsSecretAccessKey or awsSessionToken.\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_s3(\n...     name='my_s3_cred',\n...     aws_access_key_id='XXX',\n...     aws_secret_access_key='YYY',\n...     aws_session_token='ZZZ',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),\nclassmethod create_azure(name, azure_connection_string, description=None)\uf0c1\nCreates the Azure storage credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\nazure_connection_string (str) \u2013 the Azure connection string.\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_azure(\n...     name='my_azure_cred',\n...     azure_connection_string='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_azure_cred', 'azure'),\nclassmethod create_snowflake_key_pair(name, user=None, private_key=None, passphrase=None, config_id=None, description=None)\uf0c1\nCreates the Snowflake Key Pair credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\nuser (Optional[str]) \u2013 the Snowflake login name\nprivate_key (Optional[str]) \u2013 the private key copied exactly from user private key file. Since it contains multiple\nlines, when assign to a variable, put the key string inside triple-quotes\npassphrase (Optional[str]) \u2013 the string used to encrypt the private key\nconfig_id (Optional[str]) \u2013 The ID of the saved shared secure configuration. If specified, cannot include user,\nprivateKeyStr or passphrase.\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_snowflake_key_pair(\n...     name='key_pair_cred',\n...     user='XXX',\n...     private_key='YYY',\n...     passphrase='ZZZ',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'key_pair_cred', 'snowflake_key_pair_user_account'),\nclassmethod create_databricks_access_token(name, databricks_access_token, description=None)\uf0c1\nCreates the Databricks access token credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\ndatabricks_access_token (Optional[str]) \u2013 the Databricks personal access token\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_access_token(\n...     name='access_token_cred',\n...     databricks_access_token='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'access_token_cred', 'databricks_access_token_account'),\nclassmethod create_databricks_service_principal(name, client_id=None, client_secret=None, config_id=None, description=None)\uf0c1\nCreates the Databricks access token credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\nclient_id (Optional[str]) \u2013 the client ID for Databricks Service Principal\nclient_secret (Optional[str]) \u2013 the client secret for Databricks Service Principal\nconfig_id (Optional[str]) \u2013 The ID of the saved shared secure configuration. If specified, cannot include clientId\nand clientSecret.\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_service_principal(\n...     name='svc_principal_cred',\n...     client_id='XXX',\n...     client_secret='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'svc_principal_cred', 'databricks_service_principal_account'),\nclassmethod create_azure_service_principal(name, client_id=None, client_secret=None, azure_tenant_id=None, config_id=None, description=None)\uf0c1\nCreates the Azure service principal credentials.\nParameters:\nname (str) \u2013 The name to use for these credentials.\nclient_id (Optional[str]) \u2013 The client ID.\nclient_secret (Optional[str]) \u2013 The client secret.\nazure_tenant_id (Optional[str]) \u2013 The Azure tenant ID.\nconfig_id (Optional[str]) \u2013 The ID of the saved secure configuration. If specified, the ID cannot include clientId,\nclientSecret, or azureTenantId.\ndescription (Optional[str]) \u2013 The description to use for these credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_azure_service_principal(\n...     name='my_azure_service_principal_cred',\n...     client_id='XXX',\n...     client_secret='YYY',\n...     azure_tenant_id='ZZZ',\n... )\n>>> cred\nCredential('66c9172d8b7a361cda126f5c', 'my_azure_service_principal_cred', 'azure_service_principal')\nclassmethod create_adls_oauth(name, client_id=None, client_secret=None, oauth_scopes=None, config_id=None, description=None)\uf0c1\nCreates the ADLS OAuth credentials.\nParameters:\nname (str) \u2013 The name to use for these credentials.\nclient_id (Optional[str]) \u2013 The client ID.\nclient_secret (Optional[str]) \u2013 The client secret.\noauth_scopes (List[str], optional) \u2013 The OAuth scopes.\nconfig_id (Optional[str]) \u2013 The ID of the saved shared secure configuration. If specified, cannot include clientId,\nclientSecret, or oauthScopes.\ndescription (Optional[str]) \u2013 The description to use for the ADLS OAuth credentials.\nReturns:\ncredential \u2013 The created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_adls_oauth(\n...     name='my_adls_oauth_cred',\n...     client_id='XXX',\n...     client_secret='YYY',\n...     oauth_scopes=['ZZZ'],\n... )\n>>> cred\nCredential('66c91e0f03010d4790735220', 'my_adls_oauth_cred', 'adls_gen2_oauth')\nclassmethod create_gcp(name, gcp_key=None, description=None)\uf0c1\nCreates the GCP credentials.\nParameters:\nname (str) \u2013 the name to use for this set of credentials.\ngcp_key (str | dict) \u2013 the GCP key in json format or parsed as dict.\ndescription (Optional[str]) \u2013 the description to use for this set of credentials.\nReturns:\ncredential \u2013 the created credential.\nReturn type:\nCredential\nExamples\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_gcp(\n...     name='my_gcp_cred',\n...     gcp_key='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_gcp_cred', 'gcp'),\nupdate(name=None, description=None, **kwargs)\uf0c1\nUpdate the credential values of an existing credential. Updates this object in place.\nAdded in version v3.2.\nParameters:\nname (str) \u2013 The name to use for this set of credentials.\ndescription (Optional[str]) \u2013 The description to use for this set of credentials; if omitted, and name is not\nomitted, then it clears any previous description for that name.\nkwargs (Keyword arguments specific to the given credential_type that should be updated.)\nReturn type:\nNone",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        ">>> import datarobot as dr\n>>> data_sources = dr.Credential.list()\n>>> data_sources\n[\n    Credential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),\n    Credential('5e42cc4dcf8a5f3256865840', 'my_jdbc_cred', 'jdbc'),\n]",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n>>> cred.delete()",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_basic(\n...     name='my_basic_cred',\n...     user='username',\n...     password='password',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_basic_cred', 'basic'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_oauth(\n...     name='my_oauth_cred',\n...     token='XXX',\n...     refresh_token='YYY',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_oauth_cred', 'oauth'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_s3(\n...     name='my_s3_cred',\n...     aws_access_key_id='XXX',\n...     aws_secret_access_key='YYY',\n...     aws_session_token='ZZZ',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_azure(\n...     name='my_azure_cred',\n...     azure_connection_string='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_azure_cred', 'azure'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_snowflake_key_pair(\n...     name='key_pair_cred',\n...     user='XXX',\n...     private_key='YYY',\n...     passphrase='ZZZ',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'key_pair_cred', 'snowflake_key_pair_user_account'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_access_token(\n...     name='access_token_cred',\n...     databricks_access_token='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'access_token_cred', 'databricks_access_token_account'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_service_principal(\n...     name='svc_principal_cred',\n...     client_id='XXX',\n...     client_secret='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'svc_principal_cred', 'databricks_service_principal_account'),",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_azure_service_principal(\n...     name='my_azure_service_principal_cred',\n...     client_id='XXX',\n...     client_secret='YYY',\n...     azure_tenant_id='ZZZ',\n... )\n>>> cred\nCredential('66c9172d8b7a361cda126f5c', 'my_azure_service_principal_cred', 'azure_service_principal')",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_adls_oauth(\n...     name='my_adls_oauth_cred',\n...     client_id='XXX',\n...     client_secret='YYY',\n...     oauth_scopes=['ZZZ'],\n... )\n>>> cred\nCredential('66c91e0f03010d4790735220', 'my_adls_oauth_cred', 'adls_gen2_oauth')",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_gcp(\n...     name='my_gcp_cred',\n...     gcp_key='XXX',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_gcp_cred', 'gcp'),"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/custom-metrics.html",
      "title": "Custom metrics\uf0c1",
      "description": "",
      "content": "Custom metrics\uf0c1\nclass datarobot.models.deployment.custom_metrics.CustomMetric\uf0c1\nA DataRobot custom metric.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the custom metric.\ndeployment_id (str) \u2013 The ID of the deployment.\nname (str) \u2013 The name of the custom metric.\nunits (str) \u2013 The units, or the y-axis label, of the given custom metric.\nbaseline_values (BaselinesValues) \u2013 The baseline value used to add \u201creference dots\u201d to the values over time chart.\nis_model_specific (bool) \u2013 Determines whether the metric is related to the model or deployment.\ntype (CustomMetricAggregationType) \u2013 The aggregation type of the custom metric.\ndirectionality (CustomMetricDirectionality) \u2013 The directionality of the custom metric.\ntime_step (CustomMetricBucketTimeStep) \u2013 Custom metric time bucket size.\ndescription (str) \u2013 A description of the custom metric.\nassociation_id (DatasetColumn) \u2013 A custom metric association_id column source when reading values from columnar dataset.\ntimestamp (DatasetColumn) \u2013 A custom metric timestamp column source when reading values from columnar dataset.\nvalue (DatasetColumn) \u2013 A custom metric value source when reading values from columnar dataset.\nsample_count (DatasetColumn) \u2013 A custom metric sample source when reading values from columnar dataset.\nbatch (str) \u2013 A custom metric batch ID source when reading values from columnar dataset.\nclassmethod create(name, deployment_id, units, is_model_specific, aggregation_type, time_step='hour', directionality=None, description=None, baseline_value=None, value_column_name=None, sample_count_column_name=None, timestamp_column_name=None, timestamp_format=None, batch_column_name=None, categories=None, is_geospatial=None, geospatial_segment_attribute=None)\uf0c1\nCreate a custom metric for a deployment\nParameters:\nname (str) \u2013 The name of the custom metric.\ndeployment_id (str) \u2013 The id of the deployment.\nunits (str) \u2013 The units, or the y-axis label, of the given custom metric.\nbaseline_value (float) \u2013 The baseline value used to add \u201creference dots\u201d to the values over time chart.\nis_model_specific (bool) \u2013 Determines whether the metric is related to the model or deployment.\naggregation_type (CustomMetricAggregationType) \u2013 The aggregation type of the custom metric.\ndirectionality (CustomMetricDirectionality) \u2013 The directionality of the custom metric.\ntime_step (CustomMetricBucketTimeStep) \u2013 Custom metric time bucket size.\ndescription (Optional[str]) \u2013 A description of the custom metric.\nvalue_column_name (Optional[str]) \u2013 A custom metric value column name when reading values from columnar dataset.\nsample_count_column_name (Optional[str]) \u2013 Points to a weight column name if users provide pre-aggregated metric values from columnar dataset.\ntimestamp_column_name (Optional[str]) \u2013 A custom metric timestamp column name when reading values from columnar dataset.\ntimestamp_format (Optional[str]) \u2013 A custom metric timestamp format when reading values from columnar dataset.\nbatch_column_name (Optional[str]) \u2013 A custom metric batch ID column name when reading values from columnar dataset.\nis_geospatial (Optional[bool]) \u2013 Determines whether the metric is geospatial or not.\ngeospatial_segment_attribute (Optional[str]) \u2013 The name of  the geospatial segment attribute.\nReturns:\nThe custom metric object.\nReturn type:\nCustomMetric\nExamples\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.create(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"Sample metric\",\nunits=\"Y\",\nbaseline_value=12,\nis_model_specific=True,\naggregation_type=CustomMetricAggregationType.AVERAGE,\ndirectionality=CustomMetricDirectionality.HIGHER_IS_BETTER\n)\nclassmethod get(deployment_id, custom_metric_id)\uf0c1\nGet a custom metric for a deployment\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\ncustom_metric_id (str) \u2013 The ID of the custom metric.\nReturns:\nThe custom metric object.\nReturn type:\nCustomMetric\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\ncustom_metric.id\n>>>'65f17bdcd2d66683cdfc1113'\nclassmethod list(deployment_id)\uf0c1\nList all custom metrics for a deployment\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nReturns:\ncustom_metrics \u2013 A list of custom metrics objects.\nReturn type:\nlist\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metrics = CustomMetric.list(deployment_id=\"5c939e08962d741e34f609f0\")\ncustom_metrics[0].id\n>>>'65f17bdcd2d66683cdfc1113'\nclassmethod delete(deployment_id, custom_metric_id)\uf0c1\nDelete a custom metric associated with a deployment.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\ncustom_metric_id (str) \u2013 The ID of the custom metric.\nReturn type:\nNone\nExamples\nfrom datarobot.models.deployment import CustomMetric\nCustomMetric.delete(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nupdate(name=None, units=None, aggregation_type=None, directionality=None, time_step=None, description=None, baseline_value=None, value_column_name=None, sample_count_column_name=None, timestamp_column_name=None, timestamp_format=None, batch_column_name=None)\uf0c1\nUpdate metadata of a custom metric\nParameters:\nname (Optional[str]) \u2013 The name of the custom metric.\nunits (Optional[str]) \u2013 The units, or the y-axis label, of the given custom metric.\nbaseline_value (Optional[float]) \u2013 The baseline value used to add \u201creference dots\u201d to the values over time chart.\naggregation_type (Optional[CustomMetricAggregationType]) \u2013 The aggregation type of the custom metric.\ndirectionality (Optional[CustomMetricDirectionality]) \u2013 The directionality of the custom metric.\ntime_step (Optional[CustomMetricBucketTimeStep]) \u2013 Custom metric time bucket size.\ndescription (Optional[str]) \u2013 A description of the custom metric.\nvalue_column_name (Optional[str]) \u2013 A custom metric value column name when reading values from columnar dataset.\nsample_count_column_name (Optional[str]) \u2013 Points to a weight column name if users provide pre-aggregated metric values from columnar dataset.\ntimestamp_column_name (Optional[str]) \u2013 A custom metric timestamp column name when reading values from columnar dataset.\ntimestamp_format (Optional[str]) \u2013 A custom metric timestamp format when reading values from columnar dataset.\nbatch_column_name (Optional[str]) \u2013 A custom metric batch ID column name when reading values from columnar dataset.\nReturns:\nThe custom metric object.\nReturn type:\nCustomMetric\nExamples\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\ncustom_metric = custom_metric.update(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"Sample metric\",\nunits=\"Y\",\nbaseline_value=12,\nis_model_specific=True,\naggregation_type=CustomMetricAggregationType.AVERAGE,\ndirectionality=CustomMetricDirectionality.HIGHER_IS_BETTER\n)\nunset_baseline()\uf0c1\nUnset the baseline value of a custom metric\nReturn type:\nNone\nExamples\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\ncustom_metric.baseline_values\n>>> [{'value': 12.0}]\ncustom_metric.unset_baseline()\ncustom_metric.baseline_values\n>>> []\nsubmit_values(data, model_id=None, model_package_id=None, dry_run=False)\uf0c1\nSubmit aggregated custom metrics values from JSON.\nParameters:\ndata (pd.DataFrame or List[CustomMetricBucket]) \u2013 The data containing aggregated custom metric values.\nmodel_id (Optional[str]) \u2013 For a model metric: the ID of the associated champion/challenger model, used to update the metric values.\nFor a deployment metric: the ID of the model is not needed.\nmodel_package_id (Optional[str]) \u2013 For a model metric: the ID of the associated champion/challenger model, used to update the metric values.\nFor a deployment metric: the ID of the model package is not needed.\ndry_run (Optional[bool]) \u2013 Specifies whether or not metric data is submitted in production mode (where data is saved).\nReturn type:\nNone\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# data for values over time\ndata = [{\n'value': 12,\n'sample_size': 3,\n'timestamp': '2024-03-15T14:00:00'\n}]\n# data witch association ID\ndata = [{\n'value': 12,\n'sample_size': 3,\n'timestamp': '2024-03-15T14:00:00',\n'association_id': '65f44d04dbe192b552e752ed'\n}]\n# data for batches\ndata = [{\n'value': 12,\n'sample_size': 3,\n'batch': '65f44c93fedc5de16b673a0d'\n}]\n# for deployment specific metrics\ncustom_metric.submit_values(data=data)\n# for model specific metrics pass model_package_id or model_id\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\")\n# dry run\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\", dry_run=True)\nsubmit_single_value(value, model_id=None, model_package_id=None, dry_run=False, segments=None)\uf0c1\nSubmit a single custom metric value at the current moment.\nParameters:\nvalue (float) \u2013 Single numeric custom metric value.\nmodel_id (Optional[str]) \u2013 For a model metric: the ID of the associated champion/challenger model, used to update the metric values.\nFor a deployment metric: the ID of the model is not needed.\nmodel_package_id (Optional[str]) \u2013 For a model metric: the ID of the associated champion/challenger model, used to update the metric values.\nFor a deployment metric: the ID of the model package is not needed.\ndry_run (Optional[bool]) \u2013 Specifies whether or not metric data is submitted in production mode (where data is saved).\nsegments (Optional[CustomMetricSegmentFromJSON]) \u2013 A list of segments for a custom metric used in segmented analysis.\nReturn type:\nNone\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# for deployment specific metrics\ncustom_metric.submit_single_value(value=121)\n# for model specific metrics pass model_package_id or model_id\ncustom_metric.submit_single_value(value=121, model_package_id=\"6421df32525c58cc6f991f25\")\n# dry run\ncustom_metric.submit_single_value(value=121, model_package_id=\"6421df32525c58cc6f991f25\", dry_run=True)\n# for segmented analysis\nsegments = [{\"name\": \"custom_seg\", \"value\": \"val_1\"}]\ncustom_metric.submit_single_value(value=121, model_package_id=\"6421df32525c58cc6f991f25\", segments=segments)\nsubmit_values_from_catalog(dataset_id, model_id=None, model_package_id=None, batch_id=None, segments=None, geospatial=None)\uf0c1\nSubmit aggregated custom metrics values from dataset (AI catalog).\nThe names of the columns in the dataset should correspond to the names of the columns that were defined in\nthe custom metric. In addition, the format of the timestamps should also be the same as defined in the metric.\nParameters:\ndataset_id (str) \u2013 The ID of the source dataset.\nmodel_id (Optional[str]) \u2013 For a model metric: the ID of the associated champion/challenger model, used to update the metric values.\nFor a deployment metric: the ID of the model is not needed.\nmodel_package_id (Optional[str]) \u2013 For a model metric: the ID of the associated champion/challenger model, used to update the metric values.\nFor a deployment metric: the ID of the model package is not needed.\nbatch_id (Optional[str]) \u2013 Specifies a batch ID associated with all values provided by this dataset, an alternative\nto providing batch IDs as a column within a dataset (at the record level).\nsegments (Optional[CustomMetricSegmentFromDataset]) \u2013 A list of segments for a custom metric used in segmented analysis.\ngeospatial (Optional[Geospatial]) \u2013 A geospatial column source when reading values from columnar dataset.\nReturn type:\nNone\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# for deployment specific metrics\ncustom_metric.submit_values_from_catalog(dataset_id=\"61093144cabd630828bca321\")\n# for model specific metrics pass model_package_id or model_id\ncustom_metric.submit_values_from_catalog(\ndataset_id=\"61093144cabd630828bca321\",\nmodel_package_id=\"6421df32525c58cc6f991f25\"\n)\n# for segmented analysis\nsegments = [{\"name\": \"custom_seg\", \"column\": \"column_with_segment_values\"}]\ncustom_metric.submit_values_from_catalog(\ndataset_id=\"61093144cabd630828bca321\",\nmodel_package_id=\"6421df32525c58cc6f991f25\",\nsegments=segments\n)\nget_values_over_time(start, end, model_package_id=None, model_id=None, segment_attribute=None, segment_value=None, bucket_size='P7D')\uf0c1\nRetrieve values of a single custom metric over a time period.\nParameters:\nstart (datetime or str) \u2013 Start of the time period.\nend (datetime or str) \u2013 End of the time period.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nbucket_size (Optional[str]) \u2013 Time duration of a bucket, in ISO 8601 time duration format.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_over_time \u2013 The queried custom metric values over time information.\nReturn type:\nCustomMetricValuesOverTime\nExamples\nfrom datarobot.models.deployment import CustomMetric\nfrom datetime import datetime, timedelta\nnow=datetime.now()\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nvalues_over_time = custom_metric.get_values_over_time(start=now - timedelta(days=7), end=now)\nvalues_over_time.bucket_values\n>>> {datetime.datetime(2024, 3, 22, 14, 0, tzinfo=tzutc()): 1.0,\n>>> datetime.datetime(2024, 3, 22, 15, 0, tzinfo=tzutc()): 123.0}}\nvalues_over_time.bucket_sample_sizes\n>>> {datetime.datetime(2024, 3, 22, 14, 0, tzinfo=tzutc()): 1,\n>>>  datetime.datetime(2024, 3, 22, 15, 0, tzinfo=tzutc()): 1}}\nvalues_over_time.get_buckets_as_dataframe()\n>>>                        start                       end  value  sample_size\n>>> 0  2024-03-21 16:00:00+00:00 2024-03-21 17:00:00+00:00    NaN          NaN\n>>> 1  2024-03-21 17:00:00+00:00 2024-03-21 18:00:00+00:00    NaN          NaN\nget_values_over_space(start=None, end=None, model_id=None, model_package_id=None)\uf0c1\nRetrieve values of a custom metric over space.\nParameters:\nstart (Optional[datetime]) \u2013 Start of the time period.\nend (Optional[datetime]) \u2013 End of the time period.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nReturns:\ncustom_metric_over_space \u2013 The queried custom metric values over space information.\nReturn type:\nCustomMetricValuesOverSpace\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nvalues_over_space = custom_metric.get_values_over_space(model_package_id='6421df32525c58cc6f991f25')\nget_summary(start, end, model_package_id=None, model_id=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve the summary of a custom metric over a time period.\nParameters:\nstart (datetime or str) \u2013 Start of the time period.\nend (datetime or str) \u2013 End of the time period.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_summary \u2013 The summary of the custom metric.\nReturn type:\nCustomMetricSummary\nExamples\nfrom datarobot.models.deployment import CustomMetric\nfrom datetime import datetime, timedelta\nnow=datetime.now()\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nsummary = custom_metric.get_summary(start=now - timedelta(days=7), end=now)\nprint(summary)\n>> \"CustomMetricSummary(2024-03-21 15:52:13.392178+00:00 - 2024-03-22 15:52:13.392168+00:00:\n{'id': '65fd9b1c0c1a840bc6751ce0', 'name': 'Test METRIC', 'value': 215.0, 'sample_count': 13,\n'baseline_value': 12.0, 'percent_change': 24.02})\"\nget_values_over_batch(batch_ids=None, model_package_id=None, model_id=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve values of a single custom metric over batches.\nParameters:\nbatch_ids (Optional[List[str]]) \u2013 Specify a list of batch IDs to pull the data for.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_over_batch \u2013 The queried custom metric values over batch information.\nReturn type:\nCustomMetricValuesOverBatch\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nvalues_over_batch = custom_metric.get_values_over_batch(model_package_id='6421df32525c58cc6f991f25')\nvalues_over_batch.bucket_values\n>>> {'6572db2c9f9d4ad3b9de33d0': 35.0, '6572db2c9f9d4ad3b9de44e1': 105.0}\nvalues_over_batch.bucket_sample_sizes\n>>> {'6572db2c9f9d4ad3b9de33d0': 6, '6572db2c9f9d4ad3b9de44e1': 8}\nvalues_over_batch.get_buckets_as_dataframe()\n>>>                    batch_id                     batch_name  value  sample_size\n>>> 0  6572db2c9f9d4ad3b9de33d0  Batch 1 - 03/26/2024 13:04:46   35.0            6\n>>> 1  6572db2c9f9d4ad3b9de44e1  Batch 2 - 03/26/2024 13:06:04  105.0            8\nget_batch_summary(batch_ids=None, model_package_id=None, model_id=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve the summary of a custom metric over a batch.\nParameters:\nbatch_ids (Optional[List[str]]) \u2013 Specify a list of batch IDs to pull the data for.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_summary \u2013 The batch summary of the custom metric.\nReturn type:\nCustomMetricBatchSummary\nExamples\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nbatch_summary = custom_metric.get_batch_summary(model_package_id='6421df32525c58cc6f991f25')\nprint(batch_summary)\n>> CustomMetricBatchSummary({'id': '6605396413434b3a7b74342c', 'name': 'batch metric', 'value': 41.25,\n'sample_count': 28, 'baseline_value': 123.0, 'percent_change': -66.46})\nclass datarobot.models.deployment.custom_metrics.CustomMetricValuesOverTime\uf0c1\nCustom metric over time information.\nAdded in version v3.4.\nVariables:\nbuckets (List[Bucket]) \u2013 A list of bucketed time periods and the custom metric values aggregated over that period.\nsummary (Summary) \u2013 The summary of values over time retrieval.\nmetric (Dict) \u2013 A custom metric definition.\ndeployment_id (str) \u2013 The ID of the deployment.\nsegment_attribute (str) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (str) \u2013 The value of the segment_attribute to segment on.\nclassmethod get(deployment_id, custom_metric_id, start, end, model_id=None, model_package_id=None, segment_attribute=None, segment_value=None, bucket_size='P7D')\uf0c1\nRetrieve values of a single custom metric over a time period.\nParameters:\ncustom_metric_id (str) \u2013 The ID of the custom metric.\ndeployment_id (str) \u2013 The ID of the deployment.\nstart (datetime or str) \u2013 Start of the time period.\nend (datetime or str) \u2013 End of the time period.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nbucket_size (Optional[str]) \u2013 Time duration of a bucket, in ISO 8601 time duration format.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_over_time \u2013 The queried custom metric values over time information.\nReturn type:\nCustomMetricValuesOverTime\nproperty bucket_values: Dict[datetime, int]\uf0c1\nThe metric value for all time buckets, keyed by start time of the bucket.\nReturns:\nbucket_values\nReturn type:\nDict\nproperty bucket_sample_sizes: Dict[datetime, int]\uf0c1\nThe sample size for all time buckets, keyed by start time of the bucket.\nReturns:\nbucket_sample_sizes\nReturn type:\nDict\nget_buckets_as_dataframe()\uf0c1\nRetrieves all custom metrics buckets in a pandas DataFrame.\nReturns:\nbuckets\nReturn type:\npd.DataFrame\nclass datarobot.models.deployment.custom_metrics.CustomMetricSummary\uf0c1\nThe summary of a custom metric.\nAdded in version v3.4.\nVariables:\nperiod (Period) \u2013 A time period defined by a start and end tie\nmetric (Dict) \u2013 The summary of the custom metric.\nclassmethod get(deployment_id, custom_metric_id, start, end, model_id=None, model_package_id=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve the summary of a custom metric over a time period.\nParameters:\ncustom_metric_id (str) \u2013 The ID of the custom metric.\ndeployment_id (str) \u2013 The ID of the deployment.\nstart (datetime or str) \u2013 Start of the time period.\nend (datetime or str) \u2013 End of the time period.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_summary \u2013 The summary of the custom metric.\nReturn type:\nCustomMetricSummary\nclass datarobot.models.deployment.custom_metrics.CustomMetricValuesOverBatch\uf0c1\nCustom metric over batch information.\nAdded in version v3.4.\nVariables:\nbuckets (List[BatchBucket]) \u2013 A list of buckets with custom metric values aggregated over batches.\nmetric (Dict) \u2013 A custom metric definition.\ndeployment_id (str) \u2013 The ID of the deployment.\nsegment_attribute (str) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (str) \u2013 The value of the segment_attribute to segment on.\nclassmethod get(deployment_id, custom_metric_id, batch_ids=None, model_id=None, model_package_id=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve values of a single custom metric over batches.\nParameters:\ncustom_metric_id (str) \u2013 The ID of the custom metric.\ndeployment_id (str) \u2013 The ID of the deployment.\nbatch_ids (Optional[List[str]]) \u2013 Specify a list of batch IDs to pull the data for.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_over_batch \u2013 The queried custom metric values over batch information.\nReturn type:\nCustomMetricValuesOverBatch\nproperty bucket_values: Dict[str, int]\uf0c1\nThe metric value for all batch buckets, keyed by batch ID\nReturns:\nbucket_values\nReturn type:\nDict\nproperty bucket_sample_sizes: Dict[str, int]\uf0c1\nThe sample size for all batch buckets, keyed by batch ID.\nReturns:\nbucket_sample_sizes\nReturn type:\nDict\nget_buckets_as_dataframe()\uf0c1\nRetrieves all custom metrics buckets in a pandas DataFrame.\nReturns:\nbuckets\nReturn type:\npd.DataFrame\nclass datarobot.models.deployment.custom_metrics.CustomMetricBatchSummary\uf0c1\nThe batch summary of a custom metric.\nAdded in version v3.4.\nVariables:\nmetric (Dict) \u2013 The summary of the batch custom metric.\nclassmethod get(deployment_id, custom_metric_id, batch_ids=None, model_id=None, model_package_id=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve the summary of a custom metric over a batch.\nParameters:\ncustom_metric_id (str) \u2013 The ID of the custom metric.\ndeployment_id (str) \u2013 The ID of the deployment.\nbatch_ids (Optional[List[str]]) \u2013 Specify a list of batch IDs to pull the data for.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmodel_package_id (Optional[str]) \u2013 The ID of the model package.\nsegment_attribute (Optional[str]) \u2013 The name of the segment on which segment analysis is being performed.\nsegment_value (Optional[str]) \u2013 The value of the segment_attribute to segment on.\nReturns:\ncustom_metric_summary \u2013 The batch summary of the custom metric.\nReturn type:\nCustomMetricBatchSummary\nclass datarobot.models.deployment.custom_metrics.HostedCustomMetricTemplate\uf0c1\nTemplate for hosted custom metric.\nclassmethod list(search=None, order_by=None, metric_type=None, offset=None, limit=None)\uf0c1\nList all hosted custom metric templates.\nParameters:\nsearch (Optional[str]) \u2013 Search string.\norder_by (Optional[ListHostedCustomMetricTemplatesSortQueryParams]) \u2013 Ordering field.\nmetric_type (Optional[HostedCustomMetricsTemplateMetricTypeQueryParams]) \u2013 Type of the metric.\noffset (Optional[int]) \u2013 Offset for pagination.\nlimit (Optional[int]) \u2013 Limit for pagination.\nReturns:\ntemplates\nReturn type:\nList[HostedCustomMetricTemplate]\nclassmethod get(template_id)\uf0c1\nGet a hosted custom metric template by ID.\nParameters:\ntemplate_id (str) \u2013 ID of the template.\nReturns:\ntemplate\nReturn type:\nHostedCustomMetricTemplate\nclass datarobot.models.deployment.custom_metrics.HostedCustomMetric\uf0c1\nHosted custom metric.\nclassmethod list(job_id, skip=None, limit=None)\uf0c1\nList all hosted custom metrics for a job.\nParameters:\njob_id (str) \u2013 ID of the job.\nReturns:\nmetrics\nReturn type:\nList[HostedCustomMetric]\nclassmethod create_from_template(template_id, deployment_id, job_name, custom_metric_name, job_description=None, custom_metric_description=None, sidecar_deployment_id=None, baseline_value=None, timestamp=None, value=None, sample_count=None, batch=None, schedule=None, parameter_overrides=None)\uf0c1\nCreate a hosted custom metric from a template.\nA shortcut for 2 calls:\nJob.from_custom_metric_template(template_id)\nHostedCustomMetrics.create_from_custom_job()\nParameters:\ntemplate_id (str) \u2013 ID of the template.\ndeployment_id (str) \u2013 ID of the deployment.\njob_name (str) \u2013 Name of the job.\ncustom_metric_name (str) \u2013 Name of the metric.\njob_description (Optional[str]) \u2013 Description of the job.\ncustom_metric_description (Optional[str]) \u2013 Description of the metric.\nsidecar_deployment_id (Optional[str]) \u2013 ID of the sidecar deployment.\nbaseline_value (Optional[float]) \u2013 Baseline value.\ntimestamp (Optional[MetricTimestampSpoofing]) \u2013 Timestamp details.\nvalue (Optional[ValueField]) \u2013 Value details.\nsample_count (Optional[SampleCountField]) \u2013 Sample count details.\nbatch (Optional[BatchField]) \u2013 Batch details.\nschedule (Optional[Schedule]) \u2013 Schedule details.\nparameter_overrides (Optional[List[RuntimeParameterValue]]) \u2013 Parameter overrides.\nReturns:\nmetric\nReturn type:\nHostedCustomMetric\nclassmethod create_from_custom_job(custom_job_id, deployment_id, name, description=None, baseline_value=None, timestamp=None, value=None, sample_count=None, batch=None, schedule=None, parameter_overrides=None, geospatial_segment_attribute=None)\uf0c1\nCreate a hosted custom metric from existing custom job.\nParameters:\ncustom_job_id (str) \u2013 ID of the custom job.\ndeployment_id (str) \u2013 ID of the deployment.\nname (str) \u2013 Name of the metric.\ndescription (Optional[str]) \u2013 Description of the metric.\nbaseline_value (Optional[float]) \u2013 Baseline value.\ntimestamp (Optional[MetricTimestampSpoofing]) \u2013 Timestamp details.\nvalue (Optional[ValueField]) \u2013 Value details.\nsample_count (Optional[SampleCountField]) \u2013 Sample count details.\nbatch (Optional[BatchField]) \u2013 Batch details.\nschedule (Optional[Schedule]) \u2013 Schedule details.\nparameter_overrides (Optional[List[RuntimeParameterValue]]) \u2013 Parameter overrides.\ngeospatial_segment_attribute (Optional[str]) \u2013 The name of the geospatial segment attribute. Only applicable for geospatial custom metrics.\nReturns:\nmetric\nReturn type:\nHostedCustomMetric\nupdate(name=None, description=None, units=None, directionality=None, aggregation_type=None, baseline_value=None, timestamp=None, value=None, sample_count=None, batch=None, schedule=None, parameter_overrides=None)\uf0c1\nUpdate the hosted custom metric.\nParameters:\nname (Optional[str]) \u2013 Name of the metric.\ndescription (Optional[str]) \u2013 Description of the metric.\nunits (Optional[str]) \u2013 Units of the metric.\ndirectionality (Optional[str]) \u2013 Directionality of the metric.\naggregation_type (Optional[CustomMetricAggregationType]) \u2013 Aggregation type of the metric.\nbaseline_value (Optional[float]) \u2013 Baseline values.\ntimestamp (Optional[MetricTimestampSpoofing]) \u2013 Timestamp details.\nvalue (Optional[ValueField]) \u2013 Value details.\nsample_count (Optional[SampleCountField]) \u2013 Sample count details.\nbatch (Optional[BatchField]) \u2013 Batch details.\nschedule (Optional[Schedule]) \u2013 Schedule details.\nparameter_overrides (Optional[List[RuntimeParameterValue]]) \u2013 Parameter overrides.\nReturns:\nmetric\nReturn type:\nHostedCustomMetric\ndelete()\uf0c1\nDelete the hosted custom metric.\nReturn type:\nNone\nclass datarobot.models.deployment.custom_metrics.DeploymentDetails\uf0c1\nInformation about a hosted custom metric deployment.\nclass datarobot.models.deployment.custom_metrics.MetricBaselineValue\uf0c1\nThe baseline values for a custom metric.\nclass datarobot.models.deployment.custom_metrics.SampleCountField\uf0c1\nA weight column used with columnar datasets if pre-aggregated metric values are provided.\nclass datarobot.models.deployment.custom_metrics.ValueField\uf0c1\nA custom metric value source for when reading values from a columnar dataset like a file.\nclass datarobot.models.deployment.custom_metrics.MetricTimestampSpoofing\uf0c1\nCustom metric timestamp spoofing. Occurs when reading values from a file, like a dataset.\nBy default, replicates pd.to_datetime formatting behavior.\nclass datarobot.models.deployment.custom_metrics.BatchField\uf0c1\nA custom metric batch ID source for when reading values from a columnar dataset like a file.\nclass datarobot.models.deployment.custom_metrics.HostedCustomMetricBlueprint\uf0c1\nHosted custom metric blueprints provide an option to share custom metric settings between multiple\ncustom metrics sharing the same custom jobs. When a custom job of a hosted custom metric type is connected to the\ndeployment, all the custom metric parameters from the blueprint are automatically copied.\nclassmethod get(custom_job_id)\uf0c1\nGet a hosted custom metric blueprint.\nParameters:\ncustom_job_id (str) \u2013 ID of the custom job.\nReturns:\nblueprint\nReturn type:\nHostedCustomMetricBlueprint\nclassmethod create(custom_job_id, directionality, units, type, time_step, is_model_specific, is_geospatial=None)\uf0c1\nCreate a hosted custom metric blueprint.\nParameters:\ncustom_job_id (str) \u2013 ID of the custom job.\ndirectionality (str) \u2013 Directionality of the metric.\nunits (str) \u2013 Units of the metric.\ntype (str) \u2013 Type of the metric.\ntime_step (str) \u2013 Time step of the metric.\nis_model_specific (bool) \u2013 Whether the metric is model specific.\nis_geospatial (Optional[bool]) \u2013 Determines whether the metric is geospatial.\nReturns:\nblueprint\nReturn type:\nHostedCustomMetricBlueprint\nupdate(directionality=None, units=None, type=None, time_step=None, is_model_specific=None, is_geospatial=None)\uf0c1\nUpdate a hosted custom metric blueprint.\nParameters:\ndirectionality (Optional[str]) \u2013 Directionality of the metric.\nunits (Optional[str]) \u2013 Units of the metric.\ntype (Optional[str]) \u2013 Type of the metric.\ntime_step (Optional[str]) \u2013 Time step of the metric.\nis_model_specific (Optional[bool]) \u2013 Determines whether the metric is model specific.\nis_geospatial (Optional[bool]) \u2013 Determines whether the metric is geospatial.\nReturns:\nupdated_blueprint\nReturn type:\nHostedCustomMetricBlueprint\nclass datarobot.models.deployment.custom_metrics.CustomMetricValuesOverSpace\uf0c1\nCustom metric values over space.\nAdded in version v3.7.\nVariables:\nbuckets (List[BatchBucket]) \u2013 A list of buckets with custom metric values aggregated over geospatial hexagons.\nmetric (Dict) \u2013 A custom metric definition.\nmodel_id (str) \u2013 The ID of the model.\nmodel_package_id (str) \u2013 The ID of the model package (also known as registered model version id).\nsummary (Dict) \u2013 Start-end interval over which data is retrieved.\nclassmethod get(deployment_id, custom_metric_id, start=None, end=None, model_package_id=None, model_id=None)\uf0c1\nRetrieve custom metric values over space.\nParameters:\ndeployment_id (str) \u2013 The id of the deployment.\ncustom_metric_id (str) \u2013 The id of the custom metric.\nstart (datetime) \u2013 The start time of the interval.\nend (datetime) \u2013 The end time of the interval.\nmodel_package_id (str) \u2013 The id of the model package.\nmodel_id (str) \u2013 The id of the model.\nReturns:\nvalues_over_space \u2013 Custom metric values over geospatial hexagons.\nReturn type:\nCustomMetricValuesOverSpace",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.create(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"Sample metric\",\n    units=\"Y\",\n    baseline_value=12,\n    is_model_specific=True,\n    aggregation_type=CustomMetricAggregationType.AVERAGE,\n    directionality=CustomMetricDirectionality.HIGHER_IS_BETTER\n    )",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n\ncustom_metric.id\n>>>'65f17bdcd2d66683cdfc1113'",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metrics = CustomMetric.list(deployment_id=\"5c939e08962d741e34f609f0\")\ncustom_metrics[0].id\n>>>'65f17bdcd2d66683cdfc1113'",
        "from datarobot.models.deployment import CustomMetric\n\nCustomMetric.delete(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)",
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\ncustom_metric = custom_metric.update(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"Sample metric\",\n    units=\"Y\",\n    baseline_value=12,\n    is_model_specific=True,\n    aggregation_type=CustomMetricAggregationType.AVERAGE,\n    directionality=CustomMetricDirectionality.HIGHER_IS_BETTER\n    )",
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\ncustom_metric.baseline_values\n>>> [{'value': 12.0}]\ncustom_metric.unset_baseline()\ncustom_metric.baseline_values\n>>> []",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n\n# data for values over time\ndata = [{\n    'value': 12,\n    'sample_size': 3,\n    'timestamp': '2024-03-15T14:00:00'\n}]\n\n# data witch association ID\ndata = [{\n    'value': 12,\n    'sample_size': 3,\n    'timestamp': '2024-03-15T14:00:00',\n    'association_id': '65f44d04dbe192b552e752ed'\n}]\n\n# data for batches\ndata = [{\n    'value': 12,\n    'sample_size': 3,\n    'batch': '65f44c93fedc5de16b673a0d'\n}]\n\n# for deployment specific metrics\ncustom_metric.submit_values(data=data)\n\n# for model specific metrics pass model_package_id or model_id\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\")\n\n# dry run\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\", dry_run=True)",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n\n# for deployment specific metrics\ncustom_metric.submit_single_value(value=121)\n\n# for model specific metrics pass model_package_id or model_id\ncustom_metric.submit_single_value(value=121, model_package_id=\"6421df32525c58cc6f991f25\")\n\n# dry run\ncustom_metric.submit_single_value(value=121, model_package_id=\"6421df32525c58cc6f991f25\", dry_run=True)\n\n# for segmented analysis\nsegments = [{\"name\": \"custom_seg\", \"value\": \"val_1\"}]\ncustom_metric.submit_single_value(value=121, model_package_id=\"6421df32525c58cc6f991f25\", segments=segments)",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n\n# for deployment specific metrics\ncustom_metric.submit_values_from_catalog(dataset_id=\"61093144cabd630828bca321\")\n\n# for model specific metrics pass model_package_id or model_id\ncustom_metric.submit_values_from_catalog(\n    dataset_id=\"61093144cabd630828bca321\",\n    model_package_id=\"6421df32525c58cc6f991f25\"\n)\n\n# for segmented analysis\nsegments = [{\"name\": \"custom_seg\", \"column\": \"column_with_segment_values\"}]\ncustom_metric.submit_values_from_catalog(\n    dataset_id=\"61093144cabd630828bca321\",\n    model_package_id=\"6421df32525c58cc6f991f25\",\n    segments=segments\n)",
        "from datarobot.models.deployment import CustomMetric\nfrom datetime import datetime, timedelta\n\nnow=datetime.now()\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nvalues_over_time = custom_metric.get_values_over_time(start=now - timedelta(days=7), end=now)\n\nvalues_over_time.bucket_values\n>>> {datetime.datetime(2024, 3, 22, 14, 0, tzinfo=tzutc()): 1.0,\n>>> datetime.datetime(2024, 3, 22, 15, 0, tzinfo=tzutc()): 123.0}}\n\nvalues_over_time.bucket_sample_sizes\n>>> {datetime.datetime(2024, 3, 22, 14, 0, tzinfo=tzutc()): 1,\n>>>  datetime.datetime(2024, 3, 22, 15, 0, tzinfo=tzutc()): 1}}\n\nvalues_over_time.get_buckets_as_dataframe()\n>>>                        start                       end  value  sample_size\n>>> 0  2024-03-21 16:00:00+00:00 2024-03-21 17:00:00+00:00    NaN          NaN\n>>> 1  2024-03-21 17:00:00+00:00 2024-03-21 18:00:00+00:00    NaN          NaN",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nvalues_over_space = custom_metric.get_values_over_space(model_package_id='6421df32525c58cc6f991f25')",
        "from datarobot.models.deployment import CustomMetric\nfrom datetime import datetime, timedelta\n\nnow=datetime.now()\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\nsummary = custom_metric.get_summary(start=now - timedelta(days=7), end=now)\n\nprint(summary)\n>> \"CustomMetricSummary(2024-03-21 15:52:13.392178+00:00 - 2024-03-22 15:52:13.392168+00:00:\n{'id': '65fd9b1c0c1a840bc6751ce0', 'name': 'Test METRIC', 'value': 215.0, 'sample_count': 13,\n'baseline_value': 12.0, 'percent_change': 24.02})\"",
        "from datarobot.models.deployment import CustomMetric\n\n   custom_metric = CustomMetric.get(\n       deployment_id=\"5c939e08962d741e34f609f0\",\n       custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n   )\n   # all batch metrics all model specific\n   values_over_batch = custom_metric.get_values_over_batch(model_package_id='6421df32525c58cc6f991f25')\n\n   values_over_batch.bucket_values\n   >>> {'6572db2c9f9d4ad3b9de33d0': 35.0, '6572db2c9f9d4ad3b9de44e1': 105.0}\n\n   values_over_batch.bucket_sample_sizes\n   >>> {'6572db2c9f9d4ad3b9de33d0': 6, '6572db2c9f9d4ad3b9de44e1': 8}\n\nvalues_over_batch.get_buckets_as_dataframe()\n>>>                    batch_id                     batch_name  value  sample_size\n>>> 0  6572db2c9f9d4ad3b9de33d0  Batch 1 - 03/26/2024 13:04:46   35.0            6\n>>> 1  6572db2c9f9d4ad3b9de44e1  Batch 2 - 03/26/2024 13:06:04  105.0            8",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nbatch_summary = custom_metric.get_batch_summary(model_package_id='6421df32525c58cc6f991f25')\n\nprint(batch_summary)\n>> CustomMetricBatchSummary({'id': '6605396413434b3a7b74342c', 'name': 'batch metric', 'value': 41.25,\n'sample_count': 28, 'baseline_value': 123.0, 'percent_change': -66.46})"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/custom-models.html",
      "title": "Custom models\uf0c1",
      "description": "A file item attached to a DataRobot custom model version.",
      "content": "Custom models\uf0c1\nclass datarobot.models.custom_model_version.CustomModelFileItem\uf0c1\nA file item attached to a DataRobot custom model version.\nAdded in version v2.21.\nVariables:\nid (str) \u2013 The ID of the file item.\nfile_name (str) \u2013 The name of the file item.\nfile_path (str) \u2013 The path of the file item.\nfile_source (str) \u2013 The source of the file item.\ncreated_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the version was created.\nclass datarobot.CustomInferenceModel\uf0c1\nA custom inference model.\nAdded in version v2.21.\nVariables:\nid (str) \u2013 The ID of the custom model.\nname (str) \u2013 The name of the custom model.\nlanguage (str) \u2013 The programming language of the custom inference model.\nCan be \u201cpython\u201d, \u201cr\u201d, \u201cjava\u201d or \u201cother\u201d.\ndescription (str) \u2013 The description of the custom inference model.\ntarget_type (datarobot.TARGET_TYPE) \u2013 Target type of the custom inference model.\nValues: [datarobot.TARGET_TYPE.BINARY, datarobot.TARGET_TYPE.REGRESSION,\ndatarobot.TARGET_TYPE.MULTICLASS, datarobot.TARGET_TYPE.UNSTRUCTURED,\ndatarobot.TARGET_TYPE.ANOMALY, datarobot.TARGET_TYPE.TEXT_GENERATION]\ntarget_name (str) \u2013 Target feature name.\nIt is optional(ignored if provided) for datarobot.TARGET_TYPE.UNSTRUCTURED\nor datarobot.TARGET_TYPE.ANOMALY target type.\nlatest_version (datarobot.CustomModelVersion or None) \u2013 The latest version of the custom model if the model has a latest version.\ndeployments_count (int) \u2013 Number of a deployments of the custom models.\ntarget_name \u2013 The custom model target name.\npositive_class_label (str) \u2013 For binary classification projects, a label of a positive class.\nnegative_class_label (str) \u2013 For binary classification projects, a label of a negative class.\nprediction_threshold (float) \u2013 For binary classification projects, a threshold used for predictions.\ntraining_data_assignment_in_progress (bool) \u2013 Flag describing if training data assignment is in progress.\ntraining_dataset_id (Optional[str]) \u2013 The ID of a dataset assigned to the custom model.\ntraining_dataset_version_id (Optional[str]) \u2013 The ID of a dataset version assigned to the custom model.\ntraining_data_file_name (Optional[str]) \u2013 The name of assigned training data file.\ntraining_data_partition_column (Optional[str]) \u2013 The name of a partition column in a training dataset assigned to the custom model.\ncreated_by (str) \u2013 The username of a user who created the custom model.\nupdated_at (str) \u2013 ISO-8601 formatted timestamp of when the custom model was updated\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the custom model was created\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s.\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster\nis_training_data_for_versions_permanently_enabled (Optional[bool]) \u2013 Whether training data assignment on the version level is permanently enabled for the model.\nclassmethod list(is_deployed=None, search_for=None, order_by=None)\uf0c1\nList custom inference models available to the user.\nAdded in version v2.21.\nParameters:\nis_deployed (Optional[bool]) \u2013 Flag for filtering custom inference models.\nIf set to True, only deployed custom inference models are returned.\nIf set to False, only not deployed custom inference models are returned.\nsearch_for (Optional[str]) \u2013 String for filtering custom inference models - only custom\ninference models that contain the string in name or description will\nbe returned.\nIf not specified, all custom models will be returned\norder_by (Optional[str]) \u2013 Property to sort custom inference models by.\nSupported properties are \u201ccreated\u201d and \u201cupdated\u201d.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. order_by=\u2019-created\u2019.\nBy default, the order_by parameter is None which will result in\ncustom models being returned in order of creation time descending.\nReturns:\nA list of custom inference models.\nReturn type:\nList[CustomInferenceModel]\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status\nclassmethod get(custom_model_id)\uf0c1\nGet custom inference model by id.\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom inference model.\nReturns:\nRetrieved custom inference model.\nReturn type:\nCustomInferenceModel\nRaises:\ndatarobot.errors.ClientError \u2013 The ID the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 The ID the server responded with 5xx status.\ndownload_latest_version(file_path)\uf0c1\nDownload the latest custom inference model version.\nAdded in version v2.21.\nParameters:\nfile_path (str) \u2013 Path to create a file with custom model version content.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nReturn type:\nNone\nclassmethod create(name, target_type, target_name=None, language=None, description=None, positive_class_label=None, negative_class_label=None, prediction_threshold=None, class_labels=None, class_labels_file=None, network_egress_policy=None, maximum_memory=None, replicas=None, is_training_data_for_versions_permanently_enabled=None)\uf0c1\nCreate a custom inference model.\nAdded in version v2.21.\nParameters:\nname (str) \u2013 Name of the custom inference model.\ntarget_type (datarobot.TARGET_TYPE) \u2013 Target type of the custom inference model.\nValues: [datarobot.TARGET_TYPE.BINARY, datarobot.TARGET_TYPE.REGRESSION,\ndatarobot.TARGET_TYPE.MULTICLASS, datarobot.TARGET_TYPE.UNSTRUCTURED,\ndatarobot.TARGET_TYPE.TEXT_GENERATION]\ntarget_name (Optional[str]) \u2013 Target feature name.\nIt is optional(ignored if provided) for datarobot.TARGET_TYPE.UNSTRUCTURED target type.\nlanguage (Optional[str]) \u2013 Programming language of the custom learning model.\ndescription (Optional[str]) \u2013 Description of the custom learning model.\npositive_class_label (Optional[str]) \u2013 Custom inference model positive class label for binary classification.\nnegative_class_label (Optional[str]) \u2013 Custom inference model negative class label for binary classification.\nprediction_threshold (Optional[float]) \u2013 Custom inference model prediction threshold.\nclass_labels (List[str], optional) \u2013 Custom inference model class labels for multiclass classification.\nCannot be used with class_labels_file.\nclass_labels_file (Optional[str]) \u2013 Path to file containing newline separated class labels for multiclass classification.\nCannot be used with class_labels.\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC]\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s.\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster.\nis_training_data_for_versions_permanently_enabled (Optional[bool]) \u2013 Permanently enable training data assignment on the version level for the current model,\ninstead of training data assignment on the model level.\nReturns:\nCreated a custom inference model.\nReturn type:\nCustomInferenceModel\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclassmethod copy_custom_model(custom_model_id)\uf0c1\nCreate a custom inference model by copying existing one.\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom inference model to copy.\nReturns:\nCreated a custom inference model.\nReturn type:\nCustomInferenceModel\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nupdate(name=None, language=None, description=None, target_name=None, positive_class_label=None, negative_class_label=None, prediction_threshold=None, class_labels=None, class_labels_file=None, is_training_data_for_versions_permanently_enabled=None)\uf0c1\nUpdate custom inference model properties.\nAdded in version v2.21.\nParameters:\nname (Optional[str]) \u2013 New custom inference model name.\nlanguage (Optional[str]) \u2013 New custom inference model programming language.\ndescription (Optional[str]) \u2013 New custom inference model description.\ntarget_name (Optional[str]) \u2013 New custom inference model target name.\npositive_class_label (Optional[str]) \u2013 New custom inference model positive class label.\nnegative_class_label (Optional[str]) \u2013 New custom inference model negative class label.\nprediction_threshold (Optional[float]) \u2013 New custom inference model prediction threshold.\nclass_labels (List[str], optional) \u2013 custom inference model class labels for multiclass classification\nCannot be used with class_labels_file\nclass_labels_file (Optional[str]) \u2013 Path to file containing newline separated class labels for multiclass classification.\nCannot be used with class_labels\nis_training_data_for_versions_permanently_enabled (Optional[bool]) \u2013 Permanently enable training data assignment on the version level for the current model,\ninstead of training data assignment on the model level.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nReturn type:\nNone\nrefresh()\uf0c1\nUpdate custom inference model with the latest data from server.\n:rtype: None\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\ndelete()\uf0c1\nDelete custom inference model.\n:rtype: None\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nassign_training_data(dataset_id, partition_column=None, max_wait=600)\uf0c1\nAssign training data to the custom inference model.\nAdded in version v2.21.\nParameters:\ndataset_id (str) \u2013 The ID of the training dataset to be assigned.\npartition_column (Optional[str]) \u2013 The name of a partition column in the training dataset.\nmax_wait (Optional[int]) \u2013 The max time to wait for a training data assignment.\nIf set to None, then method will return without waiting.\nDefaults to 10 min.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status\nReturn type:\nNone\nget_access_list()\uf0c1\nRetrieve access control settings of this custom model.\nAdded in version v2.36.\nReturn type:\nlist of SharingAccess\nshare(access_list)\uf0c1\nUpdate the access control settings of this custom model.\nAdded in version v2.36.\nParameters:\naccess_list (list of SharingAccess) \u2013 A list of SharingAccess to update.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nNone\nExamples\nTransfer access to the custom model from old_user@datarobot.com to new_user@datarobot.com\nimport datarobot as dr\nnew_access = dr.SharingAccess(new_user@datarobot.com,\ndr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\ndr.CustomInferenceModel.get('custom-model-id').share(access_list)\nclass datarobot.CustomModelTest\uf0c1\nAn custom model test.\nAdded in version v2.21.\nVariables:\nid (str) \u2013 test id\ncustom_model_image_id (str) \u2013 id of a custom model image\nimage_type (str) \u2013 the type of the image, either CUSTOM_MODEL_IMAGE_TYPE.CUSTOM_MODEL_IMAGE if the testing\nattempt is using a CustomModelImage as its model or\nCUSTOM_MODEL_IMAGE_TYPE.CUSTOM_MODEL_VERSION if the testing attempt is\nusing a CustomModelVersion with dependency management\noverall_status (str) \u2013 a string representing testing status.\nStatus can be\n- \u2018not_tested\u2019: the check not run\n- \u2018failed\u2019: the check failed\n- \u2018succeeded\u2019: the check succeeded\n- \u2018warning\u2019: the check resulted in a warning, or in non-critical failure\n- \u2018in_progress\u2019: the check is in progress\ndetailed_status (dict) \u2013 detailed testing status - maps the testing types to their status and message.\nThe keys of the dict are one of \u2018errorCheck\u2019, \u2018nullValueImputation\u2019,\n\u2018longRunningService\u2019, \u2018sideEffects\u2019.\nThe values are dict with \u2018message\u2019 and \u2018status\u2019 keys.\ncreated_by (str) \u2013 a user who created a test\ndataset_id (Optional[str]) \u2013 id of a dataset used for testing\ndataset_version_id (Optional[str]) \u2013 id of a dataset version used for testing\ncompleted_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the test has completed\ncreated_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the version was created\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster\nclassmethod create(custom_model_id, custom_model_version_id, dataset_id=None, max_wait=600, network_egress_policy=None, maximum_memory=None, replicas=None)\uf0c1\nCreate and start a custom model test.\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 the id of the custom model\ncustom_model_version_id (str) \u2013 the id of the custom model version\ndataset_id (Optional[str]) \u2013 The id of the testing dataset for non-unstructured custom models.\nIgnored and not required for unstructured models.\nmax_wait (Optional[int]) \u2013 max time to wait for a test completion.\nIf set to None - method will return without waiting.\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster\nReturns:\ncreated custom model test\nReturn type:\nCustomModelTest\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod list(custom_model_id)\uf0c1\nList custom model tests.\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 the id of the custom model\nReturns:\na list of custom model tests\nReturn type:\nList[CustomModelTest]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(custom_model_test_id)\uf0c1\nGet custom model test by id.\nAdded in version v2.21.\nParameters:\ncustom_model_test_id (str) \u2013 the id of the custom model test\nReturns:\nretrieved custom model test\nReturn type:\nCustomModelTest\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nget_log()\uf0c1\nGet log of a custom model test.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nget_log_tail()\uf0c1\nGet log tail of a custom model test.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ncancel()\uf0c1\nCancel custom model test that is in progress.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nrefresh()\uf0c1\nUpdate custom model test with the latest data from server.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclass datarobot.CustomModelVersion\uf0c1\nA version of a DataRobot custom model.\nAdded in version v2.21.\nVariables:\nid (str) \u2013 The ID of the custom model version.\ncustom_model_id (str) \u2013 The ID of the custom model.\nversion_minor (int) \u2013 A minor version number of the custom model version.\nversion_major (int) \u2013 A major version number of the custom model version.\nis_frozen (bool) \u2013 A flag if the custom model version is frozen.\nitems (List[CustomModelFileItem]) \u2013 A list of file items attached to the custom model version.\nbase_environment_id (str) \u2013 The ID of the environment to use with the model.\nbase_environment_version_id (str) \u2013 The ID of the environment version to use with the model.\nlabel (Optional[str]) \u2013 A short human readable string to label the version.\ndescription (Optional[str]) \u2013 The custom model version description.\ncreated_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the version was created.\ndependencies (List[CustomDependency]) \u2013 The parsed dependencies of the custom model version if the\nversion has a valid requirements.txt file.\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s.\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster.\nrequired_metadata_values (List[RequiredMetadataValue]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\ntraining_data (TrainingData, optional) \u2013 The information about the training data assigned to the model version.\nholdout_data (HoldoutData, optional) \u2013 The information about the holdout data assigned to the model version.\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nCustomModelVersion\nclassmethod create_clean(custom_model_id, base_environment_id=None, is_major_update=True, folder_path=None, files=None, network_egress_policy=None, maximum_memory=None, replicas=None, required_metadata_values=None, training_dataset_id=None, partition_column=None, holdout_dataset_id=None, keep_training_holdout_data=None, max_wait=600, runtime_parameter_values=None, base_environment_version_id=None)\uf0c1\nCreate a custom model version without files from previous versions.\nCreate a version with training or holdout data:\nIf training/holdout data related parameters are provided,\nthe training data is assigned asynchronously.\nIn this case:\n* if max_wait is not None, the function returns once the job is finished.\n* if max_wait is None, the function returns immediately. Progress can be polled by the user (see examples).\nIf training data assignment fails, new version is still created,\nbut it is not allowed to create a model package (version) for the model version and to deploy it.\nTo check for training data assignment error, check version.training_data.assignment_error[\u201cmessage\u201d].\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\nbase_environment_id (str) \u2013 The base environment to use with this model version.\nAt least one of \u201cbase_environment_id\u201d and \u201cbase_environment_version_id\u201d must be provided.\nIf both are specified, the version must belong to the environment.\nbase_environment_version_id (str) \u2013 The base environment version ID to use with this model version.\nAt least one of \u201cbase_environment_id\u201d and \u201cbase_environment_version_id\u201d must be provided.\nIf both are specified, the version must belong to the environment.\nIf not specified: in case previous model versions exist, the value from the latest model\nversion is inherited, otherwise, latest successfully built version of the environment\nspecified in \u201cbase_environment_id\u201d is used.\nis_major_update (Optional[bool]) \u2013 The flag defining if a custom model version will be a minor or a major version.\nDefault to True\nfolder_path (Optional[str]) \u2013 The path to a folder containing files to be uploaded.\nEach file in the folder is uploaded under path relative to a folder path.\nfiles (Optional[List]) \u2013 The list of tuples, where values in each tuple are the local filesystem path and\nthe path the file should be placed in the model.\nIf the list is of strings, then basenames will be used for tuples.\nExample:\n[(\u201c/home/user/Documents/myModel/file1.txt\u201d, \u201cfile1.txt\u201d),\n(\u201c/home/user/Documents/myModel/folder/file2.txt\u201d, \u201cfolder/file2.txt\u201d)]\nor\n[\u201c/home/user/Documents/myModel/file1.txt\u201d,\n\u201c/home/user/Documents/myModel/folder/file2.txt\u201d]\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s.\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster.\nrequired_metadata_values (List[RequiredMetadataValue]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\ntraining_dataset_id (Optional[str]) \u2013 The ID of the training dataset to assign to the custom model.\npartition_column (Optional[str]) \u2013 Name of a partition column in a training dataset assigned to the custom model.\nCan only be assigned for structured models.\nholdout_dataset_id (Optional[str]) \u2013 The ID of the holdout dataset to assign to the custom model.\nCan only be assigned for unstructured models.\nkeep_training_holdout_data (Optional[bool]) \u2013 If the version should inherit training and holdout data from the previous version.\nDefaults to True.\nThis field is only applicable if the model has training data for versions enabled,\notherwise the field value will be ignored.\nmax_wait (Optional[int]) \u2013 Max time to wait for training data assignment.\nIf set to None - method will return without waiting.\nDefaults to 10 minutes.\nruntime_parameter_values (List[RuntimeParameterValue]) \u2013 Additional parameters to be injected into a model at runtime. The fieldName\nmust match a fieldName that is listed in the runtimeParameterDefinitions section\nof the model-metadata.yaml file.\nReturns:\nCreated custom model version.\nReturn type:\nCustomModelVersion\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\ndatarobot.errors.InvalidUsageError \u2013 If wrong parameters are provided.\ndatarobot.errors.TrainingDataAssignmentError \u2013 If training data assignment fails.\nExamples\nCreate a version with blocking (default max_wait=600) training data assignment:\nimport datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\ndr.Client(token=my_token, endpoint=endpoint)\ntry:\nversion = dr.CustomModelVersion.create_clean(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n)\nexcept TrainingDataAssignmentError as e:\nprint(e)\nCreate a version with non-blocking training data assignment:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nversion = dr.CustomModelVersion.create_clean(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\nmax_wait=None,\n)\nwhile version.training_data.assignment_in_progress:\ntime.sleep(10)\nversion.refresh()\nif version.training_data.assignment_error:\nprint(version.training_data.assignment_error[\"message\"])\nclassmethod create_from_previous(custom_model_id, base_environment_id=None, is_major_update=True, folder_path=None, files=None, files_to_delete=None, network_egress_policy=None, maximum_memory=None, replicas=None, required_metadata_values=None, training_dataset_id=None, partition_column=None, holdout_dataset_id=None, keep_training_holdout_data=None, max_wait=600, runtime_parameter_values=None, base_environment_version_id=None)\uf0c1\nCreate a custom model version containing files from a previous version.\nCreate a version with training/holdout data:\nIf training/holdout data related parameters are provided,\nthe training data is assigned asynchronously.\nIn this case:\n* if max_wait is not None, function returns once job is finished.\n* if max_wait is None, function returns immediately, progress can be polled by the user, see examples.\nIf training data assignment fails, new version is still created,\nbut it is not allowed to create a model package (version) for the model version and to deploy it.\nTo check for training data assignment error, check version.training_data.assignment_error[\u201cmessage\u201d].\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\nbase_environment_id (str) \u2013 The base environment to use with this model version.\nAt least one of \u201cbase_environment_id\u201d and \u201cbase_environment_version_id\u201d must be provided.\nIf both are specified, the version must belong to the environment.\nbase_environment_version_id (str) \u2013 The base environment version ID to use with this model version.\nAt least one of \u201cbase_environment_id\u201d and \u201cbase_environment_version_id\u201d must be provided.\nIf both are specified, the version must belong to the environment.\nIf not specified: in case previous model versions exist, the value from the latest model\nversion is inherited, otherwise, latest successfully built version of the environment\nspecified in \u201cbase_environment_id\u201d is used.\nis_major_update (Optional[bool]) \u2013 The flag defining if a custom model version will be a minor or a major version.\nDefaults to True.\nfolder_path (Optional[str]) \u2013 The path to a folder containing files to be uploaded.\nEach file in the folder is uploaded under path relative to a folder path.\nfiles (Optional[List]) \u2013 The list of tuples, where values in each tuple are the local filesystem path and\nthe path the file should be placed in the model.\nIf list is of strings, then basenames will be used for tuples\nExample:\n[(\u201c/home/user/Documents/myModel/file1.txt\u201d, \u201cfile1.txt\u201d),\n(\u201c/home/user/Documents/myModel/folder/file2.txt\u201d, \u201cfolder/file2.txt\u201d)]\nor\n[\u201c/home/user/Documents/myModel/file1.txt\u201d,\n\u201c/home/user/Documents/myModel/folder/file2.txt\u201d]\nfiles_to_delete (Optional[List]) \u2013 The list of a file items ids to be deleted.\nExample: [\u201c5ea95f7a4024030aba48e4f9\u201d, \u201c5ea6b5da402403181895cc51\u201d]\nnetwork_egress_policy (datarobot.NETWORK_EGRESS_POLICY, optional) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE, datarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nmaximum_memory (Optional[int]) \u2013 The maximum memory that might be allocated by the custom-model.\nIf exceeded, the custom-model will be killed by k8s\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed in the cluster\nrequired_metadata_values (List[RequiredMetadataValue]) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\ntraining_dataset_id (Optional[str]) \u2013 The ID of the training dataset to assign to the custom model.\npartition_column (Optional[str]) \u2013 Name of a partition column in a training dataset assigned to the custom model.\nCan only be assigned for structured models.\nholdout_dataset_id (Optional[str]) \u2013 The ID of the holdout dataset to assign to the custom model.\nCan only be assigned for unstructured models.\nkeep_training_holdout_data (Optional[bool]) \u2013 If the version should inherit training and holdout data from the previous version.\nDefaults to True.\nThis field is only applicable if the model has training data for versions enabled,\notherwise the field value will be ignored.\nmax_wait (Optional[int]) \u2013 Max time to wait for training data assignment.\nIf set to None - method will return without waiting.\nDefaults to 10 minutes.\nruntime_parameter_values (List[RuntimeParameterValue]) \u2013 Additional parameters to be injected into the model at runtime. The fieldName\nmust match a fieldName that is listed in the runtimeParameterDefinitions section\nof the model-metadata.yaml file. This list will be merged with any existing\nruntime values set from the prior version, so it is possible to specify a null value\nto unset specific parameters and fall back to the defaultValue from the definition.\nReturns:\ncreated custom model version\nReturn type:\nCustomModelVersion\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\ndatarobot.errors.InvalidUsageError \u2013 If wrong parameters are provided.\ndatarobot.errors.TrainingDataAssignmentError \u2013 If training data assignment fails.\nExamples\nCreate a version with blocking (default max_wait=600) training data assignment:\nimport datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\ndr.Client(token=my_token, endpoint=endpoint)\ntry:\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n)\nexcept TrainingDataAssignmentError as e:\nprint(e)\nCreate a version with non-blocking training data assignment:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\nmax_wait=None,\n)\nwhile version.training_data.assignment_in_progress:\ntime.sleep(10)\nversion.refresh()\nif version.training_data.assignment_error:\nprint(version.training_data.assignment_error[\"message\"])\nclassmethod list(custom_model_id)\uf0c1\nList custom model versions.\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\nReturns:\nA list of custom model versions.\nReturn type:\nList[CustomModelVersion]\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclassmethod get(custom_model_id, custom_model_version_id)\uf0c1\nGet custom model version by id.\nAdded in version v2.21.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\ncustom_model_version_id (str) \u2013 The id of the custom model version to retrieve.\nReturns:\nRetrieved custom model version.\nReturn type:\nCustomModelVersion\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\ndownload(file_path)\uf0c1\nDownload custom model version.\nAdded in version v2.21.\nParameters:\nfile_path (str) \u2013 Path to create a file with custom model version content.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nReturn type:\nNone\nupdate(description=None, required_metadata_values=None)\uf0c1\nUpdate custom model version properties.\nAdded in version v2.21.\nParameters:\ndescription (Optional[str]) \u2013 New custom model version description.\nrequired_metadata_values (List[RequiredMetadataValue], optional) \u2013 Additional parameters required by the execution environment. The required keys are\ndefined by the fieldNames in the base environment\u2019s requiredMetadataKeys.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nReturn type:\nNone\nrefresh()\uf0c1\nUpdate custom model version with the latest data from server.\n:rtype: None\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nget_feature_impact(with_metadata=False)\uf0c1\nGet custom model feature impact.\nAdded in version v2.23.\nParameters:\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\nReturns:\nfeature_impacts \u2013 The feature impact data. Each item is a dict with the keys \u2018featureName\u2019,\n\u2018impactNormalized\u2019, and \u2018impactUnnormalized\u2019, and \u2018redundantWith\u2019.\nReturn type:\nlist of dict\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\ncalculate_feature_impact(max_wait=600)\uf0c1\nCalculate custom model feature impact.\nAdded in version v2.23.\nParameters:\nmax_wait (Optional[int]) \u2013 Max time to wait for feature impact calculation.\nIf set to None - method will return without waiting.\nDefaults to 10 min\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nNone\nclass datarobot.models.execution_environment.RequiredMetadataKey\uf0c1\nDefinition of a metadata key that custom models using this environment must define\nAdded in version v2.25.\nVariables:\nfield_name (str) \u2013 The required field key. This value will be added as an environment\nvariable when running custom models.\ndisplay_name (str) \u2013 A human readable name for the required field.\nclass datarobot.models.CustomModelVersionConversion\uf0c1\nA conversion of a DataRobot custom model version.\nAdded in version v2.27.\nVariables:\nid (str) \u2013 The ID of the custom model version conversion.\ncustom_model_version_id (str) \u2013 The ID of the custom model version.\ncreated (str) \u2013 ISO-8601 timestamp of when the custom model conversion created.\nmain_program_item_id (str or None) \u2013 The ID of the main program item.\nlog_message (str or None) \u2013 The conversion output log message.\ngenerated_metadata (dict or None) \u2013 The dict contains two items: \u2018outputDataset\u2019 & \u2018outputColumns\u2019.\nconversion_succeeded (bool) \u2013 Whether the conversion succeeded or not.\nconversion_in_progress (bool) \u2013 Whether a given conversion is in progress or not.\nshould_stop (bool) \u2013 Whether the user asked to stop a conversion.\nclassmethod run_conversion(custom_model_id, custom_model_version_id, main_program_item_id, max_wait=None)\uf0c1\nInitiate a new custom model version conversion.\nParameters:\ncustom_model_id (str) \u2013 The associated custom model ID.\ncustom_model_version_id (str) \u2013 The associated custom model version ID.\nmain_program_item_id (str) \u2013 The selected main program item ID. This should be one of the SAS items in the\nassociated custom model version.\nmax_wait (int or None) \u2013 Max wait time in seconds. If None, then don\u2019t wait.\nReturns:\nconversion_id \u2013 The ID of the newly created conversion entity.\nReturn type:\nstr\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclassmethod stop_conversion(custom_model_id, custom_model_version_id, conversion_id)\uf0c1\nStop a conversion that is in progress.\nParameters:\ncustom_model_id (str) \u2013 The ID of the associated custom model.\ncustom_model_version_id (str) \u2013 The ID of the associated custom model version.\nconversion_id (str) \u2013 The ID of a conversion that is in-progress.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nReturn type:\nResponse\nclassmethod get(custom_model_id, custom_model_version_id, conversion_id)\uf0c1\nGet custom model version conversion by id.\nAdded in version v2.27.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\ncustom_model_version_id (str) \u2013 The ID of the custom model version.\nconversion_id (str) \u2013 The ID of the conversion to retrieve.\nReturns:\nRetrieved custom model version conversion.\nReturn type:\nCustomModelVersionConversion\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclassmethod get_latest(custom_model_id, custom_model_version_id)\uf0c1\nGet latest custom model version conversion for a given custom model version.\nAdded in version v2.27.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\ncustom_model_version_id (str) \u2013 The ID of the custom model version.\nReturns:\nRetrieved latest conversion for a given custom model version.\nReturn type:\nCustomModelVersionConversion or None\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclassmethod list(custom_model_id, custom_model_version_id)\uf0c1\nGet custom model version conversions list per custom model version.\nAdded in version v2.27.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\ncustom_model_version_id (str) \u2013 The ID of the custom model version.\nReturns:\nRetrieved conversions for a given custom model version.\nReturn type:\nList[CustomModelVersionConversion]\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclass datarobot.CustomModelVersionDependencyBuild\uf0c1\nMetadata about a DataRobot custom model version\u2019s dependency build\nAdded in version v2.22.\nVariables:\ncustom_model_id (str) \u2013 The ID of the custom model.\ncustom_model_version_id (str) \u2013 The ID of the custom model version.\nbuild_status (str) \u2013 The status of the custom model version\u2019s dependency build.\nstarted_at (str) \u2013 ISO-8601 formatted timestamp of when the build was started.\ncompleted_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the build has completed.\nclassmethod get_build_info(custom_model_id, custom_model_version_id)\uf0c1\nRetrieve information about a custom model version\u2019s dependency build\nAdded in version v2.22.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model.\ncustom_model_version_id (str) \u2013 The ID of the custom model version.\nReturns:\nThe dependency build information.\nReturn type:\nCustomModelVersionDependencyBuild\nclassmethod start_build(custom_model_id, custom_model_version_id, max_wait=600)\uf0c1\nStart the dependency build for a custom model version  dependency build\nAdded in version v2.22.\nParameters:\ncustom_model_id (str) \u2013 The ID of the custom model\ncustom_model_version_id (str) \u2013 the ID of the custom model version\nmax_wait (Optional[int]) \u2013 Max time to wait for a build completion.\nIf set to None - method will return without waiting.\nReturn type:\nOptional[CustomModelVersionDependencyBuild]\nget_log()\uf0c1\nGet log of a custom model version dependency build.\n:rtype: str\nAdded in version v2.22.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\ncancel()\uf0c1\nCancel custom model version dependency build that is in progress.\n:rtype: None\nAdded in version v2.22.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nrefresh()\uf0c1\nUpdate custom model version dependency build with the latest data from server.\n:rtype: None\nAdded in version v2.22.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclass datarobot.ExecutionEnvironment\uf0c1\nAn execution environment entity.\nAdded in version v2.21.\nVariables:\nid (str) \u2013 The ID of the execution environment.\nname (str) \u2013 The name of the execution environment.\ndescription (Optional[str]) \u2013 The description of the execution environment.\nprogramming_language (Optional[str]) \u2013 The programming language of the execution environment.\nCan be \u201cpython\u201d, \u201cr\u201d, \u201cjava\u201d or \u201cother\u201d.\nis_public (Optional[bool]) \u2013 Public accessibility of environment, visible only for admin user.\ncreated_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the execution environment version was created.\nlatest_version (ExecutionEnvironmentVersion, optional) \u2013 The latest version of the execution environment.\nlatest_successful_version (ExecutionEnvironmentVersion, optional) \u2013 The latest version of the execution environment, which contains a successfully built image.\nrequired_metadata_keys (Optional[List[RequiredMetadataKey]]) \u2013 The definition of metadata keys that custom models using this environment must define.\nuse_cases (Optional[List[str]]) \u2013 A list of use-cases this environment may be used for.\nclassmethod create(name, description=None, programming_language=None, required_metadata_keys=None, is_public=None, use_cases=None)\uf0c1\nCreate an execution environment.\nAdded in version v2.21.\nParameters:\nname (str) \u2013 execution environment name\ndescription (Optional[str]) \u2013 execution environment description\nprogramming_language (Optional[str]) \u2013 programming language of the environment to be created.\nCan be \u201cpython\u201d, \u201cr\u201d, \u201cjava\u201d or \u201cother\u201d. Default value - \u201cother\u201d\nrequired_metadata_keys (List[RequiredMetadataKey]) \u2013 Definition of a metadata keys that custom models using this environment must define\nis_public (bool, optional) \u2013 public accessibility of environment\nuse_cases (List[str], optional) \u2013 List of use-cases this environment may be used for\nReturns:\ncreated execution environment\nReturn type:\nExecutionEnvironment\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod list(search_for=None, is_own=None, use_cases=None, offset=0, limit=0)\uf0c1\nList execution environments available to the user.\nAdded in version v2.21.\nParameters:\nsearch_for (Optional[str]) \u2013 the string for filtering execution environment - only execution\nenvironments that contain the string in name or description will\nbe returned.\nis_own (bool, optional) \u2013 Only return execution environments that were created by the current user.\nuse_cases (str, optional) \u2013 Only return execution environments that contain the specified use case\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 0 to maintain previous behavior.\nThe default on the server is 20, with a maximum of 100.\nReturns:\na list of execution environments.\nReturn type:\nList[ExecutionEnvironment]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(execution_environment_id)\uf0c1\nGet execution environment by its ID.\nAdded in version v2.21.\nParameters:\nexecution_environment_id (str) \u2013 ID of the execution environment to retrieve\nReturns:\nretrieved execution environment\nReturn type:\nExecutionEnvironment\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndelete()\uf0c1\nDelete execution environment.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nupdate(name=None, description=None, required_metadata_keys=None, is_public=None, use_cases=None)\uf0c1\nUpdate execution environment properties.\nAdded in version v2.21.\nParameters:\nname (Optional[str]) \u2013 new execution environment name\ndescription (Optional[str]) \u2013 new execution environment description\nrequired_metadata_keys (List[RequiredMetadataKey]) \u2013 Definition of a metadata keys that custom models using this environment must define\nis_public (bool, optional) \u2013 public accessibility of environment\nuse_cases (List[str], optional) \u2013 List of use-cases this environment may be used for\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nrefresh()\uf0c1\nUpdate execution environment with the latest data from server.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nget_access_list()\uf0c1\nRetrieve access control settings of this environment.\nAdded in version v2.36.\nReturn type:\nlist of SharingAccess\nshare(access_list)\uf0c1\nUpdate the access control settings of this execution environment.\nAdded in version v2.36.\nParameters:\naccess_list (list of SharingAccess) \u2013 A list of SharingAccess to update.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nReturn type:\nNone\nExamples\nTransfer access to the execution environment from old_user@datarobot.com to new_user@datarobot.com\nimport datarobot as dr\nnew_access = dr.SharingAccess(new_user@datarobot.com,\ndr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\ndr.ExecutionEnvironment.get('environment-id').share(access_list)\nclass datarobot.ExecutionEnvironmentVersion\uf0c1\nA version of a DataRobot execution environment.\nAdded in version v2.21.\nVariables:\nid (str) \u2013 the id of the execution environment version\nenvironment_id (str) \u2013 the id of the execution environment the version belongs to\nbuild_status (str) \u2013 the status of the execution environment version build\nimage_id (str) \u2013 The Docker image ID of the environment version.\nlabel (Optional[str]) \u2013 the label of the execution environment version\ndescription (Optional[str]) \u2013 the description of the execution environment version\ncreated_at (Optional[str]) \u2013 ISO-8601 formatted timestamp of when the execution environment version was created\ndocker_context_size (Optional[int]) \u2013 The size of the uploaded Docker context in bytes if available or None if not\ndocker_image_size (Optional[int]) \u2013 The size of the built Docker image in bytes if available or None if not\ndocker_image_uri (Optional[str]) \u2013 The URI that the source Docker image execution environment version is based on.\nSet to None if there is not one provided.\nclassmethod create(execution_environment_id, docker_context_path=None, docker_image_uri=None, label=None, description=None, max_wait=600)\uf0c1\nCreate an execution environment version.\nAdded in version v2.21.\nParameters:\nexecution_environment_id (str) \u2013 the id of the execution environment\ndocker_context_path (Optional[str]) \u2013 The path to a Docker context archive or folder. This parameter has lower priority\nthan docker_image_uri if they are both provided.\ndocker_image_uri (Optional[str]) \u2013 The docker_image_uri to be used as an environment.\nIt has priority over the docker_context_path. If both are provided,\nthe environment is created from docker_image_uri, and context is uploaded for\ninformation purposes.\nlabel (Optional[str]) \u2013 A human-readable string to label the version.\ndescription (Optional[str]) \u2013 execution environment version description\nmax_wait (Optional[int]) \u2013 max time to wait for a final build status (\u201csuccess\u201d or \u201cfailed\u201d).\nIf set to None - method will return without waiting.\nReturns:\ncreated execution environment version\nReturn type:\nExecutionEnvironmentVersion\nRaises:\ndatarobot.errors.AsyncTimeoutError \u2013 if version did not reach final state during timeout seconds\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod list(execution_environment_id, build_status=None)\uf0c1\nList execution environment versions available to the user.\n.. versionadded:: v2.21\nParameters:\nexecution_environment_id (str) \u2013 the id of the execution environment\nbuild_status (Optional[str]) \u2013 build status of the execution environment version to filter by.\nSee datarobot.enums.EXECUTION_ENVIRONMENT_VERSION_BUILD_STATUS for valid options\nReturns:\na list of execution environment versions.\nReturn type:\nList[ExecutionEnvironmentVersion]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(execution_environment_id, version_id)\uf0c1\nGet execution environment version by id.\nAdded in version v2.21.\nParameters:\nexecution_environment_id (str) \u2013 the id of the execution environment\nversion_id (str) \u2013 the id of the execution environment version to retrieve\nReturns:\nretrieved execution environment version\nReturn type:\nExecutionEnvironmentVersion\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\ndownload(file_path)\uf0c1\nDownload execution environment version.\nAdded in version v2.21.\nParameters:\nfile_path (str) \u2013 path to create a file with execution environment version content\nReturns:\nretrieved execution environment version\nReturn type:\nExecutionEnvironmentVersion\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nget_build_log()\uf0c1\nGet execution environment version build log and error.\nAdded in version v2.21.\nReturns:\nretrieved execution environment version build log and error.\nIf there is no build error - None is returned.\nReturn type:\nTuple[str, str]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nrefresh()\uf0c1\nUpdate execution environment version with the latest data from server.\nAdded in version v2.21.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclass datarobot.models.custom_model_version.HoldoutData\uf0c1\nHoldout data assigned to a DataRobot custom model version.\nAdded in version v3.2.\nVariables:\ndataset_id (str) \u2013 The ID of the dataset.\ndataset_version_id (str) \u2013 The ID of the dataset version.\ndataset_name (str) \u2013 The name of the dataset.\npartition_column (str) \u2013 The name of the partitions column.\nclass datarobot.models.custom_model_version.TrainingData\uf0c1\nTraining data assigned to a DataRobot custom model version.\nAdded in version v3.2.\nVariables:\ndataset_id (str) \u2013 The ID of the dataset.\ndataset_version_id (str) \u2013 The ID of the dataset version.\ndataset_name (str) \u2013 The name of the dataset.\nassignment_in_progress (bool) \u2013 The status of the assignment in progress.\nassignment_error (dict) \u2013 The assignment error message.\nclass datarobot.models.custom_model_version.RuntimeParameter\uf0c1\nDefinition of a runtime parameter used for the custom model version, it includesthe override value if provided.\nAdded in version v3.4.0.\nVariables:\nfield_name (str) \u2013 The runtime parameter name. This value is added as an environment variable when\nrunning custom models.\ntype (str) \u2013 The value type accepted by the runtime parameter.\ndescription (str) \u2013 Describes how the runtime parameter impacts the running model.\nallow_empty (bool) \u2013 Indicates if the runtime parameter must be set before registration.\nmin_value (float) \u2013 The minimum value for a numeric field.\nmax_value (float) \u2013 The maximum value for a numeric field.\ndefault_value (str, bool, float or None) \u2013 The default value for the given field.\noverride_value (str, bool, float or None) \u2013 The value set by the user that overrides the default set in the runtime parameter\ndefinition.\ncurrent_value (str, bool, float or None) \u2013 After the default and the override values are applied, this is the value of the\nruntime parameter.\ncredential_type (str) \u2013 Describes the type of credential, used only for credentials parameters.\nclass datarobot.models.custom_model_version.RuntimeParameterValue\uf0c1\nThe definition of a runtime parameter value used for the custom model version, this defines\nthe runtime parameter override.\nAdded in version v3.4.0.\nVariables:\nfield_name (str) \u2013 The runtime parameter name. This value is added as an environment variable when\nrunning custom models.\ntype (str) \u2013 The value type accepted by the runtime parameter.\nvalue (str, bool or float) \u2013 After the default and the override values are applied, this is the value of the\nruntime parameter.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.TARGET_TYPE",
        "datarobot.CustomModelVersion",
        "datarobot.NETWORK_EGRESS_POLICY",
        "List[CustomInferenceModel]",
        "datarobot.TARGET_TYPE",
        "datarobot.NETWORK_EGRESS_POLICY",
        "import datarobot as dr\n\nnew_access = dr.SharingAccess(new_user@datarobot.com,\n                              dr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\n\ndr.CustomInferenceModel.get('custom-model-id').share(access_list)",
        "datarobot.NETWORK_EGRESS_POLICY",
        "datarobot.NETWORK_EGRESS_POLICY",
        "List[CustomModelTest]",
        "List[CustomModelFileItem]",
        "datarobot.NETWORK_EGRESS_POLICY",
        "datarobot.NETWORK_EGRESS_POLICY",
        "import datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ntry:\n    version = dr.CustomModelVersion.create_clean(\n        custom_model_id=\"6444482e5583f6ee2e572265\",\n        base_environment_id=\"642209acc563893014a41e24\",\n        training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    )\nexcept TrainingDataAssignmentError as e:\n    print(e)",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nversion = dr.CustomModelVersion.create_clean(\n    custom_model_id=\"6444482e5583f6ee2e572265\",\n    base_environment_id=\"642209acc563893014a41e24\",\n    training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    max_wait=None,\n)\n\nwhile version.training_data.assignment_in_progress:\n    time.sleep(10)\n    version.refresh()\nif version.training_data.assignment_error:\n    print(version.training_data.assignment_error[\"message\"])",
        "datarobot.NETWORK_EGRESS_POLICY",
        "import datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ntry:\n    version = dr.CustomModelVersion.create_from_previous(\n        custom_model_id=\"6444482e5583f6ee2e572265\",\n        base_environment_id=\"642209acc563893014a41e24\",\n        training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    )\nexcept TrainingDataAssignmentError as e:\n    print(e)",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nversion = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=\"6444482e5583f6ee2e572265\",\n    base_environment_id=\"642209acc563893014a41e24\",\n    training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    max_wait=None,\n)\n\nwhile version.training_data.assignment_in_progress:\n    time.sleep(10)\n    version.refresh()\nif version.training_data.assignment_error:\n    print(version.training_data.assignment_error[\"message\"])",
        "List[CustomModelVersion]",
        "CustomModelVersionConversion",
        "CustomModelVersionConversion",
        "List[CustomModelVersionConversion]",
        "CustomModelVersionDependencyBuild",
        "CustomModelVersionDependencyBuild",
        "import datarobot as dr\n\nnew_access = dr.SharingAccess(new_user@datarobot.com,\n                              dr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\n\ndr.ExecutionEnvironment.get('environment-id').share(access_list)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-connectivity.html",
      "title": "Database connectivity\uf0c1",
      "description": "",
      "content": "Database connectivity\uf0c1\nclass datarobot.DataDriver\uf0c1\nA data driver\nVariables:\nid (str) \u2013 the id of the driver.\nclass_name (str) \u2013 the Java class name for the driver.\ncanonical_name (str) \u2013 the user-friendly name of the driver.\ncreator (str) \u2013 the id of the user who created the driver.\nbase_names (List[str]) \u2013 a list of the file name(s) of the jar files.\nclassmethod list(typ=None)\uf0c1\nReturns list of available drivers.\nParameters:\ntyp (DataDriverListTypes) \u2013 If specified, filters by specified driver type.\nReturns:\ndrivers \u2013 contains a list of available drivers.\nReturn type:\nlist of DataDriver instances\nExamples\n>>> import datarobot as dr\n>>> drivers = dr.DataDriver.list()\n>>> drivers\n[DataDriver('mysql'), DataDriver('RedShift'), DataDriver('PostgreSQL')]\nclassmethod get(driver_id)\uf0c1\nGets the driver.\nParameters:\ndriver_id (str) \u2013 the identifier of the driver.\nReturns:\ndriver \u2013 the required driver.\nReturn type:\nDataDriver\nExamples\n>>> import datarobot as dr\n>>> driver = dr.DataDriver.get('5ad08a1889453d0001ea7c5c')\n>>> driver\nDataDriver('PostgreSQL')\nclassmethod create(class_name, canonical_name, files=None, typ=None, database_driver=None)\uf0c1\nCreates the driver. Only available to admin users.\nParameters:\nclass_name (str) \u2013 the Java class name for the driver. Specify None if typ is DataDriverTypes.DR_DATABASE_V1`.\ncanonical_name (str) \u2013 the user-friendly name of the driver.\nfiles (List[str]) \u2013 a list of the file paths on file system file_path(s) for the driver.\ntyp (str) \u2013 Optional. Specify the type of the driver. Defaults to DataDriverTypes.JDBC, may also be\nDataDriverTypes.DR_DATABASE_V1.\ndatabase_driver (str) \u2013 Optional. Specify when typ is DataDriverTypes.DR_DATABASE_V1 to create a native database\ndriver. See DrDatabaseV1Types enum for some of the types, but that list may not be exhaustive.\nReturns:\ndriver \u2013 the created driver.\nReturn type:\nDataDriver\nRaises:\nClientError \u2013 raised if user is not granted for Can manage JDBC database drivers feature\nExamples\n>>> import datarobot as dr\n>>> driver = dr.DataDriver.create(\n...     class_name='org.postgresql.Driver',\n...     canonical_name='PostgreSQL',\n...     files=['/tmp/postgresql-42.2.2.jar']\n... )\n>>> driver\nDataDriver('PostgreSQL')\nupdate(class_name=None, canonical_name=None)\uf0c1\nUpdates the driver. Only available to admin users.\nParameters:\nclass_name (str) \u2013 the Java class name for the driver.\ncanonical_name (str) \u2013 the user-friendly name of the driver.\nRaises:\nClientError \u2013 raised if user is not granted for Can manage JDBC database drivers feature\nReturn type:\nNone\nExamples\n>>> import datarobot as dr\n>>> driver = dr.DataDriver.get('5ad08a1889453d0001ea7c5c')\n>>> driver.canonical_name\n'PostgreSQL'\n>>> driver.update(canonical_name='postgres')\n>>> driver.canonical_name\n'postgres'\ndelete()\uf0c1\nRemoves the driver. Only available to admin users.\nRaises:\nClientError \u2013 raised if user is not granted for Can manage JDBC database drivers feature\nReturn type:\nNone\nclass datarobot.Connector\uf0c1\nA connector\nVariables:\nid (str) \u2013 the id of the connector.\ncreator_id (str) \u2013 the id of the user who created the connector.\nbase_name (str) \u2013 the file name of the jar file.\ncanonical_name (str) \u2013 the user-friendly name of the connector.\nconfiguration_id (str) \u2013 the id of the configuration of the connector.\nclassmethod list()\uf0c1\nReturns list of available connectors.\nReturns:\nconnectors \u2013 contains a list of available connectors.\nReturn type:\nlist of Connector instances\nExamples\n>>> import datarobot as dr\n>>> connectors = dr.Connector.list()\n>>> connectors\n[Connector('ADLS Gen2 Connector'), Connector('S3 Connector')]\nclassmethod get(connector_id)\uf0c1\nGets the connector.\nParameters:\nconnector_id (str) \u2013 the identifier of the connector.\nReturns:\nconnector \u2013 the required connector.\nReturn type:\nConnector\nExamples\n>>> import datarobot as dr\n>>> connector = dr.Connector.get('5fe1063e1c075e0245071446')\n>>> connector\nConnector('ADLS Gen2 Connector')\nclassmethod create(file_path=None, connector_type=None)\uf0c1\nCreates the connector from a jar file. Only available to admin users.\nParameters:\nfile_path (str) \u2013 (Deprecated in version v3.6)\nthe file path on file system file_path(s) for the java-based connector.\nconnector_type (str) \u2013 The type of the native connector to create\nReturns:\nconnector \u2013 the created connector.\nReturn type:\nConnector\nRaises:\nClientError \u2013 raised if user is not granted for Can manage connectors feature\nExamples\n>>> import datarobot as dr\n>>> connector = dr.Connector.create('/tmp/connector-adls-gen2.jar')\n>>> connector\nConnector('ADLS Gen2 Connector')\nupdate(file_path)\uf0c1\nUpdates the connector with new jar file. Only available to admin users.\nParameters:\nfile_path (str) \u2013 (Deprecated in version v3.6)\nthe file path on file system file_path(s) for the java-based connector.\nReturns:\nconnector \u2013 the updated connector.\nReturn type:\nConnector\nRaises:\nClientError \u2013 raised if user is not granted for Can manage connectors feature\nExamples\n>>> import datarobot as dr\n>>> connector = dr.Connector.get('5fe1063e1c075e0245071446')\n>>> connector.base_name\n'connector-adls-gen2.jar'\n>>> connector.update('/tmp/connector-s3.jar')\n>>> connector.base_name\n'connector-s3.jar'\ndelete()\uf0c1\nRemoves the connector. Only available to admin users.\nRaises:\nClientError \u2013 raised if user is not granted for Can manage connectors feature\nReturn type:\nNone\nclass datarobot.DataStore\uf0c1\nA data store. Represents database\nVariables:\nid (str) \u2013 The id of the data store.\ndata_store_type (str) \u2013 The type of data store.\ncanonical_name (str) \u2013 The user-friendly name of the data store.\ncreator (str) \u2013 The id of the user who created the data store.\nupdated (datetime.datetime) \u2013 The time of the last update\nparams (DataStoreParameters) \u2013 A list specifying data store parameters.\nrole (str) \u2013 Your access role for this data store.\nclassmethod list(typ=None, name=None, substitute_url_parameters=False)\uf0c1\nReturns list of available data stores.\nParameters:\ntyp (str) \u2013 If specified, filters by specified data store type. If not specified, the default\nis DataStoreListTypes.JDBC.\nname (str) \u2013 If specified, filters by data store names that match or contain this name.\nThe search is case-insensitive.\nsubstitute_url_parameters (bool) \u2013 If specified, dynamic parameters in the URL will be substituted.\nReturns:\ndata_stores \u2013 contains a list of available data stores.\nReturn type:\nlist of DataStore instances\nExamples\n>>> import datarobot as dr\n>>> data_stores = dr.DataStore.list()\n>>> data_stores\n[DataStore('Demo'), DataStore('Airlines')]\nclassmethod get(data_store_id, substitute_url_parameters=False)\uf0c1\nGets the data store.\nParameters:\ndata_store_id (str) \u2013 the identifier of the data store.\nsubstitute_url_parameters (bool) \u2013 If specified, dynamic parameters in the URL will be substituted.\nReturns:\ndata_store \u2013 the required data store.\nReturn type:\nDataStore\nExamples\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5a8ac90b07a57a0001be501e')\n>>> data_store\nDataStore('Demo')\nclassmethod create(data_store_type, canonical_name, driver_id=None, jdbc_url=None, fields=None, connector_id=None)\uf0c1\nCreates the data store.\nParameters:\ndata_store_type (str or DataStoreTypes) \u2013 the type of data store.\ncanonical_name (str) \u2013 the user-friendly name of the data store.\ndriver_id (str) \u2013 Optional. The identifier of the DataDriver if data_store_type is DataStoreListTypes.JDBC or\nDataStoreListTypes.DR_DATABASE_V1.\njdbc_url (str) \u2013 Optional. The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).\nfields (list) \u2013 Optional. If the type is dr-database-v1, then the fields specify the configuration.\nconnector_id (str) \u2013 Optional. The identifier of the Connector if data_store_type is DataStoreListTypes.DR_CONNECTOR_V1\nReturns:\ndata_store \u2013 the created data store.\nReturn type:\nDataStore\nExamples\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.create(\n...     data_store_type='jdbc',\n...     canonical_name='Demo DB',\n...     driver_id='5a6af02eb15372000117c040',\n...     jdbc_url='jdbc:postgresql://my.db.address.org:5432/perftest'\n... )\n>>> data_store\nDataStore('Demo DB')\nupdate(canonical_name=None, driver_id=None, connector_id=None, jdbc_url=None, fields=None)\uf0c1\nUpdates the data store.\nParameters:\ncanonical_name (str) \u2013 optional, the user-friendly name of the data store.\ndriver_id (str) \u2013 Optional. The identifier of the DataDriver. if the type is one of DataStoreTypes.DR_DATABASE_V1\nor DataStoreTypes.JDBC.\nconnector_id (str) \u2013 Optional. The identifier of the Connector. if the type is DataStoreTypes.DR_CONNECTOR_V1.\njdbc_url (str) \u2013 Optional. The full JDBC URL (for example: jdbc:postgresql://my.dbaddress.org:5432/my_db).\nfields (list) \u2013 Optional. If the type is dr-database-v1, then the fields specify the configuration.\nReturn type:\nNone\nExamples\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store\nDataStore('Demo DB')\n>>> data_store.update(canonical_name='Demo DB updated')\n>>> data_store\nDataStore('Demo DB updated')\ndelete()\uf0c1\nRemoves the DataStore\nReturn type:\nNone\ntest(username=None, password=None, credential_id=None, use_kerberos=None, credential_data=None)\uf0c1\nTests database connection.\nChanged in version v3.2: Added credential_id, use_kerberos and credential_data optional params and made\nusername and password optional.\nParameters:\nusername (str) \u2013 optional, the username for database authentication.\npassword (str) \u2013 optional, the password for database authentication. The password is encrypted\nat server side and never saved / stored\ncredential_id (str) \u2013 optional, id of the set of credentials to use instead of username and password\nuse_kerberos (bool) \u2013 optional, whether to use Kerberos for data store authentication\ncredential_data (dict) \u2013 optional, the credentials to authenticate with the database, to use instead of\nuser/password or credential ID\nReturns:\nmessage \u2013 message with status.\nReturn type:\ndict\nExamples\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store.test(username='db_username', password='db_password')\n{'message': 'Connection successful'}\nschemas(username, password)\uf0c1\nReturns list of available schemas.\nParameters:\nusername (str) \u2013 the username for database authentication.\npassword (str) \u2013 the password for database authentication. The password is encrypted\nat server side and never saved / stored\nReturns:\nresponse \u2013 dict with database name and list of str - available schemas\nReturn type:\ndict\nExamples\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store.schemas(username='db_username', password='db_password')\n{'catalog': 'perftest', 'schemas': ['demo', 'information_schema', 'public']}\ntables(username, password, schema=None)\uf0c1\nReturns list of available tables in schema.\nParameters:\nusername (str) \u2013 optional, the username for database authentication.\npassword (str) \u2013 optional, the password for database authentication. The password is encrypted\nat server side and never saved / stored\nschema (str) \u2013 optional, the schema name.\nReturns:\nresponse \u2013 dict with catalog name and tables info\nReturn type:\ndict\nExamples\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store.tables(username='db_username', password='db_password', schema='demo')\n{'tables': [{'type': 'TABLE', 'name': 'diagnosis', 'schema': 'demo'}, {'type': 'TABLE',\n'name': 'kickcars', 'schema': 'demo'}, {'type': 'TABLE', 'name': 'patient',\n'schema': 'demo'}, {'type': 'TABLE', 'name': 'transcript', 'schema': 'demo'}],\n'catalog': 'perftest'}\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nDataStore\nget_shared_roles()\uf0c1\nRetrieve what users have access to this data store\nAdded in version v3.2.\nReturn type:\nlist of SharingRole\nshare(access_list)\uf0c1\nModify the ability of users to access this data store\nAdded in version v2.14.\nParameters:\naccess_list (list of SharingRole) \u2013 the modifications to make.\nReturn type:\nNone\nRaises:\ndatarobot.ClientError : \u2013 if you do not have permission to share this data store, if the user you\u2019re sharing with\ndoesn\u2019t exist, if the same user appears multiple times in the access_list, or if these\nchanges would leave the data store without an owner.\nExamples\nThe SharingRole class is needed in order to\nshare a Data Store with one or more users.\nFor example, suppose you had a list of user IDs you wanted to share this DataStore with. You could use\na loop to generate a list of SharingRole objects for them,\nand bulk share this Data Store.\n>>> import datarobot as dr\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_ids = [\"60912e09fd1f04e832a575c1\", \"639ce542862e9b1b1bfa8f1b\", \"63e185e7cd3a5f8e190c6393\"]\n>>> sharing_roles = []\n>>> for user_id in user_ids:\n...     new_sharing_role = SharingRole(\n...         role=SHARING_ROLE.CONSUMER,\n...         share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...         id=user_id,\n...         can_share=True,\n...     )\n...     sharing_roles.append(new_sharing_role)\n>>> dr.DataStore.get('my-data-store-id').share(access_list)\nSimilarly, a SharingRole instance can be used to\nremove a user\u2019s access if the role is set to SHARING_ROLE.NO_ROLE, like in this example:\n>>> import datarobot as dr\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_to_remove = \"[email\u00a0protected]\"\n... remove_sharing_role = SharingRole(\n...     role=SHARING_ROLE.NO_ROLE,\n...     share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...     username=user_to_remove,\n...     can_share=False,\n... )\n>>> dr.DataStore.get('my-data-store-id').share(roles=[remove_sharing_role])\nclass datarobot.DataSource\uf0c1\nA data source. Represents data request\nVariables:\nid (str) \u2013 the id of the data source.\ntype (str) \u2013 the type of data source.\ncanonical_name (str) \u2013 the user-friendly name of the data source.\ncreator (str) \u2013 the id of the user who created the data source.\nupdated (datetime.datetime) \u2013 the time of the last update.\nparams (DataSourceParameters) \u2013 a list specifying data source parameters.\nrole (str or None) \u2013 if a string, represents a particular level of access and should be one of\ndatarobot.enums.SHARING_ROLE.  For more information on the specific access levels, see\nthe sharing documentation.  If None, can be passed to a share\nfunction to revoke access for a specific user.\nclassmethod list(typ=None)\uf0c1\nReturns list of available data sources.\nParameters:\ntyp (DataStoreListTypes) \u2013 If specified, filters by specified datasource type. If not specified it will\ndefault to DataStoreListTypes.DATABASES\nReturns:\ndata_sources \u2013 contains a list of available data sources.\nReturn type:\nlist of DataSource instances\nExamples\n>>> import datarobot as dr\n>>> data_sources = dr.DataSource.list()\n>>> data_sources\n[DataSource('Diagnostics'), DataSource('Airlines 100mb'), DataSource('Airlines 10mb')]\nclassmethod get(data_source_id)\uf0c1\nGets the data source.\nParameters:\ndata_source_id (str) \u2013 the identifier of the data source.\nReturns:\ndata_source \u2013 the requested data source.\nReturn type:\nDataSource\nExamples\n>>> import datarobot as dr\n>>> data_source = dr.DataSource.get('5a8ac9ab07a57a0001be501f')\n>>> data_source\nDataSource('Diagnostics')\nclassmethod create(data_source_type, canonical_name, params)\uf0c1\nCreates the data source.\nParameters:\ndata_source_type (str or DataStoreTypes) \u2013 the type of data source.\ncanonical_name (str) \u2013 the user-friendly name of the data source.\nparams (DataSourceParameters) \u2013 a list specifying data source parameters.\nReturns:\ndata_source \u2013 the created data source.\nReturn type:\nDataSource\nExamples\n>>> import datarobot as dr\n>>> params = dr.DataSourceParameters(\n...     data_store_id='5a8ac90b07a57a0001be501e',\n...     query='SELECT * FROM airlines10mb WHERE \"Year\" >= 1995;'\n... )\n>>> data_source = dr.DataSource.create(\n...     data_source_type='jdbc',\n...     canonical_name='airlines stats after 1995',\n...     params=params\n... )\n>>> data_source\nDataSource('airlines stats after 1995')\nupdate(canonical_name=None, params=None)\uf0c1\nCreates the data source.\nParameters:\ncanonical_name (str) \u2013 optional, the user-friendly name of the data source.\nparams (DataSourceParameters) \u2013 optional, the identifier of the DataDriver.\nReturn type:\nNone\nExamples\n>>> import datarobot as dr\n>>> data_source = dr.DataSource.get('5ad840cc613b480001570953')\n>>> data_source\nDataSource('airlines stats after 1995')\n>>> params = dr.DataSourceParameters(\n...     query='SELECT * FROM airlines10mb WHERE \"Year\" >= 1990;'\n... )\n>>> data_source.update(\n...     canonical_name='airlines stats after 1990',\n...     params=params\n... )\n>>> data_source\nDataSource('airlines stats after 1990')\ndelete()\uf0c1\nRemoves the DataSource\nReturn type:\nNone\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(TDataSource, bound= DataSource)\nget_access_list()\uf0c1\nRetrieve what users have access to this data source\nAdded in version v2.14.\nReturn type:\nlist of SharingAccess\nshare(access_list)\uf0c1\nModify the ability of users to access this data source\nAdded in version v2.14.\nParameters:\naccess_list (list of SharingAccess) \u2013 The modifications to make.\nReturn type:\nNone\nRaises:\ndatarobot.ClientError: \u2013 If you do not have permission to share this data source, if the user you\u2019re sharing with\ndoesn\u2019t exist, if the same user appears multiple times in the access_list, or if these\nchanges would leave the data source without an owner.\nExamples\nTransfer access to the data source from old_user@datarobot.com to new_user@datarobot.com\nfrom datarobot.enums import SHARING_ROLE\nfrom datarobot.models.data_source import DataSource\nfrom datarobot.models.sharing import SharingAccess\nnew_access = SharingAccess(\n\"[email\u00a0protected]\",\nSHARING_ROLE.OWNER,\ncan_share=True,\n)\naccess_list = [\nSharingAccess(\"[email\u00a0protected]\", SHARING_ROLE.OWNER, can_share=True),\nnew_access,\n]\nDataSource.get('my-data-source-id').share(access_list)\ncreate_dataset(username=None, password=None, do_snapshot=None, persist_data_after_ingestion=None, categories=None, credential_id=None, use_kerberos=None)\uf0c1\nCreate a Dataset from this data source.\nAdded in version v2.22.\nParameters:\nusername (string, optional) \u2013 The username for database authentication.\npassword (string, optional) \u2013 The password (in cleartext) for database authentication. The password\nwill be encrypted on the server side in scope of HTTP request and never saved or stored.\ndo_snapshot (Optional[bool]) \u2013 If unset, uses the server default: True.\nIf true, creates a snapshot dataset; if\nfalse, creates a remote dataset. Creating snapshots from non-file sources requires an\nadditional permission, Enable Create Snapshot Data Source.\npersist_data_after_ingestion (Optional[bool]) \u2013 If unset, uses the server default: True.\nIf true, will enforce saving all data\n(for download and sampling) and will allow a user to view extended data profile\n(which includes data statistics like min/max/median/mean, histogram, etc.). If false,\nwill not enforce saving data. The data schema (feature names and types) still will be\navailable. Specifying this parameter to false and doSnapshot to true will result in\nan error.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\ncredential_id (string, optional) \u2013 The ID of the set of credentials to\nuse instead of user and password. Note that with this change, username and password\nwill become optional.\nuse_kerberos (Optional[bool]) \u2013 If unset, uses the server default: False.\nIf true, use kerberos authentication for database authentication.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data\nReturn type:\nDataset\nclass datarobot.DataSourceParameters\uf0c1\nData request configuration\nVariables:\ndata_store_id (str) \u2013 the id of the DataStore.\ntable (str) \u2013 Optional. The name of specified database table.\nschema (str) \u2013 Optional. The name of the schema associated with the table.\npartition_column (str) \u2013 Optional. The name of the partition column.\nquery (str) \u2013 Optional. The user specified SQL query.\nfetch_size (int) \u2013 Optional. A user specified fetch size in the range [1, 20000].\nBy default a fetchSize will be assigned to balance throughput and memory usage\npath (str) \u2013 Optional. The user-specified path for BLOB storage\nData store\uf0c1\nclass datarobot.models.data_store.TestResponse\uf0c1\nclass datarobot.models.data_store.SchemasResponse\uf0c1\nclass datarobot.models.data_store.TablesResponse\uf0c1",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/sharing.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        ">>> import datarobot as dr\n>>> drivers = dr.DataDriver.list()\n>>> drivers\n[DataDriver('mysql'), DataDriver('RedShift'), DataDriver('PostgreSQL')]",
        ">>> import datarobot as dr\n>>> driver = dr.DataDriver.get('5ad08a1889453d0001ea7c5c')\n>>> driver\nDataDriver('PostgreSQL')",
        ">>> import datarobot as dr\n>>> driver = dr.DataDriver.create(\n...     class_name='org.postgresql.Driver',\n...     canonical_name='PostgreSQL',\n...     files=['/tmp/postgresql-42.2.2.jar']\n... )\n>>> driver\nDataDriver('PostgreSQL')",
        ">>> import datarobot as dr\n>>> driver = dr.DataDriver.get('5ad08a1889453d0001ea7c5c')\n>>> driver.canonical_name\n'PostgreSQL'\n>>> driver.update(canonical_name='postgres')\n>>> driver.canonical_name\n'postgres'",
        ">>> import datarobot as dr\n>>> connectors = dr.Connector.list()\n>>> connectors\n[Connector('ADLS Gen2 Connector'), Connector('S3 Connector')]",
        ">>> import datarobot as dr\n>>> connector = dr.Connector.get('5fe1063e1c075e0245071446')\n>>> connector\nConnector('ADLS Gen2 Connector')",
        ">>> import datarobot as dr\n>>> connector = dr.Connector.create('/tmp/connector-adls-gen2.jar')\n>>> connector\nConnector('ADLS Gen2 Connector')",
        ">>> import datarobot as dr\n>>> connector = dr.Connector.get('5fe1063e1c075e0245071446')\n>>> connector.base_name\n'connector-adls-gen2.jar'\n>>> connector.update('/tmp/connector-s3.jar')\n>>> connector.base_name\n'connector-s3.jar'",
        ">>> import datarobot as dr\n>>> data_stores = dr.DataStore.list()\n>>> data_stores\n[DataStore('Demo'), DataStore('Airlines')]",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5a8ac90b07a57a0001be501e')\n>>> data_store\nDataStore('Demo')",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.create(\n...     data_store_type='jdbc',\n...     canonical_name='Demo DB',\n...     driver_id='5a6af02eb15372000117c040',\n...     jdbc_url='jdbc:postgresql://my.db.address.org:5432/perftest'\n... )\n>>> data_store\nDataStore('Demo DB')",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store\nDataStore('Demo DB')\n>>> data_store.update(canonical_name='Demo DB updated')\n>>> data_store\nDataStore('Demo DB updated')",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store.test(username='db_username', password='db_password')\n{'message': 'Connection successful'}",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store.schemas(username='db_username', password='db_password')\n{'catalog': 'perftest', 'schemas': ['demo', 'information_schema', 'public']}",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.get('5ad5d2afef5cd700014d3cae')\n>>> data_store.tables(username='db_username', password='db_password', schema='demo')\n{'tables': [{'type': 'TABLE', 'name': 'diagnosis', 'schema': 'demo'}, {'type': 'TABLE',\n'name': 'kickcars', 'schema': 'demo'}, {'type': 'TABLE', 'name': 'patient',\n'schema': 'demo'}, {'type': 'TABLE', 'name': 'transcript', 'schema': 'demo'}],\n'catalog': 'perftest'}",
        ">>> import datarobot as dr\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_ids = [\"60912e09fd1f04e832a575c1\", \"639ce542862e9b1b1bfa8f1b\", \"63e185e7cd3a5f8e190c6393\"]\n>>> sharing_roles = []\n>>> for user_id in user_ids:\n...     new_sharing_role = SharingRole(\n...         role=SHARING_ROLE.CONSUMER,\n...         share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...         id=user_id,\n...         can_share=True,\n...     )\n...     sharing_roles.append(new_sharing_role)\n>>> dr.DataStore.get('my-data-store-id').share(access_list)",
        ">>> import datarobot as dr\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_to_remove = \"[email\u00a0protected]\"\n... remove_sharing_role = SharingRole(\n...     role=SHARING_ROLE.NO_ROLE,\n...     share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...     username=user_to_remove,\n...     can_share=False,\n... )\n>>> dr.DataStore.get('my-data-store-id').share(roles=[remove_sharing_role])",
        "datarobot.enums.SHARING_ROLE",
        ">>> import datarobot as dr\n>>> data_sources = dr.DataSource.list()\n>>> data_sources\n[DataSource('Diagnostics'), DataSource('Airlines 100mb'), DataSource('Airlines 10mb')]",
        ">>> import datarobot as dr\n>>> data_source = dr.DataSource.get('5a8ac9ab07a57a0001be501f')\n>>> data_source\nDataSource('Diagnostics')",
        ">>> import datarobot as dr\n>>> params = dr.DataSourceParameters(\n...     data_store_id='5a8ac90b07a57a0001be501e',\n...     query='SELECT * FROM airlines10mb WHERE \"Year\" >= 1995;'\n... )\n>>> data_source = dr.DataSource.create(\n...     data_source_type='jdbc',\n...     canonical_name='airlines stats after 1995',\n...     params=params\n... )\n>>> data_source\nDataSource('airlines stats after 1995')",
        ">>> import datarobot as dr\n>>> data_source = dr.DataSource.get('5ad840cc613b480001570953')\n>>> data_source\nDataSource('airlines stats after 1995')\n>>> params = dr.DataSourceParameters(\n...     query='SELECT * FROM airlines10mb WHERE \"Year\" >= 1990;'\n... )\n>>> data_source.update(\n...     canonical_name='airlines stats after 1990',\n...     params=params\n... )\n>>> data_source\nDataSource('airlines stats after 1990')",
        "from datarobot.enums import SHARING_ROLE\nfrom datarobot.models.data_source import DataSource\nfrom datarobot.models.sharing import SharingAccess\n\nnew_access = SharingAccess(\n    \"[email\u00a0protected]\",\n    SHARING_ROLE.OWNER,\n    can_share=True,\n)\naccess_list = [\n    SharingAccess(\"[email\u00a0protected]\", SHARING_ROLE.OWNER, can_share=True),\n    new_access,\n]\n\nDataSource.get('my-data-source-id').share(access_list)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-exploration.html",
      "title": "Data exports\uf0c1",
      "description": "",
      "content": "Data exports\uf0c1\nclass datarobot.models.deployment.data_exports.PredictionDataExport\uf0c1\nA prediction data export.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the prediction data export.\nmodel_id (str) \u2013 The ID of the model (or null if not specified).\ncreated_at (datetime) \u2013 Prediction data export creation timestamp.\nperiod (Period) \u2013 A prediction data time range definition.\nstatus (ExportStatus) \u2013 A prediction data export processing state.\nerror (ExportError) \u2013 Error description, appears when prediction data export job failed (status is FAILED).\nbatches (ExportBatches) \u2013 Metadata associated with exported batch.\ndeployment_id (str) \u2013 The ID of the deployment.\nclassmethod list(deployment_id, status=None, model_id=None, batch=None, offset=0, limit=100)\uf0c1\nRetrieve a list of prediction data exports.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nmodel_id (Optional[str]) \u2013 The ID of the model used for prediction data export.\nstatus (Optional[ExportStatus]) \u2013 A prediction data export processing state.\nbatch (Optional[bool]) \u2013 If true, only return batch exports.\nIf false, only return real-time exports.\nIf not provided, return both real-time and batch exports.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 100 (0 means no limit).\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nReturns:\nprediction_data_exports \u2013 A list of PredictionDataExport objects.\nReturn type:\nlist\nExamples\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_exports = PredictionDataExport.list(deployment_id='5c939e08962d741e34f609f0')\nclassmethod get(deployment_id, export_id)\uf0c1\nRetrieve a single prediction data export.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nexport_id (str) \u2013 The ID of the prediction data export.\nReturns:\nprediction_data_export \u2013 A prediction data export.\nReturn type:\nPredictionDataExport\nExamples\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_export = PredictionDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n)\nclassmethod create(deployment_id, start, end, model_id=None, batch_ids=None, max_wait=600)\uf0c1\nCreate a deployment prediction data export.\nWaits until ready and fetches PredictionDataExport after the export finishes. This method is blocking.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nstart (Union[datetime, str]) \u2013 Inclusive start of the time range.\nend (Union[datetime, str]) \u2013 Exclusive end of the time range.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nbatch_ids (Optional[List[str]]) \u2013 IDs of batches to export. Null for real-time data exports.\nmax_wait (int,) \u2013 Seconds to wait for successful resolution.\nReturns:\nprediction_data_export \u2013 A prediction data export.\nReturn type:\nPredictionDataExport\nExamples\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\nnow=datetime.now()\nprediction_data_export = PredictionDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now\n)\nfetch_data()\uf0c1\nReturn data from prediction export as datarobot Dataset.\nReturns:\nprediction_datasets \u2013 List of datasets for a given export, most often it is just one.\nReturn type:\nList[Dataset]\nExamples\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_export = PredictionDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n)\nprediction_datasets = prediction_data_export.fetch_data()\nclass datarobot.models.deployment.data_exports.ActualsDataExport\uf0c1\nAn actuals data export.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the actuals data export.\nmodel_id (str) \u2013 The ID of the model (or null if not specified).\ncreated_at (datetime) \u2013 Actuals data export creation timestamp.\nperiod (Period) \u2013 A actuals data time range definition.\nstatus (ExportStatus) \u2013 A data export processing state.\nerror (ExportError) \u2013 Error description, appears when actuals data export job failed (status is FAILED).\nonly_matched_predictions (bool) \u2013 If true, exports actuals with matching predictions only.\ndeployment_id (str) \u2013 The ID of the deployment.\nclassmethod list(deployment_id, status=None, offset=0, limit=100)\uf0c1\nRetrieve a list of actuals data exports.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nstatus (Optional[ExportStatus]) \u2013 Actuals data export processing state.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 100 (0 means no limit).\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nReturns:\nactuals_data_exports \u2013 A list of ActualsDataExport objects.\nReturn type:\nlist\nExamples\nfrom datarobot.models.deployment import ActualsDataExport\nactuals_data_exports = ActualsDataExport.list(deployment_id='5c939e08962d741e34f609f0')\nclassmethod get(deployment_id, export_id)\uf0c1\nRetrieve a single actuals data export.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nexport_id (str) \u2013 The ID of the actuals data export.\nReturns:\nactuals_data_export \u2013 An actuals data export.\nReturn type:\nActualsDataExport\nExamples\nfrom datarobot.models.deployment import ActualsDataExport\nactuals_data_export = ActualsDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fb0a6c9bb187781cfdea36'\n)\nclassmethod create(deployment_id, start, end, model_id=None, only_matched_predictions=None, max_wait=600)\uf0c1\nCreate a deployment actuals data export.\nWaits until ready and fetches ActualsDataExport after the export finishes. This method is blocking.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nstart (Union[datetime, str]) \u2013 Inclusive start of the time range.\nend (Union[datetime, str]) \u2013 Exclusive end of the time range.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nonly_matched_predictions (Optional[bool]) \u2013 If true, exports actuals with matching predictions only.\nmax_wait (int) \u2013 Seconds to wait for successful resolution.\nReturns:\nactuals_data_export \u2013 An actuals data export.\nReturn type:\nActualsDataExport\nExamples\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now\n)\nfetch_data()\uf0c1\nReturn data from actuals export as datarobot Dataset.\nReturns:\nactuals_datasets \u2013 List of datasets for a given export, most often it is just one.\nReturn type:\nList[Dataset]\nExamples\nfrom datarobot.models.deployment import ActualsDataExport\nactuals_data_export = ActualsDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fb0a6c9bb187781cfdea36'\n)\nactuals_datasets = actuals_data_export.fetch_data()\nclass datarobot.models.deployment.data_exports.TrainingDataExport\uf0c1\nA training data export.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the training data export.\nmodel_id (str) \u2013 The ID of the model (or null if not specified).\nmodel_package_id (str) \u2013 The ID of the model package.\ncreated_at (datetime) \u2013 Training data export creation timestamp.\ndeployment_id (str) \u2013 The ID of the deployment.\nclassmethod list(deployment_id)\uf0c1\nRetrieve a list of successful training data exports.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nReturns:\ntraining_data_exports \u2013 A list of TrainingDataExport objects.\nReturn type:\nlist\nExamples\nfrom datarobot.models.deployment import TrainingDataExport\ntraining_data_exports = TrainingDataExport.list(deployment_id='5c939e08962d741e34f609f0')\nclassmethod get(deployment_id, export_id)\uf0c1\nRetrieve a single training data export.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nexport_id (str) \u2013 The ID of the training data export.\nReturns:\ntraining_data_export \u2013 A training data export.\nReturn type:\nTrainingDataExport\nExamples\nfrom datarobot.models.deployment import TrainingDataExport\ntraining_data_export = TrainingDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbf2356124f1daa3acc522'\n)\nclassmethod create(deployment_id, model_id=None, max_wait=600)\uf0c1\nCreate a single training data export.\nWaits until ready and fetches TrainingDataExport after the export finishes. This method is blocking.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nmax_wait (int) \u2013 Seconds to wait for successful resolution.\nReturn type:\nstr\nReturns:\ndataset_id (str) \u2013    A created dataset with training data.\nExamples\n--------\ncode-block:: python \u2013 from datarobot.models.deployment import TrainingDataExport\ndataset_id = TrainingDataExport.create(deployment_id=\u20195c939e08962d741e34f609f0\u2019)\nfetch_data()\uf0c1\nReturn data from training data export as datarobot Dataset.\nReturns:\ntraining_dataset \u2013 A datasets for a given export.\nReturn type:\nDataset\nExamples\nfrom datarobot.models.deployment import TrainingDataExport\ntraining_data_export = TrainingDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbf2356124f1daa3acc522'\n)\ntraining_data_export = training_data_export.fetch_data()\nclass datarobot.models.deployment.data_exports.DataQualityExport\uf0c1\nA data quality export record.\nAdded in version v3.6.\nVariables:\nassociation_id (str) \u2013 The association ID of the data quality export.\ntimestamp (datetime) \u2013 The data quality export creation timestamp.\ndeployment_id (str) \u2013 The ID of the deployment.\nprompt (Optional[str]) \u2013 The LLM prompt of the data quality export.\npredicted_value (str) \u2013 The predicted value of the data quality export.\nactual_value (Optional[str]) \u2013 The actual value (if available) of the data quality export.\ncontext (List[Dict[str, str]]) \u2013 Context data (context and link data) for the contexts associated with the data quality export.\nmetrics (List[Dict[str, Any]]) \u2013 Custom-metrics data for the data quality export.\nclassmethod list(deployment_id, start, end, model_id=None, prediction_pattern=None, prompt_pattern=None, actual_pattern=None, order_by=None, order_metric=None, filter_metric=None, filter_value=None, offset=0, limit=100)\uf0c1\nRetrieve a list of data-quality export records for a given deployment.\nAdded in version v3.6.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment.\nstart (Union[str, datetime]) \u2013 The earliest time of the objects to return.\nend (Union[str, datetime]) \u2013 The latest time of the objects to return.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nprediction_pattern (Optional[str]) \u2013 The keywords to search in a predicted value for a text generation target.\nprompt_pattern (Optional[str]) \u2013 The keywords to search in a prompt value for a text generation target.\nactual_pattern (Optional[str]) \u2013 The keywords to search in an actual value for a text generation target.\norder_by (Optional[str]) \u2013 The field to sort by (e.g. associationId, timestamp, or customMetrics). Use a leading \u2018-\u2019\nto indicate descending order. When ordering by a custom-metric, must also specify \u2018order_metric\u2019.\nThe default is None, which equates to \u2018-timestamp\u2019.\norder_metric (Optional[str]) \u2013 When \u2018order_by\u2019 is a custom-metric, this specifies the custom-metric name or ID to use for ordering.\nThe default is None.\nfilter_metric (Optional[str]) \u2013 Specifies the metric name or ID to use for matching. Must also use \u2018filter_value\u2019 to specify\nthe value that must be matched. The default is None.\nfilter_value (Optional[str]) \u2013 Specifies the value associated with \u2018filter_metric\u2019 that must be matched. The default\nis None.\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 100 (which is maximum).\nReturns:\ndata_quality_exports \u2013 A list of DataQualityExport objects.\nReturn type:\nlist\nExamples\nfrom datarobot.models.deployment import DataQualityExport\ndata_quality_exports = DataQualityExport.list(\ndeployment_id='5c939e08962d741e34f609f0', start_time='2024-07-01', end_time='2024-08-01\n)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot.models.deployment import PredictionDataExport\n\nprediction_data_exports = PredictionDataExport.list(deployment_id='5c939e08962d741e34f609f0')",
        "from datarobot.models.deployment import PredictionDataExport\n\nprediction_data_export = PredictionDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n    )",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\n\nnow=datetime.now()\nprediction_data_export = PredictionDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now\n    )",
        "from datarobot.models.deployment import PredictionDataExport\n\nprediction_data_export = PredictionDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n    )\nprediction_datasets = prediction_data_export.fetch_data()",
        "from datarobot.models.deployment import ActualsDataExport\n\nactuals_data_exports = ActualsDataExport.list(deployment_id='5c939e08962d741e34f609f0')",
        "from datarobot.models.deployment import ActualsDataExport\n\nactuals_data_export = ActualsDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fb0a6c9bb187781cfdea36'\n    )",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\n\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now\n    )",
        "from datarobot.models.deployment import ActualsDataExport\n\nactuals_data_export = ActualsDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fb0a6c9bb187781cfdea36'\n    )\nactuals_datasets = actuals_data_export.fetch_data()",
        "from datarobot.models.deployment import TrainingDataExport\n\ntraining_data_exports = TrainingDataExport.list(deployment_id='5c939e08962d741e34f609f0')",
        "from datarobot.models.deployment import TrainingDataExport\ntraining_data_export = TrainingDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbf2356124f1daa3acc522'\n    )",
        "from datarobot.models.deployment import TrainingDataExport\n\ntraining_data_export = TrainingDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbf2356124f1daa3acc522'\n    )\ntraining_data_export = training_data_export.fetch_data()",
        "from datarobot.models.deployment import DataQualityExport\n\ndata_quality_exports = DataQualityExport.list(\n    deployment_id='5c939e08962d741e34f609f0', start_time='2024-07-01', end_time='2024-08-01\n)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-wrangling.html",
      "title": "Recipes\uf0c1",
      "description": "Data wrangling entity, which contains all information needed to transform dataset and generate SQL.",
      "content": "Recipes\uf0c1\nclass datarobot.models.recipe.Recipe\uf0c1\nData wrangling entity, which contains all information needed to transform dataset and generate SQL.\nclassmethod update_downsampling(recipe_id, downsampling)\uf0c1\nSet downsampling for the recipe, applied during publishing.\nReturn type:\nRecipe\nretrieve_preview(max_wait=600, number_of_operations_to_use=None)\uf0c1\nRetrieve preview and compute it, if absent.\nParameters:\nmax_wait (int) \u2013 The number of seconds to wait for the result.\nnumber_of_operations_to_use (Optional[int]) \u2013 Request preview for particular number of operations.\nReturns:\npreview\nReturn type:\ndict\nretrieve_insights(max_wait=600, number_of_operations_to_use=None)\uf0c1\nRetrieve insights for the sample. When preview is requested, the insights job starts automatically.\nParameters:\nmax_wait (int) \u2013 The number of seconds to wait for the result.\nnumber_of_operations_to_use (Optional[int]) \u2013 Retrieves insights for the specified number of operations. First, preview computation for the same\nnumber of operations must be submitted.\nReturn type:\nAny\nclassmethod set_inputs(recipe_id, inputs)\uf0c1\nSet inputs for the recipe.\nReturn type:\nRecipe\nclassmethod set_operations(recipe_id, operations)\uf0c1\nSet operations for the recipe.\nReturn type:\nRecipe\nclassmethod set_recipe_metadata(recipe_id, metadata)\uf0c1\nUpdate metadata for the recipe.\nParameters:\nrecipe_id (str) \u2013 Recipe ID.\nmetadata (Dict[str, str]) \u2013 Dictionary of metadata to be updated.\nReturns:\nrecipe \u2013 New recipe with updated metadata.\nReturn type:\nRecipe\nget_sql(operations=None)\uf0c1\nGenerate sql for the given recipe in a transient way, recipe is not modified.\nif operations is None, recipe operations are used to generate sql.\nif operations = [], recipe operations are ignored during sql generation.\nif operations is not empty list, generate sql for them.\nReturn type:\nstr\nclassmethod from_data_store(use_case, data_store, data_source_type, dialect, data_source_inputs, recipe_type=RecipeType.WRANGLING)\uf0c1\nCreate a wrangling recipe from data store.\nReturn type:\nRecipe\nclassmethod from_dataset(use_case, dataset, dialect=None, inputs=None, recipe_type=RecipeType.WRANGLING, snapshot_policy=DataWranglingSnapshotPolicy.LATEST)\uf0c1\nCreate a wrangling recipe from dataset.\nReturn type:\nRecipe\nclass datarobot.models.recipe.RecipeSettings\uf0c1\nSettings, for example to apply at downsampling stage.\nclass datarobot.models.recipe.RecipeDatasetInput\uf0c1\nObject, describing inputs for recipe transformations.\nclass datarobot.models.recipe.DatasetInput\uf0c1\nclass datarobot.models.recipe.DataSourceInput\uf0c1\nInputs required to create a new recipe from data store.\nRecipe Operations\uf0c1\nclass datarobot.models.recipe_operation.WranglingOperation\uf0c1\nclass datarobot.models.recipe_operation.DownsamplingOperation\uf0c1\nclass datarobot.models.recipe_operation.SamplingOperation\uf0c1\nclass datarobot.models.recipe_operation.BaseTimeAwareTask\uf0c1\nclass datarobot.models.recipe_operation.TaskPlanElement\uf0c1\nclass datarobot.models.recipe_operation.CategoricalStats\uf0c1\nclass datarobot.models.recipe_operation.NumericStats\uf0c1\nclass datarobot.models.recipe_operation.Lags\uf0c1\nclass datarobot.models.recipe_operation.LagsOperation\uf0c1\nGenerate lags in a window.\nclass datarobot.models.recipe_operation.WindowCategoricalStatsOperation\uf0c1\nGenerate rolling statistics in a window for categorical features.\nclass datarobot.models.recipe_operation.WindowNumericStatsOperation\uf0c1\nGenerate various rolling numeric statistics in a window. Output could be a several columns.\nclass datarobot.models.recipe_operation.TimeSeriesOperation\uf0c1\nOperation to generate a dataset ready for time series modeling: with forecast point, forecast distances,\nknown in advance columns, etc.\nclass datarobot.models.recipe_operation.ComputeNewOperation\uf0c1\nclass datarobot.models.recipe_operation.RenameColumnsOperation\uf0c1\nclass datarobot.models.recipe_operation.FilterCondition\uf0c1\nclass datarobot.models.recipe_operation.FilterOperation\uf0c1\nFilter rows.\nclass datarobot.models.recipe_operation.DropColumnsOperation\uf0c1\nclass datarobot.models.recipe_operation.RandomSamplingOperation\uf0c1\nclass datarobot.models.recipe_operation.DatetimeSamplingOperation\uf0c1",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
      "title": "Datasets\uf0c1",
      "description": "Represents a Dataset returned from the api/v2/datasets/ endpoints.",
      "content": "Datasets\uf0c1\nclass datarobot.models.Dataset\uf0c1\nRepresents a Dataset returned from the api/v2/datasets/ endpoints.\nVariables:\nid (string) \u2013 The ID of this dataset\nname (string) \u2013 The name of this dataset in the catalog\nis_latest_version (bool) \u2013 Whether this dataset version is the latest version\nof this dataset\nversion_id (string) \u2013 The object ID of the catalog_version the dataset belongs to\ncategories (list(string)) \u2013 An array of strings describing the intended use of the dataset. The\nsupported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\ncreated_at (string) \u2013 The date when the dataset was created\ncreated_by (string, optional) \u2013 Username of the user who created the dataset\nis_snapshot (bool) \u2013 Whether the dataset version is an immutable snapshot of data\nwhich has previously been retrieved and saved to Data_robot\ndata_persisted (Optional[bool]) \u2013 If true, user is allowed to view extended data profile\n(which includes data statistics like min/max/median/mean, histogram, etc.) and download\ndata. If false, download is not allowed and only the data schema (feature names and types)\nwill be available.\nis_data_engine_eligible (bool) \u2013 Whether this dataset can be\na data source of a data engine query.\nprocessing_state (string) \u2013 Current ingestion process state of\nthe dataset\nrow_count (Optional[int]) \u2013 The number of rows in the dataset.\nsize (Optional[int]) \u2013 The size of the dataset as a CSV in bytes.\nsample_size (dict, optional) \u2013 The size of data fetched during dataset registration. For example, to fetch the first 95\nrows,  the sample_size value is {\u2018type\u2019: \u2018rows\u2019, \u2018value\u2019: 95}.\nCurrently only \u2018rows\u2019 type is supported.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this dataset in AI Catalog.\nReturn type:\nstr\nclassmethod upload(source)\uf0c1\nThis method covers Dataset creation from local materials (file & DataFrame) and a URL.\nParameters:\nsource (str, pd.DataFrame or file object) \u2013 Pass a URL, filepath, file or DataFrame to create and return a Dataset.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data source.\nReturn type:\nDataset\nRaises:\nInvalidUsageError \u2013 If the source parameter cannot be determined to be a URL, filepath, file or DataFrame.\nExamples\n# Upload a local file\ndataset_one = Dataset.upload(\"./data/examples.csv\")\n# Create a dataset via URL\ndataset_two = Dataset.upload(\n\"https://raw.githubusercontent.com/curran/data/gh-pages/dbpedia/cities/data.csv\"\n)\n# Create dataset with a pandas Dataframe\ndataset_three = Dataset.upload(my_df)\n# Create dataset using a local file\nwith open(\"./data/examples.csv\", \"rb\") as file_pointer:\ndataset_four = Dataset.create_from_file(filelike=file_pointer)\nclassmethod create_from_file(cls, file_path=None, filelike=None, categories=None, read_timeout=600, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from a file. Returns when the dataset has\nbeen successfully uploaded and processed.\nWarning: This function does not clean up it\u2019s open files. If you pass a filelike, you are\nresponsible for closing it. If you pass a file_path, this will create a file object from\nthe file_path but will not close it.\nParameters:\nfile_path (string, optional) \u2013 The path to the file. This will create a file object pointing to that file but will\nnot close it.\nfilelike (file, optional) \u2013 An open and readable file object.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nread_timeout (Optional[int]) \u2013 The maximum number of seconds to wait for the server to respond indicating that the\ninitial upload is complete\nmax_wait (Optional[int]) \u2013 Time in seconds after which dataset creation is considered unsuccessful\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case ids or a single Use Case id to add this new Dataset to. Must be a kwarg.\nReturns:\nresponse \u2013 A fully armed and operational Dataset\nReturn type:\nDataset\nclassmethod create_from_in_memory_data(cls, data_frame=None, records=None, categories=None, read_timeout=600, max_wait=600, fname=None, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from in-memory data. Returns when the dataset has\nbeen successfully uploaded and processed.\nThe data can be either a pandas DataFrame or a list of dictionaries with identical keys.\nParameters:\ndata_frame (DataFrame, optional) \u2013 The data frame to upload\nrecords (list[dict], optional) \u2013 A list of dictionaries with identical keys to upload\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nread_timeout (Optional[int]) \u2013 The maximum number of seconds to wait for the server to respond indicating that the\ninitial upload is complete\nmax_wait (Optional[int]) \u2013 Time in seconds after which dataset creation is considered unsuccessful\nfname (string, optional) \u2013 The file name, \u201cdata.csv\u201d by default\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case IDs or a single Use Case ID to add this new dataset to. Must be a kwarg.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data.\nReturn type:\nDataset\nRaises:\nInvalidUsageError \u2013 If neither a DataFrame or list of records is passed.\nclassmethod create_from_url(cls, url, do_snapshot=None, persist_data_after_ingestion=None, categories=None, sample_size=None, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from data stored at a url.\nReturns when the dataset has been successfully uploaded and processed.\nParameters:\nurl (string) \u2013 The URL to use as the source of data for the dataset being created.\ndo_snapshot (Optional[bool]) \u2013 If unset, uses the server default: True.\nIf true, creates a snapshot dataset; if\nfalse, creates a remote dataset. Creating snapshots from non-file sources may be\ndisabled by the permission, Disable AI Catalog Snapshots.\npersist_data_after_ingestion (Optional[bool]) \u2013 If unset, uses the server default: True.\nIf true, will enforce saving all data\n(for download and sampling) and will allow a user to view extended data profile\n(which includes data statistics like min/max/median/mean, histogram, etc.). If false,\nwill not enforce saving data. The data schema (feature names and types) still will be\navailable. Specifying this parameter to false and doSnapshot to true will result in\nan error.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nsample_size (dict, optional) \u2013 The size of data fetched during dataset registration.\nFor example, to fetch the first 95 rows,  the sample_size value would be:\n{\u2018type\u2019: \u2018rows\u2019, \u2018value\u2019: 95}.\nCurrently only \u2018rows\u2019 type is supported.\nmax_wait (Optional[int]) \u2013 Time in seconds after which dataset creation is considered unsuccessful.\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case IDs or a single Use Case ID to add this new dataset to. Must be a kwarg.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data\nReturn type:\nDataset\nclassmethod create_from_project(cls, project_id, categories=None, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new dataset from project data.\nReturns when the dataset has been successfully created.\nParameters:\nproject_id (string) \u2013 The project to create the dataset from.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nmax_wait (Optional[int]) \u2013 Time in seconds after which dataset creation is considered unsuccessful.\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case IDs or a single Use Case ID to add this new dataset to. Must be a kwarg.\nReturns:\nresponse \u2013 The dataset created from the project dataset.\nReturn type:\nDataset\nclassmethod create_from_datastage(cls, datastage_id, categories=None, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from data stored as a DataStage.\nReturns when the dataset has been successfully uploaded and processed.\nParameters:\ndatastage_id (string) \u2013 The ID of the DataStage to use as the source of data for the dataset being created.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nmax_wait (Optional[int]) \u2013 Time in seconds after which dataset creation is considered unsuccessful.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data\nReturn type:\nDataset\nclassmethod create_from_data_source(cls, data_source_id, username=None, password=None, do_snapshot=None, persist_data_after_ingestion=None, categories=None, credential_id=None, use_kerberos=None, credential_data=None, sample_size=None, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from data stored at a DataSource.\nReturns when the dataset has been successfully uploaded and processed.\nAdded in version v2.22.\nParameters:\ndata_source_id (string) \u2013 The ID of the DataSource to use as the source of data.\nusername (string, optional) \u2013 The username for database authentication.\npassword (string, optional) \u2013 The password (in cleartext) for database authentication. The password\nwill be encrypted on the server side in scope of HTTP request and never saved or stored.\ndo_snapshot (Optional[bool]) \u2013 If unset, uses the server default: True.\nIf true, creates a snapshot dataset; if\nfalse, creates a remote dataset. Creating snapshots from non-file sources requires may\nbe disabled by the permission, Disable AI Catalog Snapshots.\npersist_data_after_ingestion (Optional[bool]) \u2013 If unset, uses the server default: True.\nIf true, will enforce saving all data\n(for download and sampling) and will allow a user to view extended data profile\n(which includes data statistics like min/max/median/mean, histogram, etc.). If false,\nwill not enforce saving data. The data schema (feature names and types) still will be\navailable. Specifying this parameter to false and doSnapshot to true will result in\nan error.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\ncredential_id (string, optional) \u2013 The ID of the set of credentials to\nuse instead of user and password. Note that with this change, username and password\nwill become optional.\nuse_kerberos (Optional[bool]) \u2013 If unset, uses the server default: False.\nIf true, use kerberos authentication for database authentication.\ncredential_data (dict, optional) \u2013 The credentials to authenticate with the database, to use instead of user/password or\ncredential ID.\nsample_size (dict, optional) \u2013 The size of data fetched during dataset registration.\nFor example, to fetch the first 95 rows,  the sample_size value would be:\n{\u2018type\u2019: \u2018rows\u2019, \u2018value\u2019: 95}.\nCurrently only \u2018rows\u2019 type is supported.\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful.\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case IDs or a single Use Case ID to add this new dataset to. Must be a kwarg.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data\nReturn type:\nDataset\nclassmethod create_from_query_generator(cls, generator_id, dataset_id=None, dataset_version_id=None, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from the query generator.\nReturns when the dataset has been successfully processed. If optional\nparameters are not specified the query is applied to the dataset_id\nand dataset_version_id stored in the query generator. If specified they\nwill override the stored dataset_id/dataset_version_id, e.g. to prep a\nprediction dataset.\nParameters:\ngenerator_id (str) \u2013 The id of the query generator to use.\ndataset_id (Optional[str]) \u2013 The id of the dataset to apply the query to.\ndataset_version_id (Optional[str]) \u2013 The id of the dataset version to apply the query to. If not specified the\nlatest version associated with dataset_id (if specified) is used.\nmax_wait (int) \u2013 optional, the maximum number of seconds to wait before giving up.\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case IDs or a single Use Case ID to add this new dataset to. Must be a kwarg.\nReturns:\nresponse \u2013 The Dataset created from the query generator\nReturn type:\nDataset\nclassmethod create_from_recipe(cls, recipe, name=None, do_snapshot=None, persist_data_after_ingestion=None, categories=None, credential=None, credential_id=None, use_kerberos=None, materialization_destination=None, max_wait=600, *, use_cases=None)\uf0c1\nA blocking call that creates a new Dataset from the recipe.\nReturns when the dataset has been successfully uploaded and processed.\nAdded in version 3.6.\nReturns:\nresponse \u2013 The Dataset created from the uploaded data\nReturn type:\nDataset\nclassmethod get(dataset_id)\uf0c1\nGet information about a dataset.\nParameters:\ndataset_id (string) \u2013 the id of the dataset\nReturns:\ndataset \u2013 the queried dataset\nReturn type:\nDataset\nclassmethod delete(dataset_id)\uf0c1\nSoft deletes a dataset.  You cannot get it or list it or do actions with it, except for\nun-deleting it.\nParameters:\ndataset_id (string) \u2013 The id of the dataset to mark for deletion\nReturn type:\nNone\nclassmethod un_delete(dataset_id)\uf0c1\nUn-deletes a previously deleted dataset.  If the dataset was not deleted, nothing happens.\nParameters:\ndataset_id (string) \u2013 The id of the dataset to un-delete\nReturn type:\nNone\nclassmethod list(category=None, filter_failed=None, order_by=None, use_cases=None)\uf0c1\nList all datasets a user can view.\nParameters:\ncategory (string, optional) \u2013 Optional. If specified, only dataset versions that have the specified category will be\nincluded in the results. Categories identify the intended use of the dataset; supported\ncategories are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nfilter_failed (Optional[bool]) \u2013 If unset, uses the server default: False.\nWhether datasets that failed during import should be excluded from the results.\nIf True invalid datasets will be excluded.\norder_by (string, optional) \u2013 If unset, uses the server default: \u201c-created\u201d.\nSorting order which will be applied to catalog list, valid options are:\n- \u201ccreated\u201d \u2013 ascending order by creation datetime;\n- \u201c-created\u201d \u2013 descending order by creation datetime.\nuse_cases (Union[UseCase, List[UseCase], str, List[str]], optional) \u2013 Filter available datasets by a specific Use Case or Cases. Accepts either the entity or the ID.\nIf set to [None], the method filters the project\u2019s datasets by those not linked to a UseCase.\nReturns:\na list of datasets the user can view\nReturn type:\nlist[Dataset]\nclassmethod iterate(offset=None, limit=None, category=None, order_by=None, filter_failed=None, use_cases=None)\uf0c1\nGet an iterator for the requested datasets a user can view.\nThis lazily retrieves results. It does not get the next page from the server until the\ncurrent page is exhausted.\nParameters:\noffset (Optional[int]) \u2013 If set, this many results will be skipped\nlimit (Optional[int]) \u2013 Specifies the size of each page retrieved from the server.  If unset, uses the server\ndefault.\ncategory (string, optional) \u2013 Optional. If specified, only dataset versions that have the specified category will be\nincluded in the results. Categories identify the intended use of the dataset; supported\ncategories are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nfilter_failed (Optional[bool]) \u2013 If unset, uses the server default: False.\nWhether datasets that failed during import should be excluded from the results.\nIf True invalid datasets will be excluded.\norder_by (string, optional) \u2013 If unset, uses the server default: \u201c-created\u201d.\nSorting order which will be applied to catalog list, valid options are:\n- \u201ccreated\u201d \u2013 ascending order by creation datetime;\n- \u201c-created\u201d \u2013 descending order by creation datetime.\nuse_cases (Union[UseCase, List[UseCase], str, List[str]], optional) \u2013 Filter available datasets by a specific Use Case or Cases. Accepts either the entity or the ID.\nIf set to [None], the method filters the project\u2019s datasets by those not linked to a UseCase.\nYields:\nDataset \u2013 An iterator of the datasets the user can view.\nReturn type:\nGenerator[TypeVar(TDataset, bound= Dataset), None, None]\nupdate()\uf0c1\nUpdates the Dataset attributes in place with the latest information from the server.\nReturn type:\nNone\nmodify(name=None, categories=None)\uf0c1\nModifies the Dataset name and/or categories.  Updates the object in place.\nParameters:\nname (string, optional) \u2013 The new name of the dataset\ncategories (list[string], optional) \u2013 A list of strings describing the intended use of the\ndataset. The supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d. If any\ncategories were previously specified for the dataset, they will be overwritten.\nIf omitted or None, keep previous categories. To clear them specify []\nReturn type:\nNone\nshare(access_list, apply_grant_to_linked_objects=False)\uf0c1\nModify the ability of users to access this dataset\nParameters:\naccess_list (list of SharingAccess) \u2013 The modifications to make.\napply_grant_to_linked_objects (bool) \u2013 If true for any users being granted access to the dataset, grant the user read access to\nany linked objects such as DataSources and DataStores that may be used by this dataset.\nIgnored if no such objects are relevant for dataset, defaults to False.\nReturn type:\nNone\nRaises:\ndatarobot.ClientError: \u2013 If you do not have permission to share this dataset, if the user you\u2019re sharing with\ndoesn\u2019t exist, if the same user appears multiple times in the access_list, or if these\nchanges would leave the dataset without an owner.\nExamples\nTransfer access to the dataset from old_user@datarobot.com to new_user@datarobot.com\nfrom datarobot.enums import SHARING_ROLE\nfrom datarobot.models.dataset import Dataset\nfrom datarobot.models.sharing import SharingAccess\nnew_access = SharingAccess(\n\"[email\u00a0protected]\",\nSHARING_ROLE.OWNER,\ncan_share=True,\n)\naccess_list = [\nSharingAccess(\n\"[email\u00a0protected]\",\nSHARING_ROLE.OWNER,\ncan_share=True,\ncan_use_data=True,\n),\nnew_access,\n]\nDataset.get('my-dataset-id').share(access_list)\nget_details()\uf0c1\nGets the details for this Dataset\nReturn type:\nDatasetDetails\nget_all_features(order_by=None)\uf0c1\nGet a list of all the features for this dataset.\nParameters:\norder_by (string, optional) \u2013 If unset, uses the server default: \u2018name\u2019.\nHow the features should be ordered. Can be \u2018name\u2019 or \u2018featureType\u2019.\nReturn type:\nlist[DatasetFeature]\niterate_all_features(offset=None, limit=None, order_by=None)\uf0c1\nGet an iterator for the requested features of a dataset.\nThis lazily retrieves results. It does not get the next page from the server until the\ncurrent page is exhausted.\nParameters:\noffset (Optional[int]) \u2013 If set, this many results will be skipped.\nlimit (Optional[int]) \u2013 Specifies the size of each page retrieved from the server.  If unset, uses the server\ndefault.\norder_by (string, optional) \u2013 If unset, uses the server default: \u2018name\u2019.\nHow the features should be ordered. Can be \u2018name\u2019 or \u2018featureType\u2019.\nYields:\nDatasetFeature\nReturn type:\nGenerator[DatasetFeature, None, None]\nget_featurelists()\uf0c1\nGet DatasetFeaturelists created on this Dataset\nReturns:\nfeature_lists\nReturn type:\nlist[DatasetFeaturelist]\ncreate_featurelist(name, features)\uf0c1\nCreate a new dataset featurelist\nParameters:\nname (str) \u2013 the name of the modeling featurelist to create. Names must be unique within the\ndataset, or the server will return an error.\nfeatures (List[str]) \u2013 the names of the features to include in the dataset featurelist. Each feature must\nbe a dataset feature.\nReturns:\nfeaturelist \u2013 the newly created featurelist\nReturn type:\nDatasetFeaturelist\nExamples\ndataset = Dataset.get('1234deadbeeffeeddead4321')\ndataset_features = dataset.get_all_features()\nselected_features = [feat.name for feat in dataset_features][:5]  # select first five\nnew_flist = dataset.create_featurelist('Simple Features', selected_features)\nget_file(file_path=None, filelike=None)\uf0c1\nRetrieves all the originally uploaded data in CSV form.\nWrites it to either the file or a filelike object that can write bytes.\nOnly one of file_path or filelike can be provided and it must be provided as a\nkeyword argument (i.e. file_path=\u2019path-to-write-to\u2019). If a file-like object is\nprovided, the user is responsible for closing it when they are done.\nThe user must also have permission to download data.\nParameters:\nfile_path (string, optional) \u2013 The destination to write the file to.\nfilelike (file, optional) \u2013 A file-like object to write to.  The object must be able to write bytes. The user is\nresponsible for closing the object\nReturn type:\nNone\nget_as_dataframe(low_memory=False)\uf0c1\nRetrieves all the originally uploaded data in a pandas DataFrame.\nAdded in version v3.0.\nParameters:\nlow_memory (Optional[bool]) \u2013 If True, use local files to reduce memory usage which will be slower.\nReturn type:\npd.DataFrame\nget_projects()\uf0c1\nRetrieves the Dataset\u2019s projects as ProjectLocation named tuples.\nReturns:\nlocations\nReturn type:\nlist[ProjectLocation]\ncreate_project(project_name=None, user=None, password=None, credential_id=None, use_kerberos=None, credential_data=None, *, use_cases=None)\uf0c1\nCreate a datarobot.models.Project from this dataset\nParameters:\nproject_name (string, optional) \u2013 The name of the project to be created.\nIf not specified, will be \u201cUntitled Project\u201d for database connections, otherwise\nthe project name will be based on the file used.\nuser (string, optional) \u2013 The username for database authentication.\npassword (string, optional) \u2013 The password (in cleartext) for database authentication. The password\nwill be encrypted on the server side in scope of HTTP request and never saved or stored\ncredential_id (string, optional) \u2013 The ID of the set of credentials to use instead of user and password.\nuse_kerberos (Optional[bool]) \u2013 Server default is False.\nIf true, use kerberos authentication for database authentication.\ncredential_data (dict, optional) \u2013 The credentials to authenticate with the database, to use instead of user/password or\ncredential ID.\nuse_cases (list[UseCase] | UseCase | list[string] | string, optional) \u2013 A list of UseCase objects, UseCase object,\nlist of Use Case ids or a single Use Case id to add this new Dataset to. Must be a kwarg.\nReturn type:\nProject\nclassmethod create_version_from_file(dataset_id, file_path=None, filelike=None, categories=None, read_timeout=600, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset version from a file. Returns when the new dataset\nversion has been successfully uploaded and processed.\nWarning: This function does not clean up it\u2019s open files. If you pass a filelike, you are\nresponsible for closing it. If you pass a file_path, this will create a file object from\nthe file_path but will not close it.\nAdded in version v2.23.\nParameters:\ndataset_id (string) \u2013 The ID of the dataset for which new version to be created\nfile_path (string, optional) \u2013 The path to the file. This will create a file object pointing to that file but will\nnot close it.\nfilelike (file, optional) \u2013 An open and readable file object.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nread_timeout (Optional[int]) \u2013 The maximum number of seconds to wait for the server to respond indicating that the\ninitial upload is complete\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful\nReturns:\nresponse \u2013 A fully armed and operational Dataset version\nReturn type:\nDataset\nclassmethod create_version_from_in_memory_data(dataset_id, data_frame=None, records=None, categories=None, read_timeout=600, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset version for a dataset from in-memory data.\nReturns when the dataset has been successfully uploaded and processed.\nThe data can be either a pandas DataFrame or a list of dictionaries with identical keys.\nAdded in version v2.23.\nParameters:\ndataset_id (string) \u2013 The ID of the dataset for which new version to be created\ndata_frame (DataFrame, optional) \u2013 The data frame to upload\nrecords (list[dict], optional) \u2013 A list of dictionaries with identical keys to upload\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nread_timeout (Optional[int]) \u2013 The maximum number of seconds to wait for the server to respond indicating that the\ninitial upload is complete\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful\nReturns:\nresponse \u2013 The Dataset version created from the uploaded data\nReturn type:\nDataset\nRaises:\nInvalidUsageError \u2013 If neither a DataFrame or list of records is passed.\nclassmethod create_version_from_url(dataset_id, url, categories=None, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset from data stored at a url for a given dataset.\nReturns when the dataset has been successfully uploaded and processed.\nAdded in version v2.23.\nParameters:\ndataset_id (string) \u2013 The ID of the dataset for which new version to be created\nurl (string) \u2013 The URL to use as the source of data for the dataset being created.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful\nReturns:\nresponse \u2013 The Dataset version created from the uploaded data\nReturn type:\nDataset\nclassmethod create_version_from_datastage(dataset_id, datastage_id, categories=None, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset from data stored as a DataStage for a given dataset.\nReturns when the dataset has been successfully uploaded and processed.\nParameters:\ndataset_id (string) \u2013 The ID of the dataset for which new version to be created\ndatastage_id (string) \u2013 The ID of the DataStage to use as the source of data for the dataset being created.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful\nReturns:\nresponse \u2013 The Dataset version created from the uploaded data\nReturn type:\nDataset\nclassmethod create_version_from_data_source(dataset_id, data_source_id, username=None, password=None, categories=None, credential_id=None, use_kerberos=None, credential_data=None, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset from data stored at a DataSource.\nReturns when the dataset has been successfully uploaded and processed.\nAdded in version v2.23.\nParameters:\ndataset_id (string) \u2013 The ID of the dataset for which new version to be created\ndata_source_id (string) \u2013 The ID of the DataSource to use as the source of data.\nusername (string, optional) \u2013 The username for database authentication.\npassword (string, optional) \u2013 The password (in cleartext) for database authentication. The password\nwill be encrypted on the server side in scope of HTTP request and never saved or stored.\ncategories (list[string], optional) \u2013 An array of strings describing the intended use of the dataset. The\ncurrent supported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\ncredential_id (string, optional) \u2013 The ID of the set of credentials to\nuse instead of user and password. Note that with this change, username and password\nwill become optional.\nuse_kerberos (Optional[bool]) \u2013 If unset, uses the server default: False.\nIf true, use kerberos authentication for database authentication.\ncredential_data (dict, optional) \u2013 The credentials to authenticate with the database, to use instead of user/password or\ncredential ID.\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful\nReturns:\nresponse \u2013 The Dataset version created from the uploaded data\nReturn type:\nDataset\nclassmethod create_version_from_recipe(dataset_id, recipe, credential=None, credential_id=None, use_kerberos=None, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset version from Recipe.\nReturns when the dataset has been successfully uploaded and processed.\nAdded in version v3.8.\nParameters:\ndataset_id (string) \u2013 The ID of the dataset for which a new version will be created.\nrecipe (Recipe) \u2013 The Recipe to use to create a new dataset version.\ncredential (Credential, optional) \u2013 The credentials to authenticate with the database.\ncredential_id (string, optional) \u2013 The ID of the set of credentials to use instead of Credential object.\nuse_kerberos (Optional[bool]) \u2013 If unset, uses the server default: False.\nIf true, use kerberos authentication for database authentication.\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful.\nReturns:\nresponse \u2013 The Dataset version created from the uploaded data\nReturn type:\nDataset\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nclass datarobot.DatasetDetails\uf0c1\nRepresents a detailed view of a Dataset. The to_dataset method creates a Dataset\nfrom this details view.\nVariables:\ndataset_id (string) \u2013 The ID of this dataset\nname (string) \u2013 The name of this dataset in the catalog\nis_latest_version (bool) \u2013 Whether this dataset version is the latest version\nof this dataset\nversion_id (string) \u2013 The object ID of the catalog_version the dataset belongs to\ncategories (list(string)) \u2013 An array of strings describing the intended use of the dataset. The\nsupported options are \u201cTRAINING\u201d and \u201cPREDICTION\u201d.\ncreated_at (string) \u2013 The date when the dataset was created\ncreated_by (string) \u2013 Username of the user who created the dataset\nis_snapshot (bool) \u2013 Whether the dataset version is an immutable snapshot of data\nwhich has previously been retrieved and saved to Data_robot\ndata_persisted (Optional[bool]) \u2013 If true, user is allowed to view extended data profile\n(which includes data statistics like min/max/median/mean, histogram, etc.) and download\ndata. If false, download is not allowed and only the data schema (feature names and types)\nwill be available.\nis_data_engine_eligible (bool) \u2013 Whether this dataset can be\na data source of a data engine query.\nprocessing_state (string) \u2013 Current ingestion process state of\nthe dataset\nrow_count (Optional[int]) \u2013 The number of rows in the dataset.\nsize (Optional[int]) \u2013 The size of the dataset as a CSV in bytes.\ndata_engine_query_id (string, optional) \u2013 ID of the source data engine query\ndata_source_id (string, optional) \u2013 ID of the datasource used as the source of the dataset\ndata_source_type (string) \u2013 the type of the datasource that was used as the source of the\ndataset\ndescription (string, optional) \u2013 the description of the dataset\neda1_modification_date (string, optional) \u2013 the ISO 8601 formatted date and time when the EDA1 for\nthe dataset was updated\neda1_modifier_full_name (string, optional) \u2013 the user who was the last to update EDA1 for the\ndataset\nerror (string) \u2013 details of exception raised during ingestion process, if any\nfeature_count (Optional[int]) \u2013 total number of features in the dataset\nfeature_count_by_type (list[FeatureTypeCount]) \u2013 number of features in the dataset grouped by feature type\nlast_modification_date (string) \u2013 the ISO 8601 formatted date and time when the dataset\nwas last modified\nlast_modifier_full_name (string) \u2013 full name of user who was the last to modify the\ndataset\ntags (list[string]) \u2013 list of tags attached to the item\nuri (string) \u2013 the uri to datasource like:\n- \u2018file_name.csv\u2019\n- \u2018jdbc:DATA_SOURCE_GIVEN_NAME/SCHEMA.TABLE_NAME\u2019\n- \u2018jdbc:DATA_SOURCE_GIVEN_NAME/<query>\u2019 - for query based datasources\n- \u2018https://s3.amazonaws.com/my_data/my_dataset.csv\u2019\n- etc.\nsample_size (dict, optional) \u2013 The size of data fetched during dataset registration. For example, to fetch the first 95\nrows,  the sample_size value is {\u2018type\u2019: \u2018rows\u2019, \u2018value\u2019: 95}.\nCurrently only \u2018rows\u2019 type is supported.\nclassmethod get(dataset_id)\uf0c1\nGet details for a Dataset from the server\nParameters:\ndataset_id (str) \u2013 The id for the Dataset from which to get details\nReturn type:\nDatasetDetails\nto_dataset()\uf0c1\nBuild a Dataset object from the information in this object\nReturn type:\nDataset\nclass datarobot.models.dataset.ProjectLocation\uf0c1\nProjectLocation(url, id)\nid\uf0c1\nAlias for field number 1\nurl\uf0c1\nAlias for field number 0\nSecondary datasets\uf0c1\nclass datarobot.helpers.feature_discovery.SecondaryDataset\uf0c1\nA secondary dataset to be used for feature discovery\nAdded in version v2.25.\nVariables:\nidentifier (str) \u2013 Alias of the dataset (used directly as part of the generated feature names)\ncatalog_id (str) \u2013 Identifier of the catalog item\ncatalog_version_id (str) \u2013 Identifier of the catalog item version\nsnapshot_policy (Optional[str]) \u2013 Policy to use while creating a project or making predictions.\nIf omitted, by default endpoint will use \u2018latest\u2019.\nMust be one of the following values:\n\u2018specified\u2019: Use specific snapshot specified by catalogVersionId\n\u2018latest\u2019: Use latest snapshot from the same catalog item\n\u2018dynamic\u2019: Get data from the source (only applicable for JDBC datasets)\nExamples\nimport datarobot as dr\ndataset_definition = dr.SecondaryDataset(\nidentifier='profile',\ncatalog_id='5ec4aec1f072bc028e3471ae',\ncatalog_version_id='5ec4aec2f072bc028e3471b1',\n)\nSecondary dataset configurations\uf0c1\nclass datarobot.models.SecondaryDatasetConfigurations\uf0c1\nCreate secondary dataset configurations for a given project\nAdded in version v2.20.\nVariables:\nid (str) \u2013 Id of this secondary dataset configuration\nproject_id (str) \u2013 Id of the associated project.\nconfig (list of DatasetConfiguration (Deprecated in version v2.23)) \u2013 List of secondary dataset configurations\nsecondary_datasets (list of SecondaryDataset (new in v2.23)) \u2013 List of secondary datasets (secondaryDataset)\nname (str) \u2013 Verbose name of the SecondaryDatasetConfig. null if it wasn\u2019t specified.\ncreated (datetime.datetime) \u2013 DR-formatted datetime. null for legacy (before DR 6.0) db records.\ncreator_user_id (str) \u2013 Id of the user created this config.\ncreator_full_name (str) \u2013 fullname or email of the user created this config.\nfeaturelist_id (Optional[str]) \u2013 Id of the feature list. null if it wasn\u2019t specified.\ncredential_ids (Optional[list of DatasetsCredentials]) \u2013 credentials used by the secondary datasets if the datasets used\nin the configuration are from datasource\nis_default (Optional[bool]) \u2013 Boolean flag if default config created during feature discovery aim\nproject_version (Optional[str]) \u2013 Version of project when its created (Release version)\nclassmethod create(project_id, secondary_datasets, name, featurelist_id=None)\uf0c1\ncreate secondary dataset configurations\nAdded in version v2.20.\nParameters:\nproject_id (str) \u2013 id of the associated project.\nsecondary_datasets (list of SecondaryDataset (New in version v2.23)) \u2013 list of secondary datasets used by the configuration\neach element is a datarobot.helpers.feature_discovery.SecondaryDataset\nname (str (New in version v2.23)) \u2013 Name of the secondary datasets configuration\nfeaturelist_id (str, or None (New in version v2.23)) \u2013 Id of the featurelist\nReturn type:\nan instance of SecondaryDatasetConfigurations\nRaises:\nClientError \u2013 raised if incorrect configuration parameters are provided\nExamples\nprofile_secondary_dataset = dr.SecondaryDataset(\nidentifier='profile',\ncatalog_id='5ec4aec1f072bc028e3471ae',\ncatalog_version_id='5ec4aec2f072bc028e3471b1',\nsnapshot_policy='latest'\n)\ntransaction_secondary_dataset = dr.SecondaryDataset(\nidentifier='transaction',\ncatalog_id='5ec4aec268f0f30289a03901',\ncatalog_version_id='5ec4aec268f0f30289a03900',\nsnapshot_policy='latest'\n)\nsecondary_datasets = [profile_secondary_dataset, transaction_secondary_dataset]\nnew_secondary_dataset_config = dr.SecondaryDatasetConfigurations.create(\nproject_id=project.id,\nname='My config',\nsecondary_datasets=secondary_datasets\n)\n>>> new_secondary_dataset_config.id\n'5fd1e86c589238a4e635e93d'\ndelete()\uf0c1\nRemoves the Secondary datasets configuration\n:rtype: None\nAdded in version v2.21.\nRaises:\nClientError \u2013 Raised if an invalid or already deleted secondary dataset config id is provided\nExamples\n# Deleting with a valid secondary_dataset_config id\nstatus_code = dr.SecondaryDatasetConfigurations.delete(some_config_id)\nstatus_code\n>>> 204\nget()\uf0c1\nRetrieve a single secondary dataset configuration for a given id\nAdded in version v2.21.\nReturns:\nsecondary_dataset_configurations \u2013 The requested secondary dataset configurations\nReturn type:\nSecondaryDatasetConfigurations\nExamples\nconfig_id = '5fd1e86c589238a4e635e93d'\nsecondary_dataset_config = dr.SecondaryDatasetConfigurations(id=config_id).get()\n>>> secondary_dataset_config\n{\n'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n'creator_full_name': u'[email\u00a0protected]',\n'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n'credential_ids': None,\n'featurelist_id': None,\n'id': u'5fd1e86c589238a4e635e93d',\n'is_default': True,\n'name': u'My config',\n'project_id': u'5fd06afce2456ec1e9d20457',\n'project_version': None,\n'secondary_datasets': [\n{\n'snapshot_policy': u'latest',\n'identifier': u'profile',\n'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n'catalog_id': u'5fd06b4af24c641b68e4d88e'\n},\n{\n'snapshot_policy': u'dynamic',\n'identifier': u'transaction',\n'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n'catalog_id': u'5fd1e86c589238a4e635e98d'\n}\n]\n}\nclassmethod list(project_id, featurelist_id=None, limit=None, offset=None)\uf0c1\nReturns list of secondary dataset configurations.\nAdded in version v2.23.\nParameters:\nproject_id (str) \u2013 The Id of project\nfeaturelist_id (Optional[str]) \u2013 Id of the feature list to filter the secondary datasets configurations\nReturns:\nsecondary_dataset_configurations \u2013 The requested list of secondary dataset configurations for a given project\nReturn type:\nlist of SecondaryDatasetConfigurations\nExamples\npid = '5fd06afce2456ec1e9d20457'\nsecondary_dataset_configs = dr.SecondaryDatasetConfigurations.list(pid)\n>>> secondary_dataset_configs[0]\n{\n'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n'creator_full_name': u'[email\u00a0protected]',\n'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n'credential_ids': None,\n'featurelist_id': None,\n'id': u'5fd1e86c589238a4e635e93d',\n'is_default': True,\n'name': u'My config',\n'project_id': u'5fd06afce2456ec1e9d20457',\n'project_version': None,\n'secondary_datasets': [\n{\n'snapshot_policy': u'latest',\n'identifier': u'profile',\n'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n'catalog_id': u'5fd06b4af24c641b68e4d88e'\n},\n{\n'snapshot_policy': u'dynamic',\n'identifier': u'transaction',\n'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n'catalog_id': u'5fd1e86c589238a4e635e98d'\n}\n]\n}\nData engine query generator\uf0c1\nclass datarobot.DataEngineQueryGenerator\uf0c1\nDataEngineQueryGenerator is used to set up time series data prep.\nAdded in version v2.27.\nVariables:\nid (str) \u2013 id of the query generator\nquery (str) \u2013 text of the generated Spark SQL query\ndatasets (list(QueryGeneratorDataset)) \u2013 datasets associated with the query generator\ngenerator_settings (QueryGeneratorSettings) \u2013 the settings used to define the query\ngenerator_type (str) \u2013 \u201cTimeSeries\u201d is the only supported type\nclassmethod create(generator_type, datasets, generator_settings)\uf0c1\nCreates a query generator entity.\nAdded in version v2.27.\nParameters:\ngenerator_type (str) \u2013 Type of data engine query generator\ndatasets (List[QueryGeneratorDataset]) \u2013 Source datasets in the Data Engine workspace.\ngenerator_settings (dict) \u2013 Data engine generator settings of the given generator_type.\nReturns:\nquery_generator \u2013 The created generator\nReturn type:\nDataEngineQueryGenerator\nExamples\nimport datarobot as dr\nfrom datarobot.models.data_engine_query_generator import (\nQueryGeneratorDataset,\nQueryGeneratorSettings,\n)\ndataset = QueryGeneratorDataset(\nalias='My_Awesome_Dataset_csv',\ndataset_id='61093144cabd630828bca321',\ndataset_version_id=1,\n)\nsettings = QueryGeneratorSettings(\ndatetime_partition_column='date',\ntime_unit='DAY',\ntime_step=1,\ndefault_numeric_aggregation_method='sum',\ndefault_categorical_aggregation_method='mostFrequent',\n)\ng = dr.DataEngineQueryGenerator.create(\ngenerator_type='TimeSeries',\ndatasets=[dataset],\ngenerator_settings=settings,\n)\ng.id\n>>>'54e639a18bd88f08078ca831'\ng.generator_type\n>>>'TimeSeries'\nclassmethod get(generator_id)\uf0c1\nGets information about a query generator.\nParameters:\ngenerator_id (str) \u2013 The identifier of the query generator you want to load.\nReturns:\nquery_generator \u2013 The queried generator\nReturn type:\nDataEngineQueryGenerator\nExamples\nimport datarobot as dr\ng = dr.DataEngineQueryGenerator.get(generator_id='54e639a18bd88f08078ca831')\ng.id\n>>>'54e639a18bd88f08078ca831'\ng.generator_type\n>>>'TimeSeries'\ncreate_dataset(dataset_id=None, dataset_version_id=None, max_wait=600)\uf0c1\nA blocking call that creates a new Dataset from the query generator.\nReturns when the dataset has been successfully processed. If optional\nparameters are not specified the query is applied to the dataset_id\nand dataset_version_id stored in the query generator. If specified they\nwill override the stored dataset_id/dataset_version_id, i.e. to prep a\nprediction dataset.\nParameters:\ndataset_id (Optional[str]) \u2013 The id of the unprepped dataset to apply the query to\ndataset_version_id (Optional[str]) \u2013 The version_id of the unprepped dataset to apply the query to\nReturns:\nresponse \u2013 The Dataset created from the query generator\nReturn type:\nDataset\nprepare_prediction_dataset_from_catalog(project_id, dataset_id, dataset_version_id=None, max_wait=600, relax_known_in_advance_features_check=None)\uf0c1\nApply time series data prep to a catalog dataset and upload it to the project\nas a PredictionDataset.\nAdded in version v3.1.\nParameters:\nproject_id (str) \u2013 The id of the project to which you upload the prediction dataset.\ndataset_id (str) \u2013 The identifier of the dataset.\ndataset_version_id (Optional[str]) \u2013 The version id of the dataset to use.\nmax_wait (Optional[int]) \u2013 Optional, the maximum number of seconds to wait before giving up.\nrelax_known_in_advance_features_check (Optional[bool]) \u2013 For time series projects only. If True, missing values in the\nknown in advance features are allowed in the forecast window at the prediction time.\nIf omitted or False, missing values are not allowed.\nReturns:\ndataset \u2013 The newly uploaded dataset.\nReturn type:\nPredictionDataset\nprepare_prediction_dataset(sourcedata, project_id, max_wait=600, relax_known_in_advance_features_check=None)\uf0c1\nApply time series data prep and upload the PredictionDataset to the project.\nAdded in version v3.1.\nParameters:\nsourcedata (str, file or pandas.DataFrame) \u2013 Data to be used for predictions. If it is a string, it can be either a path to a local file,\nor raw file content. If using a file on disk, the filename must consist of ASCII\ncharacters only.\nproject_id (str) \u2013 The id of the project to which you upload the prediction dataset.\nmax_wait (Optional[int]) \u2013 The maximum number of seconds to wait for the uploaded dataset to be processed before\nraising an error.\nrelax_known_in_advance_features_check (Optional[bool]) \u2013 For time series projects only. If True, missing values in the\nknown in advance features are allowed in the forecast window at the prediction time.\nIf omitted or False, missing values are not allowed.\nReturns:\ndataset \u2013 The newly uploaded dataset.\nReturn type:\nPredictionDataset\nRaises:\nInputNotUnderstoodError \u2013 Raised if sourcedata isn\u2019t one of supported types.\nAsyncFailureError \u2013 Raised if polling for the status of an async process resulted in a response with an\nunsupported status code.\nAsyncProcessUnsuccessfulError \u2013 Raised if project creation was unsuccessful (i.e. the server reported an error in\nuploading the dataset).\nAsyncTimeoutError \u2013 Raised if processing the uploaded dataset took more time than specified\nby the max_wait parameter.\nSharing access\uf0c1\nclass datarobot.SharingAccess\uf0c1\nRepresents metadata about whom a entity (e.g. a data store) has been shared with\nAdded in version v2.14.\nCurrently DataStores,\nDataSources,\nDatasets,\nProjects (new in version v2.15) and\nCalendarFiles (new in version 2.15) can be shared.\nThis class can represent either access that has already been granted, or be used to grant access\nto additional users.\nVariables:\nusername (str) \u2013 a particular user\nrole (str or None) \u2013 if a string, represents a particular level of access and should be one of\ndatarobot.enums.SHARING_ROLE.  For more information on the specific access levels, see\nthe sharing documentation.  If None, can be passed to a share\nfunction to revoke access for a specific user.\ncan_share (bool or None) \u2013 if a bool, indicates whether this user is permitted to further share.  When False, the\nuser has access to the entity, but can only revoke their own access but not modify any\nuser\u2019s access role.  When True, the user can share with any other user at a access role up\nto their own.  May be None if the SharingAccess was not retrieved from the DataRobot server\nbut intended to be passed into a share function; this will be equivalent to passing True.\ncan_use_data (bool or None) \u2013 if a bool, indicates whether this user should be able to view, download and process data\n(use to create projects, predictions, etc). For OWNER can_use_data is always True. If role\nis empty canUseData is ignored.\nuser_id (str or None) \u2013 the id of the user\nSharing role\uf0c1\nclass datarobot.models.sharing.SharingRole\uf0c1\nRepresents metadata about a user who has been granted access to an entity.\nAt least one of id or username must be set.\nVariables:\nid (str or None) \u2013 The ID of the user.\nrole (str) \u2013 Represents a particular level of access. Should be one of\ndatarobot.enums.SHARING_ROLE.\nshare_recipient_type (SHARING_RECIPIENT_TYPE) \u2013 The type of user for the object of the method. Can be user or organization.\nuser_full_name (str or None) \u2013 The full name of the user.\nusername (str or None) \u2013 The username (usually the email) of the user.\ncan_share (bool or None) \u2013 Indicates whether this user is permitted to share with other users. When False, the\nuser has access to the entity, but can only revoke their own access. They cannot not modify\nany user\u2019s access role. When True, the user can share with any other user at an access\nrole up to their own.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/features.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/credentials.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-connectivity.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/sharing.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot.enums import SHARING_ROLE\nfrom datarobot.models.dataset import Dataset\nfrom datarobot.models.sharing import SharingAccess\n\nnew_access = SharingAccess(\n    \"[email\u00a0protected]\",\n    SHARING_ROLE.OWNER,\n    can_share=True,\n)\naccess_list = [\n    SharingAccess(\n        \"[email\u00a0protected]\",\n        SHARING_ROLE.OWNER,\n        can_share=True,\n        can_use_data=True,\n    ),\n    new_access,\n]\n\nDataset.get('my-dataset-id').share(access_list)",
        "list[ProjectLocation]",
        "datarobot.models.Project",
        "import datarobot as dr\ndataset_definition = dr.SecondaryDataset(\n    identifier='profile',\n    catalog_id='5ec4aec1f072bc028e3471ae',\n    catalog_version_id='5ec4aec2f072bc028e3471b1',\n)",
        "datarobot.helpers.feature_discovery.SecondaryDataset",
        "profile_secondary_dataset = dr.SecondaryDataset(\n       identifier='profile',\n       catalog_id='5ec4aec1f072bc028e3471ae',\n       catalog_version_id='5ec4aec2f072bc028e3471b1',\n       snapshot_policy='latest'\n   )\n\n   transaction_secondary_dataset = dr.SecondaryDataset(\n       identifier='transaction',\n       catalog_id='5ec4aec268f0f30289a03901',\n       catalog_version_id='5ec4aec268f0f30289a03900',\n       snapshot_policy='latest'\n   )\n\n   secondary_datasets = [profile_secondary_dataset, transaction_secondary_dataset]\n   new_secondary_dataset_config = dr.SecondaryDatasetConfigurations.create(\n       project_id=project.id,\n       name='My config',\n       secondary_datasets=secondary_datasets\n   )\n\n>>> new_secondary_dataset_config.id\n'5fd1e86c589238a4e635e93d'",
        "# Deleting with a valid secondary_dataset_config id\nstatus_code = dr.SecondaryDatasetConfigurations.delete(some_config_id)\nstatus_code\n>>> 204",
        "config_id = '5fd1e86c589238a4e635e93d'\nsecondary_dataset_config = dr.SecondaryDatasetConfigurations(id=config_id).get()\n>>> secondary_dataset_config\n{\n     'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n     'creator_full_name': u'[email\u00a0protected]',\n     'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n     'credential_ids': None,\n     'featurelist_id': None,\n     'id': u'5fd1e86c589238a4e635e93d',\n     'is_default': True,\n     'name': u'My config',\n     'project_id': u'5fd06afce2456ec1e9d20457',\n     'project_version': None,\n     'secondary_datasets': [\n            {\n                'snapshot_policy': u'latest',\n                'identifier': u'profile',\n                'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n                'catalog_id': u'5fd06b4af24c641b68e4d88e'\n            },\n            {\n                'snapshot_policy': u'dynamic',\n                'identifier': u'transaction',\n                'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n                'catalog_id': u'5fd1e86c589238a4e635e98d'\n            }\n     ]\n}",
        "pid = '5fd06afce2456ec1e9d20457'\nsecondary_dataset_configs = dr.SecondaryDatasetConfigurations.list(pid)\n>>> secondary_dataset_configs[0]\n    {\n         'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n         'creator_full_name': u'[email\u00a0protected]',\n         'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n         'credential_ids': None,\n         'featurelist_id': None,\n         'id': u'5fd1e86c589238a4e635e93d',\n         'is_default': True,\n         'name': u'My config',\n         'project_id': u'5fd06afce2456ec1e9d20457',\n         'project_version': None,\n         'secondary_datasets': [\n                {\n                    'snapshot_policy': u'latest',\n                    'identifier': u'profile',\n                    'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n                    'catalog_id': u'5fd06b4af24c641b68e4d88e'\n                },\n                {\n                    'snapshot_policy': u'dynamic',\n                    'identifier': u'transaction',\n                    'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n                    'catalog_id': u'5fd1e86c589238a4e635e98d'\n                }\n         ]\n    }",
        "import datarobot as dr\nfrom datarobot.models.data_engine_query_generator import (\n   QueryGeneratorDataset,\n   QueryGeneratorSettings,\n)\ndataset = QueryGeneratorDataset(\n   alias='My_Awesome_Dataset_csv',\n   dataset_id='61093144cabd630828bca321',\n   dataset_version_id=1,\n)\nsettings = QueryGeneratorSettings(\n   datetime_partition_column='date',\n   time_unit='DAY',\n   time_step=1,\n   default_numeric_aggregation_method='sum',\n   default_categorical_aggregation_method='mostFrequent',\n)\ng = dr.DataEngineQueryGenerator.create(\n   generator_type='TimeSeries',\n   datasets=[dataset],\n   generator_settings=settings,\n)\ng.id\n>>>'54e639a18bd88f08078ca831'\ng.generator_type\n>>>'TimeSeries'",
        "import datarobot as dr\ng = dr.DataEngineQueryGenerator.get(generator_id='54e639a18bd88f08078ca831')\ng.id\n>>>'54e639a18bd88f08078ca831'\ng.generator_type\n>>>'TimeSeries'",
        "datarobot.enums.SHARING_ROLE",
        "datarobot.enums.SHARING_ROLE"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
      "title": "Exceptions\uf0c1",
      "description": "",
      "content": "Exceptions\uf0c1\nexception datarobot.errors.AppPlatformError\uf0c1\nRaised by Client.request() for requests that:\nReturn a non-200 HTTP response, or\nConnection refused/timeout or\nResponse timeout or\nMalformed request\nHave a malformed/missing header in the response.\nexception datarobot.errors.ServerError\uf0c1\nFor 500-level responses from the server\nexception datarobot.errors.ClientError\uf0c1\nFor 400-level responses from the server\nhas json parameter for additional information to be stored about error\nif need be\nexception datarobot.errors.InputNotUnderstoodError\uf0c1\nRaised if a method is called in a way that cannot be understood\nexception datarobot.errors.InvalidUsageError\uf0c1\nRaised when methods are called with invalid or incompatible arguments\nexception datarobot.errors.AllRetriesFailedError\uf0c1\nRaised when the retry manager does not successfully make a request\nexception datarobot.errors.InvalidModelCategoryError\uf0c1\nRaised when method specific for model category was called from wrong model\nexception datarobot.errors.AsyncTimeoutError\uf0c1\nRaised when an asynchronous operation did not successfully get resolved\nwithin a specified time limit\nexception datarobot.errors.AsyncFailureError\uf0c1\nRaised when querying an asynchronous status resulted in an exceptional\nstatus code (not 200 and not 303)\nexception datarobot.errors.ProjectAsyncFailureError\uf0c1\nWhen an AsyncFailureError occurs during project creation or finalizing the project\nsettings for modeling. This exception will have the attributes status_code\nindicating the unexpected status code from the server, and async_location indicating\nwhich asynchronous status object was being polled when the failure happened.\nexception datarobot.errors.AsyncProcessUnsuccessfulError\uf0c1\nRaised when querying an asynchronous status showed that async process\nwas not successful\nexception datarobot.errors.AsyncModelCreationError\uf0c1\nRaised when querying an asynchronous status showed that model creation\nwas not successful\nexception datarobot.errors.AsyncPredictionsGenerationError\uf0c1\nRaised when querying an asynchronous status showed that predictions\ngeneration was not successful\nexception datarobot.errors.PendingJobFinished\uf0c1\nRaised when the server responds with a 303 for the pending creation of a\nresource.\nexception datarobot.errors.JobNotFinished\uf0c1\nRaised when execution was trying to get a finished resource from a pending\njob, but the job is not finished\nexception datarobot.errors.DuplicateFeaturesError\uf0c1\nRaised when trying to create featurelist with duplicating features\nexception datarobot.errors.TrainingDataAssignmentError\uf0c1\nRaised when the training data assignment for a custom model version fails\nexception datarobot.errors.DataRobotDeprecationWarning\uf0c1\nRaised when using deprecated functions or using functions in a deprecated way\nSee also\nPlatformDeprecationWarning\nexception datarobot.errors.IllegalFileName\uf0c1\nRaised when trying to use a filename we can\u2019t handle.\nexception datarobot.errors.JobAlreadyRequested\uf0c1\nRaised when the requested model has already been requested.\nexception datarobot.errors.ContentRetrievalTerminatedError\uf0c1\nRaised when due to content retrieval error process of data retrieval was terminated.\nexception datarobot.errors.UpdateAttributesError\uf0c1\nexception datarobot.errors.InvalidRatingTableWarning\uf0c1\nRaised when using interacting with rating tables that failed validation\nexception datarobot.errors.PartitioningMethodWarning\uf0c1\nRaised when interacting with project methods related to partition classes, i.e.\nProject.set_partitioning_method() or Project.set_datetime_partitioning().\nexception datarobot.errors.NonPersistableProjectOptionWarning\uf0c1\nRaised when setting project options via Project.set_options if any of the options\npassed are not supported for POST requests to /api/v2/project/{project_id}/options/.\nAll options that fall under this category can be found here:\ndatarobot.enums.NonPersistableProjectOptions().\nexception datarobot.errors.OverwritingProjectOptionWarning\uf0c1\nRaised when setting project options via Project.set_options if any of the options\npassed have already been set to a value in Project.advanced_options, or if\na different value is already stored in the endpoint /api/v2/project/{project_id}/options/.\nPrecedence is given to the new value you passed in.\nexception datarobot.errors.NoRedundancyImpactAvailable\uf0c1\nRaised when retrieving old feature impact data\nRedundancy detection was added in v2.13 of the API, and some projects, e.g. multiclass projects\ndo not support redundancy detection. This warning is raised to make\nclear that redundancy detection is unavailable.\nexception datarobot.errors.ParentModelInsightFallbackWarning\uf0c1\nRaised when insights are unavailable for a model and\ninsight retrieval falls back to retrieving insights\nfor a model\u2019s parent model\nexception datarobot.errors.ProjectHasNoRecommendedModelWarning\uf0c1\nRaised when a project has no recommended model.\nexception datarobot.errors.PlatformDeprecationWarning\uf0c1\nRaised when Deprecation header is returned in the API, for example a project may be\ndeprecated as part of the 2022 Python 3 platform migration.\nSee also\nDataRobotDeprecationWarning\nexception datarobot.errors.MultipleUseCasesNotAllowed\uf0c1\nRaised when a method decorated with add_to_use_case(allow_multiple=True) calls a method\ndecorated with add_to_use_case(allow_multiple=False) with multiple UseCases passed",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.NonPersistableProjectOptions()",
        "DataRobotDeprecationWarning"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/features.html",
      "title": "Features\uf0c1",
      "description": "",
      "content": "Features\uf0c1\nclass datarobot.models.Feature\uf0c1\nA feature from a project\u2019s dataset\nThese are features either included in the originally uploaded dataset or added to it via\nfeature transformations.  In time series projects, these will be distinct from the\nModelingFeature s created during partitioning;\notherwise, they will correspond to the same features.  For more information about input and\nmodeling features, see the time series documentation.\nThe min, max, mean, median, and std_dev attributes provide information about\nthe distribution of the feature in the EDA sample data.  For non-numeric features or features\ncreated prior to these summary statistics becoming available, they will be None.  For features\nwhere the summary statistics are available, they will be in a format compatible with the data\ntype, i.e. date type features will have their summary statistics expressed as ISO-8601\nformatted date strings.\nVariables:\nid (int) \u2013 the id for the feature - note that name is used to reference the feature instead of id\nproject_id (str) \u2013 the id of the project the feature belongs to\nname (str) \u2013 the name of the feature\nfeature_type (str) \u2013 the type of the feature, e.g. \u2018Categorical\u2019, \u2018Text\u2019\nimportance (float or None) \u2013 numeric measure of the strength of relationship between the feature and target (independent\nof any model or other features); may be None for non-modeling features such as partition\ncolumns\nlow_information (bool) \u2013 whether a feature is considered too uninformative for modeling (e.g. because it has too few\nvalues)\nunique_count (int) \u2013 number of unique values\nna_count (int or None) \u2013 number of missing values\ndate_format (str or None) \u2013 For Date features, the date format string for how this feature\nwas interpreted, compatible with https://docs.python.org/2/library/time.html#time.strftime .\nFor other feature types, None.\nmin (str, int, float, or None) \u2013 The minimum value of the source data in the EDA sample\nmax (str, int, float, or None) \u2013 The maximum value of the source data in the EDA sample\nmean (str, int, or, float) \u2013 The arithmetic mean of the source data in the EDA sample\nmedian (str, int, float, or None) \u2013 The median of the source data in the EDA sample\nstd_dev (str, int, float, or None) \u2013 The standard deviation of the source data in the EDA sample\ntime_series_eligible (bool) \u2013 Whether this feature can be used as the datetime partition column in a time series project.\ntime_series_eligibility_reason (str) \u2013 Why the feature is ineligible for the datetime partition column in a time series project,\nor \u2018suitable\u2019 when it is eligible.\ntime_step (int or None) \u2013 For time series eligible features, a positive integer determining the interval at which\nwindows can be specified. If used as the datetime partition column on a time series\nproject, the feature derivation and forecast windows must start and end at an integer\nmultiple of this value. None for features that are not time series eligible.\ntime_unit (str or None) \u2013 For time series eligible features, the time unit covered by a single time step, e.g. \u2018HOUR\u2019,\nor None for features that are not time series eligible.\ntarget_leakage (str) \u2013 Whether a feature is considered to have target leakage or not.  A value of\n\u2018SKIPPED_DETECTION\u2019 indicates that target leakage detection was not run on the feature.\n\u2018FALSE\u2019 indicates no leakage, \u2018MODERATE\u2019 indicates a moderate risk of target leakage, and\n\u2018HIGH_RISK\u2019 indicates a high risk of target leakage\nfeature_lineage_id (str) \u2013 id of a lineage for automatically discovered features or derived time series features.\nkey_summary (list of dict) \u2013 Statistics for top 50 keys (truncated to 103 characters) of\nSummarized Categorical column example:\n{\u2018key\u2019:\u2019DataRobot\u2019,\n\u2018summary\u2019:{\u2018min\u2019:0, \u2018max\u2019:29815.0, \u2018stdDev\u2019:6498.029, \u2018mean\u2019:1490.75,\n\u2018median\u2019:0.0, \u2018pctRows\u2019:5.0}}\nwhere,\nkey: string or Nonename of the key\nsummary: dictstatistics of the key\nmax: maximum value of the key.\nmin: minimum value of the key.\nmean: mean value of the key.\nmedian: median value of the key.\nstdDev: standard deviation of the key.\npctRows: percentage occurrence of key in the EDA sample of the feature.\nmultilabel_insights_key (str or None) \u2013 For multicategorical columns this will contain a key for multilabel insights. The key is\nunique for a project, feature and EDA stage combination. This will be the key for the most\nrecent, finished EDA stage.\nclassmethod get(project_id, feature_name)\uf0c1\nRetrieve a single feature\nParameters:\nproject_id (str) \u2013 The ID of the project the feature is associated with.\nfeature_name (str) \u2013 The name of the feature to retrieve\nReturns:\nfeature \u2013 The queried instance\nReturn type:\nFeature\nget_multiseries_properties(multiseries_id_columns, max_wait=600)\uf0c1\nRetrieve time series properties for a potential multiseries datetime partition column\nMultiseries time series projects use multiseries id columns to model multiple distinct\nseries within a single project.  This function returns the time series properties (time step\nand time unit) of this column if it were used as a datetime partition column with the\nspecified multiseries id columns, running multiseries detection automatically if it had not\npreviously been successfully ran.\nParameters:\nmultiseries_id_columns (List[str]) \u2013 the name(s) of the multiseries id columns to use with this datetime partition column.\nCurrently only one multiseries id column is supported.\nmax_wait (Optional[int]) \u2013 if a multiseries detection task is run, the maximum amount of time to wait for it to\ncomplete before giving up\nReturns:\nproperties \u2013\nA dict with three keys:\ntime_series_eligible : bool, whether the column can be used as a partition column\ntime_unit : str or null, the inferred time unit if used as a partition column\ntime_step : int or null, the inferred time step if used as a partition column\nReturn type:\ndict\nget_cross_series_properties(datetime_partition_column, cross_series_group_by_columns, max_wait=600)\uf0c1\nRetrieve cross-series properties for multiseries ID column.\nThis function returns the cross-series properties (eligibility\nas group-by column) of this column if it were used with specified datetime partition column\nand with current multiseries id column, running cross-series group-by validation\nautomatically if it had not previously been successfully ran.\nParameters:\ndatetime_partition_column (datetime partition column)\ncross_series_group_by_columns (List[str]) \u2013 the name(s) of the columns to use with this multiseries ID column.\nCurrently only one cross-series group-by column is supported.\nmax_wait (Optional[int]) \u2013 if a multiseries detection task is run, the maximum amount of time to wait for it to\ncomplete before giving up\nReturns:\nproperties \u2013\nA dict with three keys:\nname : str, column name\neligibility : str, reason for column eligibility\nisEligible : bool, is column eligible as cross-series group-by\nReturn type:\ndict\nget_multicategorical_histogram()\uf0c1\nRetrieve multicategorical histogram for this feature\nAdded in version v2.24.\nReturn type:\ndatarobot.models.MulticategoricalHistogram\nRaises:\ndatarobot.errors.InvalidUsageError \u2013 if this method is called on a unsuited feature\nValueError \u2013 if no multilabel_insights_key is present for this feature\nget_pairwise_correlations()\uf0c1\nRetrieve pairwise label correlation for multicategorical features\nAdded in version v2.24.\nReturn type:\ndatarobot.models.PairwiseCorrelations\nRaises:\ndatarobot.errors.InvalidUsageError \u2013 if this method is called on a unsuited feature\nValueError \u2013 if no multilabel_insights_key is present for this feature\nget_pairwise_joint_probabilities()\uf0c1\nRetrieve pairwise label joint probabilities for multicategorical features\nAdded in version v2.24.\nReturn type:\ndatarobot.models.PairwiseJointProbabilities\nRaises:\ndatarobot.errors.InvalidUsageError \u2013 if this method is called on a unsuited feature\nValueError \u2013 if no multilabel_insights_key is present for this feature\nget_pairwise_conditional_probabilities()\uf0c1\nRetrieve pairwise label conditional probabilities for multicategorical features\nAdded in version v2.24.\nReturn type:\ndatarobot.models.PairwiseConditionalProbabilities\nRaises:\ndatarobot.errors.InvalidUsageError \u2013 if this method is called on a unsuited feature\nValueError \u2013 if no multilabel_insights_key is present for this feature\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nget_histogram(bin_limit=None)\uf0c1\nRetrieve a feature histogram\nParameters:\nbin_limit (int or None) \u2013 Desired max number of histogram bins. If omitted, by default\nendpoint will use 60.\nReturns:\nfeatureHistogram \u2013 The requested histogram with desired number or bins\nReturn type:\nFeatureHistogram\nclass datarobot.models.ModelingFeature\uf0c1\nA feature used for modeling\nIn time series projects, a new set of modeling features is created after setting the\npartitioning options.  These features are automatically derived from those in the project\u2019s\ndataset and are the features used for modeling.  Modeling features are only accessible once\nthe target and partitioning options have been set.  In projects that don\u2019t use time series\nmodeling, once the target has been set, ModelingFeatures and Features will behave\nthe same.\nFor more information about input and modeling features, see the\ntime series documentation.\nAs with the Feature object, the min, max, `mean,\nmedian, and std_dev attributes provide information about the distribution of the feature in\nthe EDA sample data.  For non-numeric features, they will be None.  For features where the\nsummary statistics are available, they will be in a format compatible with the data type, i.e.\ndate type features will have their summary statistics expressed as ISO-8601 formatted date\nstrings.\nVariables:\nproject_id (str) \u2013 the id of the project the feature belongs to\nname (str) \u2013 the name of the feature\nfeature_type (str) \u2013 the type of the feature, e.g. \u2018Categorical\u2019, \u2018Text\u2019\nimportance (float or None) \u2013 numeric measure of the strength of relationship between the feature and target (independent\nof any model or other features); may be None for non-modeling features such as partition\ncolumns\nlow_information (bool) \u2013 whether a feature is considered too uninformative for modeling (e.g. because it has too few\nvalues)\nunique_count (int) \u2013 number of unique values\nna_count (int or None) \u2013 number of missing values\ndate_format (str or None) \u2013 For Date features, the date format string for how this feature\nwas interpreted, compatible with https://docs.python.org/2/library/time.html#time.strftime .\nFor other feature types, None.\nmin (str, int, float, or None) \u2013 The minimum value of the source data in the EDA sample\nmax (str, int, float, or None) \u2013 The maximum value of the source data in the EDA sample\nmean (str, int, or, float) \u2013 The arithmetic mean of the source data in the EDA sample\nmedian (str, int, float, or None) \u2013 The median of the source data in the EDA sample\nstd_dev (str, int, float, or None) \u2013 The standard deviation of the source data in the EDA sample\nparent_feature_names (List[str]) \u2013 A list of the names of input features used to derive this modeling feature.  In cases where\nthe input features and modeling features are the same, this will simply contain the\nfeature\u2019s name.  Note that if a derived feature was used to create this modeling feature,\nthe values here will not necessarily correspond to the features that must be supplied at\nprediction time.\nkey_summary (list of dict) \u2013 Statistics for top 50 keys (truncated to 103 characters) of\nSummarized Categorical column example:\n{\u2018key\u2019:\u2019DataRobot\u2019,\n\u2018summary\u2019:{\u2018min\u2019:0, \u2018max\u2019:29815.0, \u2018stdDev\u2019:6498.029, \u2018mean\u2019:1490.75,\n\u2018median\u2019:0.0, \u2018pctRows\u2019:5.0}}\nwhere,\nkey: string or Nonename of the key\nsummary: dictstatistics of the key\nmax: maximum value of the key.\nmin: minimum value of the key.\nmean: mean value of the key.\nmedian: median value of the key.\nstdDev: standard deviation of the key.\npctRows: percentage occurrence of key in the EDA sample of the feature.\nclassmethod get(project_id, feature_name)\uf0c1\nRetrieve a single modeling feature\nParameters:\nproject_id (str) \u2013 The ID of the project the feature is associated with.\nfeature_name (str) \u2013 The name of the feature to retrieve\nReturns:\nfeature \u2013 The requested feature\nReturn type:\nModelingFeature\nclass datarobot.models.DatasetFeature\uf0c1\nA feature from a project\u2019s dataset\nThese are features either included in the originally uploaded dataset or added to it via\nfeature transformations.\nThe min, max, mean, median, and std_dev attributes provide information about\nthe distribution of the feature in the EDA sample data.  For non-numeric features or features\ncreated prior to these summary statistics becoming available, they will be None.  For features\nwhere the summary statistics are available, they will be in a format compatible with the data\ntype, i.e. date type features will have their summary statistics expressed as ISO-8601\nformatted date strings.\nVariables:\nid (int) \u2013 the id for the feature - note that name is used to reference the feature instead of id\ndataset_id (str) \u2013 the id of the dataset the feature belongs to\ndataset_version_id (str) \u2013 the id of the dataset version the feature belongs to\nname (str) \u2013 the name of the feature\nfeature_type (Optional[str]) \u2013 the type of the feature, e.g. \u2018Categorical\u2019, \u2018Text\u2019\nlow_information (Optional[bool]) \u2013 whether a feature is considered too uninformative for modeling (e.g. because it has too few\nvalues)\nunique_count (Optional[int]) \u2013 number of unique values\nna_count (Optional[int]) \u2013 number of missing values\ndate_format (Optional[str]) \u2013 For Date features, the date format string for how this feature\nwas interpreted, compatible with https://docs.python.org/2/library/time.html#time.strftime .\nFor other feature types, None.\nmin (str, int, Optional[float]) \u2013 The minimum value of the source data in the EDA sample\nmax (str, int, Optional[float]) \u2013 The maximum value of the source data in the EDA sample\nmean (str, int, Optional[float]) \u2013 The arithmetic mean of the source data in the EDA sample\nmedian (str, int, Optional[float]) \u2013 The median of the source data in the EDA sample\nstd_dev (str, int, Optional[float]) \u2013 The standard deviation of the source data in the EDA sample\ntime_series_eligible (Optional[bool]) \u2013 Whether this feature can be used as the datetime partition column in a time series project.\ntime_series_eligibility_reason (Optional[str]) \u2013 Why the feature is ineligible for the datetime partition column in a time series project,\nor \u2018suitable\u2019 when it is eligible.\ntime_step (Optional[int]) \u2013 For time series eligible features, a positive integer determining the interval at which\nwindows can be specified. If used as the datetime partition column on a time series\nproject, the feature derivation and forecast windows must start and end at an integer\nmultiple of this value. None for features that are not time series eligible.\ntime_unit (Optional[str]) \u2013 For time series eligible features, the time unit covered by a single time step, e.g. \u2018HOUR\u2019,\nor None for features that are not time series eligible.\ntarget_leakage (Optional[str]) \u2013 Whether a feature is considered to have target leakage or not.  A value of\n\u2018SKIPPED_DETECTION\u2019 indicates that target leakage detection was not run on the feature.\n\u2018FALSE\u2019 indicates no leakage, \u2018MODERATE\u2019 indicates a moderate risk of target leakage, and\n\u2018HIGH_RISK\u2019 indicates a high risk of target leakage\ntarget_leakage_reason (string, optional) \u2013 The descriptive text explaining the reason for target leakage, if any.\nget_histogram(bin_limit=None)\uf0c1\nRetrieve a feature histogram\nParameters:\nbin_limit (int or None) \u2013 Desired max number of histogram bins. If omitted, by default\nendpoint will use 60.\nReturns:\nfeatureHistogram \u2013 The requested histogram with desired number or bins\nReturn type:\nDatasetFeatureHistogram\nclass datarobot.models.DatasetFeatureHistogram\uf0c1\nclassmethod get(dataset_id, feature_name, bin_limit=None, key_name=None)\uf0c1\nRetrieve a single feature histogram\nParameters:\ndataset_id (str) \u2013 The ID of the Dataset the feature is associated with.\nfeature_name (str) \u2013 The name of the feature to retrieve\nbin_limit (int or None) \u2013 Desired max number of histogram bins. If omitted, by default\nthe endpoint will use 60.\nkey_name (string or None) \u2013 (Only required for summarized categorical feature)\nName of the top 50 keys for which plot to be retrieved\nReturns:\nfeatureHistogram \u2013 The queried instance with plot attribute in it.\nReturn type:\nFeatureHistogram\nclass datarobot.models.FeatureHistogram\uf0c1\nclassmethod get(project_id, feature_name, bin_limit=None, key_name=None)\uf0c1\nRetrieve a single feature histogram\nParameters:\nproject_id (str) \u2013 The ID of the project the feature is associated with.\nfeature_name (str) \u2013 The name of the feature to retrieve\nbin_limit (int or None) \u2013 Desired max number of histogram bins. If omitted, by default\nendpoint will use 60.\nkey_name (string or None) \u2013 (Only required for summarized categorical feature)\nName of the top 50 keys for which plot to be retrieved\nReturns:\nfeatureHistogram \u2013 The queried instance with plot attribute in it.\nReturn type:\nFeatureHistogram\nclass datarobot.models.InteractionFeature\uf0c1\nInteraction feature data\nAdded in version v2.21.\nVariables:\nrows (int) \u2013 Total number of rows\nsource_columns (list(str)) \u2013 names of two categorical features which were combined into this one\nbars (list(dict)) \u2013 dictionaries representing frequencies of each independent value from the source columns\nbubbles (list(dict)) \u2013 dictionaries representing frequencies of each combined value in the interaction feature.\nclassmethod get(project_id, feature_name)\uf0c1\nRetrieve a single Interaction feature\nParameters:\nproject_id (str) \u2013 The id of the project the feature belongs to\nfeature_name (str) \u2013 The name of the Interaction feature to retrieve\nReturns:\nfeature \u2013 The queried instance\nReturn type:\nInteractionFeature\nclass datarobot.models.MulticategoricalHistogram\uf0c1\nHistogram for Multicategorical feature.\nAdded in version v2.24.\nNotes\nHistogramValues contains:\nvalues.[].label : string - Label name\nvalues.[].plot : list - Histogram for label\nvalues.[].plot.[].label_relevance : int - Label relevance value\nvalues.[].plot.[].row_count : int - Row count where label has given relevance\nvalues.[].plot.[].row_pct : float - Percentage of rows where label has given relevance\nVariables:\nfeature_name (str) \u2013 Name of the feature\nvalues (list(dict)) \u2013 List of Histogram values with a schema described as HistogramValues\nclassmethod get(multilabel_insights_key)\uf0c1\nRetrieves multicategorical histogram\nYou might find it more convenient to use\nFeature.get_multicategorical_histogram\ninstead.\nParameters:\nmultilabel_insights_key (string) \u2013 Key for multilabel insights, unique for a project, feature and EDA stage combination.\nThe multilabel_insights_key can be retrieved via\nFeature.multilabel_insights_key.\nReturns:\nThe multicategorical histogram for multilabel_insights_key\nReturn type:\nMulticategoricalHistogram\nto_dataframe()\uf0c1\nConvenience method to get all the information from this multicategorical_histogram instance\nin form of a pandas.DataFrame.\nReturns:\nHistogram information as a multicategorical_histogram. The dataframe will contain these\ncolumns: feature_name, label, label_relevance, row_count and row_pct\nReturn type:\npandas.DataFrame\nclass datarobot.models.PairwiseCorrelations\uf0c1\nCorrelation of label pairs for multicategorical feature.\nAdded in version v2.24.\nNotes\nCorrelationValues contain:\nvalues.[].label_configuration : list of length 2 - Configuration of the label pair\nvalues.[].label_configuration.[].label : str \u2013 Label name\nvalues.[].statistic_value : float \u2013 Statistic value\nVariables:\nfeature_name (str) \u2013 Name of the feature\nvalues (list(dict)) \u2013 List of correlation values with a schema described as CorrelationValues\nstatistic_dataframe (pandas.DataFrame) \u2013 Correlation values for all label pairs as a DataFrame\nclassmethod get(multilabel_insights_key)\uf0c1\nRetrieves pairwise correlations\nYou might find it more convenient to use\nFeature.get_pairwise_correlations\ninstead.\nParameters:\nmultilabel_insights_key (string) \u2013 Key for multilabel insights, unique for a project, feature and EDA stage combination.\nThe multilabel_insights_key can be retrieved via\nFeature.multilabel_insights_key.\nReturns:\nThe pairwise label correlations\nReturn type:\nPairwiseCorrelations\nas_dataframe()\uf0c1\nThe pairwise label correlations as a (num_labels x num_labels) DataFrame.\nReturns:\nThe pairwise label correlations. Index and column names allow the interpretation of the\nvalues.\nReturn type:\npandas.DataFrame\nclass datarobot.models.PairwiseJointProbabilities\uf0c1\nJoint probabilities of label pairs for multicategorical feature.\nAdded in version v2.24.\nNotes\nProbabilityValues contain:\nvalues.[].label_configuration : list of length 2 - Configuration of the label pair\nvalues.[].label_configuration.[].relevance : int \u2013 0 for absence of the labels,\n1 for the presence of labels\nvalues.[].label_configuration.[].label : str \u2013 Label name\nvalues.[].statistic_value : float \u2013 Statistic value\nVariables:\nfeature_name (str) \u2013 Name of the feature\nvalues (list(dict)) \u2013 List of joint probability values with a schema described as ProbabilityValues\nstatistic_dataframes (dict(pandas.DataFrame)) \u2013 Joint Probability values as DataFrames for different relevance combinations.\nE.g. The probability P(A=0,B=1) can be retrieved via:\npairwise_joint_probabilities.statistic_dataframes[(0,1)].loc['A', 'B']\nclassmethod get(multilabel_insights_key)\uf0c1\nRetrieves pairwise joint probabilities\nYou might find it more convenient to use\nFeature.get_pairwise_joint_probabilities\ninstead.\nParameters:\nmultilabel_insights_key (string) \u2013 Key for multilabel insights, unique for a project, feature and EDA stage combination.\nThe multilabel_insights_key can be retrieved via\nFeature.multilabel_insights_key.\nReturns:\nThe pairwise joint probabilities\nReturn type:\nPairwiseJointProbabilities\nas_dataframe(relevance_configuration)\uf0c1\nJoint probabilities of label pairs as a (num_labels x num_labels) DataFrame.\nParameters:\nrelevance_configuration (tuple of length 2) \u2013 Valid options are (0, 0), (0, 1), (1, 0) and (1, 1). Values of 0 indicate absence of\nlabels and 1 indicates presence of labels. The first value describes the\npresence for the labels in axis=0 and the second value describes the presence for the\nlabels in axis=1.\nFor example the matrix values for a relevance configuration of (0, 1) describe the\nprobabilities of absent labels in the index axis and present labels in the column\naxis.\nE.g. The probability P(A=0,B=1) can be retrieved via:\npairwise_joint_probabilities.as_dataframe((0,1)).loc['A', 'B']\nReturns:\nThe joint probabilities for the requested relevance_configuration. Index and column\nnames allow the interpretation of the values.\nReturn type:\npandas.DataFrame\nclass datarobot.models.PairwiseConditionalProbabilities\uf0c1\nConditional probabilities of label pairs for multicategorical feature.\nAdded in version v2.24.\nNotes\nProbabilityValues contain:\nvalues.[].label_configuration : list of length 2 - Configuration of the label pair\nvalues.[].label_configuration.[].relevance : int \u2013 0 for absence of the labels,\n1 for the presence of labels\nvalues.[].label_configuration.[].label : str \u2013 Label name\nvalues.[].statistic_value : float \u2013 Statistic value\nVariables:\nfeature_name (str) \u2013 Name of the feature\nvalues (list(dict)) \u2013 List of conditional probability values with a schema described as ProbabilityValues\nstatistic_dataframes (dict(pandas.DataFrame)) \u2013 Conditional Probability values as DataFrames for different relevance combinations.\nThe label names in the columns are the events, on which we condition. The label names in the\nindex are the events whose conditional probability given the indexes is in the dataframe.\nE.g. The probability P(A=0|B=1) can be retrieved via:\npairwise_conditional_probabilities.statistic_dataframes[(0,1)].loc['A', 'B']\nclassmethod get(multilabel_insights_key)\uf0c1\nRetrieves pairwise conditional probabilities\nYou might find it more convenient to use\nFeature.get_pairwise_conditional_probabilities\ninstead.\nParameters:\nmultilabel_insights_key (string) \u2013 Key for multilabel insights, unique for a project, feature and EDA stage combination.\nThe multilabel_insights_key can be retrieved via\nFeature.multilabel_insights_key.\nReturns:\nThe pairwise conditional probabilities\nReturn type:\nPairwiseConditionalProbabilities\nas_dataframe(relevance_configuration)\uf0c1\nConditional probabilities of label pairs as a (num_labels x num_labels) DataFrame.\nThe label names in the columns are the events, on which we condition. The label names in the\nindex are the events whose conditional probability given the indexes is in the dataframe.\nE.g. The probability P(A=0|B=1) can be retrieved via:\npairwise_conditional_probabilities.as_dataframe((0, 1)).loc['A', 'B']\nParameters:\nrelevance_configuration (tuple of length 2) \u2013 Valid options are (0, 0), (0, 1), (1, 0) and (1, 1). Values of 0 indicate absence of\nlabels and 1 indicates presence of labels. The first value describes the\npresence for the labels in axis=0 and the second value describes the presence for the\nlabels in axis=1.\nFor example the matrix values for a relevance configuration of (0, 1) describe the\nprobabilities of absent labels in the index axis given the\npresence of labels in the column axis.\nReturns:\nThe conditional probabilities for the requested relevance_configuration.\nIndex and column names allow the interpretation of the values.\nReturn type:\npandas.DataFrame\nRestoring Discarded Features\uf0c1\nclass datarobot.models.restore_discarded_features.DiscardedFeaturesInfo\uf0c1\nAn object containing information about time series features which were reduced\nduring time series feature generation process. These features can be restored back to the\nproject. They will be included into All Time Series Features and can be used to create new\nfeature lists.\nAdded in version v2.27.\nVariables:\ntotal_restore_limit (int) \u2013 The total limit indicating how many features can be restored in this project.\nremaining_restore_limit (int) \u2013 The remaining available number of the features which can be restored in this project.\nfeatures (list of strings) \u2013 Discarded features which can be restored.\ncount (int) \u2013 Discarded features count.\nclassmethod restore(project_id, features_to_restore, max_wait=600)\uf0c1\nRestore discarded during time series feature generation process features back to the\nproject. After restoration features will be included into All Time Series Features.\nAdded in version v2.27.\nParameters:\nproject_id (string)\nfeatures_to_restore (list of strings) \u2013 List of the feature names to restore\nmax_wait (Optional[int]) \u2013 max time to wait for features to be restored.\nDefaults to 10 min\nReturns:\nstatus \u2013 information about features which were restored and which were not.\nReturn type:\nFeatureRestorationStatus\nclassmethod retrieve(project_id)\uf0c1\nRetrieve the discarded features information for a given project.\nAdded in version v2.27.\nParameters:\nproject_id (string)\nReturns:\ninfo \u2013 information about features which were discarded during feature generation process and\nlimits how many features can be restored.\nReturn type:\nDiscardedFeaturesInfo\nclass datarobot.models.restore_discarded_features.FeatureRestorationStatus\uf0c1\nStatus of the feature restoration process.\nAdded in version v2.27.\nVariables:\nwarnings (list of strings) \u2013 Warnings generated for those features which failed to restore\nremaining_restore_limit (int) \u2013 The remaining available number of the features which can be restored in this project.\nrestored_features (list of strings) \u2013 Features which were restored\nFeature lists\uf0c1\nclass datarobot.DatasetFeaturelist\uf0c1\nA set of features attached to a dataset in the AI Catalog\nVariables:\nid (str) \u2013 the id of the dataset featurelist\ndataset_id (str) \u2013 the id of the dataset the featurelist belongs to\ndataset_version_id (Optional[str]) \u2013 the version id of the dataset this featurelist belongs to\nname (str) \u2013 the name of the dataset featurelist\nfeatures (List[str]) \u2013 a list of the names of features included in this dataset featurelist\ncreation_date (datetime.datetime) \u2013 when the featurelist was created\ncreated_by (str) \u2013 the user name of the user who created this featurelist\nuser_created (bool) \u2013 whether the featurelist was created by a user or by DataRobot automation\ndescription (Optional[str]) \u2013 the description of the featurelist. Only present on DataRobot-created featurelists.\nclassmethod get(dataset_id, featurelist_id)\uf0c1\nRetrieve a dataset featurelist\nParameters:\ndataset_id (str) \u2013 the id of the dataset the featurelist belongs to\nfeaturelist_id (str) \u2013 the id of the dataset featurelist to retrieve\nReturns:\nfeaturelist \u2013 the specified featurelist\nReturn type:\nDatasetFeatureList\ndelete()\uf0c1\nDelete a dataset featurelist\nFeaturelists configured into the dataset as a default featurelist cannot be deleted.\nReturn type:\nNone\nupdate(name=None)\uf0c1\nUpdate the name of an existing featurelist\nNote that only user-created featurelists can be renamed, and that names must not\nconflict with names used by other featurelists.\nParameters:\nname (Optional[str]) \u2013 the new name for the featurelist\nReturn type:\nNone\nclass datarobot.models.Featurelist\uf0c1\nA set of features used in modeling\nVariables:\nid (str) \u2013 the id of the featurelist\nname (str) \u2013 the name of the featurelist\nfeatures (List[str]) \u2013 the names of all the Features in the featurelist\nproject_id (str) \u2013 the project the featurelist belongs to\ncreated (datetime.datetime) \u2013 (New in version v2.13) when the featurelist was created\nis_user_created (bool) \u2013 (New in version v2.13) whether the featurelist was created by a user or by DataRobot\nautomation\nnum_models (int) \u2013 (New in version v2.13) the number of models currently using this featurelist.  A model is\nconsidered to use a featurelist if it is used to train the model or as a monotonic\nconstraint featurelist, or if the model is a blender with at least one component model\nusing the featurelist.\ndescription (str) \u2013 (New in version v2.13) the description of the featurelist.  Can be updated by the user\nand may be supplied by default for DataRobot-created featurelists.\nclassmethod from_data(data)\uf0c1\nOverrides the parent method to ensure description is always populated\nParameters:\ndata (dict) \u2013 the data from the server, having gone through processing\nReturn type:\nTypeVar(TFeaturelist, bound= Featurelist)\nclassmethod get(project_id, featurelist_id)\uf0c1\nRetrieve a known feature list\nParameters:\nproject_id (str) \u2013 The id of the project the featurelist is associated with\nfeaturelist_id (str) \u2013 The ID of the featurelist to retrieve\nReturns:\nfeaturelist \u2013 The queried instance\nReturn type:\nFeaturelist\nRaises:\nValueError \u2013 passed project_id parameter value is of not supported type\ndelete(dry_run=False, delete_dependencies=False)\uf0c1\nDelete a featurelist, and any models and jobs using it\nAll models using a featurelist, whether as the training featurelist or as a monotonic\nconstraint featurelist, will also be deleted when the deletion is executed and any queued or\nrunning jobs using it will be cancelled. Similarly, predictions made on these models will\nalso be deleted. All the entities that are to be deleted with a featurelist are described\nas \u201cdependencies\u201d of it.  To preview the results of deleting a featurelist, call delete\nwith dry_run=True\nWhen deleting a featurelist with dependencies, users must specify delete_dependencies=True\nto confirm they want to delete the featurelist and all its dependencies. Without that\noption, only featurelists with no dependencies may be successfully deleted and others will\nerror.\nFeaturelists configured into the project as a default featurelist or as a default monotonic\nconstraint featurelist cannot be deleted.\nFeaturelists used in a model deployment cannot be deleted until the model deployment is\ndeleted.\nParameters:\ndry_run (Optional[bool]) \u2013 specify True to preview the result of deleting the featurelist, instead of actually\ndeleting it.\ndelete_dependencies (Optional[bool]) \u2013 specify True to successfully delete featurelists with dependencies; if left\nFalse by default, featurelists without dependencies can be successfully deleted and\nthose with dependencies will error upon attempting to delete them.\nReturns:\nresult \u2013\nA dictionary describing the result of deleting the featurelist, with the following keys\ndry_run : bool, whether the deletion was a dry run or an actual deletion\ncan_delete : bool, whether the featurelist can actually be deleted\ndeletion_blocked_reason : str, why the featurelist can\u2019t be deleted (if it can\u2019t)\nnum_affected_models : int, the number of models using this featurelist\nnum_affected_jobs : int, the number of jobs using this featurelist\nReturn type:\ndict\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nupdate(name=None, description=None)\uf0c1\nUpdate the name or description of an existing featurelist\nNote that only user-created featurelists can be renamed, and that names must not\nconflict with names used by other featurelists.\nParameters:\nname (Optional[str]) \u2013 the new name for the featurelist\ndescription (Optional[str]) \u2013 the new description for the featurelist\nReturn type:\nNone\nclass datarobot.models.ModelingFeaturelist\uf0c1\nA set of features that can be used to build a model\nIn time series projects, a new set of modeling features is created after setting the\npartitioning options.  These features are automatically derived from those in the project\u2019s\ndataset and are the features used for modeling.  Modeling features are only accessible once\nthe target and partitioning options have been set.  In projects that don\u2019t use time series\nmodeling, once the target has been set, ModelingFeaturelists and Featurelists will behave\nthe same.\nFor more information about input and modeling features, see the\ntime series documentation.\nVariables:\nid (str) \u2013 the id of the modeling featurelist\nproject_id (str) \u2013 the id of the project the modeling featurelist belongs to\nname (str) \u2013 the name of the modeling featurelist\nfeatures (List[str]) \u2013 a list of the names of features included in this modeling featurelist\ncreated (datetime.datetime) \u2013 (New in version v2.13) when the featurelist was created\nis_user_created (bool) \u2013 (New in version v2.13) whether the featurelist was created by a user or by DataRobot\nautomation\nnum_models (int) \u2013 (New in version v2.13) the number of models currently using this featurelist.  A model is\nconsidered to use a featurelist if it is used to train the model or as a monotonic\nconstraint featurelist, or if the model is a blender with at least one component model\nusing the featurelist.\ndescription (str) \u2013 (New in version v2.13) the description of the featurelist.  Can be updated by the user\nand may be supplied by default for DataRobot-created featurelists.\nclassmethod get(project_id, featurelist_id)\uf0c1\nRetrieve a modeling featurelist\nModeling featurelists can only be retrieved once the target and partitioning options have\nbeen set.\nParameters:\nproject_id (str) \u2013 the id of the project the modeling featurelist belongs to\nfeaturelist_id (str) \u2013 the id of the modeling featurelist to retrieve\nReturns:\nfeaturelist \u2013 the specified featurelist\nReturn type:\nModelingFeaturelist\nupdate(name=None, description=None)\uf0c1\nUpdate the name or description of an existing featurelist\nNote that only user-created featurelists can be renamed, and that names must not\nconflict with names used by other featurelists.\nParameters:\nname (Optional[str]) \u2013 the new name for the featurelist\ndescription (Optional[str]) \u2013 the new description for the featurelist\nReturn type:\nNone\ndelete(dry_run=False, delete_dependencies=False)\uf0c1\nDelete a featurelist, and any models and jobs using it\nAll models using a featurelist, whether as the training featurelist or as a monotonic\nconstraint featurelist, will also be deleted when the deletion is executed and any queued or\nrunning jobs using it will be cancelled. Similarly, predictions made on these models will\nalso be deleted. All the entities that are to be deleted with a featurelist are described\nas \u201cdependencies\u201d of it.  To preview the results of deleting a featurelist, call delete\nwith dry_run=True\nWhen deleting a featurelist with dependencies, users must specify delete_dependencies=True\nto confirm they want to delete the featurelist and all its dependencies. Without that\noption, only featurelists with no dependencies may be successfully deleted and others will\nerror.\nFeaturelists configured into the project as a default featurelist or as a default monotonic\nconstraint featurelist cannot be deleted.\nFeaturelists used in a model deployment cannot be deleted until the model deployment is\ndeleted.\nParameters:\ndry_run (Optional[bool]) \u2013 specify True to preview the result of deleting the featurelist, instead of actually\ndeleting it.\ndelete_dependencies (Optional[bool]) \u2013 specify True to successfully delete featurelists with dependencies; if left\nFalse by default, featurelists without dependencies can be successfully deleted and\nthose with dependencies will error upon attempting to delete them.\nReturns:\nresult \u2013\nA dictionary describing the result of deleting the featurelist, with the following keys\ndry_run : bool, whether the deletion was a dry run or an actual deletion\ncan_delete : bool, whether the featurelist can actually be deleted\ndeletion_blocked_reason : str, why the featurelist can\u2019t be deleted (if it can\u2019t)\nnum_affected_models : int, the number of models using this featurelist\nnum_affected_jobs : int, the number of jobs using this featurelist\nReturn type:\ndict\nclass datarobot.models.featurelist.DeleteFeatureListResult\uf0c1\nDataset definition\uf0c1\nclass datarobot.helpers.feature_discovery.DatasetDefinition\uf0c1\nDataset definition for the Feature Discovery\nAdded in version v2.25.\nVariables:\nidentifier (str) \u2013 Alias of the dataset (used directly as part of the generated feature names)\ncatalog_id (Optional[str]) \u2013 Identifier of the catalog item\ncatalog_version_id (str) \u2013 Identifier of the catalog item version\nprimary_temporal_key (Optional[str]) \u2013 Name of the column indicating time of record creation\nfeature_list_id (Optional[str]) \u2013 Identifier of the feature list. This decides which columns in the dataset are\nused for feature generation\nsnapshot_policy (Optional[str]) \u2013 Policy to use  when creating a project or making predictions.\nIf omitted, by default endpoint will use \u2018latest\u2019.\nMust be one of the following values:\n\u2018specified\u2019: Use specific snapshot specified by catalogVersionId\n\u2018latest\u2019: Use latest snapshot from the same catalog item\n\u2018dynamic\u2019: Get data from the source (only applicable for JDBC datasets)\nExamples\nimport datarobot as dr\ndataset_definition = dr.DatasetDefinition(\nidentifier='profile',\ncatalog_id='5ec4aec1f072bc028e3471ae',\ncatalog_version_id='5ec4aec2f072bc028e3471b1',\n)\ndataset_definition = dr.DatasetDefinition(\nidentifier='transaction',\ncatalog_id='5ec4aec1f072bc028e3471ae',\ncatalog_version_id='5ec4aec2f072bc028e3471b1',\nprimary_temporal_key='Date'\n)\nRelationships\uf0c1\nclass datarobot.helpers.feature_discovery.Relationship\uf0c1\nRelationship between dataset defined in DatasetDefinition\nAdded in version v2.25.\nVariables:\ndataset1_identifier (Optional[str]) \u2013 Identifier of the first dataset in this relationship.\nThis is specified in the identifier field of dataset_definition structure.\nIf None, then the relationship is with the primary dataset.\ndataset2_identifier (str) \u2013 Identifier of the second dataset in this relationship.\nThis is specified in the identifier field of dataset_definition schema.\ndataset1_keys (List[str]) \u2013 (max length: 10 min length: 1)\nColumn(s) from the first dataset which are used to join to the second dataset\ndataset2_keys (List[str]) \u2013 (max length: 10 min length: 1)\nColumn(s) from the second dataset that are used to join to the first dataset\nfeature_derivation_window_start (int, or None) \u2013 How many time_units of each dataset\u2019s primary temporal key into the past relative\nto the datetimePartitionColumn the feature derivation window should begin.\nWill be a negative integer,\nIf present, the feature engineering Graph will perform time-aware joins.\nfeature_derivation_window_end (Optional[int]) \u2013 How many timeUnits of each dataset\u2019s record\nprimary temporal key into the past relative to the datetimePartitionColumn the\nfeature derivation window should end.  Will be a non-positive integer, if present.\nIf present, the feature engineering Graph will perform time-aware joins.\nfeature_derivation_window_time_unit (Optional[int]) \u2013 Time unit of the feature derivation window.\nOne of datarobot.enums.AllowedTimeUnitsSAFER\nIf present, time-aware joins will be used.\nOnly applicable when dataset1_identifier is not provided.\nfeature_derivation_windows (list of dict, or None) \u2013 List of feature derivation windows settings. If present, time-aware joins will be used.\nOnly allowed when feature_derivation_window_start,\nfeature_derivation_window_end and feature_derivation_window_time_unit are not provided.\nprediction_point_rounding (Optional[int]) \u2013 Closest value of prediction_point_rounding_time_unit to round the prediction point\ninto the past when applying the feature derivation window. Will be a positive integer,\nif present.Only applicable when dataset1_identifier is not provided.\nprediction_point_rounding_time_unit (Optional[str]) \u2013 Time unit of the prediction point rounding.\nOne of datarobot.enums.AllowedTimeUnitsSAFER\nOnly applicable when dataset1_identifier is not provided.\nschema (The feature_derivation_windows is a list of dictionary with) \u2013\nstart: intHow many time_units of each dataset\u2019s primary temporal key into the past relative\nto the datetimePartitionColumn the feature derivation window should begin.\nend: intHow many timeUnits of each dataset\u2019s record\nprimary temporal key into the past relative to the datetimePartitionColumn the\nfeature derivation window should end.\nunit: strTime unit of the feature derivation window.\nOne of datarobot.enums.AllowedTimeUnitsSAFER.\nExamples\nimport datarobot as dr\nrelationship = dr.Relationship(\ndataset1_identifier='profile',\ndataset2_identifier='transaction',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID']\n)\nrelationship = dr.Relationship(\ndataset2_identifier='profile',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID'],\nfeature_derivation_window_start=-14,\nfeature_derivation_window_end=-1,\nfeature_derivation_window_time_unit='DAY',\nprediction_point_rounding=1,\nprediction_point_rounding_time_unit='DAY'\n)\nRelationships configuration\uf0c1\nclass datarobot.models.RelationshipsConfiguration\uf0c1\nA Relationships configuration specifies a set of secondary datasets as well as\nthe relationships among them. It is used to configure Feature Discovery for a project\nto generate features automatically from these datasets.\nVariables:\nid (str) \u2013 Id of the created relationships configuration\ndataset_definitions (list) \u2013 Each element is a dataset_definitions for a dataset.\nrelationships (list) \u2013 Each element is a relationship between two datasets\nfeature_discovery_mode (str) \u2013 Mode of feature discovery. Supported values are \u2018default\u2019 and \u2018manual\u2019\nfeature_discovery_settings (list) \u2013 List of feature discovery settings used to customize the feature discovery process\nis (The feature_discovery_settings structure)\nidentifier (str) \u2013 Alias of the dataset (used directly as part of the generated feature names)\ncatalog_id (str, or None) \u2013 Identifier of the catalog item\ncatalog_version_id (str) \u2013 Identifier of the catalog item version\nprimary_temporal_key (Optional[str]) \u2013 Name of the column indicating time of record creation\nfeature_list_id (Optional[str]) \u2013 Identifier of the feature list. This decides which columns in the dataset are\nused for feature generation\nsnapshot_policy (str) \u2013 Policy to use  when creating a project or making predictions.\nMust be one of the following values:\n\u2018specified\u2019: Use specific snapshot specified by catalogVersionId\n\u2018latest\u2019: Use latest snapshot from the same catalog item\n\u2018dynamic\u2019: Get data from the source (only applicable for JDBC datasets)\nfeature_lists (list) \u2013 List of feature list info\ndata_source (dict) \u2013 Data source info if the dataset is from data source\ndata_sources (list) \u2013 List of Data source details for a JDBC datasets\nis_deleted (Optional[bool]) \u2013 Whether the dataset is deleted or not\nis\ndata_store_id (str) \u2013 Id of the data store.\ndata_store_name (str) \u2013 User-friendly name of the data store.\nurl (str) \u2013 Url used to connect to the data store.\ndbtable (str) \u2013 Name of table from the data store.\nschema (The feature_derivation_windows is a list of dictionary with) \u2013 Schema definition of the table from the data store\ncatalog (str) \u2013 Catalog name of the data source.\nis\nid \u2013 Id of the featurelist\nname (str) \u2013 Name of the featurelist\nfeatures (List[str]) \u2013 Names of all the Features in the featurelist\ndataset_id (str) \u2013 Project the featurelist belongs to\ncreation_date (datetime.datetime) \u2013 When the featurelist was created\nuser_created (bool) \u2013 Whether the featurelist was created by a user or by DataRobot automation\ncreated_by (str) \u2013 Name of user who created it\ndescription (str) \u2013 Description of the featurelist.  Can be updated by the user\nand may be supplied by default for DataRobot-created featurelists.\ndataset_id \u2013 Dataset which is associated with the feature list\ndataset_version_id (str or None) \u2013 Version of the dataset which is associated with feature list.\nOnly relevant for Informative features\nis\ndataset1_identifier (str or None) \u2013 Identifier of the first dataset in this relationship.\nThis is specified in the identifier field of dataset_definition structure.\nIf None, then the relationship is with the primary dataset.\ndataset2_identifier (str) \u2013 Identifier of the second dataset in this relationship.\nThis is specified in the identifier field of dataset_definition schema.\ndataset1_keys (List[str] (max length: 10 min length: 1)) \u2013 Column(s) from the first dataset which are used to join to the second dataset\ndataset2_keys (List[str]) \u2013 (max length: 10 min length: 1)\nColumn(s) from the second dataset that are used to join to the first dataset\ntime_unit (str, or None) \u2013 Time unit of the feature derivation window. Supported\nvalues are MILLISECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR.\nIf present, the feature engineering Graph will perform time-aware joins.\nfeature_derivation_window_start (int, or None) \u2013 How many time_units of each dataset\u2019s primary temporal key into the past relative\nto the datetimePartitionColumn the feature derivation window should begin.\nWill be a negative integer,\nIf present, the feature engineering Graph will perform time-aware joins.\nfeature_derivation_window_end (int or None) \u2013 How many timeUnits of each dataset\u2019s record\nprimary temporal key into the past relative to the datetimePartitionColumn the\nfeature derivation window should end.  Will be a non-positive integer, if present.\nIf present, the feature engineering Graph will perform time-aware joins.\nfeature_derivation_window_time_unit (int or None) \u2013 Time unit of the feature derivation window. Supported values are\nMILLISECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR\nIf present, time-aware joins will be used.\nOnly applicable when dataset1Identifier is not provided.\nfeature_derivation_windows (list of dict, or None) \u2013 List of feature derivation windows settings. If present, time-aware joins will be used.\nOnly allowed when feature_derivation_window_start,\nfeature_derivation_window_end and feature_derivation_window_time_unit are not provided.\nprediction_point_rounding (int, or None) \u2013 Closest value of prediction_point_rounding_time_unit to round the prediction point\ninto the past when applying the feature derivation window. Will be a positive integer,\nif present.Only applicable when dataset1_identifier is not provided.\nprediction_point_rounding_time_unit (str, or None) \u2013 time unit of the prediction point rounding. Supported values are\nMILLISECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR\nOnly applicable when dataset1_identifier is not provided.\nschema \u2013\nstart: intHow many time_units of each dataset\u2019s primary temporal key into the past relative\nto the datetimePartitionColumn the feature derivation window should begin.\nend: intHow many timeUnits of each dataset\u2019s record\nprimary temporal key into the past relative to the datetimePartitionColumn the\nfeature derivation window should end.\nunit: strTime unit of the feature derivation window.\nOne of datarobot.enums.AllowedTimeUnitsSAFER.\nis\nname \u2013 Name of the feature discovery setting\nvalue (bool) \u2013 Value of the feature discovery setting\nspecifying (To see the list of possible settings, create a RelationshipConfiguration without)\npossible (settings and check its feature_discovery_settings attribute, which is a list of)\nvalues. (settings with their default)\nclassmethod create(dataset_definitions, relationships, feature_discovery_settings=None)\uf0c1\nCreate a Relationships Configuration\nParameters:\ndataset_definitions (list of DatasetDefinition) \u2013 Each element is a datarobot.helpers.feature_discovery.DatasetDefinition\nrelationships (list of Relationship) \u2013 Each element is a datarobot.helpers.feature_discovery.Relationship\nfeature_discovery_settings (Optional[List[FeatureDiscoverySetting]]) \u2013 Each element is a dictionary or a\ndatarobot.helpers.feature_discovery.FeatureDiscoverySetting. If not provided,\ndefault settings will be used.\nReturns:\nrelationships_configuration \u2013 Created relationships configuration\nReturn type:\nRelationshipsConfiguration\nExamples\ndataset_definition = dr.DatasetDefinition(\nidentifier='profile',\ncatalog_id='5fd06b4af24c641b68e4d88f',\ncatalog_version_id='5fd06b4af24c641b68e4d88f'\n)\nrelationship = dr.Relationship(\ndataset2_identifier='profile',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID'],\nfeature_derivation_window_start=-14,\nfeature_derivation_window_end=-1,\nfeature_derivation_window_time_unit='DAY',\nprediction_point_rounding=1,\nprediction_point_rounding_time_unit='DAY'\n)\ndataset_definitions = [dataset_definition]\nrelationships = [relationship]\nrelationship_config = dr.RelationshipsConfiguration.create(\ndataset_definitions=dataset_definitions,\nrelationships=relationships,\nfeature_discovery_settings = [\n{'name': 'enable_categorical_statistics', 'value': True},\n{'name': 'enable_numeric_skewness', 'value': True},\n]\n)\n>>> relationship_config.id\n'5c88a37770fc42a2fcc62759'\nget()\uf0c1\nRetrieve the Relationships configuration for a given id\nReturns:\nrelationships_configuration \u2013 The requested relationships configuration\nReturn type:\nRelationshipsConfiguration\nRaises:\nClientError \u2013 Raised if an invalid relationships config id is provided.\nExamples\nrelationships_config = dr.RelationshipsConfiguration(valid_config_id)\nresult = relationships_config.get()\n>>> result.id\n'5c88a37770fc42a2fcc62759'\nreplace(dataset_definitions, relationships, feature_discovery_settings=None)\uf0c1\nUpdate the Relationships Configuration which is not used in\nthe feature discovery Project\nParameters:\ndataset_definitions (List[DatasetDefinition]) \u2013 Each element is a datarobot.helpers.feature_discovery.DatasetDefinition\nrelationships (List[Relationship]) \u2013 Each element is a datarobot.helpers.feature_discovery.Relationship\nfeature_discovery_settings (Optional[List[FeatureDiscoverySetting]]) \u2013 Each element is a dictionary or a\ndatarobot.helpers.feature_discovery.FeatureDiscoverySetting. If not provided,\ndefault settings will be used.\nReturns:\nrelationships_configuration \u2013 the updated relationships configuration\nReturn type:\nRelationshipsConfiguration\ndelete()\uf0c1\nDelete the Relationships configuration\nRaises:\nClientError \u2013 Raised if an invalid relationships config id is provided.\nExamples\n# Deleting with a valid id\nrelationships_config = dr.RelationshipsConfiguration(valid_config_id)\nstatus_code = relationships_config.delete()\nstatus_code\n>>> 204\nrelationships_config.get()\n>>> ClientError: Relationships Configuration not found\nFeature lineage\uf0c1\nclass datarobot.models.FeatureLineage\uf0c1\nLineage of an automatically engineered feature.\nVariables:\nsteps (list) \u2013 list of steps which were applied to build the feature.\nsteps structure is:\nid - (int)step id starting with 0.\nstep_type: (str)one of the data/action/json/generatedData.\nname: (str)name of the step.\ndescription: (str)description of the step.\nparents: (list[int])references to other steps id.\nis_time_aware: (bool)indicator of step being time aware. Mandatory only for action and join steps.\naction step provides additional information about feature derivation window\nin the timeInfo field.\ncatalog_id: (str)id of the catalog for a data step.\ncatalog_version_id: (str)id of the catalog version for a data step.\ngroup_by: (list[str])list of columns which this action step aggregated by.\ncolumns: (list)names of columns involved into the feature generation. Available only for data steps.\ntime_info: (dict)description of the feature derivation window which was applied to this action step.\njoin_info: (list[dict])join step details.\ncolumns structure is\ndata_type: (str)the type of the feature, e.g. \u2018Categorical\u2019, \u2018Text\u2019\nis_input: (bool)indicates features which provided data to transform in this lineage.\nname: (str)feature name.\nis_cutoff: (bool)indicates a cutoff column.\ntime_info structure is:\nlatest: (dict)end of the feature derivation window applied.\nduration: (dict)size of the feature derivation window applied.\nlatest and duration structure is:\ntime_unit: (str)time unit name like \u2018MINUTE\u2019, \u2018DAY\u2019, \u2018MONTH\u2019 etc.\nduration: (int)value/size of this duration object.\njoin_info structure is:\njoin_type - (str)kind of join, left/right.\nleft_table - (dict)information about a dataset which was considered as left.\nright_table - (str)information about a dataset which was considered as right.\nleft_table and right_table structure is:\ncolumns - (list[str])list of columns which datasets were joined by.\ndatasteps - (list[int])list of data steps id which brought the columns into the current step dataset.\nclassmethod get(project_id, id)\uf0c1\nRetrieve a single FeatureLineage.\nParameters:\nproject_id (str) \u2013 The id of the project the feature belongs to\nid (str) \u2013 id of a feature lineage to retrieve\nReturns:\nlineage \u2013 The queried instance\nReturn type:\nFeatureLineage\nOCR job resources\uf0c1\nclass datarobot.models.ocr_job_resource.OCRJobResource\uf0c1\nAn OCR job resource container. It is used to:\n- Get an existing OCR  job resource.\n- List available OCR job resources.\n- Start an OCR job.\n- Check the status of a started OCR job.\n- Download the error report of a started OCR job.\nAdded in version v3.6.0b0.\nVariables:\nid (str) \u2013 The identifier of an OCR job resource.\ninput_catalog_id (str) \u2013 The identifier of an AI catalog item used as the OCR job input.\noutput_catalog_id (str) \u2013 The identifier of an AI catalog item used as the OCR job output.\nuser_id (str) \u2013 The identifier of a user.\njob_started (bool) \u2013 Determines if a job associated with the OCRJobResource has started.\nlanguage (str) \u2013 String representation of OCRJobDatasetLanguage.\nclassmethod get(job_resource_id)\uf0c1\nGet an OCR job resource.\nParameters:\njob_resource_id (str) \u2013 identifier of OCR job resource\nReturns:\nreturned OCR job resource\nReturn type:\nOCRJobResource\nclassmethod list(offset=0, limit=10)\uf0c1\nGet a list of OCR job resources.\nParameters:\noffset (int) \u2013 The offset of the query.\nlimit (int) \u2013 The limit of returned OCR job resources.\nReturns:\nA list of OCR job resources.\nReturn type:\nList[OCRJobResource]\nclassmethod create(input_catalog_id, language)\uf0c1\nCreate a new OCR job resource and return it.\nParameters:\ninput_catalog_id (str) \u2013 The identifier of an AI catalog item used as the OCR job input.\nlanguage (OCRJobDatasetLanguage) \u2013 The OCR job dataset language.\nReturns:\nThe created OCR job resource.\nReturn type:\nOCRJobResource\nstart_job()\uf0c1\nStart an OCR job with this OCR job resource.\nReturns:\nThe response of starting an OCR job.\nReturn type:\nStartOCRJobResponse\nget_job_status()\uf0c1\nGet status of the OCR job associated with this OCR job resource.\nReturns:\nOCR job status enum\nReturn type:\nOCRJobStatusEnum\ndownload_error_report(download_file_path)\uf0c1\nDownload the error report of the OCR job associated with this OCR job resource.\nParameters:\ndownload_file_path (Path) \u2013 path to download error report\nReturn type:\nNone\nclass datarobot.models.ocr_job_resource.OCRJobDatasetLanguage\uf0c1\nSupported OCR language\nclass datarobot.models.ocr_job_resource.OCRJobStatusEnum\uf0c1\nOCR Job status enum\nclass datarobot.models.ocr_job_resource.StartOCRJobResponse\uf0c1\nContainer of Start OCR Job API response\nDocument text extraction\uf0c1\nclass datarobot.models.documentai.document.FeaturesWithSamples\uf0c1\nFeaturesWithSamples(model_id, feature_name, document_task)\ndocument_task\uf0c1\nAlias for field number 2\nfeature_name\uf0c1\nAlias for field number 1\nmodel_id\uf0c1\nAlias for field number 0\nclass datarobot.models.documentai.document.DocumentPageFile\uf0c1\nPage of a document as an image file.\nVariables:\nproject_id (str) \u2013 The identifier of the project which the document page belongs to.\ndocument_page_id (str) \u2013 The unique identifier for the document page.\nheight (int) \u2013 The height of the document thumbnail in pixels.\nwidth (int) \u2013 The width of the document thumbnail in pixels.\nthumbnail_bytes (bytes) \u2013 The number of bytes of the document thumbnail image. Accessing this may\nrequire a server request and an associated delay in fetching the resource.\nmime_type (str) \u2013 The mime image type of the document thumbnail. Example: \u2018image/png\u2019\nproperty thumbnail_bytes: bytes\uf0c1\nDocument thumbnail as bytes.\nReturns:\nDocument thumbnail.\nReturn type:\nbytes\nproperty mime_type: str\uf0c1\n\u2018image/png\u2019\nReturns:\nMime image type of the document thumbnail.\nReturn type:\nstr\nType:\nMime image type of the document thumbnail. Example\nclass datarobot.models.documentai.document.DocumentThumbnail\uf0c1\nThumbnail of document from the project\u2019s dataset.\nIf Project.stage is datarobot.enums.PROJECT_STAGE.EDA2\nand it is a supervised project then the target_* attributes\nof this class will have values, otherwise the values will all be None.\nVariables:\ndocument (Document) \u2013 The document object.\nproject_id (str) \u2013 The identifier of the project which the document thumbnail belongs to.\ntarget_value (str) \u2013 The target value used for filtering thumbnails.\nclassmethod list(project_id, feature_name, target_value=None, offset=None, limit=None)\uf0c1\nGet document thumbnails from a project.\nParameters:\nproject_id (str) \u2013 The identifier of the project which the document thumbnail belongs to.\nfeature_name (str) \u2013 The name of feature that specifies the document type.\ntarget_value (Optional[str], default None) \u2013 The target value to filter thumbnails.\noffset (Optional[int], default None) \u2013 The number of documents to be skipped.\nlimit (Optional[int], default None) \u2013 The number of document thumbnails to return.\nReturns:\ndocuments \u2013 A list of DocumentThumbnail objects, each representing a single document.\nReturn type:\nList[DocumentThumbnail]\nNotes\nActual document thumbnails are not fetched from the server by this method.\nInstead the data gets loaded lazily when DocumentPageFile object attributes\nare accessed.\nExamples\nFetch document thumbnails for the given project_id and feature_name.\nfrom datarobot._experimental.models.documentai.document import DocumentThumbnail\n# Fetch five documents from the EDA SAMPLE for the specified project and specific feature\ndocument_thumbs = DocumentThumbnail.list(project_id, feature_name, limit=5)\n# Fetch five documents for the specified project with target value filtering\n# This option is only available after selecting the project target and starting modeling\ntarget1_thumbs = DocumentThumbnail.list(project_id, feature_name, target_value='target1', limit=5)\nPreview the document thumbnail.\nfrom datarobot._experimental.models.documentai.document import DocumentThumbnail\nfrom datarobot.helpers.image_utils import get_image_from_bytes\n# Fetch 3 documents\ndocument_thumbs = DocumentThumbnail.list(project_id, feature_name, limit=3)\nfor doc_thumb in document_thumbs:\nthumbnail = get_image_from_bytes(doc_thumb.document.thumbnail_bytes)\nthumbnail.show()\nclass datarobot.models.documentai.document.DocumentTextExtractionSample\uf0c1\nStateless class for computing and retrieving Document Text Extraction Samples.\nNotes\nActual document text extraction samples are not fetched from the server in the moment of\na function call. Detailed information on the documents, the pages and the rendered images of them\nare fetched when accessed on demand (lazy loading).\nExamples\n1) Compute text extraction samples for a specific model, and fetch all existing document text\nextraction samples for a specific project.\nfrom datarobot._experimental.models.documentai.document import DocumentTextExtractionSample\nSPECIFIC_MODEL_ID1 = \"model_id1\"\nSPECIFIC_MODEL_ID2 = \"model_id2\"\nSPECIFIC_PROJECT_ID = \"project_id\"\n# Order computation of document text extraction sample for specific model.\n# By default `compute` method will await for computation to end before returning\nDocumentTextExtractionSample.compute(SPECIFIC_MODEL_ID1, await_completion=False)\nDocumentTextExtractionSample.compute(SPECIFIC_MODEL_ID2)\nsamples = DocumentTextExtractionSample.list_features_with_samples(SPECIFIC_PROJECT_ID)\n2) Fetch document text extraction samples for a specific model_id and feature_name, and\ndisplay all document sample pages.\nfrom datarobot._experimental.models.documentai.document import DocumentTextExtractionSample\nfrom datarobot.helpers.image_utils import get_image_from_bytes\nSPECIFIC_MODEL_ID = \"model_id\"\nSPECIFIC_FEATURE_NAME = \"feature_name\"\nsamples = DocumentTextExtractionSample.list_pages(\nmodel_id=SPECIFIC_MODEL_ID,\nfeature_name=SPECIFIC_FEATURE_NAME\n)\nfor sample in samples:\nthumbnail = sample.document_page.thumbnail\nimage = get_image_from_bytes(thumbnail.thumbnail_bytes)\nimage.show()\n3) Fetch document text extraction samples for specific model_id and feature_name and\ndisplay text extraction details for the first page. This example displays the image of the document\nwith bounding boxes of detected text lines. It also returns a list of all text\nlines extracted from page along with their coordinates.\nfrom datarobot._experimental.models.documentai.document import DocumentTextExtractionSample\nSPECIFIC_MODEL_ID = \"model_id\"\nSPECIFIC_FEATURE_NAME = \"feature_name\"\nsamples = DocumentTextExtractionSample.list_pages(SPECIFIC_MODEL_ID, SPECIFIC_FEATURE_NAME)\n# Draw bounding boxes for first document page sample and display related text data.\nimage = samples[0].get_document_page_with_text_locations()\nimage.show()\n# For each text block represented as bounding box object drawn on original image\n# display its coordinates (top, left, bottom, right) and extracted text value\nfor text_line in samples[0].text_lines:\nprint(text_line)\nclassmethod compute(model_id, await_completion=True, max_wait=600)\uf0c1\nStarts computation of document text extraction samples for the model and, if successful,\nreturns computed text samples for it. This method allows calculation to continue for\na specified time and, if not complete, cancels the request.\nParameters:\nmodel_id (str) \u2013 The identifier of the project\u2019s model that start the creation of the cluster insights.\nawait_completion (bool) \u2013 Determines whether the method should wait for completion before exiting or not.\nmax_wait (int (default=600)) \u2013 The maximum number of seconds to wait for the request to finish before raising an\nAsyncTimeoutError.\nRaises:\nClientError \u2013 Server rejected creation due to client error.\nOften, a bad model_id is causing these errors.\nAsyncFailureError \u2013 Indicates whether any of the responses from the server are unexpected.\nAsyncProcessUnsuccessfulError \u2013 Indicates whether the cluster insights computation failed or was cancelled.\nAsyncTimeoutError \u2013 Indicates whether the cluster insights computation did not resolve within the specified\ntime limit (max_wait).\nReturn type:\nNone\nclassmethod list_features_with_samples(project_id)\uf0c1\nReturns a list of features, model_id pairs with computed document text extraction samples.\nParameters:\nproject_id (str) \u2013 The project ID to retrieve the list of computed samples for.\nReturn type:\nList[FeaturesWithSamples]\nclassmethod list_pages(model_id, feature_name, document_index=None, document_task=None)\uf0c1\nReturns a list of document text extraction sample pages.\nParameters:\nmodel_id (str) \u2013 The model identifier.\nfeature_name (str) \u2013 The specific feature name to retrieve.\ndocument_index (Optional[int]) \u2013 The specific document index to retrieve. Defaults to None.\ndocument_task (Optional[str]) \u2013 The document blueprint task.\nReturn type:\nList[DocumentTextExtractionSamplePage]\nclassmethod list_documents(model_id, feature_name)\uf0c1\nReturns a list of documents used for text extraction.\nParameters:\nmodel_id (str) \u2013 The model identifier.\nfeature_name (str) \u2013 The feature name.\nReturn type:\nList[DocumentTextExtractionSampleDocument]\nclass datarobot.models.documentai.document.DocumentTextExtractionSampleDocument\uf0c1\nDocument text extraction source.\nHolds data that contains feature and model prediction values, as well as the thumbnail of the document.\nVariables:\ndocument_index (int) \u2013 The index of the document page sample.\nfeature_name (str) \u2013 The name of the feature that the document text extraction sample is related to.\nthumbnail_id (str) \u2013 The document page ID.\nthumbnail_width (int) \u2013 The thumbnail image width.\nthumbnail_height (int) \u2013 The thumbnail image height.\nthumbnail_link (str) \u2013 The thumbnail image download link.\ndocument_task (str) \u2013 The document blueprint task that the document belongs to.\nactual_target_value (Optional[Union[str, int, List[str]]]) \u2013 The actual target value.\nprediction (Optional[PredictionType]) \u2013 Prediction values and labels.\nclassmethod list(model_id, feature_name, document_task=None)\uf0c1\nList available documents with document text extraction samples.\nParameters:\nmodel_id (str) \u2013 The identifier for the model.\nfeature_name (str) \u2013 The name of the feature,\ndocument_task (Optional[str]) \u2013 The document blueprint task.\nReturn type:\nList[DocumentTextExtractionSampleDocument]\nclass datarobot.models.documentai.document.DocumentTextExtractionSamplePage\uf0c1\nDocument text extraction sample covering one document page.\nHolds data about the document page, the recognized text, and the location of the text in the document page.\nVariables:\npage_index (int) \u2013 Index of the page inside the document\ndocument_index (int) \u2013 Index of the document inside the dataset\nfeature_name (str) \u2013 The name of the feature that the document text extraction sample belongs to.\ndocument_page_id (str) \u2013 The document page ID.\ndocument_page_width (int) \u2013 Document page width.\ndocument_page_height (int) \u2013 Document page height.\ndocument_page_link (str) \u2013 Document page link to download the document page image.\ntext_lines (List[Dict[str, Union[int, str]]]) \u2013 A list of text lines and their coordinates.\ndocument_task (str) \u2013 The document blueprint task that the page belongs to.\nactual_target_value (Optional[Union[str, int, List[str]]) \u2013 Actual target value.\nprediction (Optional[PredictionType]) \u2013 Prediction values and labels.\nclassmethod list(model_id, feature_name, document_index=None, document_task=None)\uf0c1\nReturns a list of document text extraction sample pages.\nParameters:\nmodel_id (str) \u2013 The model identifier, used to retrieve document text extraction page samples.\nfeature_name (str) \u2013 The feature name, used to retrieve document text extraction page samples.\ndocument_index (Optional[int]) \u2013 The specific document index to retrieve. Defaults to None.\ndocument_task (Optional[str]) \u2013 Document blueprint task.\nReturn type:\nList[DocumentTextExtractionSamplePage]\nget_document_page_with_text_locations(line_color='blue', line_width=3, padding=3)\uf0c1\nReturns the document page with bounding boxes drawn around the text lines as a PIL.Image.\nParameters:\nline_color (str) \u2013 The color used to draw a bounding box on the image page. Defaults to blue.\nline_width (int) \u2013 The line width of the bounding boxes that will be drawn. Defaults to 3.\npadding (int) \u2013 The additional space left between the text and the bounding box, measured in pixels. Defaults to 3.\nReturns:\nReturns a PIL.Image with drawn text-bounding boxes.\nReturn type:\nImage",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.models.MulticategoricalHistogram",
        "datarobot.models.PairwiseCorrelations",
        "datarobot.models.PairwiseJointProbabilities",
        "datarobot.models.PairwiseConditionalProbabilities",
        "import datarobot as dr\ndataset_definition = dr.DatasetDefinition(\n    identifier='profile',\n    catalog_id='5ec4aec1f072bc028e3471ae',\n    catalog_version_id='5ec4aec2f072bc028e3471b1',\n)\n\ndataset_definition = dr.DatasetDefinition(\n    identifier='transaction',\n    catalog_id='5ec4aec1f072bc028e3471ae',\n    catalog_version_id='5ec4aec2f072bc028e3471b1',\n    primary_temporal_key='Date'\n)",
        "datarobot.enums.AllowedTimeUnitsSAFER",
        "datarobot.enums.AllowedTimeUnitsSAFER",
        "datarobot.enums.AllowedTimeUnitsSAFER",
        "import datarobot as dr\nrelationship = dr.Relationship(\n    dataset1_identifier='profile',\n    dataset2_identifier='transaction',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID']\n)\n\nrelationship = dr.Relationship(\n    dataset2_identifier='profile',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID'],\n    feature_derivation_window_start=-14,\n    feature_derivation_window_end=-1,\n    feature_derivation_window_time_unit='DAY',\n    prediction_point_rounding=1,\n    prediction_point_rounding_time_unit='DAY'\n)",
        "datarobot.enums.AllowedTimeUnitsSAFER",
        "datarobot.helpers.feature_discovery.DatasetDefinition",
        "datarobot.helpers.feature_discovery.Relationship",
        "datarobot.helpers.feature_discovery.FeatureDiscoverySetting",
        "dataset_definition = dr.DatasetDefinition(\n    identifier='profile',\n    catalog_id='5fd06b4af24c641b68e4d88f',\n    catalog_version_id='5fd06b4af24c641b68e4d88f'\n)\nrelationship = dr.Relationship(\n    dataset2_identifier='profile',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID'],\n    feature_derivation_window_start=-14,\n    feature_derivation_window_end=-1,\n    feature_derivation_window_time_unit='DAY',\n    prediction_point_rounding=1,\n    prediction_point_rounding_time_unit='DAY'\n)\ndataset_definitions = [dataset_definition]\nrelationships = [relationship]\nrelationship_config = dr.RelationshipsConfiguration.create(\n    dataset_definitions=dataset_definitions,\n    relationships=relationships,\n    feature_discovery_settings = [\n        {'name': 'enable_categorical_statistics', 'value': True},\n        {'name': 'enable_numeric_skewness', 'value': True},\n    ]\n)\n>>> relationship_config.id\n'5c88a37770fc42a2fcc62759'",
        "relationships_config = dr.RelationshipsConfiguration(valid_config_id)\nresult = relationships_config.get()\n>>> result.id\n'5c88a37770fc42a2fcc62759'",
        "datarobot.helpers.feature_discovery.DatasetDefinition",
        "datarobot.helpers.feature_discovery.Relationship",
        "datarobot.helpers.feature_discovery.FeatureDiscoverySetting",
        "# Deleting with a valid id\nrelationships_config = dr.RelationshipsConfiguration(valid_config_id)\nstatus_code = relationships_config.delete()\nstatus_code\n>>> 204\nrelationships_config.get()\n>>> ClientError: Relationships Configuration not found",
        "datarobot.enums.PROJECT_STAGE.EDA2",
        "from datarobot._experimental.models.documentai.document import DocumentThumbnail\n\n# Fetch five documents from the EDA SAMPLE for the specified project and specific feature\ndocument_thumbs = DocumentThumbnail.list(project_id, feature_name, limit=5)\n\n# Fetch five documents for the specified project with target value filtering\n# This option is only available after selecting the project target and starting modeling\ntarget1_thumbs = DocumentThumbnail.list(project_id, feature_name, target_value='target1', limit=5)",
        "from datarobot._experimental.models.documentai.document import DocumentThumbnail\nfrom datarobot.helpers.image_utils import get_image_from_bytes\n\n# Fetch 3 documents\ndocument_thumbs = DocumentThumbnail.list(project_id, feature_name, limit=3)\n\nfor doc_thumb in document_thumbs:\n    thumbnail = get_image_from_bytes(doc_thumb.document.thumbnail_bytes)\n    thumbnail.show()",
        "from datarobot._experimental.models.documentai.document import DocumentTextExtractionSample\n\nSPECIFIC_MODEL_ID1 = \"model_id1\"\nSPECIFIC_MODEL_ID2 = \"model_id2\"\nSPECIFIC_PROJECT_ID = \"project_id\"\n\n# Order computation of document text extraction sample for specific model.\n# By default `compute` method will await for computation to end before returning\nDocumentTextExtractionSample.compute(SPECIFIC_MODEL_ID1, await_completion=False)\nDocumentTextExtractionSample.compute(SPECIFIC_MODEL_ID2)\n\nsamples = DocumentTextExtractionSample.list_features_with_samples(SPECIFIC_PROJECT_ID)",
        "from datarobot._experimental.models.documentai.document import DocumentTextExtractionSample\nfrom datarobot.helpers.image_utils import get_image_from_bytes\n\nSPECIFIC_MODEL_ID = \"model_id\"\nSPECIFIC_FEATURE_NAME = \"feature_name\"\n\nsamples = DocumentTextExtractionSample.list_pages(\n    model_id=SPECIFIC_MODEL_ID,\n    feature_name=SPECIFIC_FEATURE_NAME\n)\nfor sample in samples:\n    thumbnail = sample.document_page.thumbnail\n    image = get_image_from_bytes(thumbnail.thumbnail_bytes)\n    image.show()",
        "from datarobot._experimental.models.documentai.document import DocumentTextExtractionSample\n\nSPECIFIC_MODEL_ID = \"model_id\"\nSPECIFIC_FEATURE_NAME = \"feature_name\"\n\nsamples = DocumentTextExtractionSample.list_pages(SPECIFIC_MODEL_ID, SPECIFIC_FEATURE_NAME)\n# Draw bounding boxes for first document page sample and display related text data.\nimage = samples[0].get_document_page_with_text_locations()\nimage.show()\n# For each text block represented as bounding box object drawn on original image\n# display its coordinates (top, left, bottom, right) and extracted text value\nfor text_line in samples[0].text_lines:\n    print(text_line)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
      "title": "Deployment Management\uf0c1",
      "description": "",
      "content": "Deployment Management\uf0c1\nDeployments\uf0c1\nclass datarobot.models.Deployment\uf0c1\nA deployment created from a DataRobot model.\nVariables:\nid (str) \u2013 the id of the deployment\nlabel (str) \u2013 the label of the deployment\ndescription (str) \u2013 the description of the deployment\nstatus (str) \u2013 (New in version v2.29) deployment status\ndefault_prediction_server (dict) \u2013 Information about the default prediction server for the deployment.\nAccepts the following values\nid str\nPrediction server ID.\nurl Optional[str]\nPrediction server URL.\ndatarobot-key str\nCorresponds the to the PredictionServer \u201csnake_cased\u201d\ndatarobot_key parameter that allows you to verify and access the prediction server.\nimportance (Optional[str]) \u2013 deployment importance\nmodel (dict) \u2013 information on the model of the deployment\nmodel_package (dict) \u2013 (New in version v3.4) information on the model package of the deployment\nprediction_usage (dict) \u2013 information on the prediction usage of the deployment\npermissions (list) \u2013 (New in version v2.18) user\u2019s permissions on the deployment\nservice_health (dict) \u2013 information on the service health of the deployment\nmodel_health (dict) \u2013 information on the model health of the deployment\naccuracy_health (dict) \u2013 information on the accuracy health of the deployment\nfairness_health (dict) \u2013 information on the fairness health of a deployment\ngovernance (dict) \u2013 information on approval and change requests of a deployment\nowners (dict) \u2013 information on the owners of a deployment\nprediction_environment (dict) \u2013 information on the prediction environment of a deployment\ncreator (dict) \u2013 information about the creator of a deployment\nclassmethod create_from_learning_model(cls, model_id, label, description=None, default_prediction_server_id=None, importance=None, prediction_threshold=None, status=None, max_wait=600)\uf0c1\nCreate a deployment from a DataRobot model.\nAdded in version v2.17.\nParameters:\nmodel_id (str) \u2013 id of the DataRobot model to deploy\nlabel (str) \u2013 a human-readable label of the deployment\ndescription (Optional[str]) \u2013 a human-readable description of the deployment\ndefault_prediction_server_id (Optional[str]) \u2013 an identifier of a prediction server to be used as the default prediction server\nimportance (Optional[str]) \u2013 deployment importance\nprediction_threshold (Optional[float]) \u2013 threshold used for binary classification in predictions\nstatus (Optional[str]) \u2013 deployment status\nmax_wait (Optional[int]) \u2013 Seconds to wait for successful resolution of a deployment creation job.\nDeployment supports making predictions only after a deployment creating job\nhas successfully finished.\nReturns:\ndeployment \u2013 The created deployment\nReturn type:\nDeployment\nExamples\nfrom datarobot import Project, Deployment\nproject = Project.get('5506fcd38bd88f5953219da0')\nmodel = project.get_models()[0]\ndeployment = Deployment.create_from_learning_model(model.id, 'New Deployment')\ndeployment\n>>> Deployment('New Deployment')\nclassmethod create_from_leaderboard(model_id, label, description=None, default_prediction_server_id=None, importance=None, prediction_threshold=None, status=None, max_wait=600)\uf0c1\nCreate a deployment from a Leaderboard.\nAdded in version v2.17.\nParameters:\nmodel_id (str) \u2013 id of the Leaderboard to deploy\nlabel (str) \u2013 a human-readable label of the deployment\ndescription (Optional[str]) \u2013 a human-readable description of the deployment\ndefault_prediction_server_id (Optional[str]) \u2013 an identifier of a prediction server to be used as the default prediction server\nimportance (Optional[str]) \u2013 deployment importance\nprediction_threshold (Optional[float]) \u2013 threshold used for binary classification in predictions\nstatus (Optional[str]) \u2013 deployment status\nmax_wait (Optional[int]) \u2013 The amount of seconds to wait for successful resolution of a deployment creation job.\nDeployment supports making predictions only after a deployment creating job\nhas successfully finished.\nReturns:\ndeployment \u2013 The created deployment\nReturn type:\nDeployment\nExamples\nfrom datarobot import Project, Deployment\nproject = Project.get('5506fcd38bd88f5953219da0')\nmodel = project.get_models()[0]\ndeployment = Deployment.create_from_leaderboard(model.id, 'New Deployment')\ndeployment\n>>> Deployment('New Deployment')\nclassmethod create_from_custom_model_version(custom_model_version_id, label, description=None, default_prediction_server_id=None, max_wait=600, importance=None)\uf0c1\nCreate a deployment from a DataRobot custom model image.\nParameters:\ncustom_model_version_id (str) \u2013 The ID of the DataRobot custom model version to deploy.\nThe version must have a base_environment_id.\nlabel (str) \u2013 A label of the deployment.\ndescription (Optional[str]) \u2013 A description of the deployment.\ndefault_prediction_server_id (str) \u2013 An identifier of a prediction server to be used as the default\nprediction server. Required for SaaS users and optional for\nSelf-Managed users.\nmax_wait (Optional[int]) \u2013 Seconds to wait for successful resolution of a deployment creation job.\nDeployment supports making predictions only after a deployment creating job\nhas successfully finished.\nimportance (Optional[str]) \u2013 Deployment importance level.\nReturns:\ndeployment \u2013 The created deployment\nReturn type:\nDeployment\nclassmethod create_from_registered_model_version(model_package_id, label, description=None, default_prediction_server_id=None, prediction_environment_id=None, importance=None, user_provided_id=None, additional_metadata=None, max_wait=600)\uf0c1\nCreate a deployment from a DataRobot model package (version).\nParameters:\nmodel_package_id (str) \u2013 The ID of the DataRobot model package (also known as a registered model version) to deploy.\nlabel (str) \u2013 A human readable label of the deployment.\ndescription (Optional[str]) \u2013 A human readable description of the deployment.\ndefault_prediction_server_id (Optional[str]) \u2013 an identifier of a prediction server to be used as the default prediction server\nWhen working with prediction environments, default prediction server Id should not be provided\nprediction_environment_id (Optional[str]) \u2013 An identifier of a prediction environment to be used for model deployment.\nimportance (Optional[str]) \u2013 Deployment importance level.\nuser_provided_id (Optional[str]) \u2013 A user-provided unique ID associated with a deployment definition in a remote git repository.\nadditional_metadata (dict, optional) \u2013 \u2018Key/Value pair dict, with additional metadata\u2019\nmax_wait (Optional[int]) \u2013 The amount of seconds to wait for successful resolution of a deployment creation job.\nDeployment supports making predictions only after a deployment creating job\nhas successfully finished.\nReturns:\ndeployment \u2013 The created deployment\nReturn type:\nDeployment\nclassmethod list(order_by=None, search=None, filters=None, offset=0, limit=0)\uf0c1\nList all deployments a user can view.\nAdded in version v2.17.\nParameters:\norder_by (Optional[str]) \u2013 (New in version v2.18) the order to sort the deployment list by, defaults to label\nAllowed attributes to sort by are:\nlabel\nserviceHealth\nmodelHealth\naccuracyHealth\nrecentPredictions\nlastPredictionTimestamp\nIf the sort attribute is preceded by a hyphen, deployments will be sorted in descending\norder, otherwise in ascending order.\nFor health related sorting, ascending means failing, warning, passing, unknown.\nsearch (Optional[str]) \u2013 (New in version v2.18) case insensitive search against deployment\u2019s\nlabel and description.\nfilters (Optional[datarobot.models.deployment.DeploymentListFilters]) \u2013 (New in version v2.20) an object containing all filters that you\u2019d like to apply to the\nresulting list of deployments. See\nDeploymentListFilters for details on usage.\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 0 to maintain previous behavior.\nThe default on the server is 20, with a maximum of 100.\nReturns:\ndeployments \u2013 a list of deployments the user can view\nReturn type:\nlist\nExamples\nfrom datarobot import Deployment\ndeployments = Deployment.list()\ndeployments\n>>> [Deployment('New Deployment'), Deployment('Previous Deployment')]\nfrom datarobot import Deployment\nfrom datarobot.enums import DEPLOYMENT_SERVICE_HEALTH_STATUS\nfilters = DeploymentListFilters(\nrole='OWNER',\nservice_health=[DEPLOYMENT_SERVICE_HEALTH.FAILING]\n)\nfiltered_deployments = Deployment.list(filters=filters)\nfiltered_deployments\n>>> [Deployment('Deployment I Own w/ Failing Service Health')]\nclassmethod get(deployment_id)\uf0c1\nGet information about a deployment.\nAdded in version v2.17.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nReturns:\ndeployment \u2013 the queried deployment\nReturn type:\nDeployment\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.id\n>>>'5c939e08962d741e34f609f0'\ndeployment.label\n>>>'New Deployment'\npredict_batch(source, passthrough_columns=None, download_timeout=None, download_read_timeout=None, upload_read_timeout=None)\uf0c1\nA convenience method for making predictions with csv file or pandas DataFrame\nusing a batch prediction job.\nFor advanced usage, use datarobot.models.BatchPredictionJob directly.\nAdded in version v3.0.\nParameters:\nsource (str, pd.DataFrame or file object) \u2013 Pass a filepath, file, or DataFrame for making batch predictions.\npassthrough_columns (Optional[List[str]]) \u2013 Keep these columns from the scoring dataset in the scored dataset.\nThis is useful for correlating predictions with source data.\ndownload_timeout (Optional[int]) \u2013 Wait this many seconds for the download to become available.\nSee datarobot.models.BatchPredictionJob.score().\ndownload_read_timeout (Optional[int]) \u2013 Wait this many seconds for the server to respond between chunks.\nSee datarobot.models.BatchPredictionJob.score().\nupload_read_timeout (Optional[int]) \u2013 Wait this many seconds for the server to respond after a whole dataset upload.\nSee datarobot.models.BatchPredictionJob.score().\nReturns:\nPrediction results in a pandas DataFrame.\nReturn type:\npd.DataFrame\nRaises:\nInvalidUsageError \u2013 If the source parameter cannot be determined to be a filepath, file, or DataFrame.\nExamples\nfrom datarobot.models.deployment import Deployment\ndeployment = Deployment.get(\"<MY_DEPLOYMENT_ID>\")\nprediction_results_as_dataframe = deployment.predict_batch(\nsource=\"./my_local_file.csv\",\n)\nget_uri()\uf0c1\nReturns:\nurl \u2013 Deployment\u2019s overview URI\nReturn type:\nstr\nupdate(label=None, description=None, importance=None)\uf0c1\nUpdate the label and description of this deployment.\n:rtype: None\nAdded in version v2.19.\ndelete()\uf0c1\nDelete this deployment.\n:rtype: None\nAdded in version v2.17.\nactivate(max_wait=600)\uf0c1\nActivates this deployment. When succeeded, deployment status become active.\nAdded in version v2.29.\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for deployment activation to complete before erroring\nReturn type:\nNone\ndeactivate(max_wait=600)\uf0c1\nDeactivates this deployment. When succeeded, deployment status become inactive.\nAdded in version v2.29.\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for deployment deactivation to complete before erroring\nReturn type:\nNone\nreplace_model(new_model_id, reason, max_wait=600, new_registered_model_version_id=None)\uf0c1\nReplace the model used in this deployment. To confirm model replacement eligibility, usevalidate_replacement_model() beforehand.\nAdded in version v2.17.\nModel replacement is an asynchronous process, which means some preparatory work may\nbe performed after the initial request is completed. This function will not return until all\npreparatory work is fully finished.\nPredictions made against this deployment will start using the new model as soon as the\nrequest is completed. There will be no interruption for predictions throughout\nthe process.\nParameters:\nnew_model_id (Optional[str]) \u2013 The id of the new model to use. If replacing the deployment\u2019s model with a\nCustomInferenceModel, a specific CustomModelVersion ID must be used.\nIf None, new_registered_model_version_id must be specified.\nreason (MODEL_REPLACEMENT_REASON) \u2013 The reason for the model replacement. Must be one of \u2018ACCURACY\u2019, \u2018DATA_DRIFT\u2019, \u2018ERRORS\u2019,\n\u2018SCHEDULED_REFRESH\u2019, \u2018SCORING_SPEED\u2019, or \u2018OTHER\u2019. This value will be stored in the model\nhistory to keep track of why a model was replaced\nmax_wait (Optional[int]) \u2013 (new in version 2.22) The maximum time to wait for\nmodel replacement job to complete before erroring\nnew_registered_model_version_id (Optional[str]) \u2013 (new in version 3.4) The registered model version (model package) ID of the new model to use. Must be\npassed if new_model_id is None.\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment\nfrom datarobot.enums import MODEL_REPLACEMENT_REASON\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.model['id'], deployment.model['type']\n>>>('5c0a979859b00004ba52e431', 'Decision Tree Classifier (Gini)')\ndeployment.replace_model('5c0a969859b00004ba52e41b', MODEL_REPLACEMENT_REASON.ACCURACY)\ndeployment.model['id'], deployment.model['type']\n>>>('5c0a969859b00004ba52e41b', 'Support Vector Classifier (Linear Kernel)')\nperform_model_replace(new_registered_model_version_id, reason, max_wait=600)\uf0c1\nReplace the model used in this deployment. To confirm model replacement eligibility, usevalidate_replacement_model() beforehand.\nAdded in version v3.4.\nModel replacement is an asynchronous process, which means some preparatory work may\nbe performed after the initial request is completed. This function will not return until all\npreparatory work is fully finished.\nPredictions made against this deployment will start using the new model as soon as the\nrequest is completed. There will be no interruption for predictions throughout\nthe process.\nParameters:\nnew_registered_model_version_id (str) \u2013 The registered model version (model package) ID of the new model to use.\nreason (MODEL_REPLACEMENT_REASON) \u2013 The reason for the model replacement. Must be one of \u2018ACCURACY\u2019, \u2018DATA_DRIFT\u2019, \u2018ERRORS\u2019,\n\u2018SCHEDULED_REFRESH\u2019, \u2018SCORING_SPEED\u2019, or \u2018OTHER\u2019. This value will be stored in the model\nhistory to keep track of why a model was replaced\nmax_wait (Optional[int]) \u2013 The maximum time to wait for\nmodel replacement job to complete before erroring\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment\nfrom datarobot.enums import MODEL_REPLACEMENT_REASON\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.model_package['id']\n>>>'5c0a979859b00004ba52e431'\ndeployment.perform_model_replace('5c0a969859b00004ba52e41b', MODEL_REPLACEMENT_REASON.ACCURACY)\ndeployment.model_package['id']\n>>>'5c0a969859b00004ba52e41b'\nvalidate_replacement_model(new_model_id=None, new_registered_model_version_id=None)\uf0c1\nValidate a model can be used as the replacement model of the deployment.\nAdded in version v2.17.\nParameters:\nnew_model_id (Optional[str]) \u2013 the id of the new model to validate\nnew_registered_model_version_id (Optional[str]) \u2013 (new in version 3.4) The registered model version (model package) ID of the new model to use.\nReturn type:\nTuple[str, str, Dict[str, Any]]\nReturns:\nstatus (str) \u2013 status of the validation, will be one of \u2018passing\u2019, \u2018warning\u2019 or \u2018failing\u2019.\nIf the status is passing or warning, use replace_model() to\nperform a model replacement. If the status is failing, refer to checks for more\ndetail on why the new model cannot be used as a replacement.\nmessage (str) \u2013 message for the validation result\nchecks (dict) \u2013 explain why the new model can or cannot replace the deployment\u2019s current model\nget_features()\uf0c1\nRetrieve the list of features needed to make predictions on this deployment.\nNotes\nEach feature dict contains the following structure:\nname : str, feature name\nfeature_type : str, feature type\nimportance : float, numeric measure of the relationship strength between\nthe feature and target (independent of model or other features)\ndate_format : str or None, the date format string for how this feature was\ninterpreted, null if not a date feature, compatible with\nhttps://docs.python.org/2/library/time.html#time.strftime.\nknown_in_advance : bool, whether the feature was selected as known in advance in\na time series model, false for non-time series models.\nReturns:\nfeatures \u2013 a list of feature dict\nReturn type:\nlist\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nfeatures = deployment.get_features()\nfeatures[0]['feature_type']\n>>>'Categorical'\nfeatures[0]['importance']\n>>>0.133\nsubmit_actuals(data, batch_size=10000)\uf0c1\nSubmit actuals for processing.\nThe actuals submitted will be used to calculate accuracy metrics.\nParameters:\ndata (list or pandas.DataFrame)\nbatch_size (the max number of actuals in each request)\nlist (If data is a)\nand (each item should be a dict-like object with the following keys)\npandas.DataFrame (values; if data is a)\ncolumns (it should contain the following)\nassociation_id (-) \u2013 max length 128 characters\nactual_value (-) \u2013 should be numeric for deployments with regression models or\nstring for deployments with classification model\nwas_acted_on (-) \u2013 could have affected the actual outcome\ntimestamp (-) \u2013 does not have a timezone, we assume it is UTC.\nRaises:\nValueError \u2013 if input data is not a list of dict-like objects or a pandas.DataFrame\nif input data is empty\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment, AccuracyOverTime\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndata = [{\n'association_id': '439917',\n'actual_value': 'True',\n'was_acted_on': True\n}]\ndeployment.submit_actuals(data)\nsubmit_actuals_from_catalog_async(dataset_id, actual_value_column, association_id_column, dataset_version_id=None, timestamp_column=None, was_acted_on_column=None)\uf0c1\nSubmit actuals from AI Catalog for processing.\nThe actuals submitted will be used to calculate accuracy metrics.\nParameters:\ndataset_id (str,) \u2013 The ID of the source dataset.\ndataset_version_id (Optional[str]) \u2013 The ID of the dataset version to apply the query to. If not specified, the\nlatest version associated with dataset_id is used.\nassociation_id_column (str,) \u2013 The name of the column that contains a unique identifier used with a prediction.\nactual_value_column (str,) \u2013 The name of the column that contains the actual value of a prediction.\nwas_acted_on_column (Optional[str],) \u2013 The name of the column that indicates if the prediction was acted on in a way that\ncould have affected the actual outcome.\ntimestamp_column (Optional[str],) \u2013 The name of the column that contains datetime or string in RFC3339 format.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nRaises:\nValueError \u2013 if dataset_id not provided\nif actual_value_column not provided\nif association_id_column not provided\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nstatus_check_job = deployment.submit_actuals_from_catalog_async(data)\nget_predictions_by_forecast_date_settings()\uf0c1\nRetrieve predictions by forecast date settings of this deployment.\nAdded in version v2.27.\nReturns:\nsettings \u2013 Predictions by forecast date settings of the deployment.\nReturn type:\nForecastDateSettings\nupdate_predictions_by_forecast_date_settings(enable_predictions_by_forecast_date, forecast_date_column_name=None, forecast_date_format=None, max_wait=600)\uf0c1\nUpdate predictions by forecast date settings of this deployment.\nAdded in version v2.27.\nUpdating predictions by forecast date setting is an asynchronous process,\nwhich means some preparatory work may be performed after the initial request is completed.\nThis function will not return until all preparatory work is fully finished.\nExamples\n# To set predictions by forecast date settings to the same default settings you see when using\n# the DataRobot web application, you use your 'Deployment' object like this:\ndeployment.update_predictions_by_forecast_date_settings(\nenable_predictions_by_forecast_date=True,\nforecast_date_column_name=\"date (actual)\",\nforecast_date_format=\"%Y-%m-%d\",\n)\nParameters:\nenable_predictions_by_forecast_date (bool) \u2013 set to True if predictions by forecast date is to be turned on or set to \u2018\u2019False\u2019\u2019\nif predictions by forecast date is to be turned off.\nforecast_date_column_name (string, optional) \u2013 The column name in prediction datasets to be used as forecast date.\nIf \u2018\u2019enable_predictions_by_forecast_date\u2019\u2019 is set to \u2018\u2019False\u2019\u2019,\nthen the parameter will be ignored.\nforecast_date_format (string, optional) \u2013 The datetime format of the forecast date column in prediction datasets.\nIf \u2018\u2019enable_predictions_by_forecast_date\u2019\u2019 is set to \u2018\u2019False\u2019\u2019,\nthen the parameter will be ignored.\nmax_wait (Optional[int]) \u2013 seconds to wait for successful\nReturn type:\nNone\nget_challenger_models_settings()\uf0c1\nRetrieve challenger models settings of this deployment.\nAdded in version v2.27.\nReturns:\nsettings\nReturn type:\nChallengerModelsSettings\nupdate_challenger_models_settings(challenger_models_enabled, max_wait=600)\uf0c1\nUpdate challenger models settings of this deployment.\nAdded in version v2.27.\nUpdating challenger models setting is an asynchronous process, which means some preparatory\nwork may be performed after the initial request is completed. This function will not return\nuntil all preparatory work is fully finished.\nParameters:\nchallenger_models_enabled (bool) \u2013 set to True if challenger models is to be turned on or set to \u2018\u2019False\u2019\u2019 if\nchallenger models is to be turned off\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_segment_analysis_settings()\uf0c1\nRetrieve segment analysis settings of this deployment.\nAdded in version v2.27.\nReturns:\nsettings\nReturn type:\nSegmentAnalysisSettings\nupdate_segment_analysis_settings(segment_analysis_enabled, segment_analysis_attributes=None, max_wait=600)\uf0c1\nUpdate segment analysis settings of this deployment.\nAdded in version v2.27.\nUpdating segment analysis setting is an asynchronous process, which means some preparatory\nwork may be performed after the initial request is completed. This function will not return\nuntil all preparatory work is fully finished.\nParameters:\nsegment_analysis_enabled (bool) \u2013 set to True if segment analysis is to be turned on or set to \u2018\u2019False\u2019\u2019 if\nsegment analysis is to be turned off\nsegment_analysis_attributes (Optional[List]) \u2013 A list of strings that gives the segment attributes selected for tracking.\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_bias_and_fairness_settings()\uf0c1\nRetrieve bias and fairness settings of this deployment.\n..versionadded:: v3.2.0\nReturns:\nsettings\nReturn type:\nBiasAndFairnessSettings\nupdate_bias_and_fairness_settings(protected_features, fairness_metric_set, fairness_threshold, preferable_target_value, max_wait=600)\uf0c1\nUpdate bias and fairness settings of this deployment.\n..versionadded:: v3.2.0\nUpdating bias and fairness setting is an asynchronous process, which means some preparatory\nwork may be performed after the initial request is completed. This function will not return\nuntil all preparatory work is fully finished.\nParameters:\nprotected_features (List[str]) \u2013 A list of features to mark as protected.\npreferable_target_value (bool) \u2013 A target value that should be treated as a positive outcome for the prediction.\nfairness_metric_set (str) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\nfairness_threshold (float) \u2013 Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_challenger_replay_settings()\uf0c1\nRetrieve challenger replay settings of this deployment.\nAdded in version v3.4.\nReturns:\nsettings\nReturn type:\nChallengerReplaySettings\nupdate_challenger_replay_settings(enabled, schedule=None)\uf0c1\nUpdate challenger replay settings of this deployment.\nAdded in version v3.4.\nParameters:\nenabled (bool) \u2013 If challenger replay is enabled.\nschedule (Optional[Schedule]) \u2013 The recurring schedule for the challenger replay job.\nReturn type:\nNone\nget_drift_tracking_settings()\uf0c1\nRetrieve drift tracking settings of this deployment.\nAdded in version v2.17.\nReturns:\nsettings\nReturn type:\nDriftTrackingSettings\nupdate_drift_tracking_settings(target_drift_enabled=None, feature_drift_enabled=None, max_wait=600)\uf0c1\nUpdate drift tracking settings of this deployment.\nAdded in version v2.17.\nUpdating drift tracking setting is an asynchronous process, which means some preparatory\nwork may be performed after the initial request is completed. This function will not return\nuntil all preparatory work is fully finished.\nParameters:\ntarget_drift_enabled (Optional[bool]) \u2013 if target drift tracking is to be turned on\nfeature_drift_enabled (Optional[bool]) \u2013 if feature drift tracking is to be turned on\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_association_id_settings()\uf0c1\nRetrieve association ID setting for this deployment.\nAdded in version v2.19.\nReturns:\nassociation_id_settings\nReturn type:\nstr\nupdate_association_id_settings(column_names=None, required_in_prediction_requests=None, max_wait=600)\uf0c1\nUpdate association ID setting for this deployment.\nAdded in version v2.19.\nParameters:\ncolumn_names (list[string], optional) \u2013 name of the columns to be used as association ID,\ncurrently only support a list of one string\nrequired_in_prediction_requests (Optional[bool]) \u2013 whether the association ID column is required in prediction requests\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_predictions_data_collection_settings()\uf0c1\nRetrieve predictions data collection settings of this deployment.\nAdded in version v2.21.\nReturns:\npredictions_data_collection_settings \u2013\nenabled (bool)If predictions data collection is enabled for this deployment. To update\nexisting \u2018\u2019predictions_data_collection\u2019\u2019 settings, see\nupdate_predictions_data_collection_settings()\nReturn type:\ndict in the following format:\nSee also\ndatarobot.models.Deployment.update_predictions_data_collection_settingsMethod to update existing predictions data collection settings.\nupdate_predictions_data_collection_settings(enabled, max_wait=600)\uf0c1\nUpdate predictions data collection settings of this deployment.\nAdded in version v2.21.\nUpdating predictions data collection setting is an asynchronous process, which means some\npreparatory work may be performed after the initial request is completed.\nThis function will not return until all preparatory work is fully finished.\nParameters:\nenabled (bool) \u2013 if predictions data collection is to be turned on\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_prediction_warning_settings()\uf0c1\nRetrieve prediction warning settings of this deployment.\nAdded in version v2.19.\nReturns:\nsettings\nReturn type:\nPredictionWarningSettings\nupdate_prediction_warning_settings(prediction_warning_enabled, use_default_boundaries=None, lower_boundary=None, upper_boundary=None, max_wait=600)\uf0c1\nUpdate prediction warning settings of this deployment.\nAdded in version v2.19.\nParameters:\nprediction_warning_enabled (bool) \u2013 If prediction warnings should be turned on.\nuse_default_boundaries (Optional[bool]) \u2013 If default boundaries of the model should be used for the deployment.\nupper_boundary (Optional[float]) \u2013 All predictions greater than provided value will be considered anomalous\nlower_boundary (Optional[float]) \u2013 All predictions less than provided value will be considered anomalous\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nget_prediction_intervals_settings()\uf0c1\nRetrieve prediction intervals settings for this deployment.\nAdded in version v2.19.\nNotes\nNote that prediction intervals are only supported for time series deployments.\nReturns:\nsettings\nReturn type:\nPredictionIntervalsSettings\nupdate_prediction_intervals_settings(percentiles, enabled=True, max_wait=600)\uf0c1\nUpdate prediction intervals settings for this deployment.\nAdded in version v2.19.\nNotes\nUpdating prediction intervals settings is an asynchronous process, which means some\npreparatory work may be performed before the settings request is completed. This function\nwill not return until all work is fully finished.\nNote that prediction intervals are only supported for time series deployments.\nParameters:\npercentiles (list[int]) \u2013 The prediction intervals percentiles to enable for this deployment. Currently we only\nsupport setting one percentile at a time.\nenabled (Optional[bool] (defaults to True)) \u2013 Whether to enable showing prediction intervals in the results of predictions requested\nusing this deployment.\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nRaises:\nAssertionError \u2013 If percentiles is in an invalid format\nAsyncFailureError \u2013 If any of the responses from the server are unexpected\nAsyncProcessUnsuccessfulError \u2013 If the prediction intervals calculation job has failed or has been cancelled.\nAsyncTimeoutError \u2013 If the prediction intervals calculation job did not resolve in time\nReturn type:\nNone\nget_health_settings()\uf0c1\nRetrieve health settings of this deployment.\nAdded in version v3.4.\nReturns:\nsettings\nReturn type:\nHealthSettings\nupdate_health_settings(service=None, data_drift=None, accuracy=None, fairness=None, custom_metrics=None, predictions_timeliness=None, actuals_timeliness=None)\uf0c1\nUpdate health settings of this deployment.\nAdded in version v3.4.\nParameters:\nservice (dict) \u2013 Service health settings.\ndata_drift (dict) \u2013 Data drift health settings.\naccuracy (dict) \u2013 Accuracy health settings.\nfairness (dict) \u2013 Fairness health settings.\ncustom_metrics (dict) \u2013 Custom metrics health settings.\npredictions_timeliness (dict) \u2013 Predictions timeliness health settings.\nactuals_timeliness (dict) \u2013 Actuals timeliness health settings.\nReturn type:\nHealthSettings\nget_default_health_settings()\uf0c1\nRetrieve default health settings of this deployment.\nAdded in version v3.4.\nReturns:\nsettings\nReturn type:\nHealthSettings\nget_service_stats(model_id=None, start_time=None, end_time=None, execution_time_quantile=None, response_time_quantile=None, slow_requests_threshold=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieves values of many service stat metrics aggregated over a time period.\nAdded in version v2.18.\nParameters:\nmodel_id (Optional[str]) \u2013 the id of the model\nstart_time (datetime, optional) \u2013 start of the time period\nend_time (datetime, optional) \u2013 end of the time period\nexecution_time_quantile (Optional[float]) \u2013 quantile for executionTime, defaults to 0.5\nresponse_time_quantile (Optional[float]) \u2013 quantile for responseTime, defaults to 0.5\nslow_requests_threshold (Optional[float]) \u2013 threshold for slowRequests, defaults to 1000\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\nservice_stats \u2013 the queried service stats metrics information\nReturn type:\nServiceStats\nget_service_stats_over_time(metric=None, model_id=None, start_time=None, end_time=None, bucket_size=None, quantile=None, threshold=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieves values of a single service stat metric over a time period.\nAdded in version v2.18.\nParameters:\nmetric (SERVICE_STAT_METRIC, optional) \u2013 the service stat metric to retrieve\nmodel_id (Optional[str]) \u2013 the id of the model\nstart_time (datetime, optional) \u2013 start of the time period\nend_time (datetime, optional) \u2013 end of the time period\nbucket_size (Optional[str]) \u2013 time duration of a bucket, in ISO 8601 time duration format\nquantile (Optional[float]) \u2013 quantile for \u2018executionTime\u2019 or \u2018responseTime\u2019, ignored when querying other metrics\nthreshold (Optional[int]) \u2013 threshold for \u2018slowQueries\u2019, ignored when querying other metrics\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\nservice_stats_over_time \u2013 the queried service stats metric over time information\nReturn type:\nServiceStatsOverTime\nget_target_drift(model_id=None, start_time=None, end_time=None, metric=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve target drift information over a certain time period.\nAdded in version v2.21.\nParameters:\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nmetric (str) \u2013 (New in version v2.22) metric used to calculate the drift score\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\ntarget_drift \u2013 the queried target drift information\nReturn type:\nTargetDrift\nget_feature_drift(model_id=None, start_time=None, end_time=None, metric=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve drift information for deployment\u2019s features over a certain time period.\nAdded in version v2.21.\nParameters:\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nmetric (str) \u2013 (New in version v2.22) The metric used to calculate the drift score. Allowed\nvalues include psi, kl_divergence, dissimilarity, hellinger, and\njs_divergence.\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\nfeature_drift_data \u2013 the queried feature drift information\nReturn type:\n[FeatureDrift]\nget_predictions_over_time(model_ids=None, start_time=None, end_time=None, bucket_size=None, target_classes=None, include_percentiles=False, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve stats of deployment\u2019s prediction response over a certain time period.\nAdded in version v3.2.\nParameters:\nmodel_ids (list[str]) \u2013 ID of models to retrieve prediction stats\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (BUCKET_SIZE) \u2013 time duration of each bucket\ntarget_classes (list[str]) \u2013 class names of target, only for deployments with multiclass target\ninclude_percentiles (bool) \u2013 if the returned data includes percentiles,\nonly for a deployment with a binary and regression target\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\npredictions_over_time \u2013 the queried predictions over time information\nReturn type:\nPredictionsOverTime\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_over_time()\npredictions_over_time.buckets[0]['mean_predicted_value']\n>>>0.3772\npredictions_over_time.buckets[0]['row_count']\n>>>2000\nget_accuracy(model_id=None, start_time=None, end_time=None, start=None, end=None, target_classes=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieves values of many accuracy metrics aggregated over a time period.\nAdded in version v2.18.\nParameters:\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\ntarget_classes (list[str], optional) \u2013 Optional list of target class strings\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\naccuracy \u2013 the queried accuracy metrics information\nReturn type:\nAccuracy\nget_accuracy_over_time(metric=None, model_id=None, start_time=None, end_time=None, bucket_size=None, target_classes=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieves values of a single accuracy metric over a time period.\nAdded in version v2.18.\nParameters:\nmetric (ACCURACY_METRIC) \u2013 the accuracy metric to retrieve\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (str) \u2013 time duration of a bucket, in ISO 8601 time duration format\ntarget_classes (list[str], optional) \u2013 Optional list of target class strings\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\naccuracy_over_time \u2013 the queried accuracy metric over time information\nReturn type:\nAccuracyOverTime\nget_predictions_vs_actuals_over_time(model_ids=None, start_time=None, end_time=None, bucket_size=None, target_classes=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve information for deployment\u2019s predictions vs actuals over a certain time period.\nAdded in version v3.3.\nParameters:\nmodel_ids (list[str]) \u2013 The ID of models to retrieve predictions vs actuals stats for.\nstart_time (datetime) \u2013 Start of the time period.\nend_time (datetime) \u2013 End of the time period.\nbucket_size (BUCKET_SIZE) \u2013 Time duration of each bucket.\ntarget_classes (list[str]) \u2013 Class names of target, only for deployments with a multiclass target.\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\npredictions_vs_actuals_over_time \u2013 The queried predictions vs actuals over time information.\nReturn type:\nPredictionsVsActualsOverTime\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_vs_actuals_over_time()\npredictions_over_time.buckets[0]['mean_actual_value']\n>>>0.6673\npredictions_over_time.buckets[0]['row_count_with_actual']\n>>>500\nget_fairness_scores_over_time(start_time=None, end_time=None, bucket_size=None, model_id=None, protected_feature=None, fairness_metric=None)\uf0c1\nRetrieves values of a single fairness score over a time period.\nAdded in version v3.2.\nParameters:\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (str) \u2013 time duration of a bucket, in ISO 8601 time duration format\nprotected_feature (str) \u2013 name of protected feature\nfairness_metric (str) \u2013 A consolidation of the fairness metrics by the use case.\nReturns:\nfairness_scores_over_time \u2013 the queried fairness score over time information\nReturn type:\nFairnessScoresOverTime\nupdate_secondary_dataset_config(secondary_dataset_config_id, credential_ids=None)\uf0c1\nUpdate the secondary dataset config used by Feature discovery model for a\ngiven deployment.\nAdded in version v2.23.\nParameters:\nsecondary_dataset_config_id (str) \u2013 Id of the secondary dataset config\ncredential_ids (list or None) \u2013 List of DatasetsCredentials used by the secondary datasets\nReturn type:\nstr\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment(deployment_id='5c939e08962d741e34f609f0')\nconfig = deployment.update_secondary_dataset_config('5df109112ca582033ff44084')\nconfig\n>>> '5df109112ca582033ff44084'\nget_secondary_dataset_config()\uf0c1\nGet the secondary dataset config used by Feature discovery model for a\ngiven deployment.\nAdded in version v2.23.\nReturns:\nsecondary_dataset_config \u2013 Id of the secondary dataset config\nReturn type:\nSecondaryDatasetConfigurations\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_secondary_dataset_config('5df109112ca582033ff44084')\nconfig = deployment.get_secondary_dataset_config()\nconfig\n>>> '5df109112ca582033ff44084'\nget_prediction_results(model_id=None, start_time=None, end_time=None, actuals_present=None, offset=None, limit=None)\uf0c1\nRetrieve a list of prediction results of the deployment.\nAdded in version v2.24.\nParameters:\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nactuals_present (bool) \u2013 filters predictions results to only those\nwho have actuals present or with missing actuals\noffset (int) \u2013 this many results will be skipped\nlimit (int) \u2013 at most this many results are returned\nReturns:\nprediction_results \u2013 a list of prediction results\nReturn type:\nlist[dict]\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nresults = deployment.get_prediction_results()\ndownload_prediction_results(filepath, model_id=None, start_time=None, end_time=None, actuals_present=None, offset=None, limit=None)\uf0c1\nDownload prediction results of the deployment as a CSV file.\nAdded in version v2.24.\nParameters:\nfilepath (str) \u2013 path of the csv file\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nactuals_present (bool) \u2013 filters predictions results to only those\nwho have actuals present or with missing actuals\noffset (int) \u2013 this many results will be skipped\nlimit (int) \u2013 at most this many results are returned\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nresults = deployment.download_prediction_results('path_to_prediction_results.csv')\ndownload_scoring_code(filepath, source_code=False, include_agent=False, include_prediction_explanations=False, include_prediction_intervals=False, max_wait=600)\uf0c1\nRetrieve scoring code of the current deployed model.\nAdded in version v2.24.\nNotes\nWhen setting include_agent or include_predictions_explanations or\ninclude_prediction_intervals to True,\nit can take a considerably longer time to download the scoring code.\nParameters:\nfilepath (str) \u2013 path of the scoring code file\nsource_code (bool) \u2013 whether source code or binary of the scoring code will be retrieved\ninclude_agent (bool) \u2013 whether the scoring code retrieved will include tracking agent\ninclude_prediction_explanations (bool) \u2013 whether the scoring code retrieved will include prediction explanations\ninclude_prediction_intervals (bool) \u2013 whether the scoring code retrieved will support prediction intervals\nmax_wait (Optional[int]) \u2013 Seconds to wait for successful resolution of a deployment creation job.\nDeployment supports making predictions only after a deployment creating job\nhas successfully finished\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nresults = deployment.download_scoring_code('path_to_scoring_code.jar')\ndownload_model_package_file(filepath, compute_all_ts_intervals=False)\uf0c1\nRetrieve model package file (mlpkg) of the current deployed model.\nAdded in version v3.3.\nParameters:\nfilepath (str) \u2013 The file path of the model package file.\ncompute_all_ts_intervals (bool) \u2013 Includes all time series intervals into the built Model Package (.mlpkg) if set to True.\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.download_model_package_file('path_to_model_package.mlpkg')\ndelete_monitoring_data(model_id, start_time=None, end_time=None, max_wait=600)\uf0c1\nDelete deployment monitoring data.\nParameters:\nmodel_id (str) \u2013 id of the model to delete monitoring data\nstart_time (datetime, optional) \u2013 start of the time period to delete monitoring data\nend_time (datetime, optional) \u2013 end of the time period to delete monitoring data\nmax_wait (Optional[int]) \u2013 seconds to wait for successful resolution\nReturn type:\nNone\nlist_shared_roles(id=None, name=None, share_recipient_type=None, limit=100, offset=0)\uf0c1\nGet a list of users, groups and organizations that have an access to this user blueprint\nParameters:\nid (Optional[str]) \u2013 Only return the access control information for a organization, group or user with this\nID.\nname (string, Optional) \u2013 Only return the access control information for a organization, group or user with this\nname.\nshare_recipient_type (enum(``\u2019user\u2019, ``'group', 'organization'), Optional) \u2013 Only returns results with the given recipient type.\nlimit (int (Default=0)) \u2013 At most this many results are returned.\noffset (int (Default=0)) \u2013 This many results will be skipped.\nReturn type:\nList[DeploymentSharedRole]\nupdate_shared_roles(roles)\uf0c1\nShare a deployment with a user, group, or organization\nParameters:\nroles (list(or(GrantAccessControlWithUsernameValidator, GrantAccessControlWithIdValidator, SharingRole))) \u2013 Array of GrantAccessControl objects, up to maximum 100 objects.\nReturn type:\nNone\nshare(roles)\uf0c1\nShare a deployment with a user, group, or organization\nParameters:\nroles (list(SharingRole)) \u2013 Array of SharingRole objects.\nReturn type:\nNone\nlist_challengers()\uf0c1\nGet a list of challengers for this deployment.\nAdded in version v3.4.\nReturn type:\nlist(Challenger)\nget_champion_model_package()\uf0c1\nGet a champion model package for this deployment.\nReturns:\nchampion_model_package \u2013 A champion model package object.\nReturn type:\nChampionModelPackage\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nchampion_model_package = deployment.get_champion_model_package()\nlist_prediction_data_exports(model_id=None, status=None, batch=None, offset=0, limit=100)\uf0c1\nRetrieve a list of asynchronous prediction data exports.\nParameters:\nmodel_id (Optional[str]) \u2013 The ID of the model used for prediction data export.\nstatus (Optional[str]) \u2013 A prediction data export processing state.\nbatch (Optional[bool]) \u2013 If true, only return batch exports.\nIf false, only return real-time exports.\nIf not provided, return both real-time and batch exports.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 100 (0 means no limit).\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nReturns:\nprediction_data_exports \u2013 A list of prediction data exports.\nReturn type:\nList[PredictionDataExport]\nlist_actuals_data_exports(status=None, offset=0, limit=100)\uf0c1\nRetrieve a list of asynchronous actuals data exports.\nParameters:\nstatus (Optional[str]) \u2013 Actuals data export processing state.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 100 (0 means no limit).\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nReturns:\nactuals_data_exports \u2013 A list of actuals data exports.\nReturn type:\nList[ActualsDataExport]\nlist_training_data_exports()\uf0c1\nRetrieve a list of successful training data exports.\nReturns:\ntraining_data_export \u2013 A list of training data exports.\nReturn type:\nList[TrainingDataExport]\nlist_data_quality_exports(start, end, model_id=None, prediction_pattern=None, prompt_pattern=None, actual_pattern=None, order_by=None, order_metric=None, filter_metric=None, filter_value=None, offset=0, limit=100)\uf0c1\nRetrieve a list of data-quality export records for a given deployment.\nAdded in version v3.6.\nParameters:\nstart (Union[str, datetime]) \u2013 The earliest time of the objects to return.\nend (Union[str, datetime]) \u2013 The latest time of the objects to return.\nmodel_id (Optional[str]) \u2013 The ID of the model.\nprediction_pattern (Optional[str]) \u2013 The keywords to search in a predicted value for a text generation target.\nprompt_pattern (Optional[str]) \u2013 The keywords to search in a prompt value for a text generation target.\nactual_pattern (Optional[str]) \u2013 The keywords to search in an actual value for a text generation target.\norder_by (Optional[str]) \u2013 The field to sort by (e.g. associationId, timestamp, or customMetrics). Use a leading \u2018-\u2019\nto indicate descending order. When ordering by a custom-metric, must also specify \u2018order_metric\u2019.\nThe default is None, which equates to \u2018-timestamp\u2019.\norder_metric (Optional[str]) \u2013 When \u2018order_by\u2019 is a custom-metric, this specifies the custom-metric name or ID to use for ordering.\nThe default is None.\nfilter_metric (Optional[str]) \u2013 Specifies the metric name or ID to use for matching. Must also use \u2018filter_value\u2019 to specify\nthe value that must be matched. The default is None.\nfilter_value (Optional[str]) \u2013 Specifies the value associated with \u2018filter_metric\u2019 that must be matched. The default\nis None.\noffset (Optional[int]) \u2013 The starting offset of the results. The default is 0.\nlimit (Optional[int]) \u2013 The maximum number of objects to return. The default is 100 (which is maximum).\nReturns:\ndata_quality_exports \u2013 A list of DataQualityExport objects.\nReturn type:\nlist\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndata_quality_exports = deployment.list_data_quality_exports(start_time='2024-07-01', end_time='2024-08-01')\nget_capabilities()\uf0c1\nGet a list capabilities for this deployment.\nAdded in version v3.5.\nReturn type:\nlist(Capability)\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ncapabilities = deployment.get_capabilities()\nget_segment_attributes(monitoringType='serviceHealth')\uf0c1\nGet a list of segment attributes for this deployment.\nAdded in version v3.6.\nParameters:\nmonitoringType (Optional[str]) \u2013 The monitoring type for which segment attributes are being retrieved.\nReturn type:\nlist(str)\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsegment_attributes = deployment.get_segment_attributes(DEPLOYMENT_MONITORING_TYPE.SERVICE_HEALTH)\nget_segment_values(segment_attribute=None, limit=100, offset=0, search=None)\uf0c1\nGet a list of segment values for this deployment.\nAdded in version v3.6.\nParameters:\nsegment_attribute (Optional[str]) \u2013 Represents the different ways that prediction requests can be viewed.\nlimit (int, Optional) \u2013 The maximum number of values to return.\noffset (int, Optional) \u2013 The starting point of the values to be returned.\nsearch (Optional[str]) \u2013 A string to filter the values.\nReturn type:\nlist(str)\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsegment_values = deployment.get_segment_values(segment_attribute=ReservedSegmentAttributes.CONSUMER)\nget_moderation_events(limit=100, offset=0)\uf0c1\nGet a list of moderation events for this deployment\nParameters:\nlimit (int (Default=100)) \u2013 The maximum number of values to return.\noffset (int (Default=0)) \u2013 The starting point of the values to be returned.\nReturns:\nevents\nReturn type:\nList[MLOpsEvent]\nget_accuracy_metrics_settings()\uf0c1\nGet accuracy metrics settings for this deployment.\nReturns:\naccuracy_metrics \u2013 A list of deployment accuracy metric names.\nReturn type:\nlist(str)\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy_metrics = deployment.get_accuracy_metrics_settings()\nupdate_accuracy_metrics_settings(accuracy_metrics)\uf0c1\nUpdate accuracy metrics settings for this deployment.\nParameters:\naccuracy_metrics (list(str)) \u2013 A list of accuracy metric names.\nReturns:\naccuracy_metrics \u2013 A list of deployment accuracy metric names.\nReturn type:\nlist(str)\nExamples\nfrom datarobot import Deployment\nfrom datarobot.enums import ACCURACY_METRIC\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npayload = [ACCURACY_METRIC.AUC, ACCURACY_METRIC.LOGLOSS]\naccuracy_metrics = deployment.update_accuracy_metrics_settings(payload)\nget_retraining_settings()\uf0c1\nRetrieve retraining settings of this deployment.\nAdded in version v2.29.\nReturns:\nsettings\nReturn type:\nRetrainingSettings\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nretraining_settings = deployment.get_retraining_settings()\nupdate_retraining_settings(retraining_user_id=<object object>, dataset_id=<object object>, prediction_environment_id=<object object>)\uf0c1\nUpdate retraining settings of this deployment.\nAdded in version v2.29.\nParameters:\nretraining_user_id (Optional[str]) \u2013 The retraining user ID.\ndataset_id (Optional[str]) \u2013 The retraining dataset ID.\nprediction_environment_id (Optional[str]) \u2013 The retraining prediction environment ID.\nReturn type:\nNone\nExamples\nfrom datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_retraining_settings(retaining_user_id='5c939e08962d741e34f609f0')\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nclass datarobot.models.deployment.DeploymentListFilters\uf0c1\nConstruct a set of filters to pass to Deployment.list()\nAdded in version v2.20.\nParameters:\nrole (str) \u2013 A user role. If specified, then take those deployments that the user can view, then\nfilter them down to those that the user has the specified role for, and return only\nthem. Allowed options are OWNER and USER.\nservice_health (List[str]) \u2013 A list of service health status values. If specified, then only deployments whose\nservice health status is one of these will be returned. See\ndatarobot.enums.DEPLOYMENT_SERVICE_HEALTH_STATUS for allowed values.\nSupports comma-separated lists.\nmodel_health (List[str]) \u2013 A list of model health status values. If specified, then only deployments whose model\nhealth status is one of these will be returned. See\ndatarobot.enums.DEPLOYMENT_MODEL_HEALTH_STATUS for allowed values.\nSupports comma-separated lists.\naccuracy_health (List[str]) \u2013 A list of accuracy health status values. If specified, then only deployments whose\naccuracy health status is one of these will be returned. See\ndatarobot.enums.DEPLOYMENT_ACCURACY_HEALTH_STATUS for allowed values.\nSupports comma-separated lists.\nexecution_environment_type (List[str]) \u2013 A list of strings representing the type of the deployments\u2019 execution environment.\nIf provided, then only return those deployments whose execution environment type is\none of those provided. See datarobot.enums.DEPLOYMENT_EXECUTION_ENVIRONMENT_TYPE\nfor allowed values. Supports comma-separated lists.\nimportance (List[str]) \u2013 A list of strings representing the deployments\u2019 \u201cimportance\u201d.\nIf provided, then only return those deployments whose importance\nis one of those provided. See datarobot.enums.DEPLOYMENT_IMPORTANCE\nfor allowed values. Supports comma-separated lists. Note that Approval Workflows must\nbe enabled for your account to use this filter, otherwise the API will return a 403.\nExamples\nMultiple filters can be combined in interesting ways to return very specific subsets of\ndeployments.\nPerforming AND logic\nProviding multiple different parameters will result in AND logic between them.\nFor example, the following will return all deployments that I own whose service health\nstatus is failing.\nfrom datarobot import Deployment\nfrom datarobot.models.deployment import DeploymentListFilters\nfrom datarobot.enums import DEPLOYMENT_SERVICE_HEALTH_STATUS\nfilters = DeploymentListFilters(\nrole='OWNER',\nservice_health=[DEPLOYMENT_SERVICE_HEALTH.FAILING]\n)\ndeployments = Deployment.list(filters=filters)\nPerforming OR logic\nSome filters support comma-separated lists (and will say so if they do). Providing a\ncomma-separated list of values to a single filter performs OR logic between those\nvalues. For example, the following will return all deployments whose service health\nis either warning OR failing.\nfrom datarobot import Deployment\nfrom datarobot.models.deployment import DeploymentListFilters\nfrom datarobot.enums import DEPLOYMENT_SERVICE_HEALTH_STATUS\nfilters = DeploymentListFilters(\nservice_health=[\nDEPLOYMENT_SERVICE_HEALTH.WARNING,\nDEPLOYMENT_SERVICE_HEALTH.FAILING,\n]\n)\ndeployments = Deployment.list(filters=filters)\nPerforming OR logic across different filter types is not supported.\nNotes\nIn all cases, you may only retrieve deployments for which you have at least\nthe USER role for. Deployments for which you are a CONSUMER of will not be returned,\nregardless of the filters applied.\nclass datarobot.models.deployment.ServiceStats\uf0c1\nDeployment service stats information.\nVariables:\nmodel_id (str) \u2013 the model used to retrieve service stats metrics\nperiod (dict) \u2013 the time period used to retrieve service stats metrics\nmetrics (dict) \u2013 the service stats metrics\nclassmethod get(deployment_id, model_id=None, start_time=None, end_time=None, execution_time_quantile=None, response_time_quantile=None, segment_attribute=None, segment_value=None, slow_requests_threshold=None)\uf0c1\nRetrieve value of service stat metrics over a certain time period.\nAdded in version v2.18.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_id (Optional[str]) \u2013 the id of the model\nstart_time (datetime, optional) \u2013 start of the time period\nend_time (datetime, optional) \u2013 end of the time period\nexecution_time_quantile (Optional[float]) \u2013 quantile for executionTime, defaults to 0.5\nresponse_time_quantile (Optional[float]) \u2013 quantile for responseTime, defaults to 0.5\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nslow_requests_threshold (Optional[float]) \u2013 threshold for slowRequests, defaults to 1000\nReturns:\nservice_stats \u2013 the queried service stats metrics\nReturn type:\nServiceStats\nclass datarobot.models.deployment.ServiceStatsOverTime\uf0c1\nDeployment service stats over time information.\nVariables:\nmodel_id (str) \u2013 the model used to retrieve accuracy metric\nmetric (str) \u2013 the service stat metric being retrieved\nbuckets (dict) \u2013 how the service stat metric changes over time\nsummary (dict) \u2013 summary for the service stat metric\nclassmethod get(deployment_id, metric=None, model_id=None, start_time=None, end_time=None, bucket_size=None, quantile=None, threshold=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve information about how a service stat metric changes over a certain time period.\nAdded in version v2.18.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmetric (SERVICE_STAT_METRIC, optional) \u2013 the service stat metric to retrieve\nmodel_id (Optional[str]) \u2013 the id of the model\nstart_time (datetime, optional) \u2013 start of the time period\nend_time (datetime, optional) \u2013 end of the time period\nbucket_size (Optional[str]) \u2013 time duration of a bucket, in ISO 8601 time duration format\nquantile (Optional[float]) \u2013 quantile for \u2018executionTime\u2019 or \u2018responseTime\u2019, ignored when querying other metrics\nthreshold (Optional[int]) \u2013 threshold for \u2018slowQueries\u2019, ignored when querying other metrics\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\nservice_stats_over_time \u2013 the queried service stat over time information\nReturn type:\nServiceStatsOverTime\nproperty bucket_values: OrderedDict[str, int | float | None]\uf0c1\nThe metric value for all time buckets, keyed by start time of the bucket.\nReturns:\nbucket_values\nReturn type:\nOrderedDict\nclass datarobot.models.deployment.TargetDrift\uf0c1\nDeployment target drift information.\nVariables:\nmodel_id (str) \u2013 the model used to retrieve target drift metric\nperiod (dict) \u2013 the time period used to retrieve target drift metric\nmetric (str) \u2013 the data drift metric\ntarget_name (str) \u2013 name of the target\ndrift_score (float) \u2013 target drift score\nsample_size (int) \u2013 count of data points for comparison\nbaseline_sample_size (int) \u2013 count of data points for baseline\nclassmethod get(deployment_id, model_id=None, start_time=None, end_time=None, metric=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve target drift information over a certain time period.\nAdded in version v2.21.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nmetric (str) \u2013 (New in version v2.22) metric used to calculate the drift score\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\ntarget_drift \u2013 the queried target drift information\nReturn type:\nTargetDrift\nExamples\nfrom datarobot import Deployment, TargetDrift\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ntarget_drift = TargetDrift.get(deployment.id)\ntarget_drift.period['end']\n>>>'2019-08-01 00:00:00+00:00'\ntarget_drift.drift_score\n>>>0.03423\naccuracy.target_name\n>>>'readmitted'\nclass datarobot.models.deployment.FeatureDrift\uf0c1\nDeployment feature drift information.\nVariables:\nmodel_id (str) \u2013 the model used to retrieve feature drift metric\nperiod (dict) \u2013 the time period used to retrieve feature drift metric\nmetric (str) \u2013 the data drift metric\nname (str) \u2013 name of the feature\ndrift_score (float) \u2013 feature drift score\nsample_size (int) \u2013 count of data points for comparison\nbaseline_sample_size (int) \u2013 count of data points for baseline\nclassmethod list(deployment_id, model_id=None, start_time=None, end_time=None, metric=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve drift information for deployment\u2019s features over a certain time period.\nAdded in version v2.21.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nmetric (str) \u2013 (New in version v2.22) metric used to calculate the drift score\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\nfeature_drift_data \u2013 the queried feature drift information\nReturn type:\n[FeatureDrift]\nExamples\nfrom datarobot import Deployment, TargetDrift\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nfeature_drift = FeatureDrift.list(deployment.id)[0]\nfeature_drift.period\n>>>'2019-08-01 00:00:00+00:00'\nfeature_drift.drift_score\n>>>0.252\nfeature_drift.name\n>>>'age'\nclass datarobot.models.deployment.PredictionsOverTime\uf0c1\nDeployment predictions over time information.\nVariables:\nbaselines (List) \u2013 target baseline for each model queried\nbuckets (List) \u2013 predictions over time bucket for each model and bucket queried\nclassmethod get(deployment_id, model_ids=None, start_time=None, end_time=None, bucket_size=None, target_classes=None, include_percentiles=False, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve information for deployment\u2019s prediction response over a certain time period.\nAdded in version v3.2.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_ids (list[str]) \u2013 ID of models to retrieve prediction stats\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (BUCKET_SIZE) \u2013 time duration of each bucket\ntarget_classes (list[str]) \u2013 class names of target, only for deployments with multiclass target\ninclude_percentiles (bool) \u2013 if the returned data includes percentiles,\nonly for a deployment with a binary and regression target\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\npredictions_over_time \u2013 the queried predictions over time information\nReturn type:\nPredictionsOverTime\nclass datarobot.models.deployment.Accuracy\uf0c1\nDeployment accuracy information.\nVariables:\nmodel_id (str) \u2013 the model used to retrieve accuracy metrics\nperiod (dict) \u2013 the time period used to retrieve accuracy metrics\nmetrics (dict) \u2013 the accuracy metrics\nclassmethod get(deployment_id, model_id=None, start_time=None, end_time=None, target_classes=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve values of accuracy metrics over a certain time period.\nAdded in version v2.18.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\ntarget_classes (list[str], optional) \u2013 Optional list of target class strings\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\naccuracy \u2013 the queried accuracy metrics information\nReturn type:\nAccuracy\nExamples\nfrom datarobot import Deployment, Accuracy\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy = Accuracy.get(deployment.id)\naccuracy.period['end']\n>>>'2019-08-01 00:00:00+00:00'\naccuracy.metric['LogLoss']['value']\n>>>0.7533\naccuracy.metric_values['LogLoss']\n>>>0.7533\nproperty metric_values: Dict[str, int | None]\uf0c1\nThe value for all metrics, keyed by metric name.\nReturns:\nmetric_values\nReturn type:\nDict\nproperty metric_baselines: Dict[str, int | None]\uf0c1\nThe baseline value for all metrics, keyed by metric name.\nReturns:\nmetric_baselines\nReturn type:\nDict\nproperty percent_changes: Dict[str, int | None]\uf0c1\nThe percent change of value over baseline for all metrics, keyed by metric name.\nReturns:\npercent_changes\nReturn type:\nDict\nclass datarobot.models.deployment.AccuracyOverTime\uf0c1\nDeployment accuracy over time information.\nVariables:\nmodel_id (str) \u2013 the model used to retrieve accuracy metric\nmetric (str) \u2013 the accuracy metric being retrieved\nbuckets (dict) \u2013 how the accuracy metric changes over time\nsummary (dict) \u2013 summary for the accuracy metric\nbaseline (dict) \u2013 baseline for the accuracy metric\nclassmethod get(deployment_id, metric=None, model_id=None, start_time=None, end_time=None, bucket_size=None, target_classes=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve information about how an accuracy metric changes over a certain time period.\nAdded in version v2.18.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmetric (ACCURACY_METRIC) \u2013 the accuracy metric to retrieve\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (str) \u2013 time duration of a bucket, in ISO 8601 time duration format\ntarget_classes (list[str], optional) \u2013 Optional list of target class strings\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\naccuracy_over_time \u2013 the queried accuracy metric over time information\nReturn type:\nAccuracyOverTime\nExamples\nfrom datarobot import Deployment, AccuracyOverTime\nfrom datarobot.enums import ACCURACY_METRICS\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy_over_time = AccuracyOverTime.get(deployment.id, metric=ACCURACY_METRIC.LOGLOSS)\naccuracy_over_time.metric\n>>>'LogLoss'\naccuracy_over_time.metric_values\n>>>{datetime.datetime(2019, 8, 1): 0.73, datetime.datetime(2019, 8, 2): 0.55}\nclassmethod get_as_dataframe(deployment_id, metrics=None, model_id=None, start_time=None, end_time=None, bucket_size=None)\uf0c1\nRetrieve information about how a list of accuracy metrics change over\na certain time period as pandas DataFrame.\nIn the returned DataFrame, the columns corresponds to the metrics being retrieved;\nthe rows are labeled with the start time of each bucket.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmetrics ([ACCURACY_METRIC]) \u2013 the accuracy metrics to retrieve\nmodel_id (str) \u2013 the id of the model\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (str) \u2013 time duration of a bucket, in ISO 8601 time duration format\nReturns:\naccuracy_over_time\nReturn type:\npd.DataFrame\nproperty bucket_values: Dict[datetime, int]\uf0c1\nThe metric value for all time buckets, keyed by start time of the bucket.\nReturns:\nbucket_values\nReturn type:\nDict\nproperty bucket_sample_sizes: Dict[datetime, int]\uf0c1\nThe sample size for all time buckets, keyed by start time of the bucket.\nReturns:\nbucket_sample_sizes\nReturn type:\nDict\nclass datarobot.models.deployment.PredictionsVsActualsOverTime\uf0c1\nDeployment predictions vs actuals over time information.\nVariables:\nsummary (dict) \u2013 predictions vs actuals over time summary for all models and buckets queried\nbaselines (List) \u2013 target baseline for each model queried\nbuckets (List) \u2013 predictions vs actuals over time bucket for each model and bucket queried\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nclassmethod get(deployment_id, model_ids=None, start_time=None, end_time=None, bucket_size=None, target_classes=None, segment_attribute=None, segment_value=None)\uf0c1\nRetrieve information for deployment\u2019s predictions vs actuals over a certain time period.\nAdded in version v3.3.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_ids (list[str]) \u2013 ID of models to retrieve predictions vs actuals stats\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nbucket_size (BUCKET_SIZE) \u2013 time duration of each bucket\ntarget_classes (list[str]) \u2013 class names of target, only for deployments with multiclass target\nsegment_attribute (Optional[str]) \u2013 (New in Version v3.6) the segment attribute\nsegment_value (Optional[str]) \u2013 (New in Version v3.6) the segment value\nReturns:\npredictions_vs_actuals_over_time \u2013 the queried predictions vs actuals over time information\nReturn type:\nPredictionsVsActualsOverTime\nclass datarobot.models.deployment.bias_and_fairness.FairnessScoresOverTime\uf0c1\nDeployment fairness over time information.\nVariables:\nbuckets (List) \u2013 fairness over time bucket for each model and bucket queried\nsummary (dict) \u2013 summary for the fairness score\nprotected_feature (str) \u2013 name of protected feature\nfairnessThreshold (float) \u2013 threshold used to compute fairness results\nmodelId (str) \u2013 model id for which fairness is computed\nmodelPackageId (str) \u2013 model package (version) id for which fairness is computed\nfavorableTargetOutcome (bool) \u2013 preferable class of the target\nclassmethod get(deployment_id, model_id=None, start_time=None, end_time=None, bucket_size=None, fairness_metric=None, protected_feature=None)\uf0c1\nRetrieve information for deployment\u2019s fairness score response over a certain time period.\nAdded in version FUTURE.\nParameters:\ndeployment_id (str) \u2013 the id of the deployment\nmodel_id (str) \u2013 id of models to retrieve fairness score stats\nstart_time (datetime) \u2013 start of the time period\nend_time (datetime) \u2013 end of the time period\nprotected_feature (str) \u2013 name of the protected feature\nfairness_metric (str) \u2013 A consolidation of the fairness metrics by the use case.\nbucket_size (BUCKET_SIZE) \u2013 time duration of each bucket\nReturns:\nfairness_scores_over_time \u2013 the queried fairness score over time information\nReturn type:\nFairnessScoresOverTime\nclass datarobot.models.deployment.DeploymentSharedRole\uf0c1\nParameters:\nshare_recipient_type ({'user', 'group', 'organization'}) \u2013 Describes the recipient type, either user, group, or organization.\nrole ({'CONSUMER', 'USER', 'OWNER'}) \u2013 The role of the org/group/user on this deployment.\nid (str) \u2013 The ID of the recipient organization, group, or user.\nname (str) \u2013 The name of the recipient organization, group, or user.\nclass datarobot.models.deployment.DeploymentGrantSharedRoleWithId\uf0c1\nParameters:\nshare_recipient_type ({'user', 'group', 'organization'}) \u2013 Describes the recipient type, either user, group, or organization.\nrole ({'OWNER', 'USER', 'OBSERVER', 'NO_ROLE'}) \u2013 The role of the recipient on this entity. One of OWNER, USER, OBSERVER, NO_ROLE.\nIf NO_ROLE is specified, any existing role for the recipient will be removed.\nid (str) \u2013 The ID of the recipient.\nclass datarobot.models.deployment.DeploymentGrantSharedRoleWithUsername\uf0c1\nParameters:\nrole (string) \u2013 The role of the recipient on this entity. One of OWNER, USER, CONSUMER, NO_ROLE.\nIf NO_ROLE is specified, any existing role for the user will be removed.\nusername (string) \u2013 Username of the user to update the access role for.\nclass datarobot.models.deployment.deployment.FeatureDict\uf0c1\nclass datarobot.models.deployment.deployment.ForecastDateSettings\uf0c1\nForecast date settings of the deployment\nVariables:\nenabled (bool) \u2013 Is True if predictions by forecast date is enabled for this deployment.\nTo update this setting, see\nupdate_predictions_by_forecast_date_settings()\ncolumn_name (str) \u2013 The column name in prediction datasets to be used as forecast date.\ndatetime_format (str) \u2013 The datetime format of the forecast date column in prediction datasets.\nclass datarobot.models.deployment.deployment.ChallengerModelsSettings\uf0c1\nChallenger models settings of the deployment is a dict with the following format:\nVariables:\nenabled (bool) \u2013 Is True if challenger models is enabled for this deployment. To update\nexisting \u2018\u2019challenger_models\u2019\u2019 settings, see\nupdate_challenger_models_settings()\nclass datarobot.models.deployment.deployment.SegmentAnalysisSettings\uf0c1\nSegment analysis settings of the deployment containing two items with keysenabled and attributes, which are further described below.\nVariables:\nenabled (bool) \u2013 Set to True if segment analysis is enabled for this deployment. To update\nexisting setting, see\nupdate_segment_analysis_settings()\nattributes (list) \u2013 To create or update existing segment analysis attributes, see\nupdate_segment_analysis_settings()\nclass datarobot.models.deployment.deployment.BiasAndFairnessSettings\uf0c1\nBias and fairness settings of this deployment\nVariables:\nprotected_features (List[str]) \u2013 A list of features to mark as protected.\npreferable_target_value (bool) \u2013 A target value that should be treated as a positive outcome for the prediction.\nfairness_metric_set (str) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nA set of fairness metrics to use for calculating fairness.\nfairness_threshold (float) \u2013 Threshold value of the fairness metric. Cannot be less than 0 or greater than 1.\nclass datarobot.models.deployment.deployment.ChallengerReplaySettings\uf0c1\nChallenger replay settings of the deployment is a dict with the following format:\nVariables:\nenabled (bool) \u2013 If challenger replay is enabled. To update\nexisting challenger_replay settings, see\nupdate_challenger_replay_settings()\nschedule (Schedule) \u2013 The recurring schedule for the challenger replay job.\nclass datarobot.models.deployment.deployment.HealthSettings\uf0c1\nHealth settings of the deployment containing seven nested dicts with keys\nVariables:\nservice (dict) \u2013 Service health settings.\ndata_drift (dict) \u2013 Data drift health settings.\naccuracy (dict) \u2013 Accuracy health settings.\nfairness (dict) \u2013 Fairness health settings.\ncustom_metrics (dict) \u2013 Custom metrics health settings.\npredictions_timeliness (dict) \u2013 Predictions timeliness health settings.\nactuals_timeliness (dict) \u2013 Actuals timeliness health settings.\nclass datarobot.models.deployment.deployment.DriftTrackingSettings\uf0c1\nDrift tracking settings of the deployment containing two nested dicts with keytarget_drift and feature_drift, which are further described below.\nVariables:\ntarget_drift (Settings) \u2013 If target drift tracking is enabled for this deployment. To create or update\nexisting target_drift settings, see\nupdate_drift_tracking_settings()\nfeature_drift (Settings) \u2013 If feature drift tracking is enabled for this deployment. To create or update\nexisting feature_drift settings, see\nupdate_drift_tracking_settings()\nclass datarobot.models.deployment.deployment.PredictionWarningSettings\uf0c1\nPrediction warning settings of the deployment\nVariables:\nenabled (bool) \u2013 If target prediction_warning is enabled for this deployment. To create or update\nexisting \u2018\u2019prediction_warning\u2019\u2019 settings, see\nupdate_prediction_warning_settings()\ncustom_boundaries (dict or None) \u2013 If None default boundaries for a model are used. Otherwise has following keys:\nupper (float): All predictions greater than provided value are considered anomalous\nlower (float): All predictions less than provided value are considered anomalous\nclass datarobot.models.deployment.deployment.PredictionIntervalsSettings\uf0c1\nPrediction intervals settings of the deployment is a dict with the following format:\nVariables:\nenabled (bool) \u2013 Whether prediction intervals are enabled for this deployment\npercentiles (list[int]) \u2013 List of enabled prediction intervals\u2019 sizes for this deployment. Currently we only\nsupport one percentile at a time.\nclass datarobot.models.deployment.deployment.Capability\uf0c1\nclass datarobot.enums.ACCURACY_METRIC\uf0c1\nPredictions\uf0c1\nclass datarobot.models.Predictions\uf0c1\nRepresents predictions metadata and provides access to prediction results.\nVariables:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model\nprediction_id (str) \u2013 id of generated predictions\nincludes_prediction_intervals (Optional[bool]) \u2013 (New in v2.16) For time series projects only.\nIndicates if prediction intervals will be part of the response. Defaults to False.\nprediction_intervals_size (Optional[int]) \u2013 (New in v2.16) For time series projects only.\nIndicates the percentile used for prediction intervals calculation. Will be present only\nif includes_prediction_intervals is True.\nforecast_point (datetime.datetime, optional) \u2013 (New in v2.20) For time series projects only. This is the default point\nrelative to which predictions will be generated, based on the forecast window of the\nproject. See the time series prediction documentation for more\ninformation.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in v2.20) For time series projects only. The end date for bulk\npredictions, exclusive. Note that this parameter is for generating historical predictions\nusing the training data. This parameter should be provided in conjunction with\npredictions_start_date. Can\u2019t be provided with the forecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column which was used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nexplanation_algorithm (datarobot.enums.EXPLANATIONS_ALGORITHM, optional) \u2013 (New in version v2.21) If set to \u2018shap\u2019, the response will include prediction\nexplanations based on the SHAP explainer (SHapley Additive exPlanations). Defaults to null\n(no prediction explanations).\nmax_explanations (Optional[int]) \u2013 (New in version v2.21) The maximum number of explanation values that should be returned\nfor each row, ordered by absolute value, greatest to least. If null, no limit. In the case\nof \u2018shap\u2019: if the number of features is greater than the limit, the sum of remaining values\nwill also be returned as shapRemainingTotal. Defaults to null. Cannot be set if\nexplanation_algorithm is omitted.\nshap_warnings (dict, optional) \u2013 (New in version v2.21) Will be present if explanation_algorithm was set to\ndatarobot.enums.EXPLANATIONS_ALGORITHM.SHAP and there were additivity failures during SHAP\nvalues calculation.\nExamples\nList all predictions for a project\nimport datarobot as dr\n# Fetch all predictions for a project\nall_predictions = dr.Predictions.list(project_id)\n# Inspect all calculated predictions\nfor predictions in all_predictions:\nprint(predictions)  # repr includes project_id, model_id, and dataset_id\nRetrieve predictions by id\nimport datarobot as dr\n# Getting predictions by id\npredictions = dr.Predictions.get(project_id, prediction_id)\n# Dump actual predictions\ndf = predictions.get_all_as_dataframe()\nprint(df)\nclassmethod list(project_id, model_id=None, dataset_id=None)\uf0c1\nFetch all the computed predictions metadata for a project.\nParameters:\nproject_id (str) \u2013 id of the project\nmodel_id (Optional[str]) \u2013 if specified, only predictions metadata for this model will be retrieved\ndataset_id (Optional[str]) \u2013 if specified, only predictions metadata for this dataset will be retrieved\nReturn type:\nA list of Predictions objects\nclassmethod get(project_id, prediction_id)\uf0c1\nRetrieve the specific predictions metadata\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nprediction_id (str) \u2013 id of the prediction set\nReturn type:\nPredictions\nReturns:\nPredictions object representing specified\npredictions\nget_all_as_dataframe(class_prefix='class_', serializer='json')\uf0c1\nRetrieve all prediction rows and return them as a pandas.DataFrame.\nParameters:\nclass_prefix (Optional[str]) \u2013 The prefix to append to labels in the final dataframe. Default is class_\n(e.g., apple -> class_apple)\nserializer (Optional[str]) \u2013 Serializer to use for the download. Options: json (default) or csv.\nReturns:\ndataframe\nReturn type:\npandas.DataFrame\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\ndownload_to_csv(filename, encoding='utf-8', serializer='json')\uf0c1\nSave prediction rows into CSV file.\nParameters:\nfilename (str or file object) \u2013 path or file object to save prediction rows\nencoding (string, optional) \u2013 A string representing the encoding to use in the output file, defaults to\n\u2018utf-8\u2019\nserializer (Optional[str]) \u2013 Serializer to use for the download. Options: json (default) or csv.\nReturn type:\nNone\nPredictionServer\uf0c1\nclass datarobot.PredictionServer\uf0c1\nA prediction server can be used to make predictions.\nVariables:\nid (Optional[str]) \u2013 The id of the prediction server.\nurl (str) \u2013 The url of the prediction server.\ndatarobot_key (Optional[str]) \u2013 The Datarobot-Key HTTP header used in requests to this prediction server. Note that in the\ndatarobot.models.Deployment instance there is the default_prediction_server\nproperty which has this value as a \u201ckebab-cased\u201d key as opposed to \u201csnake_cased\u201d.\nclassmethod list()\uf0c1\nReturns a list of prediction servers a user can use to make predictions.\nAdded in version v2.17.\nReturns:\nprediction_servers \u2013 Contains a list of prediction servers that can be used to make predictions.\nReturn type:\nlist of PredictionServer instances\nExamples\nprediction_servers = PredictionServer.list()\nprediction_servers\n>>> [PredictionServer('https://example.com')]\nPrediction environment\uf0c1\nclass datarobot.models.PredictionEnvironment\uf0c1\nA prediction environment entity.\nAdded in version v3.3.0.\nVariables:\nid (str) \u2013 The ID of the prediction environment.\nname (str) \u2013 The name of the prediction environment.\ndescription (Optional[str]) \u2013 The description of the prediction environment.\nplatform (Optional[str]) \u2013 Indicates which platform is in use (AWS, GCP, DataRobot, etc.).\npermissions (Optional[List]) \u2013 A set of permissions for the prediction environment.\nis_deleted (boolean, optional) \u2013 The flag that shows if this prediction environment deleted.\nsupported_model_formats (list[PredictionEnvironmentModelFormats], optional) \u2013 The list of supported model formats.\nis_managed_by_management_agent (boolean, optional) \u2013 Determines if the prediction environment should be managed by the management agent. False by default.\ndatastore_id (Optional[str]) \u2013 The ID of the data store connection configuration.\nOnly applicable for external prediction environments managed by DataRobot.\ncredential_id (Optional[str]) \u2013 The ID of the credential associated with the data connection.\nOnly applicable for external prediction environments managed by DataRobot.\nclassmethod list()\uf0c1\nReturns list of available external prediction environments.\nReturns:\nprediction_environments \u2013 contains a list of available prediction environments.\nReturn type:\nlist of PredictionEnvironment instances\nExamples\n>>> import datarobot as dr\n>>> prediction_environments = dr.PredictionEnvironment.list()\n>>> prediction_environments\n[\nPredictionEnvironment('5e429d6ecf8a5f36c5693e03', 'demo_pe', 'aws', 'env for demo testing'),\nPredictionEnvironment('5e42cc4dcf8a5f3256865840', 'azure_pe', 'azure', 'env for azure demo testing'),\n]\nclassmethod get(pe_id)\uf0c1\nGets the PredictionEnvironment by id.\nParameters:\npe_id (str) \u2013 the identifier of the PredictionEnvironment.\nReturns:\nprediction_environment \u2013 the requested prediction environment object.\nReturn type:\nPredictionEnvironment\nExamples\n>>> import datarobot as dr\n>>> pe = dr.PredictionEnvironment.get('5a8ac9ab07a57a1231be501f')\n>>> pe\nPredictionEnvironment('5a8ac9ab07a57a1231be501f', 'my_predict_env', 'aws', 'demo env'),\ndelete()\uf0c1\nDeletes the prediction environment.\n:rtype: None\nExamples\n>>> import datarobot as dr\n>>> pe = dr.PredictionEnvironment.get('5a8ac9ab07a57a1231be501f')\n>>> pe.delete()\nclassmethod create(name, platform, description=None, plugin=None, supported_model_formats=None, is_managed_by_management_agent=False, datastore=None, credential=None)\uf0c1\nCreate a prediction environment.\nParameters:\nname (str) \u2013 The name of the prediction environment.\ndescription (Optional[str]) \u2013 The description of the prediction environment.\nplatform (str) \u2013 Indicates which platform is in use (AWS, GCP, DataRobot, etc.).\nplugin (str) \u2013 Optional. The plugin name to use.\nsupported_model_formats (list[PredictionEnvironmentModelFormats], optional) \u2013 The list of supported model formats.\nWhen not provided, the default value is inferred based on platform, (DataRobot platform: DataRobot,\nCustom Models; All other platforms: DataRobot, Custom Models, External Models).\nis_managed_by_management_agent (boolean, optional) \u2013 Determines if this prediction environment should be managed by the management agent. default: False\ndatastore (DataStore|Optional[str]]) \u2013 The datastore object or ID of the data store connection configuration.\nOnly applicable for external Prediction Environments managed by DataRobot.\ncredential (Credential|Optional[str]]) \u2013 The credential object or ID of the credential associated with the data connection.\nOnly applicable for external Prediction Environments managed by DataRobot.\nReturns:\nprediction_environment \u2013 the prediction environment was created\nReturn type:\nPredictionEnvironment\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nExamples\n>>> import datarobot as dr\n>>> pe = dr.PredictionEnvironment.create(\n...     name='my_predict_env',\n...     platform=PredictionEnvironmentPlatform.AWS,\n...     description='demo prediction env',\n... )\n>>> pe\nPredictionEnvironment('5e429d6ecf8a5f36c5693e99', 'my_predict_env', 'aws', 'demo prediction env'),",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot import Project, Deployment\nproject = Project.get('5506fcd38bd88f5953219da0')\nmodel = project.get_models()[0]\ndeployment = Deployment.create_from_learning_model(model.id, 'New Deployment')\ndeployment\n>>> Deployment('New Deployment')",
        "from datarobot import Project, Deployment\nproject = Project.get('5506fcd38bd88f5953219da0')\nmodel = project.get_models()[0]\ndeployment = Deployment.create_from_leaderboard(model.id, 'New Deployment')\ndeployment\n>>> Deployment('New Deployment')",
        "Optional[datarobot.models.deployment.DeploymentListFilters]",
        "from datarobot import Deployment\ndeployments = Deployment.list()\ndeployments\n>>> [Deployment('New Deployment'), Deployment('Previous Deployment')]",
        "from datarobot import Deployment\nfrom datarobot.enums import DEPLOYMENT_SERVICE_HEALTH_STATUS\nfilters = DeploymentListFilters(\n    role='OWNER',\n    service_health=[DEPLOYMENT_SERVICE_HEALTH.FAILING]\n)\nfiltered_deployments = Deployment.list(filters=filters)\nfiltered_deployments\n>>> [Deployment('Deployment I Own w/ Failing Service Health')]",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.id\n>>>'5c939e08962d741e34f609f0'\ndeployment.label\n>>>'New Deployment'",
        "datarobot.models.BatchPredictionJob",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJob.score()",
        "from datarobot.models.deployment import Deployment\n\ndeployment = Deployment.get(\"<MY_DEPLOYMENT_ID>\")\nprediction_results_as_dataframe = deployment.predict_batch(\n    source=\"./my_local_file.csv\",\n)",
        "validate_replacement_model()",
        "MODEL_REPLACEMENT_REASON",
        "from datarobot import Deployment\nfrom datarobot.enums import MODEL_REPLACEMENT_REASON\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.model['id'], deployment.model['type']\n>>>('5c0a979859b00004ba52e431', 'Decision Tree Classifier (Gini)')\n\ndeployment.replace_model('5c0a969859b00004ba52e41b', MODEL_REPLACEMENT_REASON.ACCURACY)\ndeployment.model['id'], deployment.model['type']\n>>>('5c0a969859b00004ba52e41b', 'Support Vector Classifier (Linear Kernel)')",
        "validate_replacement_model()",
        "MODEL_REPLACEMENT_REASON",
        "from datarobot import Deployment\nfrom datarobot.enums import MODEL_REPLACEMENT_REASON\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.model_package['id']\n>>>'5c0a979859b00004ba52e431'\n\ndeployment.perform_model_replace('5c0a969859b00004ba52e41b', MODEL_REPLACEMENT_REASON.ACCURACY)\ndeployment.model_package['id']\n>>>'5c0a969859b00004ba52e41b'",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nfeatures = deployment.get_features()\nfeatures[0]['feature_type']\n>>>'Categorical'\nfeatures[0]['importance']\n>>>0.133",
        "from datarobot import Deployment, AccuracyOverTime\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndata = [{\n    'association_id': '439917',\n    'actual_value': 'True',\n    'was_acted_on': True\n}]\ndeployment.submit_actuals(data)",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nstatus_check_job = deployment.submit_actuals_from_catalog_async(data)",
        "# To set predictions by forecast date settings to the same default settings you see when using\n# the DataRobot web application, you use your 'Deployment' object like this:\ndeployment.update_predictions_by_forecast_date_settings(\n   enable_predictions_by_forecast_date=True,\n   forecast_date_column_name=\"date (actual)\",\n   forecast_date_format=\"%Y-%m-%d\",\n)",
        "ChallengerModelsSettings",
        "datarobot.models.Deployment.update_predictions_data_collection_settings",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_over_time()\npredictions_over_time.buckets[0]['mean_predicted_value']\n>>>0.3772\npredictions_over_time.buckets[0]['row_count']\n>>>2000",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_vs_actuals_over_time()\npredictions_over_time.buckets[0]['mean_actual_value']\n>>>0.6673\npredictions_over_time.buckets[0]['row_count_with_actual']\n>>>500",
        "from datarobot import Deployment\ndeployment = Deployment(deployment_id='5c939e08962d741e34f609f0')\nconfig = deployment.update_secondary_dataset_config('5df109112ca582033ff44084')\nconfig\n>>> '5df109112ca582033ff44084'",
        "from datarobot import Deployment\ndeployment = Deployment(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_secondary_dataset_config('5df109112ca582033ff44084')\nconfig = deployment.get_secondary_dataset_config()\nconfig\n>>> '5df109112ca582033ff44084'",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nresults = deployment.get_prediction_results()",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nresults = deployment.download_prediction_results('path_to_prediction_results.csv')",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nresults = deployment.download_scoring_code('path_to_scoring_code.jar')",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.download_model_package_file('path_to_model_package.mlpkg')",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nchampion_model_package = deployment.get_champion_model_package()",
        "from datarobot import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndata_quality_exports = deployment.list_data_quality_exports(start_time='2024-07-01', end_time='2024-08-01')",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ncapabilities = deployment.get_capabilities()",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsegment_attributes = deployment.get_segment_attributes(DEPLOYMENT_MONITORING_TYPE.SERVICE_HEALTH)",
        "from datarobot import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsegment_values = deployment.get_segment_values(segment_attribute=ReservedSegmentAttributes.CONSUMER)",
        "from datarobot import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy_metrics = deployment.get_accuracy_metrics_settings()",
        "from datarobot import Deployment\nfrom datarobot.enums import ACCURACY_METRIC\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npayload = [ACCURACY_METRIC.AUC, ACCURACY_METRIC.LOGLOSS]\naccuracy_metrics = deployment.update_accuracy_metrics_settings(payload)",
        "from datarobot import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nretraining_settings = deployment.get_retraining_settings()",
        "from datarobot import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_retraining_settings(retaining_user_id='5c939e08962d741e34f609f0')",
        "datarobot.enums.DEPLOYMENT_SERVICE_HEALTH_STATUS",
        "datarobot.enums.DEPLOYMENT_MODEL_HEALTH_STATUS",
        "datarobot.enums.DEPLOYMENT_ACCURACY_HEALTH_STATUS",
        "datarobot.enums.DEPLOYMENT_EXECUTION_ENVIRONMENT_TYPE",
        "datarobot.enums.DEPLOYMENT_IMPORTANCE",
        "from datarobot import Deployment\nfrom datarobot.models.deployment import DeploymentListFilters\nfrom datarobot.enums import DEPLOYMENT_SERVICE_HEALTH_STATUS\nfilters = DeploymentListFilters(\n    role='OWNER',\n    service_health=[DEPLOYMENT_SERVICE_HEALTH.FAILING]\n)\ndeployments = Deployment.list(filters=filters)",
        "from datarobot import Deployment\nfrom datarobot.models.deployment import DeploymentListFilters\nfrom datarobot.enums import DEPLOYMENT_SERVICE_HEALTH_STATUS\nfilters = DeploymentListFilters(\n    service_health=[\n        DEPLOYMENT_SERVICE_HEALTH.WARNING,\n        DEPLOYMENT_SERVICE_HEALTH.FAILING,\n    ]\n)\ndeployments = Deployment.list(filters=filters)",
        "from datarobot import Deployment, TargetDrift\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ntarget_drift = TargetDrift.get(deployment.id)\ntarget_drift.period['end']\n>>>'2019-08-01 00:00:00+00:00'\ntarget_drift.drift_score\n>>>0.03423\naccuracy.target_name\n>>>'readmitted'",
        "from datarobot import Deployment, TargetDrift\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nfeature_drift = FeatureDrift.list(deployment.id)[0]\nfeature_drift.period\n>>>'2019-08-01 00:00:00+00:00'\nfeature_drift.drift_score\n>>>0.252\nfeature_drift.name\n>>>'age'",
        "from datarobot import Deployment, Accuracy\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy = Accuracy.get(deployment.id)\naccuracy.period['end']\n>>>'2019-08-01 00:00:00+00:00'\naccuracy.metric['LogLoss']['value']\n>>>0.7533\naccuracy.metric_values['LogLoss']\n>>>0.7533",
        "from datarobot import Deployment, AccuracyOverTime\nfrom datarobot.enums import ACCURACY_METRICS\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy_over_time = AccuracyOverTime.get(deployment.id, metric=ACCURACY_METRIC.LOGLOSS)\naccuracy_over_time.metric\n>>>'LogLoss'\naccuracy_over_time.metric_values\n>>>{datetime.datetime(2019, 8, 1): 0.73, datetime.datetime(2019, 8, 2): 0.55}",
        "update_challenger_models_settings()",
        "datarobot.enums.EXPLANATIONS_ALGORITHM",
        "import datarobot as dr\n\n# Fetch all predictions for a project\nall_predictions = dr.Predictions.list(project_id)\n\n# Inspect all calculated predictions\nfor predictions in all_predictions:\n    print(predictions)  # repr includes project_id, model_id, and dataset_id",
        "import datarobot as dr\n\n# Getting predictions by id\npredictions = dr.Predictions.get(project_id, prediction_id)\n\n# Dump actual predictions\ndf = predictions.get_all_as_dataframe()\nprint(df)",
        "datarobot.models.Deployment",
        "list[PredictionEnvironmentModelFormats]",
        ">>> import datarobot as dr\n>>> prediction_environments = dr.PredictionEnvironment.list()\n>>> prediction_environments\n[\n    PredictionEnvironment('5e429d6ecf8a5f36c5693e03', 'demo_pe', 'aws', 'env for demo testing'),\n    PredictionEnvironment('5e42cc4dcf8a5f3256865840', 'azure_pe', 'azure', 'env for azure demo testing'),\n]",
        ">>> import datarobot as dr\n>>> pe = dr.PredictionEnvironment.get('5a8ac9ab07a57a1231be501f')\n>>> pe\nPredictionEnvironment('5a8ac9ab07a57a1231be501f', 'my_predict_env', 'aws', 'demo env'),",
        ">>> import datarobot as dr\n>>> pe = dr.PredictionEnvironment.get('5a8ac9ab07a57a1231be501f')\n>>> pe.delete()",
        "list[PredictionEnvironmentModelFormats]",
        ">>> import datarobot as dr\n>>> pe = dr.PredictionEnvironment.create(\n...     name='my_predict_env',\n...     platform=PredictionEnvironmentPlatform.AWS,\n...     description='demo prediction env',\n... )\n>>> pe\nPredictionEnvironment('5e429d6ecf8a5f36c5693e99', 'my_predict_env', 'aws', 'demo prediction env'),"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-llm-generation.html",
      "title": "LLM Generation\uf0c1",
      "description": "The validation record checking the ability of the deployment to serve\nas a custom model LLM, custom model vector database, or custom model embedding.",
      "content": "LLM Generation\uf0c1\nclass datarobot.models.genai.custom_model_validation.CustomModelValidation\uf0c1\nThe validation record checking the ability of the deployment to serve\nas a custom model LLM, custom model vector database, or custom model embedding.\nVariables:\nid (str) \u2013 The ID of the validation.\nprompt_column_name (str) \u2013 The name of the column the deployed model uses for prompt text input.\ntarget_column_name (str) \u2013 The name of the column the deployed model uses for prediction output.\ndeployment_id (str) \u2013 The ID of the deployment.\nmodel_id (str) \u2013 The ID of the underlying deployed model, which can be found using Deployment.model[\u201cid\u201d].\nvalidation_status (str) \u2013 Can be TESTING, FAILED, or PASSED. Only PASSED is allowed for use.\ndeployment_access_data (dict, optional) \u2013 The data that will be used for accessing the deployment prediction server.\nThis field is only available for deployments that pass validation.\nDict fields are as follows:\n- prediction_api_url - The URL for the deployment prediction server.\n- datarobot_key - The first of two auth headers for the prediction server.\n- authorization_header - The second of two auth headers for the prediction server.\n- input_type - The input type the model expects, either JSON or CSV.\n- model_type - The target type of the deployed custom model.\ntenant_id (str) \u2013 The creating user\u2019s tenant ID.\nname (str) \u2013 The display name of the validated custom model.\ncreation_date (str) \u2013 The creation date of the validation (ISO 8601 formatted).\nuser_id (str) \u2013 The ID of the creating user.\nerror_message (Optional[str]) \u2013 Additional information for the errored validation.\ndeployment_name (Optional[str]) \u2013 The name of the validated deployment.\nuser_name (Optional[str]) \u2013 The name of the creating user.\nuse_case_id (Optional[str]) \u2013 The ID of the Use Case associated with the validation.\nprediction_timeout (int) \u2013 The timeout, in seconds, for the prediction API used in this custom model validation.\nclassmethod get(validation_id)\uf0c1\nGet the validation record by id.\nParameters:\nvalidation_id (Union[CustomModelValidation, str]) \u2013 The CustomModelValidation to retrieve, either CustomModelValidation or validation ID.\nReturn type:\nCustomModelValidation\nclassmethod get_by_values(prompt_column_name, target_column_name, deployment_id, model_id)\uf0c1\nGet the validation record by field values.\nParameters:\nprompt_column_name (str) \u2013 The name of the column the deployed model uses for prompt text input.\ntarget_column_name (str) \u2013 The name of the column the deployed model uses for prediction output.\ndeployment_id (str) \u2013 The ID of the deployment.\nmodel_id (str) \u2013 The ID of the underlying deployed model.\nReturn type:\nCustomModelValidation\nclassmethod list(prompt_column_name=None, target_column_name=None, deployment=None, model=None, use_cases=None, playground=None, completed_only=False, search=None, sort=None)\uf0c1\nList the validation records by field values.\nParameters:\nprompt_column_name (Optional[str], optional) \u2013 The column name the deployed model expects as the input.\ntarget_column_name (Optional[str], optional) \u2013 The target name that the deployed model will output.\ndeployment (Optional[Union[Deployment, str]], optional) \u2013 The returned validations are filtered to those associated with a specific deployment\nif specified, either Deployment or the deployment ID.\nmodel_id (Optional[Union[Model, str]], optional) \u2013 The returned validations are filtered to those associated with a specific model\nif specified, either Model or model ID.\nuse_cases (Optional[list[Union[UseCase, str]]], optional) \u2013 The returned validations are filtered to those associated with specific Use Cases\nif specified, either UseCase objects or the Use Case IDs.\nplayground_id (Optional[Union[Playground, str]], optional) \u2013 The returned validations are filtered to those used in a specific playground\nif specified, either Playground or playground ID.\ncompleted_only (Optional[bool]) \u2013 Whether to retrieve only completed validations.\nsearch (Optional[str], optional) \u2013 String for filtering validations.\nValidations that contain the string in name will be returned.\nsort (Optional[str], optional) \u2013 Property to sort validations by.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. sort=\u2019-name\u2019.\nCurrently supported options are listed in ListCustomModelValidationsSortQueryParams\nbut the values can differ with different platform versions.\nBy default, the sort parameter is None which will result in\nvalidations being returned in order of creation time descending.\nReturn type:\nList[CustomModelValidation]\nclassmethod revalidate(validation_id)\uf0c1\nRevalidate an unlinked custom model vector database or LLM.\nThis method is helpful when a deployment used as vector database or LLM is accidentally\nreplaced with another model that stopped complying with the response schema requirements.\nReplace the deployment\u2019s model with a complying model and call this method instead of\ncreating a new custom model validation from scratch.\nAnother application is if the API token used to create a validation record got revoked and\nno longer can be used to call the deployment.\nCalling revalidate will update the validation record with the token currently in use.\nParameters:\nvalidation_id (str) \u2013 The ID of the CustomModelValidation for revalidation.\nReturn type:\nCustomModelValidation\ndelete()\uf0c1\nDelete the custom model validation.\nReturn type:\nNone\nclass datarobot.models.genai.custom_model_llm_validation.CustomModelLLMValidation\uf0c1\nValidation record checking the ability of the deployment to serve\nas a custom model LLM.\nVariables:\nid (str) \u2013 The ID of the validation.\nprompt_column_name (str) \u2013 The name of the column the deployed model uses for prompt text input.\ntarget_column_name (str) \u2013 The name of the column the deployed model uses for prediction output.\nchat_model_id (Optional[str]) \u2013 The model ID to specify when calling the chat completion API of the deployment.\ndeployment_id (str) \u2013 The ID of the deployment.\nmodel_id (str) \u2013 The ID of the underlying deployed model, which can be found using Deployment.model[\u201cid\u201d].\nvalidation_status (str) \u2013 Can be TESTING, FAILED, or PASSED. Only PASSED is allowed for use.\ndeployment_access_data (dict, optional) \u2013 The data that will be used for accessing the deployment prediction server.\nThis field is only available for deployments that pass validation.\nDict fields are as follows:\n- prediction_api_url - The URL for the deployment prediction server.\n- datarobot_key - The first of two auth headers for the prediction server.\n- authorization_header - The second of two auth headers for the prediction server.\n- input_type - The input type the model expects, either JSON or CSV.\n- model_type - The target type of the deployed custom model.\ntenant_id (str) \u2013 The creating user\u2019s tenant ID.\nname (str) \u2013 The display name of the validated custom model.\ncreation_date (str) \u2013 The creation date of the validation (ISO 8601 formatted).\nuser_id (str) \u2013 The ID of the creating user.\nerror_message (Optional[str]) \u2013 Additional information for the errored validation.\ndeployment_name (Optional[str]) \u2013 The name of the validated deployment.\nuser_name (Optional[str]) \u2013 The name of the creating user.\nuse_case_id (Optional[str]) \u2013 The ID of the Use Case associated with the validation.\nprediction_timeout (int) \u2013 The timeout in seconds for the prediction API used in this custom model validation.\nclassmethod create(deployment_id, model=None, use_case=None, name=None, wait_for_completion=False, prediction_timeout=None, prompt_column_name=None, target_column_name=None, chat_model_id=None)\uf0c1\nStart the validation of the deployment that will serve as an LLM.\nParameters:\ndeployment_id (Union[Deployment, str]) \u2013 The deployment to validate, either Deployment or the deployment ID.\nmodel (Optional[Union[Model, str]], optional) \u2013 The specific model within the deployment, either Model or the model ID.\nIf not specified, the underlying model ID will be automatically derived from the\ndeployment information.\nuse_case (Optional[Union[UseCase, str]], optional) \u2013 The Use Case to link the validation to, either UseCase or the Use Case ID.\nname (Optional[str], optional) \u2013 The name of the validation.\nwait_for_completion (bool) \u2013 If set to True, the code will wait for the validation job to complete before returning\nresults. If the job does not finish in 10 minutes, this method call raises a timeout\nerror.\nIf set to False, the code does not wait for the job to complete. Instead,\nCustomModelLLMValidation.get can be used to poll for the status of the job using\nthe validation ID returned by the method.\nprediction_timeout (Optional[int], optional) \u2013 The timeout, in seconds, for the prediction API used in this custom model validation.\nprompt_column_name (Optional[str], optional) \u2013 The name of the column the deployed model uses for prompt text input.\nThis value is used to call the Prediction API of the deployment.\nFor LLM deployments that support the chat completion API, it is recommended to\nspecify chatModelId instead.\ntarget_column_name (Optional[str], optional) \u2013 The name of the column the deployed model uses for prediction output.\nThis value is used to call the Prediction API of the deployment.\nFor LLM deployments that support the chat completion API, it is recommended to\nspecify chatModelId instead.\nchat_model_id (Optional[str], optional) \u2013 The model ID to specify when calling the chat completion API of the deployment.\nIf this parameter is specified, the deployment must support the chat completion API.\nReturn type:\nCustomModelLLMValidation\nupdate(name=None, prompt_column_name=None, target_column_name=None, chat_model_id=None, deployment=None, model=None, prediction_timeout=None)\uf0c1\nUpdate a custom model validation.\nParameters:\nname (Optional[str], optional) \u2013 The new name of the custom model validation.\nprompt_column_name (Optional[str], optional) \u2013 The new name of the prompt column.\ntarget_column_name (Optional[str], optional) \u2013 The new name of the target column.\nchat_model_id (Optional[str], optional) \u2013 The new model ID to specify when calling the chat completion API of the deployment.\ndeployment (Optional[Union[Deployment, str]]) \u2013 The new deployment to validate.\nmodel (Optional[Union[Model, str]], optional) \u2013 The new model within the deployment to validate.\nprediction_timeout (Optional[int], optional) \u2013 The new timeout, in seconds, for the prediction API used in this custom model validation.\nReturn type:\nCustomModelLLMValidation\nclass datarobot.models.genai.llm_blueprint.LLMBlueprint\uf0c1\nMetadata for a DataRobot GenAI LLM blueprint.\nVariables:\nid (str) \u2013 The LLM blueprint ID.\nname (str) \u2013 The LLM blueprint name.\ndescription (str) \u2013 A description of the LLM blueprint.\nis_saved (bool) \u2013 Whether the LLM blueprint is saved (meaning the settings are locked\nand blueprint is eligible for use with ComparisonPrompts).\nis_starred (bool) \u2013 Whether the LLM blueprint is starred.\nplayground_id (str) \u2013 The ID of the playground associated with the LLM blueprint.\nllm_id (str or None) \u2013 The ID of the LLM type. If not None, this must be one of the IDs returned by LLMDefinition.list\nfor this user.\nllm_name (str or None) \u2013 The name of the LLM.\nllm_settings (dict or None) \u2013 The LLM settings for the LLM blueprint. The specific keys allowed and the\nconstraints on the values are defined in the response from LLMDefinition.list\nbut this typically has dict fields:\n- system_prompt - The system prompt that tells the LLM how to behave.\n- max_completion_length - The maximum number of tokens in the completion.\n- temperature - Controls the variability in the LLM response.\n- top_p - Whether the model considers next tokens with top_p probability mass.\nOr\n- system_prompt - The system prompt that tells the LLM how to behave.\n- validation_id - The ID of the external model LLM validation.\n- external_llm_context_size - The external LLM\u2019s context size, in tokens,\nfor external model LLM blueprints.\ncreation_date (str) \u2013 The date the playground was created.\ncreation_user_id (str) \u2013 The ID of the user creating the playground.\ncreation_user_name (str) \u2013 The name of the user creating the playground.\nlast_update_date (str) \u2013 The date the playground was last updated.\nlast_update_user_id (str) \u2013 The ID of the user who most recently updated the playground.\nprompt_type (PromptType) \u2013 The prompting strategy for the LLM blueprint.\nCurrently supported options are listed in PromptType.\nvector_database_id (str or None) \u2013 The ID of the vector database, if any, associated with the LLM blueprint.\nvector_database_settings (VectorDatabaseSettings or None) \u2013 The settings for the vector database, if any, associated with the LLM blueprint.\nvector_database_name (str or None) \u2013 The name of the vector database associated with the LLM blueprint, if any.\nvector_database_status (str or None) \u2013 The status of the vector database, if any, associated with the LLM blueprint.\nvector_database_error_message (str or None) \u2013 The error message for the vector database, if any, associated with the LLM blueprint.\nvector_database_error_resolution (str or None) \u2013 The resolution for the vector database error, if any, associated with the LLM blueprint.\ncustom_model_llm_validation_status (str or None) \u2013 The status of the custom model LLM validation if the llm_id is \u2018custom-model\u2019.\ncustom_model_llm_error_message (str or None) \u2013 The error message for the custom model LLM, if any.\ncustom_model_llm_error_resolution (str or None) \u2013 The resolution for the custom model LLM error, if any.\nclassmethod create(playground, name, prompt_type=PromptType.CHAT_HISTORY_AWARE, description='', llm=None, llm_settings=None, vector_database=None, vector_database_settings=None)\uf0c1\nCreate a new LLM blueprint.\nParameters:\nplayground (Playground or str) \u2013 The playground associated with the created LLM blueprint.\nAccepts playground or playground ID.\nname (str) \u2013 The LLM blueprint name.\nprompt_type (PromptType, optional) \u2013 Prompting type of the LLM blueprint, by default PromptType.CHAT_HISTORY_AWARE.\ndescription (Optional[str]) \u2013 An optional description for the LLM blueprint, otherwise null.\nllm (LLMDefinition, str, or None, optional) \u2013 The LLM to use for the blueprint, either LLMDefinition or LLM ID.\nllm_settings (dict or None) \u2013 The LLM settings for the LLM blueprint. The specific keys allowed and the\nconstraints on the values are defined in the response from LLMDefinition.list\nbut this typically has dict fields:\n- system_prompt - The system prompt that tells the LLM how to behave.\n- max_completion_length - The maximum number of tokens in the completion.\n- temperature - Controls the variability in the LLM response.\n- top_p - Whether the model considers next tokens with top_p probability mass.\nOr\n- system_prompt - The system prompt that tells the LLM how to behave.\n- validation_id - The ID of the custom model LLM validation\nfor custom model LLM blueprints.\nvector_database (VectorDatabase, str, or None, optional) \u2013 The vector database to use with this LLM blueprint, either\nVectorDatabase or vector database ID.\nvector_database_settings (VectorDatabaseSettings or None, optional) \u2013 The settings for the vector database, if any.\nReturns:\nllm_blueprint \u2013 The created LLM blueprint.\nReturn type:\nLLMBlueprint\nclassmethod create_from_llm_blueprint(llm_blueprint, name, description='')\uf0c1\nCreate a new LLM blueprint from an existing LLM blueprint.\nParameters:\nllm_blueprint (LLMBlueprint or str) \u2013 The LLM blueprint to use to create the new LLM blueprint.\nAccepts LLM blueprint or LLM blueprint ID.\nname (str) \u2013 LLM blueprint name.\ndescription (Optional[str]) \u2013 Description of the LLM blueprint, by default \u201c\u201d.\nReturns:\nllm_blueprint \u2013 The created LLM blueprint.\nReturn type:\nLLMBlueprint\nclassmethod get(llm_blueprint_id)\uf0c1\nRetrieve a single LLM blueprint.\nParameters:\nllm_blueprint_id (str) \u2013 The ID of the LLM blueprint you want to retrieve.\nReturns:\nllm_blueprint \u2013 The requested LLM blueprint.\nReturn type:\nLLMBlueprint\nclassmethod list(playground=None, llms=None, vector_databases=None, is_saved=None, is_starred=None, sort=None)\uf0c1\nLists all LLM blueprints available to the user. If the playground is specified, then the\nresults are restricted to the LLM blueprints associated with the playground. If the\nLLMs are specified, then the results are restricted to the LLM blueprints using those\nLLM types. If vector_databases are specified, then the results are restricted to the\nLLM blueprints using those vector databases.\nParameters:\nplayground (Optional[Union[Playground, str]], optional) \u2013 The returned LLM blueprints are filtered to those associated with a specific playground\nif it is specified. Accepts either the entity or the ID.\nllms (Optional[list[Union[LLMDefinition, str]]], optional) \u2013 The returned LLM blueprints are filtered to those associated with the LLM types\nspecified. Accepts either the entity or the ID.\nvector_databases (Optional[list[Union[VectorDatabase, str]]], optional) \u2013 The returned LLM blueprints are filtered to those associated with the vector databases\nspecified. Accepts either the entity or the ID.\nis_saved (Optional[bool], optional) \u2013 The returned LLM blueprints are filtered to those matching is_saved.\nis_starred (Optional[bool], optional) \u2013 The returned LLM blueprints are filtered to those matching is_starred.\nsort (Optional[str]) \u2013 Property to sort LLM blueprints by.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. sort=\u2019-creationDate\u2019.\nCurrently supported options are listed in ListLLMBlueprintsSortQueryParams\nbut the values can differ with different platform versions.\nBy default, the sort parameter is None which will result in\nLLM blueprints being returned in order of creation time descending.\nReturns:\nplaygrounds \u2013 A list of playgrounds available to the user.\nReturn type:\nlist[Playground]\nupdate(name=None, description=None, llm=None, llm_settings=None, vector_database=None, vector_database_settings=None, is_saved=None, is_starred=None, prompt_type=None, remove_vector_database=False)\uf0c1\nUpdate the LLM blueprint.\nParameters:\nname (str or None, optional) \u2013 The new name for the LLM blueprint.\ndescription (str or None, optional) \u2013 The new description for the LLM blueprint.\nllm (Optional[Union[LLMDefinition, str]], optional) \u2013 The new LLM type for the LLM blueprint.\nllm_settings (Optional[dict], optional) \u2013 The new LLM settings for the LLM blueprint. These must match the LLMSettings\nreturned from the LLMDefinition.list method for the LLM type used for this\nLLM blueprint but this typically has dict fields:\n- system_prompt - The system prompt that tells the LLM how to behave.\n- max_completion_length - The maximum number of tokens in the completion.\n- temperature - Controls the variability in the LLM response.\n- top_p - Whether the model considers next tokens with top_p probability mass.\nOr\n- system_prompt - The system prompt that tells the LLM how to behave.\n- validation_id - The ID of the custom model LLM validation\nfor custom model LLM blueprints.\nvector_database (Optional[Union[VectorDatabase, str]], optional) \u2013 The new vector database for the LLM blueprint.\nvector_database_settings (Optional[VectorDatabaseSettings], optional) \u2013 The new vector database settings for the LLM blueprint.\nis_saved (Optional[bool], optional) \u2013 The new is_saved attribute for the LLM blueprint (meaning the settings\nare locked and blueprint is eligible for use with ComparisonPrompts).\nis_starred (Optional[bool], optional) \u2013 The new setting for whether the LLM blueprint is starred.\nprompt_type (PromptType, optional) \u2013 The new prompting type of the LLM blueprint.\nremove_vector_database (Optional[bool], optional) \u2013 Whether to remove the vector database from the LLM blueprint.\nReturns:\nllm_blueprint \u2013 The updated LLM blueprint.\nReturn type:\nLLMBlueprint\ndelete()\uf0c1\nDelete the single LLM blueprint.\nReturn type:\nNone\nregister_custom_model(prompt_column_name=None, target_column_name=None, llm_test_configuration_ids=None, vector_database_default_prediction_server_id=None, vector_database_prediction_environment_id=None, vector_database_maximum_memory=None, vector_database_resource_bundle_id=None, vector_database_replicas=None, vector_database_network_egress_policy=None)\uf0c1\nCreate a new CustomModelVersion. This registers a custom model from the LLM blueprint.\nIf this LLM Blueprint uses a vector database and that vector database is not yet deployed,\nthis will also deploy that vector database.\nParameters:\nprompt_column_name (Optional[str]) \u2013 The column name of the prompt text.\ntarget_column_name (Optional[str]) \u2013 The column name of the response text.\nllm_test_configuration_ids (List[str], optional) \u2013 The IDs of the LLM test configurations to execute.\nvector_database_default_prediction_server_id (Optional[str]) \u2013 Only used if a new vector database is deployed. An identifier of a prediction server\nto be used as the default prediction server by the vector database. When working with\nprediction environments, default_prediction_server_id should not be provided.\nvector_database_prediction_environment_id (Optional[str]) \u2013 Only used if a new vector database is deployed. The identifier of the prediction\nenvironment to be used by the vector database.\nvector_database_maximum_memory (Optional[int]) \u2013 Only used if a new vector database is deployed. The maximum memory that will be\nallocated to the vector database.\nvector_database_resource_bundle_id (Optional[str]) \u2013 Only used if a new vector database is deployed. The ID of a\ndatarobot.models.resource_bundle.ResourceBundle that will be used by the vector\ndatabase.\nvector_database_replicas (Optional[int]) \u2013 Only used if a new vector database is deployed. The number of replicas to be deployed\nfor the vector database.\nvector_database_network_egress_policy (Optional[str]) \u2013 Only used if a new vector database is deployed. Determines whether the new vector\ndatabase deployment is isolated or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE,\ndatarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nReturns:\ncustom_model \u2013 The registered custom model.\nReturn type:\nCustomModelVersion\nclass datarobot.models.genai.llm.LLMDefinition\uf0c1\nMetadata for a DataRobot GenAI LLM.\nVariables:\nid (str) \u2013 Language model type ID.\nname (str) \u2013 Language model name.\ndescription (str) \u2013 Description of the language model.\nvendor (str) \u2013 Name of the vendor for this model.\nlicense (str) \u2013 License for this model.\nsupported_languages (str) \u2013 Languages supported by this model.\nsettings (list of LLMSettingDefinition) \u2013 Settings for this model\ncontext_size (int) \u2013 The context size for this model\nretirement_date (datetime.date, optional) \u2013 When the LLM is expected to be retired and no longer\navailable for submitting new prompts.\nis_deprecated (bool, optional) \u2013 Whether the LLM is deprecated and will be removed when\nit is past the retirement date.\nis_active (bool, optional) \u2013 Whether the LLM is active.\nclassmethod list(use_case=None, as_dict=True)\uf0c1\nList all large language models (LLMs) available to the user.\nParameters:\nuse_case (Optional[UseCase or str], optional) \u2013 The returned LLMs, including external LLMs, available\nfor the specified Use Case.\nAccepts either the entity or the Use CaseID.\nReturns:\nllms \u2013 A list of large language models (LLMs) available to the user.\nReturn type:\nlist[LLMDefinition] or list[LLMDefinitionDict]\nclass datarobot.models.genai.llm.LLMDefinitionDict\uf0c1\nDict representation of LLMDefinition.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-vector-databases.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "Union[CustomModelValidation",
        "CustomModelValidation",
        "CustomModelValidation",
        "List[CustomModelValidation]",
        "CustomModelValidation",
        "CustomModelLLMValidation",
        "CustomModelLLMValidation"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-moderation.html",
      "title": "Generative AI Moderation\uf0c1",
      "description": "Details of overall moderation configuration for a model.",
      "content": "Generative AI Moderation\uf0c1\nclass datarobot.models.moderation.configuration.ModerationConfiguration\uf0c1\nDetails of overall moderation configuration for a model.\nclassmethod get(config_id)\uf0c1\nGet a guard configuration by ID.\nAdded in version v3.6.\nParameters:\nconfig_id (str) \u2013 ID of the configuration\nReturns:\nretrieved configuration\nReturn type:\nModerationConfiguration\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nclassmethod list(entity_id, entity_type)\uf0c1\nList Guard Configurations.\nAdded in version v3.6.\nParameters:\nentity_id (str) \u2013 ID of the entity\nentity_type (ModerationGuardEntityType) \u2013 Type of the entity\nReturns:\na list of configurations\nReturn type:\nList[ModerationConfiguration]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create(template_id, name, description, stages, entity_id, entity_type, intervention=None, llm_type=None, deployment_id=None, model_info=None, nemo_info=None, openai_api_key='', openai_api_base='', openai_deployment_id='', openai_credential='')\uf0c1\nCreate a configuration. This is not a full create from scratch; it\u2019s based on a template.\nAdded in version v3.6.\nParameters:\ntemplate_id (str) \u2013 ID of the template to base this configuration on.\nname (str) \u2013 name of the configuration.\ndescription (str) \u2013 description of the configuration.\nstages (List[ModerationGuardStage]) \u2013 the stages of moderation where this guard is active\nentity_id (str) \u2013 ID of the custom model version or playground this configuration applies to.\nentity_type (ModerationGuardEntityType) \u2013 Type of the associated entity_id\nllm_type (Optional[ModerationGuardLlmType]) \u2013 the backing LLM this guard uses.\nnemo_info (Optional[GuardNemoInfo]) \u2013 additional configuration for NeMo Guardrails guards.\nmodel_info (Optional[GuardModelInfo]) \u2013 additional configuration for guards using a deployed model.\nintervention (Optional[GuardInterventionForConfiguration]) \u2013 the assessment conditions, and action the guard should take if conditions are met.\nopenai_api_key (str) \u2013 Token to use for OpenAI. Deprecated; use openai_credential instead.\nopenai_api_base (Optional[str]) \u2013 Base of the OpenAI connection\nopenai_deployment_id (Optional[str]) \u2013 ID of the OpenAI deployment\nopenai_credential (Optional[str]) \u2013 ID of the credential defined in DataRobot for OpenAI.\nReturns:\ncreated ModerationConfiguration\nReturn type:\nModerationConfiguration\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(name=None, description=None, intervention=None, llm_type=None, deployment_id=None, model_info=None, nemo_info=None, openai_api_key='', openai_api_base='', openai_deployment_id='', openai_credential='')\uf0c1\nUpdate configuration. All fields are optional, and omitted fields are left unchanged.\nentity_id, entity_type, and stages cannot be modified for a guard configuration,.\nAdded in version v3.6.\nParameters:\nname (str) \u2013 name of the configuration.\ndescription (str) \u2013 description of the configuration.\nllm_type (Optional[ModerationGuardLlmType]) \u2013 the backing LLM this guard uses.\nnemo_info (Optional[GuardNemoInfo]) \u2013 additional configuration for NeMo Guardrails guards.\nmodel_info (Optional[GuardModelInfo]) \u2013 additional configuration for guards using a deployed model.\nintervention (Optional[GuardInterventionForConfiguration]) \u2013 the assessment conditions, and action the guard should take if conditions are met.\nopenai_api_key (str) \u2013 Token to use for OpenAI. Deprecated; use openai_credential instead.\nopenai_api_base (Optional[str]) \u2013 Base of the OpenAI connection\nopenai_deployment_id (Optional[str]) \u2013 ID of the OpenAI deployment\nopenai_credential (Optional[str]) \u2013 ID of the credential defined in DataRobot for OpenAI.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\nrefresh()\uf0c1\nUpdate OverallModerationConfig with the latest data from server.\n:rtype: None\nAdded in version v3.6.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndelete()\uf0c1\nDelete configuration.\n:rtype: None\nAdded in version v3.6.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nclass datarobot.models.moderation.intervention.GuardInterventionCondition\uf0c1\nDefines a condition for intervention.\nclass datarobot.models.moderation.intervention.GuardInterventionForTemplate\uf0c1\nDefines the intervention conditions and actions a guard can take.\nConfiguration schema differs slightly from template because changes were requested after\ntemplates were baked in.\nclassmethod ensure_object(maybe_dict)\uf0c1\nintervention may arrive as an object, or as a dict. Return an object.\nReturn type:\nGuardInterventionForTemplate\nclass datarobot.models.moderation.intervention.GuardInterventionForConfiguration\uf0c1\nDefines the intervention conditions and actions a guard can take.\nConfiguration schema differs slightly from template because changes were requested after\ntemplates were baked in.\nclassmethod ensure_object(maybe_dict)\uf0c1\nintervention may arrive as an object, or as a dict. Return an object.\nReturn type:\nGuardInterventionForConfiguration\nclass datarobot.models.moderation.model_info.GuardModelInfo\uf0c1\nModel information for moderation templates and configurations.\nOmitted optional values are stored and presented as:\n* []  (for class names)\n* None  (all others)\nto_dict()\uf0c1\nConvert the model information object to a dictionary.\nReturn type:\nDict[str, Union[str, List[str], None]]\nclassmethod ensure_object(maybe_dict)\uf0c1\nintervention may arrive as an object, or as a dict. Return an object.\nReturn type:\nGuardModelInfo\nclass datarobot.models.moderation.model_version_update.ModelVersionUpdate\uf0c1\nImplements the operation provided by \u201cSave Configuration\u201d in moderation UI.\nAll guard configurations and overall config is saved to a new custom model version.\nclassmethod new_custom_model_version_with_config(custom_model_id, overall_config, configs)\uf0c1\nCreate a new custom model version with the provided moderation configuration\n:type custom_model_id: str\n:param custom_model_id:\n:type overall_config: OverallModerationConfig\n:param overall_config:\n:type configs: List[ModerationConfiguration]\n:param configs:\nReturn type:\nID of the new custom model version.\nclass datarobot.models.moderation.nemo_info.GuardNemoInfo\uf0c1\nDetails of a NeMo Guardrails moderation guard.\nclass datarobot.models.moderation.overall.OverallModerationConfig\uf0c1\nDetails of overall moderation configuration for a model.\nclassmethod find(entity_id, entity_type)\uf0c1\nFind overall configuration by entity ID and entity type.\nEach entity (such as a customModelVersion) may have at most 1 overall moderation configuration.\nAdded in version v3.6.\nParameters:\nentity_id (str) \u2013 ID of the entity\nentity_type (str) \u2013 Type of the entity\nReturns:\nan OverallModerationConfig or None\nReturn type:\nOptional[OverallModerationConfig]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod locate(entity_id, entity_type)\uf0c1\nFind overall configuration by entity ID and entity type.\nThis version of find() expects the object to exist. Its return type is not optional.\nAdded in version v3.6.\nParameters:\nentity_id (str) \u2013 ID of the entity\nentity_type (str) \u2013 Type of the entity\nReturns:\na list of OverallModerationConfig\nReturn type:\nList[OverallModerationConfig]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create(timeout_sec, timeout_action, entity_id, entity_type)\uf0c1\nCreate an OverallModerationConfig.\nAdded in version v3.6.\nParameters:\ntimeout_sec (int) \u2013 how long to wait for all moderation tasks in a phase to complete.\ntimeout_action (ModerationTimeoutActionType) \u2013 what to do if moderation times out.\nentity_id (str) \u2013 entity, such as customModelVersion, that this configuration applies to.\nentity_type (ModerationGuardEntityType) \u2013 type of the entity defined by entity_id\nReturns:\ncreated OverallModerationConfig\nReturn type:\nOverallModerationConfig\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(timeout_sec, timeout_action, entity_id, entity_type)\uf0c1\nUpdate an OverallModerationConfig.\nAdded in version v3.6.\nParameters:\ntimeout_sec (int) \u2013 how long to wait for all moderation tasks in a phase to complete.\ntimeout_action (ModerationTimeoutActionType) \u2013 what to do if moderation times out.\nentity_id (str) \u2013 entity, such as customModelVersion, that this configuration applies to.\nentity_type (ModerationGuardEntityType) \u2013 type of the entity defined by entity_id\nReturns:\ncreated OverallModerationConfig\nReturn type:\nOverallModerationConfig\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nrefresh()\uf0c1\nUpdate OverallModerationConfig with the latest data from server.\n:rtype: None\nAdded in version v3.6.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclass datarobot.models.moderation.template.ModerationTemplate\uf0c1\nA DataRobot Moderation Template.\nAdded in version v3.6.\nVariables:\nid (str) \u2013 ID of the Template\nname (str) \u2013 Template name\nclassmethod get(template_id)\uf0c1\nGet Template by id.\nAdded in version v3.6.\nParameters:\ntemplate_id (str) \u2013 ID of the Template\nReturns:\nretrieved Template\nReturn type:\nModerationTemplate\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nclassmethod list()\uf0c1\nList Templates.\nAdded in version v3.6.\nParameters:\nyet (none)\nReturns:\na list of Templates\nReturn type:\nList[ModerationTemplate]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod find(name)\uf0c1\nFind Template by name.\nAdded in version v3.6.\nParameters:\nname (str) \u2013 name of the Template\nReturns:\na list of Templates\nReturn type:\nList[ModerationTemplate]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create(name, description, type, allowed_stages, intervention=None, ootb_type=None, llm_type=None, model_info=None, nemo_info=None)\uf0c1\nCreate a Template.\nAdded in version v3.6.\nParameters:\nname (str) \u2013 name of the template.\ndescription (str) \u2013 description of the template.\ntype (GuardType) \u2013 type of the template.\nallowed_stages (List[ModerationGuardStage]) \u2013 the stages of moderation this guard is allowed to be used\nootb_type (ModerationGuardOotbType) \u2013 for guards of type \u201cootb\u201d, the specific \u201cOut of the Box\u201d metric type.\nllm_type (Optional[ModerationGuardLlmType]) \u2013 the backing LLM this guard uses.\nnemo_info (Optional[GuardNemoInfo]) \u2013 additional configuration for NeMo Guardrails guards.\nmodel_info (Optional[GuardModelInfo]) \u2013 additional configuration for guards using a deployed model.\nintervention (Optional[GuardInterventionForTemplate]) \u2013 the assessment conditions, and action the guard should take if conditions are met.\nReturns:\ncreated Template\nReturn type:\nModerationTemplate\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(name=None, description=None, type=None, allowed_stages=None, intervention=None, ootb_type=None, llm_type=None, model_info=None, nemo_info=None)\uf0c1\nUpdate Template. All fields are optional, and omitted fields are left unchanged.\nAdded in version v3.6.\nParameters:\nname (str) \u2013 name of the template.\ndescription (str) \u2013 description of the template.\ntype (GuardType) \u2013 type of the template.\nallowed_stages (List[ModerationGuardStage]) \u2013 the stages of moderation this guard is allowed to be used\nootb_type (ModerationGuardOotbType) \u2013 for guards of type \u201cootb\u201d, the specific \u201cOut of the Box\u201d metric type.\nllm_type (Optional[ModerationGuardLlmType]) \u2013 the backing LLM this guard uses.\nnemo_info (Optional[GuardNemoInfo]) \u2013 additional configuration for NeMo Guardrails guards.\nmodel_info (Optional[GuardModelInfo]) \u2013 additional configuration for guards using a deployed model.\nintervention (Optional[GuardInterventionForTemplate]) \u2013 the assessment conditions, and action the guard should take if conditions are met.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\nrefresh()\uf0c1\nUpdate Template with the latest data from server.\n:rtype: None\nAdded in version v3.6.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndelete()\uf0c1\nDelete Template.\n:rtype: None\nAdded in version v3.6.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "the new custom model version."
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
      "title": "DataRobot Models\uf0c1",
      "description": "GenericModel [ModelRecord] is the object which is returned from /modelRecords list route.\nContains most generic model information.",
      "content": "DataRobot Models\uf0c1\nGeneric models\uf0c1\nclass datarobot.models.GenericModel\uf0c1\nGenericModel [ModelRecord] is the object which is returned from /modelRecords list route.\nContains most generic model information.\nModels\uf0c1\nclass datarobot.models.Model\uf0c1\nA model trained on a project\u2019s dataset capable of making predictions.\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nSee datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nid (str) \u2013 ID of the model.\nproject_id (str) \u2013 ID of the project the model belongs to.\nprocesses (List[str]) \u2013 Processes used by the model.\nfeaturelist_name (str) \u2013 Name of the featurelist used by the model.\nfeaturelist_id (str) \u2013 ID of the featurelist used by the model.\nsample_pct (float or None) \u2013 Percentage of the project dataset used in model training. If the project uses\ndatetime partitioning, the sample_pct will be None.  See training_row_count,\ntraining_duration, and training_start_date / training_end_date instead.\ntraining_row_count (int or None) \u2013 Number of rows of the project dataset used in model training.  In a datetime\npartitioned project, if specified, defines the number of rows used to train the model and\nevaluate backtest scores; if unspecified, either training_duration or\ntraining_start_date and training_end_date is used for training_row_count.\ntraining_duration (str or None) \u2013 For datetime partitioned projects only. If specified, defines the duration spanned by the data used to train\nthe model and evaluate backtest scores.\ntraining_start_date (datetime or None) \u2013 For frozen models in datetime partitioned projects only. If specified, the start\ndate of the data used to train the model.\ntraining_end_date (datetime or None) \u2013 For frozen models in datetime partitioned projects only. If specified, the end\ndate of the data used to train the model.\nmodel_type (str) \u2013 Type of model, for example \u2018Nystroem Kernel SVM Regressor\u2019.\nmodel_category (str) \u2013 Category of model, for example \u2018prime\u2019 for DataRobot Prime models, \u2018blend\u2019 for blender models, and\n\u2018model\u2019 for other models.\nis_frozen (bool) \u2013 Whether this model is a frozen model.\nis_n_clusters_dynamically_determined (bool) \u2013 (New in version v2.27) Optional. Whether this model determines the number of clusters dynamically.\nblueprint_id (str) \u2013 ID of the blueprint used to build this model.\nmetrics (dict) \u2013 Mapping from each metric to the model\u2019s score for that metric.\nmonotonic_increasing_featurelist_id (str) \u2013 Optional. ID of the featurelist that defines the set of features with\na monotonically increasing relationship to the target.\nIf None, no such constraints are enforced.\nmonotonic_decreasing_featurelist_id (str) \u2013 Optional. ID of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target.\nIf None, no such constraints are enforced.\nn_clusters (int) \u2013 (New in version v2.27) Optional. Number of data clusters discovered by model.\nhas_empty_clusters (bool) \u2013 (New in version v2.27) Optional. Whether clustering model produces empty clusters.\nsupports_monotonic_constraints (bool) \u2013 Optional. Whether this model supports enforcing monotonic constraints.\nis_starred (bool) \u2013 Whether this model is marked as a starred model.\nprediction_threshold (float) \u2013 Binary classification projects only. Threshold used for predictions.\nprediction_threshold_read_only (bool) \u2013 Whether modification of the prediction threshold is forbidden. Threshold\nmodification is forbidden once a model has had a deployment created or predictions made via\nthe dedicated prediction API.\nmodel_number (integer) \u2013 Model number assigned to the model.\nparent_model_id (str or None) \u2013 (New in version v2.20) ID of the model that tuning parameters are derived from.\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nWhether this model is supported Composable ML.\nclassmethod get(project, model_id)\uf0c1\nRetrieve a specific model.\nParameters:\nproject (str) \u2013 Project ID.\nmodel_id (str) \u2013 ID of the model to retrieve.\nReturns:\nmodel \u2013 Queried instance.\nReturn type:\nModel\nRaises:\nValueError \u2013 passed project parameter value is of not supported type\nadvanced_tune(params, description=None)\uf0c1\nGenerate a new model with the specified advanced-tuning parameters\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nParameters:\nparams (dict) \u2013 Mapping of parameter ID to parameter value.\nThe list of valid parameter IDs for a model can be found by calling\nget_advanced_tuning_parameters().\nThis endpoint does not need to include values for all parameters.  If a parameter\nis omitted, its current_value will be used.\ndescription (str) \u2013 Human-readable string describing the newly advanced-tuned model\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ncontinue_incremental_learning_from_incremental_model(chunk_definition_id, early_stopping_rounds=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nchunk_definition_id (str) \u2013 The Mongo ID for the chunking service.\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks that, when no improvement has been shown, triggers the early stopping mechanism.\nReturns:\njob \u2013 The model retraining job that is created.\nReturn type:\nModelJob\ncross_validate()\uf0c1\nRun cross validation on the model.\nNotes\nTo perform Cross Validation on a new model with new parameters, use train instead.\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ndelete()\uf0c1\nDelete a model from the project\u2019s leaderboard.\nReturn type:\nNone\ndownload_scoring_code(file_name, source_code=False)\uf0c1\nDownload the Scoring Code JAR.\nParameters:\nfile_name (str) \u2013 File path where scoring code will be saved.\nsource_code (Optional[bool]) \u2013 Set to True to download source code archive.\nIt will not be executable.\nReturn type:\nNone\ndownload_training_artifact(file_name)\uf0c1\nRetrieve trained artifact(s) from a model containing one or more custom tasks.\nArtifact(s) will be downloaded to the specified local filepath.\nParameters:\nfile_name (str) \u2013 File path where trained model artifact(s) will be saved.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverrides the inherited method since the model must _not_ recursively change casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (list) \u2013 List of attribute namespaces like: [\u2018top.middle.bottom\u2019], that should be kept\neven if their values are None\nget_advanced_tuning_parameters()\uf0c1\nGet the advanced-tuning parameters available for this model.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nA dictionary describing the advanced-tuning parameters for the current model.\nThere are two top-level keys, tuning_description and tuning_parameters.\ntuning_description an optional value. If not None, then it indicates the\nuser-specified description of this set of tuning parameter.\ntuning_parameters is a list of a dicts, each has the following keys\nparameter_name : (str) name of the parameter (unique per task, see below)\nparameter_id : (str) opaque ID string uniquely identifying parameter\ndefault_value : (*) the actual value used to train the model; either\nthe single value of the parameter specified before training, or the best\nvalue from the list of grid-searched values (based on current_value)\ncurrent_value : (*) the single value or list of values of the\nparameter that were grid searched. Depending on the grid search\nspecification, could be a single fixed value (no grid search),\na list of discrete values, or a range.\ntask_name : (str) name of the task that this parameter belongs to\nconstraints: (dict) see the notes below\nvertex_id: (str) ID of vertex that this parameter belongs to\nReturn type:\ndict\nNotes\nThe type of default_value and current_value is defined by the constraints structure.\nIt will be a string or numeric Python type.\nconstraints is a dict with at least one, possibly more, of the following keys.\nThe presence of a key indicates that the parameter may take on the specified type.\n(If a key is absent, this means that the parameter may not take on the specified type.)\nIf a key on constraints is present, its value will be a dict containing\nall of the fields described below for that key.\n\"constraints\": {\n\"select\": {\n\"values\": [<list(basestring or number) : possible values>]\n},\n\"ascii\": {},\n\"unicode\": {},\n\"int\": {\n\"min\": <int : minimum valid value>,\n\"max\": <int : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"float\": {\n\"min\": <float : minimum valid value>,\n\"max\": <float : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"intList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <int : minimum valid value>,\n\"max_val\": <int : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"floatList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <float : minimum valid value>,\n\"max_val\": <float : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n}\n}\nThe keys have meaning as follows:\nselect:\nRather than specifying a specific data type, if present, it indicates that the parameter\nis permitted to take on any of the specified values.  Listed values may be of any string\nor real (non-complex) numeric type.\nascii:\nThe parameter may be a unicode object that encodes simple ASCII characters.\n(A-Z, a-z, 0-9, whitespace, and certain common symbols.)  In addition to listed\nconstraints, ASCII keys currently may not contain either newlines or semicolons.\nunicode:\nThe parameter may be any Python unicode object.\nint:\nThe value may be an object of type int within the specified range (inclusive).\nPlease note that the value will be passed around using the JSON format, and\nsome JSON parsers have undefined behavior with integers outside of the range\n[-(2**53)+1, (2**53)-1].\nfloat:\nThe value may be an object of type float within the specified range (inclusive).\nintList, floatList:\nThe value may be a list of int or float objects, respectively, following constraints\nas specified respectively by the int and float types (above).\nMany parameters only specify one key under constraints.  If a parameter specifies multiple\nkeys, the parameter may take on any value permitted by any key.\nget_all_confusion_charts(fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of all confusion matrices available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent for any source that is not available for this model and if this\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\nReturns:\nData for all available confusion charts for model.\nReturn type:\nlist of ConfusionChart\nget_all_feature_impacts(data_slice_filter=None)\uf0c1\nRetrieve a list of all feature impact results available for the model.\nParameters:\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen no data_slice filtering will be applied when requesting the roc_curve.\nReturns:\nData for all available model feature impacts. Or an empty list if not data found.\nReturn type:\nlist of dicts\nExamples\nmodel = datarobot.Model(id='model-id', project_id='project-id')\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()\nget_all_lift_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (Optional[bool]) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned lift chart by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model lift charts. Or an empty list if no data found.\nReturn type:\nlist of LiftChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()\nget_all_multiclass_lift_charts(fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nData for all available model lift charts.\nReturn type:\nlist of LiftChart\nget_all_residuals_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all residuals charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent\nfor any source that is not available for this model and if this model has a\ndefined parent model. If omitted or False, or this model has no parent, this will\nnot attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned residuals charts by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model residuals charts.\nReturn type:\nlist of ResidualsChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()\nget_all_roc_curves(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all ROC curves available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 filters the returned roc_curve by data_slice_filter.id.  If None (the default) applies no filter based on\ndata_slice_id.\nReturns:\nData for all available model ROC curves. Or an empty list if no RocCurves are found.\nReturn type:\nlist of RocCurve\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()\nget_confusion_chart(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a multiclass model\u2019s confusion matrix for the specified source.\nParameters:\nsource (str) \u2013 Confusion chart source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent if the confusion chart is not available for this model and the\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel ConfusionChart data\nReturn type:\nConfusionChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_cross_class_accuracy_scores()\uf0c1\nRetrieves a list of Cross Class Accuracy scores for the model.\nReturn type:\njson\nget_cross_validation_scores(partition=None, metric=None)\uf0c1\nReturn a dictionary, keyed by metric, showing cross validation\nscores per partition.\nCross Validation should already have been performed using\ncross_validate or\ntrain.\nNotes\nModels that computed cross validation before this feature was added will need\nto be deleted and retrained before this method can be used.\nParameters:\npartition (float) \u2013 optional, the id of the partition (1,2,3.0,4.0,etc\u2026) to filter results by\ncan be a whole number positive integer or float value. 0 corresponds to the\nvalidation partition.\nmetric (unicode) \u2013 optional name of the metric to filter to resulting cross validation scores by\nReturns:\ncross_validation_scores \u2013 A dictionary keyed by metric showing cross validation scores per\npartition.\nReturn type:\ndict\nget_data_disparity_insights(feature, class_name1, class_name2)\uf0c1\nRetrieve a list of Cross Class Data Disparity insights for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\nclass_name1 (str) \u2013 One of the compared classes\nclass_name2 (str) \u2013 Another compared class\nReturn type:\njson\nget_fairness_insights(fairness_metrics_set=None, offset=0, limit=100)\uf0c1\nRetrieve a list of Per Class Bias insights for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturn type:\njson\nget_feature_effect(source, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model.\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, retrieve unsliced insight data.\nReturns:\nfeature_effects \u2013 The feature effects data.\nReturn type:\nFeatureEffects\nRaises:\nClientError \u2013 If the feature effects have not been computed or source is not valid value.\nget_feature_effect_metadata()\uf0c1\nRetrieve Feature Effects metadata. Response contains status and available model sources.\nFeature Effect for the training partition is always available, with the exception of older\nprojects that only supported Feature Effect for validation.\nWhen a model is trained into validation or holdout without stacked predictions\n(i.e., no out-of-sample predictions in those partitions),\nFeature Effects is not available for validation or holdout.\nFeature Effects for holdout is not available when holdout was not unlocked for\nthe project.\nUse source to retrieve Feature Effects, selecting one of the provided sources.\nReturns:\nfeature_effect_metadata\nReturn type:\nFeatureEffectMetadata\nget_feature_effects_multiclass(source='training', class_=None)\uf0c1\nRetrieve Feature Effects for the multiclass model.\nFeature Effects provide partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (str) \u2013 The source Feature Effects are retrieved for.\nclass (str or None) \u2013 The class name Feature Effects are retrieved for.\nReturns:\nThe list of multiclass feature effects.\nReturn type:\nlist\nRaises:\nClientError \u2013 If Feature Effects have not been computed or source is not valid value.\nget_feature_impact(with_metadata=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the computed Feature Impact results, a measure of the relevance of each\nfeature in the model.\nFeature Impact is computed for each column by creating new data with that column randomly\npermuted (but the others left unchanged), and seeing how the error metric score for the\npredictions is affected. The \u2018impactUnnormalized\u2019 is how much worse the error metric score\nis when making predictions on this modified data. The \u2018impactNormalized\u2019 is normalized so\nthat the largest value is 1. In both cases, larger values indicate more important features.\nIf a feature is a redundant feature, i.e. once other features are considered it doesn\u2019t\ncontribute much in addition, the \u2018redundantWith\u2019 value is the name of feature that has the\nhighest correlation with this feature. Note that redundancy detection is only available for\njobs run after the addition of this feature. When retrieving data that predates this\nfunctionality, a NoRedundancyImpactAvailable warning will be used.\nElsewhere this technique is sometimes called \u2018Permutation Importance\u2019.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nParameters:\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_feature_impact will raise a ValueError.\nReturns:\nThe feature impact data response depends on the with_metadata parameter. The response is\neither a dict with metadata and a list with actual data or just a list with that data.\nEach List item is a dict with the keys featureName, impactNormalized, and\nimpactUnnormalized, redundantWith and count.\nFor dict response available keys are:\nfeatureImpacts - Feature Impact data as a dictionary. Each item is a dict withkeys: featureName, impactNormalized, and impactUnnormalized, and\nredundantWith.\nshapBased - A boolean that indicates whether Feature Impact was calculated usingShapley values.\nranRedundancyDetection - A boolean that indicates whether redundant featureidentification was run while calculating this Feature Impact.\nrowCount - An integer or None that indicates the number of rows that was used tocalculate Feature Impact. For the Feature Impact calculated with the default\nlogic, without specifying the rowCount, we return None here.\ncount - An integer with the number of features under the featureImpacts.\nReturn type:\nlist or dict\nRaises:\nClientError \u2013 If the feature impacts have not been computed.\nValueError \u2013 If data_slice_filter passed as None\nget_features_used()\uf0c1\nQuery the server to determine which features were used.\nNote that the data returned by this method is possibly different\nthan the names of the features in the featurelist used by this model.\nThis method will return the raw features that must be supplied in order\nfor predictions to be generated on a new set of data. The featurelist,\nin contrast, would also include the names of derived features.\nReturns:\nfeatures \u2013 The names of the features used in the model.\nReturn type:\nList[str]\nget_frozen_child_models()\uf0c1\nRetrieve the IDs for all models that are frozen from this model.\nReturn type:\nA list of Models\nget_labelwise_roc_curves(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of LabelwiseRocCurve instances for a multilabel model for the given source and all labels.\nThis method is valid only for multilabel projects. For binary projects, use Model.get_roc_curve API .\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\nReturns:\nLabelwise ROC Curve instances for source and all labels\nReturn type:\nlist of LabelwiseRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\nReturns:\nModel lift chart data\nReturn type:\nLiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_missing_report_info()\uf0c1\nRetrieve a report on missing training data that can be used to understand missing\nvalues treatment in the model. The report consists of missing values resolutions for\nfeatures numeric or categorical features that were part of building the model.\nReturns:\nThe queried model missing report, sorted by missing count (DESCENDING order).\nReturn type:\nAn iterable of MissingReportPerFeature\nget_model_blueprint_chart()\uf0c1\nRetrieve a diagram that can be used to understand\ndata flow in the blueprint.\nReturns:\nThe queried model blueprint chart.\nReturn type:\nModelBlueprintChart\nget_model_blueprint_documents()\uf0c1\nGet documentation for tasks used in this model.\nReturns:\nAll documents available for the model.\nReturn type:\nlist of BlueprintTaskDocument\nget_model_blueprint_json()\uf0c1\nGet the blueprint json representation used by this model.\nReturns:\nJson representation of the blueprint stages.\nReturn type:\nBlueprintJson\nget_multiclass_feature_impact()\uf0c1\nFor multiclass it\u2019s possible to calculate feature impact separately for each target class.\nThe method for calculation is exactly the same, calculated in one-vs-all style for each\ntarget class.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. Each item is a dict with the keys \u2018featureImpacts\u2019 (list),\n\u2018class\u2019 (str). Each item in \u2018featureImpacts\u2019 is a dict with the keys \u2018featureName\u2019,\n\u2018impactNormalized\u2019, and \u2018impactUnnormalized\u2019, and \u2018redundantWith\u2019.\nReturn type:\nlist of dict\nRaises:\nClientError \u2013 If the multiclass feature impacts have not been computed.\nget_multiclass_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_multilabel_lift_charts(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve model Lift charts for the specified source.\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_num_iterations_trained()\uf0c1\nRetrieves the number of estimators trained by early-stopping tree-based models.\n\u2013 versionadded:: v2.22\nReturns:\nprojectId (str) \u2013 id of project containing the model\nmodelId (str) \u2013 id of the model\ndata (array) \u2013 list of numEstimatorsItem objects, one for each modeling stage.\nnumEstimatorsItem will be of the form\nstage (str) \u2013 indicates the modeling stage (for multi-stage models); None of single-stage models\nnumIterations (int) \u2013 the number of estimators or iterations trained by the model\nget_or_request_feature_effect(source, max_wait=600, row_count=None, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model, requesting a new job if it hasn\u2019t been run previously.\nSee get_feature_effect_metadata\nfor retrieving information of source.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effect job to complete before erroring.\nrow_count (Optional[int]) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nfeature_effects \u2013 The Feature Effects data.\nReturn type:\nFeatureEffects\nget_or_request_feature_effects_multiclass(source, top_n_features=None, features=None, row_count=None, class_=None, max_wait=600)\uf0c1\nRetrieve Feature Effects for the multiclass model, requesting a job if it hasn\u2019t been run\npreviously.\nParameters:\nsource (string) \u2013 The source Feature Effects retrieve for.\nclass (str or None) \u2013 The class name Feature Effects retrieve for.\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by Feature Impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effects job to complete before\nerroring.\nReturns:\nfeature_effects \u2013 The list of multiclass feature effects data.\nReturn type:\nlist of FeatureEffectsMulticlass\nget_or_request_feature_impact(max_wait=600, **kwargs)\uf0c1\nRetrieve feature impact for the model, requesting a job if it hasn\u2019t been run previously\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature impact job to complete before erroring\n**kwargs \u2013 Arbitrary keyword arguments passed to\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. See\nget_feature_impact for the exact\nschema.\nReturn type:\nlist or dict\nget_parameters()\uf0c1\nRetrieve model parameters.\nReturns:\nModel parameters for this model.\nReturn type:\nModelParameters\nget_pareto_front()\uf0c1\nRetrieve the Pareto Front for a Eureqa model.\nThis method is only supported for Eureqa models.\nReturns:\nModel ParetoFront data\nReturn type:\nParetoFront\nget_prime_eligibility()\uf0c1\nCheck if this model can be approximated with DataRobot Prime\nReturns:\nprime_eligibility \u2013 a dict indicating whether a model can be approximated with DataRobot Prime\n(key can_make_prime) and why it may be ineligible (key message)\nReturn type:\ndict\nget_residuals_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible\nvalues.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent if\nthe residuals chart is not available for this model and the model has a defined parent\nmodel. If omitted or False, or there is no parent model, will not attempt to return\nresiduals data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_residuals_chart will raise a ValueError.\nReturns:\nModel residuals chart data\nReturn type:\nResidualsChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_roc_curve(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the ROC curve for a binary model for the specified source.\nThis method is valid only for binary projects. For multilabel projects, use\nModel.get_labelwise_roc_curves.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_roc_curve will raise a ValueError.\nReturns:\nModel ROC curve data\nReturn type:\nRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\n(New in version v3.0) TypeError \u2013 If the underlying project type is multilabel\nValueError \u2013 If data_slice_filter passed as None\nget_rulesets()\uf0c1\nList the rulesets approximating this model generated by DataRobot Prime\nIf this model hasn\u2019t been approximated yet, will return an empty list.  Note that these\nare rulesets approximating this model, not rulesets used to construct this model.\nReturns:\nrulesets\nReturn type:\nlist of Ruleset\nget_supported_capabilities()\uf0c1\nRetrieves a summary of the capabilities supported by a model.\nAdded in version v2.14.\nReturns:\nsupportsBlending (bool) \u2013 whether the model supports blending\nsupportsMonotonicConstraints (bool) \u2013 whether the model supports monotonic constraints\nhasWordCloud (bool) \u2013 whether the model has word cloud data available\neligibleForPrime (bool) \u2013 (Deprecated in version v3.6)\nwhether the model is eligible for Prime\nhasParameters (bool) \u2013 whether the model has parameters that can be retrieved\nsupportsCodeGeneration (bool) \u2013 (New in version v2.18) whether the model supports code generation\nsupportsShap (bool) \u2013\n(New in version v2.18) True if the model supports Shapley package. i.e. Shapley basedfeature Importance\nsupportsEarlyStopping (bool) \u2013 (New in version v2.22) True if this is an early stopping\ntree-based model and number of trained iterations can be retrieved.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this model at leaderboard.\nReturn type:\nstr\nget_word_cloud(exclude_stop_words=False)\uf0c1\nRetrieve word cloud data for the model.\nParameters:\nexclude_stop_words (Optional[bool]) \u2013 Set to True if you want stopwords filtered out of response.\nReturns:\nWord cloud data for the model.\nReturn type:\nWordCloud\nincremental_train(data_stage_id, training_data_name=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model.\nSee train_incremental documentation.\nReturn type:\nModelJob\nclassmethod list(project_id, sort_by_partition='validation', sort_by_metric=None, with_metric=None, search_term=None, featurelists=None, families=None, blueprints=None, labels=None, characteristics=None, training_filters=None, number_of_clusters=None, limit=100, offset=0)\uf0c1\nRetrieve paginated model records, sorted by scores, with optional filtering.\nParameters:\nsort_by_partition (str, one of validation, backtesting, crossValidation or holdout) \u2013 Set the partition to use for sorted (by score) list of models. validation is the default.\nsort_by_metric (str) \u2013 Set the project metric to use for model sorting. DataRobot-selected project optimization metric\nis the default.\nwith_metric (str) \u2013 For a single-metric list of results, specify that project metric.\nsearch_term (str) \u2013 If specified, only models containing the term in their name or processes are returned.\nfeaturelists (List[str]) \u2013 If specified, only models trained on selected featurelists are returned.\nfamilies (List[str]) \u2013 If specified, only models belonging to selected families are returned.\nblueprints (List[str]) \u2013 If specified, only models trained on specified blueprint IDs are returned.\nlabels (List[str], starred or prepared for deployment) \u2013 If specified, only models tagged with all listed labels are returned.\ncharacteristics (List[str]) \u2013 If specified, only models matching all listed characteristics are returned.\ntraining_filters (List[str]) \u2013 If specified, only models matching at least one of the listed training conditions are returned.\nThe following formats are supported for autoML and datetime partitioned projects:\n- number of rows in training subset\nFor datetime partitioned projects:\n- <training duration>, example P6Y0M0D\n- <training_duration>-<time_window_sample_percent>-<sampling_method> Example: P6Y0M0D-78-Random,\n(returns models trained on 6 years of data, sampling rate 78%, random sampling).\n- Start/end date\n- Project settings\nnumber_of_clusters (list of int) \u2013 Filter models by number of clusters. Applicable only in unsupervised clustering projects.\nlimit (int)\noffset (int)\nReturns:\ngeneric_models\nReturn type:\nlist of GenericModel\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nrequest_approximation()\uf0c1\nRequest an approximation of this model using DataRobot Prime\nThis will create several rulesets that could be used to approximate this model.  After\ncomparing their scores and rule counts, the code used in the approximation can be downloaded\nand run locally.\nReturns:\njob \u2013 the job generating the rulesets\nReturn type:\nJob\nrequest_cross_class_accuracy_scores()\uf0c1\nRequest data disparity insights to be computed for the model.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_data_disparity_insights(feature, compared_class_names)\uf0c1\nRequest data disparity insights to be computed for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\ncompared_class_names (list(str)) \u2013 List of two classes to compare\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_external_test(dataset_id, actual_value_column=None)\uf0c1\nRequest external test to compute scores and insights on an external test dataset\nParameters:\ndataset_id (string) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nReturns:\njob \u2013 a Job representing external dataset insights computation\nReturn type:\nJob\nrequest_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest fairness insights to be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_feature_effect(row_count=None, data_slice_id=None)\uf0c1\nSubmit request to compute Feature Effects for the model.\nSee get_feature_effect for more\ninformation on the result of the job.\nParameters:\nrow_count (int) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 A Job representing the feature effect computation. To get the completed feature effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nRaises:\nJobAlreadyRequested \u2013 If the feature effect have already been requested.\nrequest_feature_effects_multiclass(row_count=None, top_n_features=None, features=None)\uf0c1\nRequest Feature Effects computation for the multiclass model.\nSee get_feature_effect for\nmore information on the result of the job.\nParameters:\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by feature impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nReturns:\njob \u2013 A Job representing Feature Effect computation. To get the completed Feature Effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nrequest_feature_impact(row_count=None, with_metadata=False, data_slice_id=None)\uf0c1\nRequest feature impacts to be computed for the model.\nSee get_feature_impact for more\ninformation on the result of the job.\nParameters:\nrow_count (Optional[int]) \u2013 The sample size (specified in rows) to use for Feature Impact computation. This is not\nsupported for unsupervised, multiclass (which has a separate method), and time series\nprojects.\nwith_metadata (Optional[bool]) \u2013 Flag indicating whether the result should include the metadata.\nIf true, metadata is included.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 Job representing the Feature Impact computation. To retrieve the completed Feature Impact\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob or status_id\nRaises:\nJobAlreadyRequested \u2013 If the feature impacts have already been requested.\nrequest_frozen_datetime_model(training_row_count=None, training_duration=None, training_start_date=None, training_end_date=None, time_window_sample_pct=None, sampling_method=None)\uf0c1\nTrain a new frozen model with parameters from this model.\nRequires that this model belongs to a datetime partitioned project.  If it does not, an\nerror will occur when submitting the job.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nIn addition of training_row_count and training_duration, frozen datetime models may be\ntrained on an exact date range.  Only one of training_row_count, training_duration, or\ntraining_start_date and training_end_date should be specified.\nModels specified using training_start_date and training_end_date are the only ones that can\nbe trained into the holdout data (once the holdout is unlocked).\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\ntraining_duration may not be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, training_row_count may not be specified.\ntraining_start_date (datetime.datetime, optional) \u2013 the start date of the data to train to model on.  Only rows occurring at or after\nthis datetime will be used.  If training_start_date is specified, training_end_date\nmust also be specified.\ntraining_end_date (datetime.datetime, optional) \u2013 the end date of the data to train the model on.  Only rows occurring strictly before\nthis datetime will be used.  If training_end_date is specified, training_start_date\nmust also be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates).  An integer between 1 and 99 indicating the percentage to sample by\nwithin the window.  The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_frozen_model(sample_pct=None, training_row_count=None)\uf0c1\nTrain a new frozen model with parameters from this model\nNotes\nThis method only works if project the model belongs to is not datetime\npartitioned.  If it is, use request_frozen_datetime_model instead.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nParameters:\nsample_pct (float) \u2013 optional, the percentage of the dataset to use with the model.  If not provided, will\nuse the value from this model.\ntraining_row_count (int) \u2013 (New in version v2.9) optional, the integer number of rows of the dataset to use with\nthe model. Only one of sample_pct and training_row_count should be specified.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_lift_chart(source, data_slice_id=None)\uf0c1\nRequest the model Lift Chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_per_class_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest per-class fairness insights be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 The fairness metric used to calculate the fairness scores.\nValue can be any one of <datarobot.enums.FairnessMetricsSet>.\nReturns:\nstatus_check_job \u2013 The returned object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_predictions(dataset_id=None, dataset=None, dataframe=None, file_path=None, file=None, include_prediction_intervals=None, prediction_intervals_size=None, forecast_point=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, explanation_algorithm=None, max_explanations=None, max_ngram_explanations=None)\uf0c1\nRequests predictions against a previously uploaded dataset.\nParameters:\ndataset_id (string, optional) \u2013 The ID of the dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataset (Dataset, optional) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataframe (pd.DataFrame, optional) \u2013 (New in v3.0)\nThe dataframe to make predictions against\nfile_path (Optional[str]) \u2013 (New in v3.0)\nPath to file to make predictions against\nfile (IOBase, optional) \u2013 (New in v3.0)\nFile to make predictions against\ninclude_prediction_intervals (Optional[bool]) \u2013 (New in v2.16) For time series projects only.\nSpecifies whether prediction intervals should be calculated for this request. Defaults\nto True if prediction_intervals_size is specified, otherwise defaults to False.\nprediction_intervals_size (Optional[int]) \u2013 (New in v2.16) For time series projects only.\nRepresents the percentile to use for the size of the prediction intervals. Defaults to\n80 if include_prediction_intervals is True. Prediction intervals size must be\nbetween 1 and 100 (inclusive).\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The end date for bulk\npredictions, exclusive. Note that this parameter is for generating historical\npredictions using the training data. This parameter should be provided in conjunction\nwith predictions_start_date. Can\u2019t be provided with the\nforecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nexplanation_algorithm ((New in version v2.21) optional; If set to 'shap', the) \u2013 response will include prediction explanations based on the SHAP explainer (SHapley\nAdditive exPlanations). Defaults to null (no prediction explanations).\nmax_explanations ((New in version v2.21) int optional; specifies the maximum number of) \u2013 explanation values that should be returned for each row, ordered by absolute value,\ngreatest to least. If null, no limit. In the case of \u2018shap\u2019: if the number of features\nis greater than the limit, the sum of remaining values will also be returned as\nshapRemainingTotal. Defaults to null. Cannot be set if explanation_algorithm is\nomitted.\nmax_ngram_explanations (optional;\u00a0 int or str) \u2013 (New in version v2.29) Specifies the maximum number of text explanation values that\nshould be returned. If set to all, text explanations will be computed and all the\nngram explanations will be returned. If set to a non zero positive integer value, text\nexplanations will be computed and this amount of descendingly sorted ngram explanations\nwill be returned. By default text explanation won\u2019t be triggered to be computed.\nReturns:\njob \u2013 The job computing the predictions\nReturn type:\nPredictJob\nrequest_residuals_chart(source, data_slice_id=None)\uf0c1\nRequest the model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_roc_curve(source, data_slice_id=None)\uf0c1\nRequest the model Roc Curve for the specified source.\nParameters:\nsource (str) \u2013 Roc Curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_training_predictions(data_subset, explanation_algorithm=None, max_explanations=None)\uf0c1\nStart a job to build training predictions\nParameters:\ndata_subset (str) \u2013 data set definition to build predictions on.\nChoices are:\ndr.enums.DATA_SUBSET.ALL or string all for all data available. Not valid formodels in datetime partitioned projects\ndr.enums.DATA_SUBSET.VALIDATION_AND_HOLDOUT or string validationAndHoldout forall data except training set. Not valid for models in datetime partitioned\nprojects\ndr.enums.DATA_SUBSET.HOLDOUT or string holdout for holdout data set only\ndr.enums.DATA_SUBSET.ALL_BACKTESTS or string allBacktests for downloadingthe predictions for all backtest validation folds. Requires the model to have\nsuccessfully scored all backtests. Datetime partitioned projects only.\nexplanation_algorithm (dr.enums.EXPLANATIONS_ALGORITHM) \u2013 (New in v2.21) Optional. If set to dr.enums.EXPLANATIONS_ALGORITHM.SHAP, the response\nwill include prediction explanations based on the SHAP explainer (SHapley Additive\nexPlanations). Defaults to None (no prediction explanations).\nmax_explanations (int) \u2013 (New in v2.21) Optional. Specifies the maximum number of explanation values that should\nbe returned for each row, ordered by absolute value, greatest to least. In the case of\ndr.enums.EXPLANATIONS_ALGORITHM.SHAP:  If not set, explanations are returned for all\nfeatures. If the number of features is greater than the max_explanations, the sum of\nremaining values will also be returned as shap_remaining_total. Max 100. Defaults to\nnull for datasets narrower than 100 columns, defaults to 100 for datasets wider than 100\ncolumns. Is ignored if explanation_algorithm is not set.\nReturns:\nan instance of created async job\nReturn type:\nJob\nretrain(sample_pct=None, featurelist_id=None, training_row_count=None, n_clusters=None)\uf0c1\nSubmit a job to the queue to train a blender model.\nParameters:\nsample_pct (Optional[float]) \u2013 The sample size in percents (1 to 100) to use in training. If this parameter is used\nthen training_row_count should not be given.\nfeaturelist_id (Optional[str]) \u2013 The featurelist id\ntraining_row_count (Optional[int]) \u2013 The number of rows used to train the model. If this parameter is used, then sample_pct\nshould not be given.\nn_clusters (Optional[int]) \u2013 (new in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that do not determine\nthe number of clusters automatically.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nset_prediction_threshold(threshold)\uf0c1\nSet a custom prediction threshold for the model.\nMay not be used once prediction_threshold_read_only is True for this model.\nParameters:\nthreshold (float) \u2013 only used for binary classification projects. The threshold to when deciding between\nthe positive and negative classes when making predictions.  Should be between 0.0 and\n1.0 (inclusive).\nstar_model()\uf0c1\nMark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nstart_advanced_tuning_session()\uf0c1\nStart an Advanced Tuning session.  Returns an object that helps\nset up arguments for an Advanced Tuning model execution.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nSession for setting up and running Advanced Tuning on a model\nReturn type:\nAdvancedTuningSession\nstart_incremental_learning_from_sample(early_stopping_rounds=None, first_iteration_only=False, chunk_definition_id=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks in which no improvement is observed that triggers the early stopping mechanism.\nfirst_iteration_only (bool) \u2013 Specifies whether incremental learning training should be limited to the first\niteration. If set to True, the training process will be performed only for the first\niteration. If set to False, training will continue until early stopping conditions\nare met or the maximum number of iterations is reached. The default value is False.\nchunk_definition_id (str) \u2013 The id of the chunk definition to be use for incremental training.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\ntrain(sample_pct=None, featurelist_id=None, scoring_type=None, training_row_count=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>)\uf0c1\nTrain the blueprint used in model on a particular featurelist or amount of data.\nThis method creates a new training job for worker and appends it to\nthe end of the queue for this project.\nAfter the job has finished you can get the newly trained model by retrieving\nit from the project leaderboard, or by retrieving the result of the job.\nEither sample_pct or training_row_count can be used to specify the amount of data to\nuse, but not both.  If neither are specified, a default of the maximum amount of data that\ncan safely be used to train any blueprint without going into the validation data will be\nselected.\nIn smart-sampled projects, sample_pct and training_row_count are assumed to be in terms\nof rows of the minority class.\nNotes\nFor datetime partitioned projects, see train_datetime instead.\nParameters:\nsample_pct (Optional[float]) \u2013 The amount of data to use for training, as a percentage of the project dataset from\n0 to 100.\nfeaturelist_id (Optional[str]) \u2013 The identifier of the featurelist to use. If not defined, the\nfeaturelist of this model is used.\nscoring_type (Optional[str]) \u2013 Either validation or crossValidation (also dr.SCORING_TYPE.validation\nor dr.SCORING_TYPE.cross_validation). validation is available for every\npartitioning type, and indicates that the default model validation should be\nused for the project.\nIf the project uses a form of cross-validation partitioning,\ncrossValidation can also be used to indicate\nthat all of the available training/validation combinations\nshould be used to evaluate the model.\ntraining_row_count (Optional[int]) \u2013 The number of rows to use to train the requested model.\nmonotonic_increasing_featurelist_id (str) \u2013 (new in version 2.11) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (str) \u2013 (new in version 2.11) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nReturns:\nmodel_job_id \u2013 id of created job, can be used as parameter to ModelJob.get\nmethod or wait_for_async_model_creation function\nReturn type:\nstr\nExamples\nproject = Project.get('project-id')\nmodel = Model.get('project-id', 'model-id')\nmodel_job_id = model.train(training_row_count=project.max_train_rows)\ntrain_datetime(featurelist_id=None, training_row_count=None, training_duration=None, time_window_sample_pct=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, use_project_settings=False, sampling_method=None, n_clusters=None)\uf0c1\nTrains this model on a different featurelist or sample size.\nRequires that this model is part of a datetime partitioned project; otherwise, an error will\noccur.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\nfeaturelist_id (Optional[str]) \u2013 the featurelist to use to train the model.  If not specified, the featurelist of this\nmodel is used.\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\nneither training_duration nor use_project_settings may be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, neither training_row_count nor use_project_settings may be\nspecified.\nuse_project_settings (Optional[bool]) \u2013 (New in version v2.20) defaults to False. If True, indicates that the custom\nbacktest partitioning settings specified by the user will be used to train the model and\nevaluate backtest scores. If specified, neither training_row_count nor\ntraining_duration may be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates). An integer between 1 and 99 indicating the percentage to sample by\nwithin the window. The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nn_clusters (Optional[int]) \u2013 (New in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nReturns:\njob \u2013 the created job to build the model\nReturn type:\nModelJob\ntrain_incremental(data_stage_id, training_data_name=None, data_stage_encoding=None, data_stage_delimiter=None, data_stage_compression=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model using\nadditional data. The id of the additional data to use for training is specified with the data_stage_id.\nOptionally a name for the iteration can be supplied by the user to help identify the contents of data in\nthe iteration.\nThis functionality requires the INCREMENTAL_LEARNING feature flag to be enabled.\nParameters:\ndata_stage_id (str) \u2013 The id of the data stage to use for training.\ntraining_data_name (Optional[str]) \u2013 The name of the iteration or data stage to indicate what the incremental learning was performed on.\ndata_stage_encoding (Optional[str]) \u2013 The encoding type of the data in the data stage (default: UTF-8).\nSupported formats: UTF-8, ASCII, WINDOWS1252\ndata_stage_encoding \u2013 The delimiter used by the data in the data stage (default: \u2018,\u2019).\ndata_stage_compression (Optional[str]) \u2013 The compression type of the data stage file, e.g. \u2018zip\u2019 (default: None).\nSupported formats: zip\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nunstar_model()\uf0c1\nUnmark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nclass datarobot.models.model.AdvancedTuningParamsType\uf0c1\nclass datarobot.models.model.BiasMitigationFeatureInfo\uf0c1\nPrime models\uf0c1\nclass datarobot.models.PrimeModel\uf0c1\nRepresents a DataRobot Prime model approximating a parent model with downloadable code.\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nid (str) \u2013 the id of the model\nproject_id (str) \u2013 the id of the project the model belongs to\nprocesses (List[str]) \u2013 the processes used by the model\nfeaturelist_name (str) \u2013 the name of the featurelist used by the model\nfeaturelist_id (str) \u2013 the id of the featurelist used by the model\nsample_pct (float) \u2013 the percentage of the project dataset used in training the model\ntraining_row_count (int or None) \u2013 the number of rows of the project dataset used in training the model.  In a datetime\npartitioned project, if specified, defines the number of rows used to train the model and\nevaluate backtest scores; if unspecified, either training_duration or\ntraining_start_date and training_end_date was used to determine that instead.\ntraining_duration (str or None) \u2013 only present for models in datetime partitioned projects.  If specified, a duration string\nspecifying the duration spanned by the data used to train the model and evaluate backtest\nscores.\ntraining_start_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the start\ndate of the data used to train the model.\ntraining_end_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the end\ndate of the data used to train the model.\nmodel_type (str) \u2013 what model this is, e.g. \u2018DataRobot Prime\u2019\nmodel_category (str) \u2013 what kind of model this is - always \u2018prime\u2019 for DataRobot Prime models\nis_frozen (bool) \u2013 whether this model is a frozen model\nblueprint_id (str) \u2013 the id of the blueprint used in this model\nmetrics (dict) \u2013 a mapping from each metric to the model\u2019s scores for that metric\nruleset (Ruleset) \u2013 the ruleset used in the Prime model\nparent_model_id (str) \u2013 the id of the model that this Prime model approximates\nmonotonic_increasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically increasing relationship to the target.\nIf None, no such constraints are enforced.\nmonotonic_decreasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target.\nIf None, no such constraints are enforced.\nsupports_monotonic_constraints (bool) \u2013 optional, whether this model supports enforcing monotonic constraints\nis_starred (bool) \u2013 whether this model is marked as starred\nprediction_threshold (float) \u2013 for binary classification projects, the threshold used for predictions\nprediction_threshold_read_only (bool) \u2013 indicated whether modification of the prediction threshold is forbidden. Threshold\nmodification is forbidden once a model has had a deployment created or predictions made via\nthe dedicated prediction API.\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nwhether this model is supported in the Composable ML.\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve a specific prime model.\nParameters:\nproject_id (str) \u2013 The id of the project the prime model belongs to\nmodel_id (str) \u2013 The model_id of the prime model to retrieve.\nReturns:\nmodel \u2013 The queried instance.\nReturn type:\nPrimeModel\nrequest_download_validation(language)\uf0c1\nPrep and validate the downloadable code for the ruleset associated with this model.\nParameters:\nlanguage (str) \u2013 the language the code should be downloaded in - see datarobot.enums.PRIME_LANGUAGE\nfor available languages\nReturns:\njob \u2013 A job tracking the code preparation and validation\nReturn type:\nJob\nadvanced_tune(params, description=None)\uf0c1\nGenerate a new model with the specified advanced-tuning parameters\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nParameters:\nparams (dict) \u2013 Mapping of parameter ID to parameter value.\nThe list of valid parameter IDs for a model can be found by calling\nget_advanced_tuning_parameters().\nThis endpoint does not need to include values for all parameters.  If a parameter\nis omitted, its current_value will be used.\ndescription (str) \u2013 Human-readable string describing the newly advanced-tuned model\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ncontinue_incremental_learning_from_incremental_model(chunk_definition_id, early_stopping_rounds=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nchunk_definition_id (str) \u2013 The Mongo ID for the chunking service.\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks that, when no improvement has been shown, triggers the early stopping mechanism.\nReturns:\njob \u2013 The model retraining job that is created.\nReturn type:\nModelJob\ncross_validate()\uf0c1\nRun cross validation on the model.\nNotes\nTo perform Cross Validation on a new model with new parameters, use train instead.\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ndelete()\uf0c1\nDelete a model from the project\u2019s leaderboard.\nReturn type:\nNone\ndownload_scoring_code(file_name, source_code=False)\uf0c1\nDownload the Scoring Code JAR.\nParameters:\nfile_name (str) \u2013 File path where scoring code will be saved.\nsource_code (Optional[bool]) \u2013 Set to True to download source code archive.\nIt will not be executable.\nReturn type:\nNone\ndownload_training_artifact(file_name)\uf0c1\nRetrieve trained artifact(s) from a model containing one or more custom tasks.\nArtifact(s) will be downloaded to the specified local filepath.\nParameters:\nfile_name (str) \u2013 File path where trained model artifact(s) will be saved.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nget_advanced_tuning_parameters()\uf0c1\nGet the advanced-tuning parameters available for this model.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nA dictionary describing the advanced-tuning parameters for the current model.\nThere are two top-level keys, tuning_description and tuning_parameters.\ntuning_description an optional value. If not None, then it indicates the\nuser-specified description of this set of tuning parameter.\ntuning_parameters is a list of a dicts, each has the following keys\nparameter_name : (str) name of the parameter (unique per task, see below)\nparameter_id : (str) opaque ID string uniquely identifying parameter\ndefault_value : (*) the actual value used to train the model; either\nthe single value of the parameter specified before training, or the best\nvalue from the list of grid-searched values (based on current_value)\ncurrent_value : (*) the single value or list of values of the\nparameter that were grid searched. Depending on the grid search\nspecification, could be a single fixed value (no grid search),\na list of discrete values, or a range.\ntask_name : (str) name of the task that this parameter belongs to\nconstraints: (dict) see the notes below\nvertex_id: (str) ID of vertex that this parameter belongs to\nReturn type:\ndict\nNotes\nThe type of default_value and current_value is defined by the constraints structure.\nIt will be a string or numeric Python type.\nconstraints is a dict with at least one, possibly more, of the following keys.\nThe presence of a key indicates that the parameter may take on the specified type.\n(If a key is absent, this means that the parameter may not take on the specified type.)\nIf a key on constraints is present, its value will be a dict containing\nall of the fields described below for that key.\n\"constraints\": {\n\"select\": {\n\"values\": [<list(basestring or number) : possible values>]\n},\n\"ascii\": {},\n\"unicode\": {},\n\"int\": {\n\"min\": <int : minimum valid value>,\n\"max\": <int : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"float\": {\n\"min\": <float : minimum valid value>,\n\"max\": <float : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"intList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <int : minimum valid value>,\n\"max_val\": <int : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"floatList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <float : minimum valid value>,\n\"max_val\": <float : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n}\n}\nThe keys have meaning as follows:\nselect:\nRather than specifying a specific data type, if present, it indicates that the parameter\nis permitted to take on any of the specified values.  Listed values may be of any string\nor real (non-complex) numeric type.\nascii:\nThe parameter may be a unicode object that encodes simple ASCII characters.\n(A-Z, a-z, 0-9, whitespace, and certain common symbols.)  In addition to listed\nconstraints, ASCII keys currently may not contain either newlines or semicolons.\nunicode:\nThe parameter may be any Python unicode object.\nint:\nThe value may be an object of type int within the specified range (inclusive).\nPlease note that the value will be passed around using the JSON format, and\nsome JSON parsers have undefined behavior with integers outside of the range\n[-(2**53)+1, (2**53)-1].\nfloat:\nThe value may be an object of type float within the specified range (inclusive).\nintList, floatList:\nThe value may be a list of int or float objects, respectively, following constraints\nas specified respectively by the int and float types (above).\nMany parameters only specify one key under constraints.  If a parameter specifies multiple\nkeys, the parameter may take on any value permitted by any key.\nget_all_confusion_charts(fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of all confusion matrices available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent for any source that is not available for this model and if this\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\nReturns:\nData for all available confusion charts for model.\nReturn type:\nlist of ConfusionChart\nget_all_feature_impacts(data_slice_filter=None)\uf0c1\nRetrieve a list of all feature impact results available for the model.\nParameters:\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen no data_slice filtering will be applied when requesting the roc_curve.\nReturns:\nData for all available model feature impacts. Or an empty list if not data found.\nReturn type:\nlist of dicts\nExamples\nmodel = datarobot.Model(id='model-id', project_id='project-id')\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()\nget_all_lift_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (Optional[bool]) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned lift chart by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model lift charts. Or an empty list if no data found.\nReturn type:\nlist of LiftChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()\nget_all_multiclass_lift_charts(fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nData for all available model lift charts.\nReturn type:\nlist of LiftChart\nget_all_residuals_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all residuals charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent\nfor any source that is not available for this model and if this model has a\ndefined parent model. If omitted or False, or this model has no parent, this will\nnot attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned residuals charts by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model residuals charts.\nReturn type:\nlist of ResidualsChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()\nget_all_roc_curves(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all ROC curves available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 filters the returned roc_curve by data_slice_filter.id.  If None (the default) applies no filter based on\ndata_slice_id.\nReturns:\nData for all available model ROC curves. Or an empty list if no RocCurves are found.\nReturn type:\nlist of RocCurve\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()\nget_confusion_chart(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a multiclass model\u2019s confusion matrix for the specified source.\nParameters:\nsource (str) \u2013 Confusion chart source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent if the confusion chart is not available for this model and the\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel ConfusionChart data\nReturn type:\nConfusionChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_cross_class_accuracy_scores()\uf0c1\nRetrieves a list of Cross Class Accuracy scores for the model.\nReturn type:\njson\nget_cross_validation_scores(partition=None, metric=None)\uf0c1\nReturn a dictionary, keyed by metric, showing cross validation\nscores per partition.\nCross Validation should already have been performed using\ncross_validate or\ntrain.\nNotes\nModels that computed cross validation before this feature was added will need\nto be deleted and retrained before this method can be used.\nParameters:\npartition (float) \u2013 optional, the id of the partition (1,2,3.0,4.0,etc\u2026) to filter results by\ncan be a whole number positive integer or float value. 0 corresponds to the\nvalidation partition.\nmetric (unicode) \u2013 optional name of the metric to filter to resulting cross validation scores by\nReturns:\ncross_validation_scores \u2013 A dictionary keyed by metric showing cross validation scores per\npartition.\nReturn type:\ndict\nget_data_disparity_insights(feature, class_name1, class_name2)\uf0c1\nRetrieve a list of Cross Class Data Disparity insights for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\nclass_name1 (str) \u2013 One of the compared classes\nclass_name2 (str) \u2013 Another compared class\nReturn type:\njson\nget_fairness_insights(fairness_metrics_set=None, offset=0, limit=100)\uf0c1\nRetrieve a list of Per Class Bias insights for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturn type:\njson\nget_feature_effect(source, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model.\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, retrieve unsliced insight data.\nReturns:\nfeature_effects \u2013 The feature effects data.\nReturn type:\nFeatureEffects\nRaises:\nClientError \u2013 If the feature effects have not been computed or source is not valid value.\nget_feature_effect_metadata()\uf0c1\nRetrieve Feature Effects metadata. Response contains status and available model sources.\nFeature Effect for the training partition is always available, with the exception of older\nprojects that only supported Feature Effect for validation.\nWhen a model is trained into validation or holdout without stacked predictions\n(i.e., no out-of-sample predictions in those partitions),\nFeature Effects is not available for validation or holdout.\nFeature Effects for holdout is not available when holdout was not unlocked for\nthe project.\nUse source to retrieve Feature Effects, selecting one of the provided sources.\nReturns:\nfeature_effect_metadata\nReturn type:\nFeatureEffectMetadata\nget_feature_effects_multiclass(source='training', class_=None)\uf0c1\nRetrieve Feature Effects for the multiclass model.\nFeature Effects provide partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (str) \u2013 The source Feature Effects are retrieved for.\nclass (str or None) \u2013 The class name Feature Effects are retrieved for.\nReturns:\nThe list of multiclass feature effects.\nReturn type:\nlist\nRaises:\nClientError \u2013 If Feature Effects have not been computed or source is not valid value.\nget_feature_impact(with_metadata=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the computed Feature Impact results, a measure of the relevance of each\nfeature in the model.\nFeature Impact is computed for each column by creating new data with that column randomly\npermuted (but the others left unchanged), and seeing how the error metric score for the\npredictions is affected. The \u2018impactUnnormalized\u2019 is how much worse the error metric score\nis when making predictions on this modified data. The \u2018impactNormalized\u2019 is normalized so\nthat the largest value is 1. In both cases, larger values indicate more important features.\nIf a feature is a redundant feature, i.e. once other features are considered it doesn\u2019t\ncontribute much in addition, the \u2018redundantWith\u2019 value is the name of feature that has the\nhighest correlation with this feature. Note that redundancy detection is only available for\njobs run after the addition of this feature. When retrieving data that predates this\nfunctionality, a NoRedundancyImpactAvailable warning will be used.\nElsewhere this technique is sometimes called \u2018Permutation Importance\u2019.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nParameters:\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_feature_impact will raise a ValueError.\nReturns:\nThe feature impact data response depends on the with_metadata parameter. The response is\neither a dict with metadata and a list with actual data or just a list with that data.\nEach List item is a dict with the keys featureName, impactNormalized, and\nimpactUnnormalized, redundantWith and count.\nFor dict response available keys are:\nfeatureImpacts - Feature Impact data as a dictionary. Each item is a dict withkeys: featureName, impactNormalized, and impactUnnormalized, and\nredundantWith.\nshapBased - A boolean that indicates whether Feature Impact was calculated usingShapley values.\nranRedundancyDetection - A boolean that indicates whether redundant featureidentification was run while calculating this Feature Impact.\nrowCount - An integer or None that indicates the number of rows that was used tocalculate Feature Impact. For the Feature Impact calculated with the default\nlogic, without specifying the rowCount, we return None here.\ncount - An integer with the number of features under the featureImpacts.\nReturn type:\nlist or dict\nRaises:\nClientError \u2013 If the feature impacts have not been computed.\nValueError \u2013 If data_slice_filter passed as None\nget_features_used()\uf0c1\nQuery the server to determine which features were used.\nNote that the data returned by this method is possibly different\nthan the names of the features in the featurelist used by this model.\nThis method will return the raw features that must be supplied in order\nfor predictions to be generated on a new set of data. The featurelist,\nin contrast, would also include the names of derived features.\nReturns:\nfeatures \u2013 The names of the features used in the model.\nReturn type:\nList[str]\nget_frozen_child_models()\uf0c1\nRetrieve the IDs for all models that are frozen from this model.\nReturn type:\nA list of Models\nget_labelwise_roc_curves(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of LabelwiseRocCurve instances for a multilabel model for the given source and all labels.\nThis method is valid only for multilabel projects. For binary projects, use Model.get_roc_curve API .\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\nReturns:\nLabelwise ROC Curve instances for source and all labels\nReturn type:\nlist of LabelwiseRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\nReturns:\nModel lift chart data\nReturn type:\nLiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_missing_report_info()\uf0c1\nRetrieve a report on missing training data that can be used to understand missing\nvalues treatment in the model. The report consists of missing values resolutions for\nfeatures numeric or categorical features that were part of building the model.\nReturns:\nThe queried model missing report, sorted by missing count (DESCENDING order).\nReturn type:\nAn iterable of MissingReportPerFeature\nget_model_blueprint_chart()\uf0c1\nRetrieve a diagram that can be used to understand\ndata flow in the blueprint.\nReturns:\nThe queried model blueprint chart.\nReturn type:\nModelBlueprintChart\nget_model_blueprint_documents()\uf0c1\nGet documentation for tasks used in this model.\nReturns:\nAll documents available for the model.\nReturn type:\nlist of BlueprintTaskDocument\nget_model_blueprint_json()\uf0c1\nGet the blueprint json representation used by this model.\nReturns:\nJson representation of the blueprint stages.\nReturn type:\nBlueprintJson\nget_multiclass_feature_impact()\uf0c1\nFor multiclass it\u2019s possible to calculate feature impact separately for each target class.\nThe method for calculation is exactly the same, calculated in one-vs-all style for each\ntarget class.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. Each item is a dict with the keys \u2018featureImpacts\u2019 (list),\n\u2018class\u2019 (str). Each item in \u2018featureImpacts\u2019 is a dict with the keys \u2018featureName\u2019,\n\u2018impactNormalized\u2019, and \u2018impactUnnormalized\u2019, and \u2018redundantWith\u2019.\nReturn type:\nlist of dict\nRaises:\nClientError \u2013 If the multiclass feature impacts have not been computed.\nget_multiclass_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_multilabel_lift_charts(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve model Lift charts for the specified source.\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_num_iterations_trained()\uf0c1\nRetrieves the number of estimators trained by early-stopping tree-based models.\n\u2013 versionadded:: v2.22\nReturns:\nprojectId (str) \u2013 id of project containing the model\nmodelId (str) \u2013 id of the model\ndata (array) \u2013 list of numEstimatorsItem objects, one for each modeling stage.\nnumEstimatorsItem will be of the form\nstage (str) \u2013 indicates the modeling stage (for multi-stage models); None of single-stage models\nnumIterations (int) \u2013 the number of estimators or iterations trained by the model\nget_or_request_feature_effect(source, max_wait=600, row_count=None, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model, requesting a new job if it hasn\u2019t been run previously.\nSee get_feature_effect_metadata\nfor retrieving information of source.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effect job to complete before erroring.\nrow_count (Optional[int]) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nfeature_effects \u2013 The Feature Effects data.\nReturn type:\nFeatureEffects\nget_or_request_feature_effects_multiclass(source, top_n_features=None, features=None, row_count=None, class_=None, max_wait=600)\uf0c1\nRetrieve Feature Effects for the multiclass model, requesting a job if it hasn\u2019t been run\npreviously.\nParameters:\nsource (string) \u2013 The source Feature Effects retrieve for.\nclass (str or None) \u2013 The class name Feature Effects retrieve for.\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by Feature Impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effects job to complete before\nerroring.\nReturns:\nfeature_effects \u2013 The list of multiclass feature effects data.\nReturn type:\nlist of FeatureEffectsMulticlass\nget_or_request_feature_impact(max_wait=600, **kwargs)\uf0c1\nRetrieve feature impact for the model, requesting a job if it hasn\u2019t been run previously\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature impact job to complete before erroring\n**kwargs \u2013 Arbitrary keyword arguments passed to\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. See\nget_feature_impact for the exact\nschema.\nReturn type:\nlist or dict\nget_parameters()\uf0c1\nRetrieve model parameters.\nReturns:\nModel parameters for this model.\nReturn type:\nModelParameters\nget_pareto_front()\uf0c1\nRetrieve the Pareto Front for a Eureqa model.\nThis method is only supported for Eureqa models.\nReturns:\nModel ParetoFront data\nReturn type:\nParetoFront\nget_prime_eligibility()\uf0c1\nCheck if this model can be approximated with DataRobot Prime\nReturns:\nprime_eligibility \u2013 a dict indicating whether a model can be approximated with DataRobot Prime\n(key can_make_prime) and why it may be ineligible (key message)\nReturn type:\ndict\nget_residuals_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible\nvalues.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent if\nthe residuals chart is not available for this model and the model has a defined parent\nmodel. If omitted or False, or there is no parent model, will not attempt to return\nresiduals data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_residuals_chart will raise a ValueError.\nReturns:\nModel residuals chart data\nReturn type:\nResidualsChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_roc_curve(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the ROC curve for a binary model for the specified source.\nThis method is valid only for binary projects. For multilabel projects, use\nModel.get_labelwise_roc_curves.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_roc_curve will raise a ValueError.\nReturns:\nModel ROC curve data\nReturn type:\nRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\n(New in version v3.0) TypeError \u2013 If the underlying project type is multilabel\nValueError \u2013 If data_slice_filter passed as None\nget_rulesets()\uf0c1\nList the rulesets approximating this model generated by DataRobot Prime\nIf this model hasn\u2019t been approximated yet, will return an empty list.  Note that these\nare rulesets approximating this model, not rulesets used to construct this model.\nReturns:\nrulesets\nReturn type:\nlist of Ruleset\nget_supported_capabilities()\uf0c1\nRetrieves a summary of the capabilities supported by a model.\nAdded in version v2.14.\nReturns:\nsupportsBlending (bool) \u2013 whether the model supports blending\nsupportsMonotonicConstraints (bool) \u2013 whether the model supports monotonic constraints\nhasWordCloud (bool) \u2013 whether the model has word cloud data available\neligibleForPrime (bool) \u2013 (Deprecated in version v3.6)\nwhether the model is eligible for Prime\nhasParameters (bool) \u2013 whether the model has parameters that can be retrieved\nsupportsCodeGeneration (bool) \u2013 (New in version v2.18) whether the model supports code generation\nsupportsShap (bool) \u2013\n(New in version v2.18) True if the model supports Shapley package. i.e. Shapley basedfeature Importance\nsupportsEarlyStopping (bool) \u2013 (New in version v2.22) True if this is an early stopping\ntree-based model and number of trained iterations can be retrieved.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this model at leaderboard.\nReturn type:\nstr\nget_word_cloud(exclude_stop_words=False)\uf0c1\nRetrieve word cloud data for the model.\nParameters:\nexclude_stop_words (Optional[bool]) \u2013 Set to True if you want stopwords filtered out of response.\nReturns:\nWord cloud data for the model.\nReturn type:\nWordCloud\nincremental_train(data_stage_id, training_data_name=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model.\nSee train_incremental documentation.\nReturn type:\nModelJob\nclassmethod list(project_id, sort_by_partition='validation', sort_by_metric=None, with_metric=None, search_term=None, featurelists=None, families=None, blueprints=None, labels=None, characteristics=None, training_filters=None, number_of_clusters=None, limit=100, offset=0)\uf0c1\nRetrieve paginated model records, sorted by scores, with optional filtering.\nParameters:\nsort_by_partition (str, one of validation, backtesting, crossValidation or holdout) \u2013 Set the partition to use for sorted (by score) list of models. validation is the default.\nsort_by_metric (str) \u2013 Set the project metric to use for model sorting. DataRobot-selected project optimization metric\nis the default.\nwith_metric (str) \u2013 For a single-metric list of results, specify that project metric.\nsearch_term (str) \u2013 If specified, only models containing the term in their name or processes are returned.\nfeaturelists (List[str]) \u2013 If specified, only models trained on selected featurelists are returned.\nfamilies (List[str]) \u2013 If specified, only models belonging to selected families are returned.\nblueprints (List[str]) \u2013 If specified, only models trained on specified blueprint IDs are returned.\nlabels (List[str], starred or prepared for deployment) \u2013 If specified, only models tagged with all listed labels are returned.\ncharacteristics (List[str]) \u2013 If specified, only models matching all listed characteristics are returned.\ntraining_filters (List[str]) \u2013 If specified, only models matching at least one of the listed training conditions are returned.\nThe following formats are supported for autoML and datetime partitioned projects:\n- number of rows in training subset\nFor datetime partitioned projects:\n- <training duration>, example P6Y0M0D\n- <training_duration>-<time_window_sample_percent>-<sampling_method> Example: P6Y0M0D-78-Random,\n(returns models trained on 6 years of data, sampling rate 78%, random sampling).\n- Start/end date\n- Project settings\nnumber_of_clusters (list of int) \u2013 Filter models by number of clusters. Applicable only in unsupervised clustering projects.\nlimit (int)\noffset (int)\nReturns:\ngeneric_models\nReturn type:\nlist of GenericModel\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nrequest_cross_class_accuracy_scores()\uf0c1\nRequest data disparity insights to be computed for the model.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_data_disparity_insights(feature, compared_class_names)\uf0c1\nRequest data disparity insights to be computed for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\ncompared_class_names (list(str)) \u2013 List of two classes to compare\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_external_test(dataset_id, actual_value_column=None)\uf0c1\nRequest external test to compute scores and insights on an external test dataset\nParameters:\ndataset_id (string) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nReturns:\njob \u2013 a Job representing external dataset insights computation\nReturn type:\nJob\nrequest_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest fairness insights to be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_feature_effect(row_count=None, data_slice_id=None)\uf0c1\nSubmit request to compute Feature Effects for the model.\nSee get_feature_effect for more\ninformation on the result of the job.\nParameters:\nrow_count (int) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 A Job representing the feature effect computation. To get the completed feature effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nRaises:\nJobAlreadyRequested \u2013 If the feature effect have already been requested.\nrequest_feature_effects_multiclass(row_count=None, top_n_features=None, features=None)\uf0c1\nRequest Feature Effects computation for the multiclass model.\nSee get_feature_effect for\nmore information on the result of the job.\nParameters:\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by feature impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nReturns:\njob \u2013 A Job representing Feature Effect computation. To get the completed Feature Effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nrequest_feature_impact(row_count=None, with_metadata=False, data_slice_id=None)\uf0c1\nRequest feature impacts to be computed for the model.\nSee get_feature_impact for more\ninformation on the result of the job.\nParameters:\nrow_count (Optional[int]) \u2013 The sample size (specified in rows) to use for Feature Impact computation. This is not\nsupported for unsupervised, multiclass (which has a separate method), and time series\nprojects.\nwith_metadata (Optional[bool]) \u2013 Flag indicating whether the result should include the metadata.\nIf true, metadata is included.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 Job representing the Feature Impact computation. To retrieve the completed Feature Impact\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob or status_id\nRaises:\nJobAlreadyRequested \u2013 If the feature impacts have already been requested.\nrequest_lift_chart(source, data_slice_id=None)\uf0c1\nRequest the model Lift Chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_per_class_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest per-class fairness insights be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 The fairness metric used to calculate the fairness scores.\nValue can be any one of <datarobot.enums.FairnessMetricsSet>.\nReturns:\nstatus_check_job \u2013 The returned object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_predictions(dataset_id=None, dataset=None, dataframe=None, file_path=None, file=None, include_prediction_intervals=None, prediction_intervals_size=None, forecast_point=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, explanation_algorithm=None, max_explanations=None, max_ngram_explanations=None)\uf0c1\nRequests predictions against a previously uploaded dataset.\nParameters:\ndataset_id (string, optional) \u2013 The ID of the dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataset (Dataset, optional) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataframe (pd.DataFrame, optional) \u2013 (New in v3.0)\nThe dataframe to make predictions against\nfile_path (Optional[str]) \u2013 (New in v3.0)\nPath to file to make predictions against\nfile (IOBase, optional) \u2013 (New in v3.0)\nFile to make predictions against\ninclude_prediction_intervals (Optional[bool]) \u2013 (New in v2.16) For time series projects only.\nSpecifies whether prediction intervals should be calculated for this request. Defaults\nto True if prediction_intervals_size is specified, otherwise defaults to False.\nprediction_intervals_size (Optional[int]) \u2013 (New in v2.16) For time series projects only.\nRepresents the percentile to use for the size of the prediction intervals. Defaults to\n80 if include_prediction_intervals is True. Prediction intervals size must be\nbetween 1 and 100 (inclusive).\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The end date for bulk\npredictions, exclusive. Note that this parameter is for generating historical\npredictions using the training data. This parameter should be provided in conjunction\nwith predictions_start_date. Can\u2019t be provided with the\nforecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nexplanation_algorithm ((New in version v2.21) optional; If set to 'shap', the) \u2013 response will include prediction explanations based on the SHAP explainer (SHapley\nAdditive exPlanations). Defaults to null (no prediction explanations).\nmax_explanations ((New in version v2.21) int optional; specifies the maximum number of) \u2013 explanation values that should be returned for each row, ordered by absolute value,\ngreatest to least. If null, no limit. In the case of \u2018shap\u2019: if the number of features\nis greater than the limit, the sum of remaining values will also be returned as\nshapRemainingTotal. Defaults to null. Cannot be set if explanation_algorithm is\nomitted.\nmax_ngram_explanations (optional;\u00a0 int or str) \u2013 (New in version v2.29) Specifies the maximum number of text explanation values that\nshould be returned. If set to all, text explanations will be computed and all the\nngram explanations will be returned. If set to a non zero positive integer value, text\nexplanations will be computed and this amount of descendingly sorted ngram explanations\nwill be returned. By default text explanation won\u2019t be triggered to be computed.\nReturns:\njob \u2013 The job computing the predictions\nReturn type:\nPredictJob\nrequest_residuals_chart(source, data_slice_id=None)\uf0c1\nRequest the model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_roc_curve(source, data_slice_id=None)\uf0c1\nRequest the model Roc Curve for the specified source.\nParameters:\nsource (str) \u2013 Roc Curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_training_predictions(data_subset, explanation_algorithm=None, max_explanations=None)\uf0c1\nStart a job to build training predictions\nParameters:\ndata_subset (str) \u2013 data set definition to build predictions on.\nChoices are:\ndr.enums.DATA_SUBSET.ALL or string all for all data available. Not valid formodels in datetime partitioned projects\ndr.enums.DATA_SUBSET.VALIDATION_AND_HOLDOUT or string validationAndHoldout forall data except training set. Not valid for models in datetime partitioned\nprojects\ndr.enums.DATA_SUBSET.HOLDOUT or string holdout for holdout data set only\ndr.enums.DATA_SUBSET.ALL_BACKTESTS or string allBacktests for downloadingthe predictions for all backtest validation folds. Requires the model to have\nsuccessfully scored all backtests. Datetime partitioned projects only.\nexplanation_algorithm (dr.enums.EXPLANATIONS_ALGORITHM) \u2013 (New in v2.21) Optional. If set to dr.enums.EXPLANATIONS_ALGORITHM.SHAP, the response\nwill include prediction explanations based on the SHAP explainer (SHapley Additive\nexPlanations). Defaults to None (no prediction explanations).\nmax_explanations (int) \u2013 (New in v2.21) Optional. Specifies the maximum number of explanation values that should\nbe returned for each row, ordered by absolute value, greatest to least. In the case of\ndr.enums.EXPLANATIONS_ALGORITHM.SHAP:  If not set, explanations are returned for all\nfeatures. If the number of features is greater than the max_explanations, the sum of\nremaining values will also be returned as shap_remaining_total. Max 100. Defaults to\nnull for datasets narrower than 100 columns, defaults to 100 for datasets wider than 100\ncolumns. Is ignored if explanation_algorithm is not set.\nReturns:\nan instance of created async job\nReturn type:\nJob\nretrain(sample_pct=None, featurelist_id=None, training_row_count=None, n_clusters=None)\uf0c1\nSubmit a job to the queue to train a blender model.\nParameters:\nsample_pct (Optional[float]) \u2013 The sample size in percents (1 to 100) to use in training. If this parameter is used\nthen training_row_count should not be given.\nfeaturelist_id (Optional[str]) \u2013 The featurelist id\ntraining_row_count (Optional[int]) \u2013 The number of rows used to train the model. If this parameter is used, then sample_pct\nshould not be given.\nn_clusters (Optional[int]) \u2013 (new in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that do not determine\nthe number of clusters automatically.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nset_prediction_threshold(threshold)\uf0c1\nSet a custom prediction threshold for the model.\nMay not be used once prediction_threshold_read_only is True for this model.\nParameters:\nthreshold (float) \u2013 only used for binary classification projects. The threshold to when deciding between\nthe positive and negative classes when making predictions.  Should be between 0.0 and\n1.0 (inclusive).\nstar_model()\uf0c1\nMark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nstart_advanced_tuning_session()\uf0c1\nStart an Advanced Tuning session.  Returns an object that helps\nset up arguments for an Advanced Tuning model execution.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nSession for setting up and running Advanced Tuning on a model\nReturn type:\nAdvancedTuningSession\nstart_incremental_learning_from_sample(early_stopping_rounds=None, first_iteration_only=False, chunk_definition_id=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks in which no improvement is observed that triggers the early stopping mechanism.\nfirst_iteration_only (bool) \u2013 Specifies whether incremental learning training should be limited to the first\niteration. If set to True, the training process will be performed only for the first\niteration. If set to False, training will continue until early stopping conditions\nare met or the maximum number of iterations is reached. The default value is False.\nchunk_definition_id (str) \u2013 The id of the chunk definition to be use for incremental training.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\ntrain_incremental(data_stage_id, training_data_name=None, data_stage_encoding=None, data_stage_delimiter=None, data_stage_compression=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model using\nadditional data. The id of the additional data to use for training is specified with the data_stage_id.\nOptionally a name for the iteration can be supplied by the user to help identify the contents of data in\nthe iteration.\nThis functionality requires the INCREMENTAL_LEARNING feature flag to be enabled.\nParameters:\ndata_stage_id (str) \u2013 The id of the data stage to use for training.\ntraining_data_name (Optional[str]) \u2013 The name of the iteration or data stage to indicate what the incremental learning was performed on.\ndata_stage_encoding (Optional[str]) \u2013 The encoding type of the data in the data stage (default: UTF-8).\nSupported formats: UTF-8, ASCII, WINDOWS1252\ndata_stage_encoding \u2013 The delimiter used by the data in the data stage (default: \u2018,\u2019).\ndata_stage_compression (Optional[str]) \u2013 The compression type of the data stage file, e.g. \u2018zip\u2019 (default: None).\nSupported formats: zip\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nunstar_model()\uf0c1\nUnmark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nPrime files\uf0c1\nclass datarobot.models.PrimeFile\uf0c1\nRepresents an executable file available for download of the code for a DataRobot Prime model\nVariables:\nid (str) \u2013 the id of the PrimeFile\nproject_id (str) \u2013 the id of the project this PrimeFile belongs to\nparent_model_id (str) \u2013 the model being approximated by this PrimeFile\nmodel_id (str) \u2013 the prime model this file represents\nruleset_id (int) \u2013 the ruleset being used in this PrimeFile\nlanguage (str) \u2013 the language of the code in this file - see enums.LANGUAGE for possibilities\nis_valid (bool) \u2013 whether the code passed basic validation\ndownload(filepath)\uf0c1\nDownload the code and save it to a file\nParameters:\nfilepath (string) \u2013 the location to save the file to\nReturn type:\nNone\nBlender models\uf0c1\nclass datarobot.models.BlenderModel\uf0c1\nRepresents blender model that combines prediction results from other models.\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nid (str) \u2013 the id of the model\nproject_id (str) \u2013 the id of the project the model belongs to\nprocesses (List[str]) \u2013 the processes used by the model\nfeaturelist_name (str) \u2013 the name of the featurelist used by the model\nfeaturelist_id (str) \u2013 the id of the featurelist used by the model\nsample_pct (float) \u2013 the percentage of the project dataset used in training the model\ntraining_row_count (int or None) \u2013 the number of rows of the project dataset used in training the model.  In a datetime\npartitioned project, if specified, defines the number of rows used to train the model and\nevaluate backtest scores; if unspecified, either training_duration or\ntraining_start_date and training_end_date was used to determine that instead.\ntraining_duration (str or None) \u2013 only present for models in datetime partitioned projects.  If specified, a duration string\nspecifying the duration spanned by the data used to train the model and evaluate backtest\nscores.\ntraining_start_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the start\ndate of the data used to train the model.\ntraining_end_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the end\ndate of the data used to train the model.\nmodel_type (str) \u2013 what model this is, e.g. \u2018DataRobot Prime\u2019\nmodel_category (str) \u2013 what kind of model this is - always \u2018prime\u2019 for DataRobot Prime models\nis_frozen (bool) \u2013 whether this model is a frozen model\nblueprint_id (str) \u2013 the id of the blueprint used in this model\nmetrics (dict) \u2013 a mapping from each metric to the model\u2019s scores for that metric\nmodel_ids (List[str]) \u2013 List of model ids used in blender\nblender_method (str) \u2013 Method used to blend results from underlying models\nmonotonic_increasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically increasing relationship to the target.\nIf None, no such constraints are enforced.\nmonotonic_decreasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target.\nIf None, no such constraints are enforced.\nsupports_monotonic_constraints (bool) \u2013 optional, whether this model supports enforcing monotonic constraints\nis_starred (bool) \u2013 whether this model marked as starred\nprediction_threshold (float) \u2013 for binary classification projects, the threshold used for predictions\nprediction_threshold_read_only (bool) \u2013 indicated whether modification of the prediction threshold is forbidden. Threshold\nmodification is forbidden once a model has had a deployment created or predictions made via\nthe dedicated prediction API.\nmodel_number (integer) \u2013 model number assigned to a model\nparent_model_id (str or None) \u2013 (New in version v2.20) the id of the model that tuning parameters are derived from\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nwhether this model is supported in the Composable ML.\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve a specific blender.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nmodel_id (str) \u2013 The model_id of the leaderboard item to retrieve.\nReturns:\nmodel \u2013 The queried instance.\nReturn type:\nBlenderModel\nadvanced_tune(params, description=None)\uf0c1\nGenerate a new model with the specified advanced-tuning parameters\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nParameters:\nparams (dict) \u2013 Mapping of parameter ID to parameter value.\nThe list of valid parameter IDs for a model can be found by calling\nget_advanced_tuning_parameters().\nThis endpoint does not need to include values for all parameters.  If a parameter\nis omitted, its current_value will be used.\ndescription (str) \u2013 Human-readable string describing the newly advanced-tuned model\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ncontinue_incremental_learning_from_incremental_model(chunk_definition_id, early_stopping_rounds=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nchunk_definition_id (str) \u2013 The Mongo ID for the chunking service.\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks that, when no improvement has been shown, triggers the early stopping mechanism.\nReturns:\njob \u2013 The model retraining job that is created.\nReturn type:\nModelJob\ncross_validate()\uf0c1\nRun cross validation on the model.\nNotes\nTo perform Cross Validation on a new model with new parameters, use train instead.\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ndelete()\uf0c1\nDelete a model from the project\u2019s leaderboard.\nReturn type:\nNone\ndownload_scoring_code(file_name, source_code=False)\uf0c1\nDownload the Scoring Code JAR.\nParameters:\nfile_name (str) \u2013 File path where scoring code will be saved.\nsource_code (Optional[bool]) \u2013 Set to True to download source code archive.\nIt will not be executable.\nReturn type:\nNone\ndownload_training_artifact(file_name)\uf0c1\nRetrieve trained artifact(s) from a model containing one or more custom tasks.\nArtifact(s) will be downloaded to the specified local filepath.\nParameters:\nfile_name (str) \u2013 File path where trained model artifact(s) will be saved.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverrides the inherited method since the model must _not_ recursively change casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (list) \u2013 List of attribute namespaces like: [\u2018top.middle.bottom\u2019], that should be kept\neven if their values are None\nget_advanced_tuning_parameters()\uf0c1\nGet the advanced-tuning parameters available for this model.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nA dictionary describing the advanced-tuning parameters for the current model.\nThere are two top-level keys, tuning_description and tuning_parameters.\ntuning_description an optional value. If not None, then it indicates the\nuser-specified description of this set of tuning parameter.\ntuning_parameters is a list of a dicts, each has the following keys\nparameter_name : (str) name of the parameter (unique per task, see below)\nparameter_id : (str) opaque ID string uniquely identifying parameter\ndefault_value : (*) the actual value used to train the model; either\nthe single value of the parameter specified before training, or the best\nvalue from the list of grid-searched values (based on current_value)\ncurrent_value : (*) the single value or list of values of the\nparameter that were grid searched. Depending on the grid search\nspecification, could be a single fixed value (no grid search),\na list of discrete values, or a range.\ntask_name : (str) name of the task that this parameter belongs to\nconstraints: (dict) see the notes below\nvertex_id: (str) ID of vertex that this parameter belongs to\nReturn type:\ndict\nNotes\nThe type of default_value and current_value is defined by the constraints structure.\nIt will be a string or numeric Python type.\nconstraints is a dict with at least one, possibly more, of the following keys.\nThe presence of a key indicates that the parameter may take on the specified type.\n(If a key is absent, this means that the parameter may not take on the specified type.)\nIf a key on constraints is present, its value will be a dict containing\nall of the fields described below for that key.\n\"constraints\": {\n\"select\": {\n\"values\": [<list(basestring or number) : possible values>]\n},\n\"ascii\": {},\n\"unicode\": {},\n\"int\": {\n\"min\": <int : minimum valid value>,\n\"max\": <int : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"float\": {\n\"min\": <float : minimum valid value>,\n\"max\": <float : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"intList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <int : minimum valid value>,\n\"max_val\": <int : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"floatList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <float : minimum valid value>,\n\"max_val\": <float : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n}\n}\nThe keys have meaning as follows:\nselect:\nRather than specifying a specific data type, if present, it indicates that the parameter\nis permitted to take on any of the specified values.  Listed values may be of any string\nor real (non-complex) numeric type.\nascii:\nThe parameter may be a unicode object that encodes simple ASCII characters.\n(A-Z, a-z, 0-9, whitespace, and certain common symbols.)  In addition to listed\nconstraints, ASCII keys currently may not contain either newlines or semicolons.\nunicode:\nThe parameter may be any Python unicode object.\nint:\nThe value may be an object of type int within the specified range (inclusive).\nPlease note that the value will be passed around using the JSON format, and\nsome JSON parsers have undefined behavior with integers outside of the range\n[-(2**53)+1, (2**53)-1].\nfloat:\nThe value may be an object of type float within the specified range (inclusive).\nintList, floatList:\nThe value may be a list of int or float objects, respectively, following constraints\nas specified respectively by the int and float types (above).\nMany parameters only specify one key under constraints.  If a parameter specifies multiple\nkeys, the parameter may take on any value permitted by any key.\nget_all_confusion_charts(fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of all confusion matrices available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent for any source that is not available for this model and if this\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\nReturns:\nData for all available confusion charts for model.\nReturn type:\nlist of ConfusionChart\nget_all_feature_impacts(data_slice_filter=None)\uf0c1\nRetrieve a list of all feature impact results available for the model.\nParameters:\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen no data_slice filtering will be applied when requesting the roc_curve.\nReturns:\nData for all available model feature impacts. Or an empty list if not data found.\nReturn type:\nlist of dicts\nExamples\nmodel = datarobot.Model(id='model-id', project_id='project-id')\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()\nget_all_lift_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (Optional[bool]) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned lift chart by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model lift charts. Or an empty list if no data found.\nReturn type:\nlist of LiftChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()\nget_all_multiclass_lift_charts(fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nData for all available model lift charts.\nReturn type:\nlist of LiftChart\nget_all_residuals_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all residuals charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent\nfor any source that is not available for this model and if this model has a\ndefined parent model. If omitted or False, or this model has no parent, this will\nnot attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned residuals charts by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model residuals charts.\nReturn type:\nlist of ResidualsChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()\nget_all_roc_curves(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all ROC curves available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 filters the returned roc_curve by data_slice_filter.id.  If None (the default) applies no filter based on\ndata_slice_id.\nReturns:\nData for all available model ROC curves. Or an empty list if no RocCurves are found.\nReturn type:\nlist of RocCurve\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()\nget_confusion_chart(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a multiclass model\u2019s confusion matrix for the specified source.\nParameters:\nsource (str) \u2013 Confusion chart source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent if the confusion chart is not available for this model and the\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel ConfusionChart data\nReturn type:\nConfusionChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_cross_class_accuracy_scores()\uf0c1\nRetrieves a list of Cross Class Accuracy scores for the model.\nReturn type:\njson\nget_cross_validation_scores(partition=None, metric=None)\uf0c1\nReturn a dictionary, keyed by metric, showing cross validation\nscores per partition.\nCross Validation should already have been performed using\ncross_validate or\ntrain.\nNotes\nModels that computed cross validation before this feature was added will need\nto be deleted and retrained before this method can be used.\nParameters:\npartition (float) \u2013 optional, the id of the partition (1,2,3.0,4.0,etc\u2026) to filter results by\ncan be a whole number positive integer or float value. 0 corresponds to the\nvalidation partition.\nmetric (unicode) \u2013 optional name of the metric to filter to resulting cross validation scores by\nReturns:\ncross_validation_scores \u2013 A dictionary keyed by metric showing cross validation scores per\npartition.\nReturn type:\ndict\nget_data_disparity_insights(feature, class_name1, class_name2)\uf0c1\nRetrieve a list of Cross Class Data Disparity insights for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\nclass_name1 (str) \u2013 One of the compared classes\nclass_name2 (str) \u2013 Another compared class\nReturn type:\njson\nget_fairness_insights(fairness_metrics_set=None, offset=0, limit=100)\uf0c1\nRetrieve a list of Per Class Bias insights for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturn type:\njson\nget_feature_effect(source, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model.\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, retrieve unsliced insight data.\nReturns:\nfeature_effects \u2013 The feature effects data.\nReturn type:\nFeatureEffects\nRaises:\nClientError \u2013 If the feature effects have not been computed or source is not valid value.\nget_feature_effect_metadata()\uf0c1\nRetrieve Feature Effects metadata. Response contains status and available model sources.\nFeature Effect for the training partition is always available, with the exception of older\nprojects that only supported Feature Effect for validation.\nWhen a model is trained into validation or holdout without stacked predictions\n(i.e., no out-of-sample predictions in those partitions),\nFeature Effects is not available for validation or holdout.\nFeature Effects for holdout is not available when holdout was not unlocked for\nthe project.\nUse source to retrieve Feature Effects, selecting one of the provided sources.\nReturns:\nfeature_effect_metadata\nReturn type:\nFeatureEffectMetadata\nget_feature_effects_multiclass(source='training', class_=None)\uf0c1\nRetrieve Feature Effects for the multiclass model.\nFeature Effects provide partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (str) \u2013 The source Feature Effects are retrieved for.\nclass (str or None) \u2013 The class name Feature Effects are retrieved for.\nReturns:\nThe list of multiclass feature effects.\nReturn type:\nlist\nRaises:\nClientError \u2013 If Feature Effects have not been computed or source is not valid value.\nget_feature_impact(with_metadata=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the computed Feature Impact results, a measure of the relevance of each\nfeature in the model.\nFeature Impact is computed for each column by creating new data with that column randomly\npermuted (but the others left unchanged), and seeing how the error metric score for the\npredictions is affected. The \u2018impactUnnormalized\u2019 is how much worse the error metric score\nis when making predictions on this modified data. The \u2018impactNormalized\u2019 is normalized so\nthat the largest value is 1. In both cases, larger values indicate more important features.\nIf a feature is a redundant feature, i.e. once other features are considered it doesn\u2019t\ncontribute much in addition, the \u2018redundantWith\u2019 value is the name of feature that has the\nhighest correlation with this feature. Note that redundancy detection is only available for\njobs run after the addition of this feature. When retrieving data that predates this\nfunctionality, a NoRedundancyImpactAvailable warning will be used.\nElsewhere this technique is sometimes called \u2018Permutation Importance\u2019.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nParameters:\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_feature_impact will raise a ValueError.\nReturns:\nThe feature impact data response depends on the with_metadata parameter. The response is\neither a dict with metadata and a list with actual data or just a list with that data.\nEach List item is a dict with the keys featureName, impactNormalized, and\nimpactUnnormalized, redundantWith and count.\nFor dict response available keys are:\nfeatureImpacts - Feature Impact data as a dictionary. Each item is a dict withkeys: featureName, impactNormalized, and impactUnnormalized, and\nredundantWith.\nshapBased - A boolean that indicates whether Feature Impact was calculated usingShapley values.\nranRedundancyDetection - A boolean that indicates whether redundant featureidentification was run while calculating this Feature Impact.\nrowCount - An integer or None that indicates the number of rows that was used tocalculate Feature Impact. For the Feature Impact calculated with the default\nlogic, without specifying the rowCount, we return None here.\ncount - An integer with the number of features under the featureImpacts.\nReturn type:\nlist or dict\nRaises:\nClientError \u2013 If the feature impacts have not been computed.\nValueError \u2013 If data_slice_filter passed as None\nget_features_used()\uf0c1\nQuery the server to determine which features were used.\nNote that the data returned by this method is possibly different\nthan the names of the features in the featurelist used by this model.\nThis method will return the raw features that must be supplied in order\nfor predictions to be generated on a new set of data. The featurelist,\nin contrast, would also include the names of derived features.\nReturns:\nfeatures \u2013 The names of the features used in the model.\nReturn type:\nList[str]\nget_frozen_child_models()\uf0c1\nRetrieve the IDs for all models that are frozen from this model.\nReturn type:\nA list of Models\nget_labelwise_roc_curves(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of LabelwiseRocCurve instances for a multilabel model for the given source and all labels.\nThis method is valid only for multilabel projects. For binary projects, use Model.get_roc_curve API .\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\nReturns:\nLabelwise ROC Curve instances for source and all labels\nReturn type:\nlist of LabelwiseRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\nReturns:\nModel lift chart data\nReturn type:\nLiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_missing_report_info()\uf0c1\nRetrieve a report on missing training data that can be used to understand missing\nvalues treatment in the model. The report consists of missing values resolutions for\nfeatures numeric or categorical features that were part of building the model.\nReturns:\nThe queried model missing report, sorted by missing count (DESCENDING order).\nReturn type:\nAn iterable of MissingReportPerFeature\nget_model_blueprint_chart()\uf0c1\nRetrieve a diagram that can be used to understand\ndata flow in the blueprint.\nReturns:\nThe queried model blueprint chart.\nReturn type:\nModelBlueprintChart\nget_model_blueprint_documents()\uf0c1\nGet documentation for tasks used in this model.\nReturns:\nAll documents available for the model.\nReturn type:\nlist of BlueprintTaskDocument\nget_model_blueprint_json()\uf0c1\nGet the blueprint json representation used by this model.\nReturns:\nJson representation of the blueprint stages.\nReturn type:\nBlueprintJson\nget_multiclass_feature_impact()\uf0c1\nFor multiclass it\u2019s possible to calculate feature impact separately for each target class.\nThe method for calculation is exactly the same, calculated in one-vs-all style for each\ntarget class.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. Each item is a dict with the keys \u2018featureImpacts\u2019 (list),\n\u2018class\u2019 (str). Each item in \u2018featureImpacts\u2019 is a dict with the keys \u2018featureName\u2019,\n\u2018impactNormalized\u2019, and \u2018impactUnnormalized\u2019, and \u2018redundantWith\u2019.\nReturn type:\nlist of dict\nRaises:\nClientError \u2013 If the multiclass feature impacts have not been computed.\nget_multiclass_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_multilabel_lift_charts(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve model Lift charts for the specified source.\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_num_iterations_trained()\uf0c1\nRetrieves the number of estimators trained by early-stopping tree-based models.\n\u2013 versionadded:: v2.22\nReturns:\nprojectId (str) \u2013 id of project containing the model\nmodelId (str) \u2013 id of the model\ndata (array) \u2013 list of numEstimatorsItem objects, one for each modeling stage.\nnumEstimatorsItem will be of the form\nstage (str) \u2013 indicates the modeling stage (for multi-stage models); None of single-stage models\nnumIterations (int) \u2013 the number of estimators or iterations trained by the model\nget_or_request_feature_effect(source, max_wait=600, row_count=None, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model, requesting a new job if it hasn\u2019t been run previously.\nSee get_feature_effect_metadata\nfor retrieving information of source.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effect job to complete before erroring.\nrow_count (Optional[int]) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nfeature_effects \u2013 The Feature Effects data.\nReturn type:\nFeatureEffects\nget_or_request_feature_effects_multiclass(source, top_n_features=None, features=None, row_count=None, class_=None, max_wait=600)\uf0c1\nRetrieve Feature Effects for the multiclass model, requesting a job if it hasn\u2019t been run\npreviously.\nParameters:\nsource (string) \u2013 The source Feature Effects retrieve for.\nclass (str or None) \u2013 The class name Feature Effects retrieve for.\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by Feature Impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effects job to complete before\nerroring.\nReturns:\nfeature_effects \u2013 The list of multiclass feature effects data.\nReturn type:\nlist of FeatureEffectsMulticlass\nget_or_request_feature_impact(max_wait=600, **kwargs)\uf0c1\nRetrieve feature impact for the model, requesting a job if it hasn\u2019t been run previously\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature impact job to complete before erroring\n**kwargs \u2013 Arbitrary keyword arguments passed to\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. See\nget_feature_impact for the exact\nschema.\nReturn type:\nlist or dict\nget_parameters()\uf0c1\nRetrieve model parameters.\nReturns:\nModel parameters for this model.\nReturn type:\nModelParameters\nget_pareto_front()\uf0c1\nRetrieve the Pareto Front for a Eureqa model.\nThis method is only supported for Eureqa models.\nReturns:\nModel ParetoFront data\nReturn type:\nParetoFront\nget_prime_eligibility()\uf0c1\nCheck if this model can be approximated with DataRobot Prime\nReturns:\nprime_eligibility \u2013 a dict indicating whether a model can be approximated with DataRobot Prime\n(key can_make_prime) and why it may be ineligible (key message)\nReturn type:\ndict\nget_residuals_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible\nvalues.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent if\nthe residuals chart is not available for this model and the model has a defined parent\nmodel. If omitted or False, or there is no parent model, will not attempt to return\nresiduals data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_residuals_chart will raise a ValueError.\nReturns:\nModel residuals chart data\nReturn type:\nResidualsChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_roc_curve(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the ROC curve for a binary model for the specified source.\nThis method is valid only for binary projects. For multilabel projects, use\nModel.get_labelwise_roc_curves.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_roc_curve will raise a ValueError.\nReturns:\nModel ROC curve data\nReturn type:\nRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\n(New in version v3.0) TypeError \u2013 If the underlying project type is multilabel\nValueError \u2013 If data_slice_filter passed as None\nget_rulesets()\uf0c1\nList the rulesets approximating this model generated by DataRobot Prime\nIf this model hasn\u2019t been approximated yet, will return an empty list.  Note that these\nare rulesets approximating this model, not rulesets used to construct this model.\nReturns:\nrulesets\nReturn type:\nlist of Ruleset\nget_supported_capabilities()\uf0c1\nRetrieves a summary of the capabilities supported by a model.\nAdded in version v2.14.\nReturns:\nsupportsBlending (bool) \u2013 whether the model supports blending\nsupportsMonotonicConstraints (bool) \u2013 whether the model supports monotonic constraints\nhasWordCloud (bool) \u2013 whether the model has word cloud data available\neligibleForPrime (bool) \u2013 (Deprecated in version v3.6)\nwhether the model is eligible for Prime\nhasParameters (bool) \u2013 whether the model has parameters that can be retrieved\nsupportsCodeGeneration (bool) \u2013 (New in version v2.18) whether the model supports code generation\nsupportsShap (bool) \u2013\n(New in version v2.18) True if the model supports Shapley package. i.e. Shapley basedfeature Importance\nsupportsEarlyStopping (bool) \u2013 (New in version v2.22) True if this is an early stopping\ntree-based model and number of trained iterations can be retrieved.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this model at leaderboard.\nReturn type:\nstr\nget_word_cloud(exclude_stop_words=False)\uf0c1\nRetrieve word cloud data for the model.\nParameters:\nexclude_stop_words (Optional[bool]) \u2013 Set to True if you want stopwords filtered out of response.\nReturns:\nWord cloud data for the model.\nReturn type:\nWordCloud\nincremental_train(data_stage_id, training_data_name=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model.\nSee train_incremental documentation.\nReturn type:\nModelJob\nclassmethod list(project_id, sort_by_partition='validation', sort_by_metric=None, with_metric=None, search_term=None, featurelists=None, families=None, blueprints=None, labels=None, characteristics=None, training_filters=None, number_of_clusters=None, limit=100, offset=0)\uf0c1\nRetrieve paginated model records, sorted by scores, with optional filtering.\nParameters:\nsort_by_partition (str, one of validation, backtesting, crossValidation or holdout) \u2013 Set the partition to use for sorted (by score) list of models. validation is the default.\nsort_by_metric (str) \u2013 Set the project metric to use for model sorting. DataRobot-selected project optimization metric\nis the default.\nwith_metric (str) \u2013 For a single-metric list of results, specify that project metric.\nsearch_term (str) \u2013 If specified, only models containing the term in their name or processes are returned.\nfeaturelists (List[str]) \u2013 If specified, only models trained on selected featurelists are returned.\nfamilies (List[str]) \u2013 If specified, only models belonging to selected families are returned.\nblueprints (List[str]) \u2013 If specified, only models trained on specified blueprint IDs are returned.\nlabels (List[str], starred or prepared for deployment) \u2013 If specified, only models tagged with all listed labels are returned.\ncharacteristics (List[str]) \u2013 If specified, only models matching all listed characteristics are returned.\ntraining_filters (List[str]) \u2013 If specified, only models matching at least one of the listed training conditions are returned.\nThe following formats are supported for autoML and datetime partitioned projects:\n- number of rows in training subset\nFor datetime partitioned projects:\n- <training duration>, example P6Y0M0D\n- <training_duration>-<time_window_sample_percent>-<sampling_method> Example: P6Y0M0D-78-Random,\n(returns models trained on 6 years of data, sampling rate 78%, random sampling).\n- Start/end date\n- Project settings\nnumber_of_clusters (list of int) \u2013 Filter models by number of clusters. Applicable only in unsupervised clustering projects.\nlimit (int)\noffset (int)\nReturns:\ngeneric_models\nReturn type:\nlist of GenericModel\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nrequest_approximation()\uf0c1\nRequest an approximation of this model using DataRobot Prime\nThis will create several rulesets that could be used to approximate this model.  After\ncomparing their scores and rule counts, the code used in the approximation can be downloaded\nand run locally.\nReturns:\njob \u2013 the job generating the rulesets\nReturn type:\nJob\nrequest_cross_class_accuracy_scores()\uf0c1\nRequest data disparity insights to be computed for the model.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_data_disparity_insights(feature, compared_class_names)\uf0c1\nRequest data disparity insights to be computed for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\ncompared_class_names (list(str)) \u2013 List of two classes to compare\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_external_test(dataset_id, actual_value_column=None)\uf0c1\nRequest external test to compute scores and insights on an external test dataset\nParameters:\ndataset_id (string) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nReturns:\njob \u2013 a Job representing external dataset insights computation\nReturn type:\nJob\nrequest_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest fairness insights to be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_feature_effect(row_count=None, data_slice_id=None)\uf0c1\nSubmit request to compute Feature Effects for the model.\nSee get_feature_effect for more\ninformation on the result of the job.\nParameters:\nrow_count (int) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 A Job representing the feature effect computation. To get the completed feature effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nRaises:\nJobAlreadyRequested \u2013 If the feature effect have already been requested.\nrequest_feature_effects_multiclass(row_count=None, top_n_features=None, features=None)\uf0c1\nRequest Feature Effects computation for the multiclass model.\nSee get_feature_effect for\nmore information on the result of the job.\nParameters:\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by feature impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nReturns:\njob \u2013 A Job representing Feature Effect computation. To get the completed Feature Effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nrequest_feature_impact(row_count=None, with_metadata=False, data_slice_id=None)\uf0c1\nRequest feature impacts to be computed for the model.\nSee get_feature_impact for more\ninformation on the result of the job.\nParameters:\nrow_count (Optional[int]) \u2013 The sample size (specified in rows) to use for Feature Impact computation. This is not\nsupported for unsupervised, multiclass (which has a separate method), and time series\nprojects.\nwith_metadata (Optional[bool]) \u2013 Flag indicating whether the result should include the metadata.\nIf true, metadata is included.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 Job representing the Feature Impact computation. To retrieve the completed Feature Impact\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob or status_id\nRaises:\nJobAlreadyRequested \u2013 If the feature impacts have already been requested.\nrequest_frozen_datetime_model(training_row_count=None, training_duration=None, training_start_date=None, training_end_date=None, time_window_sample_pct=None, sampling_method=None)\uf0c1\nTrain a new frozen model with parameters from this model.\nRequires that this model belongs to a datetime partitioned project.  If it does not, an\nerror will occur when submitting the job.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nIn addition of training_row_count and training_duration, frozen datetime models may be\ntrained on an exact date range.  Only one of training_row_count, training_duration, or\ntraining_start_date and training_end_date should be specified.\nModels specified using training_start_date and training_end_date are the only ones that can\nbe trained into the holdout data (once the holdout is unlocked).\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\ntraining_duration may not be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, training_row_count may not be specified.\ntraining_start_date (datetime.datetime, optional) \u2013 the start date of the data to train to model on.  Only rows occurring at or after\nthis datetime will be used.  If training_start_date is specified, training_end_date\nmust also be specified.\ntraining_end_date (datetime.datetime, optional) \u2013 the end date of the data to train the model on.  Only rows occurring strictly before\nthis datetime will be used.  If training_end_date is specified, training_start_date\nmust also be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates).  An integer between 1 and 99 indicating the percentage to sample by\nwithin the window.  The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_frozen_model(sample_pct=None, training_row_count=None)\uf0c1\nTrain a new frozen model with parameters from this model\nNotes\nThis method only works if project the model belongs to is not datetime\npartitioned.  If it is, use request_frozen_datetime_model instead.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nParameters:\nsample_pct (float) \u2013 optional, the percentage of the dataset to use with the model.  If not provided, will\nuse the value from this model.\ntraining_row_count (int) \u2013 (New in version v2.9) optional, the integer number of rows of the dataset to use with\nthe model. Only one of sample_pct and training_row_count should be specified.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_lift_chart(source, data_slice_id=None)\uf0c1\nRequest the model Lift Chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_per_class_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest per-class fairness insights be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 The fairness metric used to calculate the fairness scores.\nValue can be any one of <datarobot.enums.FairnessMetricsSet>.\nReturns:\nstatus_check_job \u2013 The returned object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_predictions(dataset_id=None, dataset=None, dataframe=None, file_path=None, file=None, include_prediction_intervals=None, prediction_intervals_size=None, forecast_point=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, explanation_algorithm=None, max_explanations=None, max_ngram_explanations=None)\uf0c1\nRequests predictions against a previously uploaded dataset.\nParameters:\ndataset_id (string, optional) \u2013 The ID of the dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataset (Dataset, optional) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataframe (pd.DataFrame, optional) \u2013 (New in v3.0)\nThe dataframe to make predictions against\nfile_path (Optional[str]) \u2013 (New in v3.0)\nPath to file to make predictions against\nfile (IOBase, optional) \u2013 (New in v3.0)\nFile to make predictions against\ninclude_prediction_intervals (Optional[bool]) \u2013 (New in v2.16) For time series projects only.\nSpecifies whether prediction intervals should be calculated for this request. Defaults\nto True if prediction_intervals_size is specified, otherwise defaults to False.\nprediction_intervals_size (Optional[int]) \u2013 (New in v2.16) For time series projects only.\nRepresents the percentile to use for the size of the prediction intervals. Defaults to\n80 if include_prediction_intervals is True. Prediction intervals size must be\nbetween 1 and 100 (inclusive).\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The end date for bulk\npredictions, exclusive. Note that this parameter is for generating historical\npredictions using the training data. This parameter should be provided in conjunction\nwith predictions_start_date. Can\u2019t be provided with the\nforecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nexplanation_algorithm ((New in version v2.21) optional; If set to 'shap', the) \u2013 response will include prediction explanations based on the SHAP explainer (SHapley\nAdditive exPlanations). Defaults to null (no prediction explanations).\nmax_explanations ((New in version v2.21) int optional; specifies the maximum number of) \u2013 explanation values that should be returned for each row, ordered by absolute value,\ngreatest to least. If null, no limit. In the case of \u2018shap\u2019: if the number of features\nis greater than the limit, the sum of remaining values will also be returned as\nshapRemainingTotal. Defaults to null. Cannot be set if explanation_algorithm is\nomitted.\nmax_ngram_explanations (optional;\u00a0 int or str) \u2013 (New in version v2.29) Specifies the maximum number of text explanation values that\nshould be returned. If set to all, text explanations will be computed and all the\nngram explanations will be returned. If set to a non zero positive integer value, text\nexplanations will be computed and this amount of descendingly sorted ngram explanations\nwill be returned. By default text explanation won\u2019t be triggered to be computed.\nReturns:\njob \u2013 The job computing the predictions\nReturn type:\nPredictJob\nrequest_residuals_chart(source, data_slice_id=None)\uf0c1\nRequest the model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_roc_curve(source, data_slice_id=None)\uf0c1\nRequest the model Roc Curve for the specified source.\nParameters:\nsource (str) \u2013 Roc Curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_training_predictions(data_subset, explanation_algorithm=None, max_explanations=None)\uf0c1\nStart a job to build training predictions\nParameters:\ndata_subset (str) \u2013 data set definition to build predictions on.\nChoices are:\ndr.enums.DATA_SUBSET.ALL or string all for all data available. Not valid formodels in datetime partitioned projects\ndr.enums.DATA_SUBSET.VALIDATION_AND_HOLDOUT or string validationAndHoldout forall data except training set. Not valid for models in datetime partitioned\nprojects\ndr.enums.DATA_SUBSET.HOLDOUT or string holdout for holdout data set only\ndr.enums.DATA_SUBSET.ALL_BACKTESTS or string allBacktests for downloadingthe predictions for all backtest validation folds. Requires the model to have\nsuccessfully scored all backtests. Datetime partitioned projects only.\nexplanation_algorithm (dr.enums.EXPLANATIONS_ALGORITHM) \u2013 (New in v2.21) Optional. If set to dr.enums.EXPLANATIONS_ALGORITHM.SHAP, the response\nwill include prediction explanations based on the SHAP explainer (SHapley Additive\nexPlanations). Defaults to None (no prediction explanations).\nmax_explanations (int) \u2013 (New in v2.21) Optional. Specifies the maximum number of explanation values that should\nbe returned for each row, ordered by absolute value, greatest to least. In the case of\ndr.enums.EXPLANATIONS_ALGORITHM.SHAP:  If not set, explanations are returned for all\nfeatures. If the number of features is greater than the max_explanations, the sum of\nremaining values will also be returned as shap_remaining_total. Max 100. Defaults to\nnull for datasets narrower than 100 columns, defaults to 100 for datasets wider than 100\ncolumns. Is ignored if explanation_algorithm is not set.\nReturns:\nan instance of created async job\nReturn type:\nJob\nretrain(sample_pct=None, featurelist_id=None, training_row_count=None, n_clusters=None)\uf0c1\nSubmit a job to the queue to train a blender model.\nParameters:\nsample_pct (Optional[float]) \u2013 The sample size in percents (1 to 100) to use in training. If this parameter is used\nthen training_row_count should not be given.\nfeaturelist_id (Optional[str]) \u2013 The featurelist id\ntraining_row_count (Optional[int]) \u2013 The number of rows used to train the model. If this parameter is used, then sample_pct\nshould not be given.\nn_clusters (Optional[int]) \u2013 (new in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that do not determine\nthe number of clusters automatically.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nset_prediction_threshold(threshold)\uf0c1\nSet a custom prediction threshold for the model.\nMay not be used once prediction_threshold_read_only is True for this model.\nParameters:\nthreshold (float) \u2013 only used for binary classification projects. The threshold to when deciding between\nthe positive and negative classes when making predictions.  Should be between 0.0 and\n1.0 (inclusive).\nstar_model()\uf0c1\nMark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nstart_advanced_tuning_session()\uf0c1\nStart an Advanced Tuning session.  Returns an object that helps\nset up arguments for an Advanced Tuning model execution.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nSession for setting up and running Advanced Tuning on a model\nReturn type:\nAdvancedTuningSession\nstart_incremental_learning_from_sample(early_stopping_rounds=None, first_iteration_only=False, chunk_definition_id=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks in which no improvement is observed that triggers the early stopping mechanism.\nfirst_iteration_only (bool) \u2013 Specifies whether incremental learning training should be limited to the first\niteration. If set to True, the training process will be performed only for the first\niteration. If set to False, training will continue until early stopping conditions\nare met or the maximum number of iterations is reached. The default value is False.\nchunk_definition_id (str) \u2013 The id of the chunk definition to be use for incremental training.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\ntrain(sample_pct=None, featurelist_id=None, scoring_type=None, training_row_count=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>)\uf0c1\nTrain the blueprint used in model on a particular featurelist or amount of data.\nThis method creates a new training job for worker and appends it to\nthe end of the queue for this project.\nAfter the job has finished you can get the newly trained model by retrieving\nit from the project leaderboard, or by retrieving the result of the job.\nEither sample_pct or training_row_count can be used to specify the amount of data to\nuse, but not both.  If neither are specified, a default of the maximum amount of data that\ncan safely be used to train any blueprint without going into the validation data will be\nselected.\nIn smart-sampled projects, sample_pct and training_row_count are assumed to be in terms\nof rows of the minority class.\nNotes\nFor datetime partitioned projects, see train_datetime instead.\nParameters:\nsample_pct (Optional[float]) \u2013 The amount of data to use for training, as a percentage of the project dataset from\n0 to 100.\nfeaturelist_id (Optional[str]) \u2013 The identifier of the featurelist to use. If not defined, the\nfeaturelist of this model is used.\nscoring_type (Optional[str]) \u2013 Either validation or crossValidation (also dr.SCORING_TYPE.validation\nor dr.SCORING_TYPE.cross_validation). validation is available for every\npartitioning type, and indicates that the default model validation should be\nused for the project.\nIf the project uses a form of cross-validation partitioning,\ncrossValidation can also be used to indicate\nthat all of the available training/validation combinations\nshould be used to evaluate the model.\ntraining_row_count (Optional[int]) \u2013 The number of rows to use to train the requested model.\nmonotonic_increasing_featurelist_id (str) \u2013 (new in version 2.11) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (str) \u2013 (new in version 2.11) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nReturns:\nmodel_job_id \u2013 id of created job, can be used as parameter to ModelJob.get\nmethod or wait_for_async_model_creation function\nReturn type:\nstr\nExamples\nproject = Project.get('project-id')\nmodel = Model.get('project-id', 'model-id')\nmodel_job_id = model.train(training_row_count=project.max_train_rows)\ntrain_datetime(featurelist_id=None, training_row_count=None, training_duration=None, time_window_sample_pct=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, use_project_settings=False, sampling_method=None, n_clusters=None)\uf0c1\nTrains this model on a different featurelist or sample size.\nRequires that this model is part of a datetime partitioned project; otherwise, an error will\noccur.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\nfeaturelist_id (Optional[str]) \u2013 the featurelist to use to train the model.  If not specified, the featurelist of this\nmodel is used.\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\nneither training_duration nor use_project_settings may be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, neither training_row_count nor use_project_settings may be\nspecified.\nuse_project_settings (Optional[bool]) \u2013 (New in version v2.20) defaults to False. If True, indicates that the custom\nbacktest partitioning settings specified by the user will be used to train the model and\nevaluate backtest scores. If specified, neither training_row_count nor\ntraining_duration may be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates). An integer between 1 and 99 indicating the percentage to sample by\nwithin the window. The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nn_clusters (Optional[int]) \u2013 (New in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nReturns:\njob \u2013 the created job to build the model\nReturn type:\nModelJob\ntrain_incremental(data_stage_id, training_data_name=None, data_stage_encoding=None, data_stage_delimiter=None, data_stage_compression=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model using\nadditional data. The id of the additional data to use for training is specified with the data_stage_id.\nOptionally a name for the iteration can be supplied by the user to help identify the contents of data in\nthe iteration.\nThis functionality requires the INCREMENTAL_LEARNING feature flag to be enabled.\nParameters:\ndata_stage_id (str) \u2013 The id of the data stage to use for training.\ntraining_data_name (Optional[str]) \u2013 The name of the iteration or data stage to indicate what the incremental learning was performed on.\ndata_stage_encoding (Optional[str]) \u2013 The encoding type of the data in the data stage (default: UTF-8).\nSupported formats: UTF-8, ASCII, WINDOWS1252\ndata_stage_encoding \u2013 The delimiter used by the data in the data stage (default: \u2018,\u2019).\ndata_stage_compression (Optional[str]) \u2013 The compression type of the data stage file, e.g. \u2018zip\u2019 (default: None).\nSupported formats: zip\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nunstar_model()\uf0c1\nUnmark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nDatetime models\uf0c1\nclass datarobot.models.DatetimeModel\uf0c1\nRepresents a model from a datetime partitioned project\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nNote that only one of training_row_count, training_duration, and\ntraining_start_date and training_end_date will be specified, depending on the\ndata_selection_method of the model.  Whichever method was selected determines the amount of\ndata used to train on when making predictions and scoring the backtests and the holdout.\nVariables:\nid (str) \u2013 the id of the model\nproject_id (str) \u2013 the id of the project the model belongs to\nprocesses (List[str]) \u2013 the processes used by the model\nfeaturelist_name (str) \u2013 the name of the featurelist used by the model\nfeaturelist_id (str) \u2013 the id of the featurelist used by the model\nsample_pct (float) \u2013 the percentage of the project dataset used in training the model\ntraining_row_count (int or None) \u2013 If specified, an int specifying the number of rows used to train the model and evaluate\nbacktest scores.\ntraining_duration (str or None) \u2013 If specified, a duration string specifying the duration spanned by the data used to train\nthe model and evaluate backtest scores.\ntraining_start_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the start\ndate of the data used to train the model.\ntraining_end_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the end\ndate of the data used to train the model.\ntime_window_sample_pct (int or None) \u2013 An integer between 1 and 99 indicating the percentage of sampling within the training\nwindow.  The points kept are determined by a random uniform sample.  If not specified, no\nsampling was done.\nsampling_method (str or None) \u2013 (New in v2.23) indicates the way training data has been selected (either how rows have been\nselected within backtest or how time_window_sample_pct has been applied).\nmodel_type (str) \u2013 what model this is, e.g. \u2018Nystroem Kernel SVM Regressor\u2019\nmodel_category (str) \u2013 what kind of model this is - \u2018prime\u2019 for DataRobot Prime models, \u2018blend\u2019 for blender models,\nand \u2018model\u2019 for other models\nis_frozen (bool) \u2013 whether this model is a frozen model\nblueprint_id (str) \u2013 the id of the blueprint used in this model\nmetrics (dict) \u2013 a mapping from each metric to the model\u2019s scores for that metric.  The keys in metrics are\nthe different metrics used to evaluate the model, and the values are the results.  The\ndictionaries inside of metrics will be as described here: \u2018validation\u2019, the score\nfor a single backtest; \u2018crossValidation\u2019, always None; \u2018backtesting\u2019, the average score for\nall backtests if all are available and computed, or None otherwise; \u2018backtestingScores\u2019, a\nlist of scores for all backtests where the score is None if that backtest does not have a\nscore available; and \u2018holdout\u2019, the score for the holdout or None if the holdout is locked\nor the score is unavailable.\nbacktests (list of dict) \u2013 describes what data was used to fit each backtest, the score for the project metric, and\nwhy the backtest score is unavailable if it is not provided.\ndata_selection_method (str) \u2013 which of training_row_count, training_duration, or training_start_data and training_end_date\nwere used to determine the data used to fit the model.  One of \u2018rowCount\u2019,\n\u2018duration\u2019, or \u2018selectedDateRange\u2019.\ntraining_info (dict) \u2013 describes which data was used to train on when scoring the holdout and making predictions.\ntraining_info` will have the following keys: holdout_training_start_date,\nholdout_training_duration, holdout_training_row_count, holdout_training_end_date,\nprediction_training_start_date, prediction_training_duration,\nprediction_training_row_count, prediction_training_end_date. Start and end dates will\nbe datetimes, durations will be duration strings, and rows will be integers.\nholdout_score (float or None) \u2013 the score against the holdout, if available and the holdout is unlocked, according to the\nproject metric.\nholdout_status (string or None) \u2013 the status of the holdout score, e.g. \u201cCOMPLETED\u201d, \u201cHOLDOUT_BOUNDARIES_EXCEEDED\u201d.\nUnavailable if the holdout fold was disabled in the partitioning configuration.\nmonotonic_increasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically increasing relationship to the target.\nIf None, no such constraints are enforced.\nmonotonic_decreasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target.\nIf None, no such constraints are enforced.\nsupports_monotonic_constraints (bool) \u2013 optional, whether this model supports enforcing monotonic constraints\nis_starred (bool) \u2013 whether this model marked as starred\nprediction_threshold (float) \u2013 for binary classification projects, the threshold used for predictions\nprediction_threshold_read_only (bool) \u2013 indicated whether modification of the prediction threshold is forbidden. Threshold\nmodification is forbidden once a model has had a deployment created or predictions made via\nthe dedicated prediction API.\neffective_feature_derivation_window_start (int or None) \u2013 (New in v2.16) For time series projects only.\nHow many units of the windows_basis_unit into the past relative to the forecast point\nthe user needs to provide history for at prediction time. This can differ from the\nfeature_derivation_window_start set on the project due to the differencing method and\nperiod selected, or if the model is a time series native model such as ARIMA. Will be a\nnegative integer in time series projects and None otherwise.\neffective_feature_derivation_window_end (int or None) \u2013 (New in v2.16) For time series projects only.\nHow many units of the windows_basis_unit into the past relative to the forecast point\nthe feature derivation window should end. Will be a non-positive integer in time series\nprojects and None otherwise.\nforecast_window_start (int or None) \u2013 (New in v2.16) For time series projects only.\nHow many units of the windows_basis_unit into the future relative to the forecast point\nthe forecast window should start. Note that this field will be the same as what is shown in\nthe project settings. Will be a non-negative integer in time series projects and None\notherwise.\nforecast_window_end (int or None) \u2013 (New in v2.16) For time series projects only.\nHow many units of the windows_basis_unit into the future relative to the forecast point\nthe forecast window should end. Note that this field will be the same as what is shown in\nthe project settings. Will be a non-negative integer in time series projects and None\notherwise.\nwindows_basis_unit (str or None) \u2013 (New in v2.16) For time series projects only.\nIndicates which unit is the basis for the feature derivation window and the forecast window.\nNote that this field will be the same as what is shown in the project settings. In time\nseries projects, will be either the detected time unit or \u201cROW\u201d, and None otherwise.\nmodel_number (integer) \u2013 model number assigned to a model\nparent_model_id (str or None) \u2013 (New in version v2.20) the id of the model that tuning parameters are derived from\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nwhether this model is supported in the Composable ML.\nis_n_clusters_dynamically_determined (Optional[bool]) \u2013 (New in version 2.27) if True, indicates that model determines number of clusters\nautomatically.\nn_clusters (Optional[int]) \u2013 (New in version 2.27) Number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nclassmethod get(project, model_id)\uf0c1\nRetrieve a specific datetime model.\nIf the project does not use datetime partitioning, a ClientError will occur.\nParameters:\nproject (str) \u2013 the id of the project the model belongs to\nmodel_id (str) \u2013 the id of the model to retrieve\nReturns:\nmodel \u2013 the model\nReturn type:\nDatetimeModel\nscore_backtests()\uf0c1\nCompute the scores for all available backtests.\nSome backtests may be unavailable if the model is trained into their validation data.\nReturns:\njob \u2013 a job tracking the backtest computation.  When it is complete, all available backtests\nwill have scores computed.\nReturn type:\nJob\ncross_validate()\uf0c1\nInherited from the model. DatetimeModels cannot request cross validation scores;\nuse backtests instead.\nReturn type:\nNoReturn\nget_cross_validation_scores(partition=None, metric=None)\uf0c1\nInherited from Model - DatetimeModels cannot request Cross Validation scores,\nUse backtests instead.\nReturn type:\nNoReturn\nrequest_training_predictions(data_subset, *args, **kwargs)\uf0c1\nStart a job that builds training predictions.\nParameters:\ndata_subset (str) \u2013 data set definition to build predictions on.\nChoices are:\ndr.enums.DATA_SUBSET.HOLDOUT for holdout data set only\ndr.enums.DATA_SUBSET.ALL_BACKTESTS for downloading the predictions for allbacktest validation folds. Requires the model to have successfully scored all\nbacktests.\nReturns:\nan instance of created async job\nReturn type:\nJob\nget_series_accuracy_as_dataframe(offset=0, limit=100, metric=None, multiseries_value=None, order_by=None, reverse=False)\uf0c1\nRetrieve series accuracy results for the specified model as a pandas.DataFrame.\nParameters:\noffset (Optional[int]) \u2013 The number of results to skip. Defaults to 0 if not specified.\nlimit (Optional[int]) \u2013 The maximum number of results to return. Defaults to 100 if not specified.\nmetric (Optional[str]) \u2013 The name of the metric to retrieve scores for. If omitted, the default project metric\nwill be used.\nmultiseries_value (Optional[str]) \u2013 If specified, only the series containing the given value in one of the series ID columns\nwill be returned.\norder_by (Optional[str]) \u2013 Used for sorting the series. Attribute must be one of\ndatarobot.enums.SERIES_ACCURACY_ORDER_BY.\nreverse (Optional[bool]) \u2013 Used for sorting the series. If True, will sort the series in descending order by\nthe attribute specified by order_by.\nReturns:\nA pandas.DataFrame with the Series Accuracy for the specified model.\nReturn type:\ndata\ndownload_series_accuracy_as_csv(filename, encoding='utf-8', offset=0, limit=100, metric=None, multiseries_value=None, order_by=None, reverse=False)\uf0c1\nSave series accuracy results for the specified model in a CSV file.\nParameters:\nfilename (str or file object) \u2013 The path or file object to save the data to.\nencoding (Optional[str]) \u2013 A string representing the encoding to use in the output csv file.\nDefaults to \u2018utf-8\u2019.\noffset (Optional[int]) \u2013 The number of results to skip. Defaults to 0 if not specified.\nlimit (Optional[int]) \u2013 The maximum number of results to return. Defaults to 100 if not specified.\nmetric (Optional[str]) \u2013 The name of the metric to retrieve scores for. If omitted, the default project metric\nwill be used.\nmultiseries_value (Optional[str]) \u2013 If specified, only the series containing the given value in one of the series ID columns\nwill be returned.\norder_by (Optional[str]) \u2013 Used for sorting the series. Attribute must be one of\ndatarobot.enums.SERIES_ACCURACY_ORDER_BY.\nreverse (Optional[bool]) \u2013 Used for sorting the series. If True, will sort the series in descending order by\nthe attribute specified by order_by.\nget_series_clusters(offset=0, limit=100, order_by=None, reverse=False)\uf0c1\nRetrieve a dictionary of series and the clusters assigned to each series. This\nis only usable for clustering projects.\nParameters:\noffset (Optional[int]) \u2013 The number of results to skip. Defaults to 0 if not specified.\nlimit (Optional[int]) \u2013 The maximum number of results to return. Defaults to 100 if not specified.\norder_by (Optional[str]) \u2013 Used for sorting the series. Attribute must be one of\ndatarobot.enums.SERIES_ACCURACY_ORDER_BY.\nreverse (Optional[bool]) \u2013 Used for sorting the series. If True, will sort the series in descending order by\nthe attribute specified by order_by.\nReturns:\nA dictionary of the series in the dataset with their associated cluster\nReturn type:\nDict\nRaises:\nValueError \u2013 If the model type returns an unsupported insight\nClientError \u2013 If the insight is not available for this model\ncompute_series_accuracy(compute_all_series=False)\uf0c1\nCompute series accuracy for the model.\nParameters:\ncompute_all_series (Optional[bool]) \u2013 Calculate accuracy for all series or only first 1000.\nReturns:\nan instance of the created async job\nReturn type:\nJob\nretrain(time_window_sample_pct=None, featurelist_id=None, training_row_count=None, training_duration=None, training_start_date=None, training_end_date=None, sampling_method=None, n_clusters=None)\uf0c1\nRetrain an existing datetime model using a new training period for the model\u2019s training\nset (with optional time window sampling) or a different feature list.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\nfeaturelist_id (Optional[str]) \u2013 The ID of the featurelist to use.\ntraining_row_count (Optional[int]) \u2013 The number of rows to train the model on. If this parameter is used then sample_pct\ncannot be specified.\ntime_window_sample_pct (Optional[int]) \u2013 An int between 1 and 99 indicating the percentage of\nsampling within the time window. The points kept are determined by a random uniform\nsample. If specified, training_row_count must not be specified and either\ntraining_duration or training_start_date and training_end_date must be specified.\ntraining_duration (Optional[str]) \u2013 A duration string representing the training duration for the submitted model. If\nspecified then training_row_count, training_start_date, and training_end_date\ncannot be specified.\ntraining_start_date (Optional[str]) \u2013 A datetime string representing the start date of\nthe data to use for training this model.  If specified, training_end_date must also be\nspecified, and training_duration cannot be specified. The value must be before the\ntraining_end_date value.\ntraining_end_date (Optional[str]) \u2013 A datetime string representing the end date of the\ndata to use for training this model.  If specified, training_start_date must also be\nspecified, and training_duration cannot be specified. The value must be after the\ntraining_start_date value.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nn_clusters (Optional[int]) \u2013 (New in version 2.27) Number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nget_feature_effect_metadata()\uf0c1\nRetrieve Feature Effect metadata for each backtest. Response contains status and available\nsources for each backtest of the model.\nEach backtest is available for training and validation\nIf holdout is configured for the project it has holdout as backtestIndex. It has\ntraining and holdout sources available.\nStart/stop models contain a single response item with startstop value for backtestIndex.\nFeature Effect of training is always available\n(except for the old project which supports only Feature Effect for validation).\nWhen a model is trained into validation or holdout without stacked prediction\n(e.g. no out-of-sample prediction in validation or holdout),\nFeature Effect is not available for validation or holdout.\nFeature Effect for holdout is not available when there is no holdout configured for\nthe project.\nsource is expected parameter to retrieve Feature Effect. One of provided sources\nshall be used.\nbacktestIndex is expected parameter to submit compute request and retrieve Feature Effect.\nOne of provided backtest indexes shall be used.\nReturns:\nfeature_effect_metadata\nReturn type:\nFeatureEffectMetadataDatetime\nrequest_feature_effect(backtest_index, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRequest feature effects to be computed for the model.\nSee get_feature_effect for more\ninformation on the result of the job.\nSee get_feature_effect_metadata\nfor retrieving information of backtest_index.\nParameters:\nbacktest_index (string, FeatureEffectMetadataDatetime.backtest_index.) \u2013 The backtest index to retrieve Feature Effects for.\nReturns:\njob \u2013 A Job representing the feature effect computation. To get the completed feature effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nRaises:\nJobAlreadyRequested \u2013 If the feature effect have already been requested.\nget_feature_effect(source, backtest_index, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve Feature Effects for the model.\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information of source, backtest_index.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\nOne value of [FeatureEffectMetadataDatetime.sources]. To retrieve the available\nsources for feature effect.\nbacktest_index (string, FeatureEffectMetadataDatetime.backtest_index.) \u2013 The backtest index to retrieve Feature Effects for.\nReturns:\nfeature_effects \u2013 The feature effects data.\nReturn type:\nFeatureEffects\nRaises:\nClientError \u2013 If the feature effects have not been computed or source is not valid value.\nget_or_request_feature_effect(source, backtest_index, max_wait=600, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve Feature Effects computations for the model, requesting a new job if it hasn\u2019t been run previously.\nSee get_feature_effect_metadata\nfor retrieving information of source, backtest_index.\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature effect job to complete before erroring\nsource (string) \u2013 The source Feature Effects are retrieved for.\nOne value of [FeatureEffectMetadataDatetime.sources]. To retrieve the available sources\nfor feature effect.\nbacktest_index (string, FeatureEffectMetadataDatetime.backtest_index.) \u2013 The backtest index to retrieve Feature Effects for.\nReturns:\nfeature_effects \u2013 The feature effects data.\nReturn type:\nFeatureEffects\nrequest_feature_effects_multiclass(backtest_index, row_count=None, top_n_features=None, features=None)\uf0c1\nRequest feature effects to be computed for the multiclass datetime model.\nSee get_feature_effect for\nmore information on the result of the job.\nParameters:\nbacktest_index (str) \u2013 The backtest index to use for Feature Effects calculation.\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by Feature Impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features to use to calculate Feature Effects.\nReturns:\njob \u2013 A Job representing Feature Effects computation. To get the completed Feature Effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nget_feature_effects_multiclass(backtest_index, source='training', class_=None)\uf0c1\nRetrieve Feature Effects for the multiclass datetime model.\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nbacktest_index (str) \u2013 The backtest index to retrieve Feature Effects for.\nsource (str) \u2013 The source Feature Effects are retrieved for.\nclass (str or None) \u2013 The class name Feature Effects are retrieved for.\nReturns:\nThe list of multiclass Feature Effects.\nReturn type:\nlist\nRaises:\nClientError \u2013 If the Feature Effects have not been computed or source is not valid value.\nget_or_request_feature_effects_multiclass(backtest_index, source, top_n_features=None, features=None, row_count=None, class_=None, max_wait=600)\uf0c1\nRetrieve Feature Effects for a datetime multiclass model, and request a job if it hasn\u2019t\nbeen run previously.\nParameters:\nbacktest_index (str) \u2013 The backtest index to retrieve Feature Effects for.\nsource (string) \u2013 The source from which Feature Effects are retrieved.\nclass (str or None) \u2013 The class name Feature Effects retrieve for.\nrow_count (int) \u2013 The number of rows used from the dataset for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by feature impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature effect job to complete before erroring.\nReturns:\nfeature_effects \u2013 The list of multiclass feature effects data.\nReturn type:\nlist of FeatureEffectsMulticlass\ncalculate_prediction_intervals(prediction_intervals_size)\uf0c1\nCalculate prediction intervals for this DatetimeModel for the specified size.\nAdded in version v2.19.\nParameters:\nprediction_intervals_size (int) \u2013 The prediction interval\u2019s size to calculate for this model. See the\nprediction intervals documentation for more information.\nReturns:\njob \u2013 a Job tracking the prediction intervals computation\nReturn type:\nJob\nget_calculated_prediction_intervals(offset=None, limit=None)\uf0c1\nRetrieve a list of already-calculated prediction intervals for this model\nAdded in version v2.19.\nParameters:\noffset (Optional[int]) \u2013 If provided, this many results will be skipped\nlimit (Optional[int]) \u2013 If provided, at most this many results will be returned. If not provided, will return\nat most 100 results.\nReturns:\nA descending-ordered list of already-calculated prediction interval sizes\nReturn type:\nlist[int]\ncompute_datetime_trend_plots(backtest=0, source=SOURCE_TYPE.VALIDATION, forecast_distance_start=None, forecast_distance_end=None)\uf0c1\nComputes datetime trend plots\n(Accuracy over Time, Forecast vs Actual, Anomaly over Time) for this model\nAdded in version v2.25.\nParameters:\nbacktest (int or string, optional) \u2013 Compute plots for a specific backtest (use the backtest index starting from zero).\nTo compute plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nforecast_distance_start (Optional[int]:) \u2013 The start of forecast distance range (forecast window) to compute.\nIf not specified, the first forecast distance for this project will be used.\nOnly for time series supervised models\nforecast_distance_end (Optional[int]:) \u2013 The end of forecast distance range (forecast window) to compute.\nIf not specified, the last forecast distance for this project will be used.\nOnly for time series supervised models\nReturns:\njob \u2013 a Job tracking the datetime trend plots computation\nReturn type:\nJob\nNotes\nForecast distance specifies the number of time steps\nbetween the predicted point and the origin point.\nFor the multiseries models only first 1000 series in\nalphabetical order and an average plot for them will be computed.\nMaximum 100 forecast distances can be requested for\ncalculation in time series supervised projects.\nget_accuracy_over_time_plots_metadata(forecast_distance=None)\uf0c1\nRetrieve Accuracy over Time plots metadata for this model.\nAdded in version v2.25.\nParameters:\nforecast_distance (Optional[int]) \u2013 Forecast distance to retrieve the metadata for.\nIf not specified, the first forecast distance for this project will be used.\nOnly available for time series projects.\nReturns:\nmetadata \u2013 a AccuracyOverTimePlotsMetadata\nrepresenting Accuracy over Time plots metadata\nReturn type:\nAccuracyOverTimePlotsMetadata\nget_accuracy_over_time_plot(backtest=0, source=SOURCE_TYPE.VALIDATION, forecast_distance=None, series_id=None, resolution=None, max_bin_size=None, start_date=None, end_date=None, max_wait=600)\uf0c1\nRetrieve Accuracy over Time plots for this model.\nAdded in version v2.25.\nParameters:\nbacktest (int or string, optional) \u2013 Retrieve plots for a specific backtest (use the backtest index starting from zero).\nTo retrieve plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nforecast_distance (Optional[int]) \u2013 Forecast distance to retrieve the plots for.\nIf not specified, the first forecast distance for this project will be used.\nOnly available for time series projects.\nseries_id (string, optional) \u2013 The name of the series to retrieve for multiseries projects.\nIf not provided an average plot for the first 1000 series will be retrieved.\nresolution (string, optional) \u2013 Specifying at which resolution the data should be binned.\nIf not provided an optimal resolution will be used to\nbuild chart data with number of bins <= max_bin_size.\nOne of dr.enums.DATETIME_TREND_PLOTS_RESOLUTION.\nmax_bin_size (Optional[int]) \u2013 An int between 1 and 1000, which specifies\nthe maximum number of bins for the retrieval. Default is 500.\nstart_date (datetime.datetime, optional) \u2013 The start of the date range to return.\nIf not specified, start date for requested plot will be used.\nend_date (datetime.datetime, optional) \u2013 The end of the date range to return.\nIf not specified, end date for requested plot will be used.\nmax_wait (int or None, optional) \u2013 The maximum time to wait for a compute job to complete before retrieving the plots.\nDefault is dr.enums.DEFAULT_MAX_WAIT.\nIf 0 or None, the plots would be retrieved without attempting the computation.\nReturns:\nplot \u2013 a AccuracyOverTimePlot\nrepresenting Accuracy over Time plot\nReturn type:\nAccuracyOverTimePlot\nExamples\nimport datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_accuracy_over_time_plot()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", [\"actual\", \"predicted\"]).get_figure()\nfigure.savefig(\"accuracy_over_time.png\")\nget_accuracy_over_time_plot_preview(backtest=0, source=SOURCE_TYPE.VALIDATION, forecast_distance=None, series_id=None, max_wait=600)\uf0c1\nRetrieve Accuracy over Time preview plots for this model.\nAdded in version v2.25.\nParameters:\nbacktest (int or string, optional) \u2013 Retrieve plots for a specific backtest (use the backtest index starting from zero).\nTo retrieve plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nforecast_distance (Optional[int]) \u2013 Forecast distance to retrieve the plots for.\nIf not specified, the first forecast distance for this project will be used.\nOnly available for time series projects.\nseries_id (string, optional) \u2013 The name of the series to retrieve for multiseries projects.\nIf not provided an average plot for the first 1000 series will be retrieved.\nmax_wait (int or None, optional) \u2013 The maximum time to wait for a compute job to complete before retrieving the plots.\nDefault is dr.enums.DEFAULT_MAX_WAIT.\nIf 0 or None, the plots would be retrieved without attempting the computation.\nReturns:\nplot \u2013 a AccuracyOverTimePlotPreview\nrepresenting Accuracy over Time plot preview\nReturn type:\nAccuracyOverTimePlotPreview\nExamples\nimport datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_accuracy_over_time_plot_preview()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", [\"actual\", \"predicted\"]).get_figure()\nfigure.savefig(\"accuracy_over_time_preview.png\")\nget_forecast_vs_actual_plots_metadata()\uf0c1\nRetrieve Forecast vs Actual plots metadata for this model.\nAdded in version v2.25.\nReturns:\nmetadata \u2013 a ForecastVsActualPlotsMetadata\nrepresenting Forecast vs Actual plots metadata\nReturn type:\nForecastVsActualPlotsMetadata\nget_forecast_vs_actual_plot(backtest=0, source=SOURCE_TYPE.VALIDATION, forecast_distance_start=None, forecast_distance_end=None, series_id=None, resolution=None, max_bin_size=None, start_date=None, end_date=None, max_wait=600)\uf0c1\nRetrieve Forecast vs Actual plots for this model.\nAdded in version v2.25.\nParameters:\nbacktest (int or string, optional) \u2013 Retrieve plots for a specific backtest (use the backtest index starting from zero).\nTo retrieve plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nforecast_distance_start (Optional[int]:) \u2013 The start of forecast distance range (forecast window) to retrieve.\nIf not specified, the first forecast distance for this project will be used.\nforecast_distance_end (Optional[int]:) \u2013 The end of forecast distance range (forecast window) to retrieve.\nIf not specified, the last forecast distance for this project will be used.\nseries_id (string, optional) \u2013 The name of the series to retrieve for multiseries projects.\nIf not provided an average plot for the first 1000 series will be retrieved.\nresolution (string, optional) \u2013 Specifying at which resolution the data should be binned.\nIf not provided an optimal resolution will be used to\nbuild chart data with number of bins <= max_bin_size.\nOne of dr.enums.DATETIME_TREND_PLOTS_RESOLUTION.\nmax_bin_size (Optional[int]) \u2013 An int between 1 and 1000, which specifies\nthe maximum number of bins for the retrieval. Default is 500.\nstart_date (datetime.datetime, optional) \u2013 The start of the date range to return.\nIf not specified, start date for requested plot will be used.\nend_date (datetime.datetime, optional) \u2013 The end of the date range to return.\nIf not specified, end date for requested plot will be used.\nmax_wait (int or None, optional) \u2013 The maximum time to wait for a compute job to complete before retrieving the plots.\nDefault is dr.enums.DEFAULT_MAX_WAIT.\nIf 0 or None, the plots would be retrieved without attempting the computation.\nReturns:\nplot \u2013 a ForecastVsActualPlot\nrepresenting Forecast vs Actual plot\nReturn type:\nForecastVsActualPlot\nExamples\nimport datarobot as dr\nimport pandas as pd\nimport matplotlib.pyplot as plt\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_forecast_vs_actual_plot()\ndf = pd.DataFrame.from_dict(plot.bins)\n# As an example, get the forecasts for the 10th point\nforecast_point_index = 10\n# Pad the forecasts for plotting. The forecasts length must match the df length\nforecasts = [None] * forecast_point_index + df.forecasts[forecast_point_index]\nforecasts = forecasts + [None] * (len(df) - len(forecasts))\nplt.plot(df.start_date, df.actual, label=\"Actual\")\nplt.plot(df.start_date, forecasts, label=\"Forecast\")\nforecast_point = df.start_date[forecast_point_index]\nplt.title(\"Forecast vs Actual (Forecast Point {})\".format(forecast_point))\nplt.legend()\nplt.savefig(\"forecast_vs_actual.png\")\nget_forecast_vs_actual_plot_preview(backtest=0, source=SOURCE_TYPE.VALIDATION, series_id=None, max_wait=600)\uf0c1\nRetrieve Forecast vs Actual preview plots for this model.\nAdded in version v2.25.\nParameters:\nbacktest (int or string, optional) \u2013 Retrieve plots for a specific backtest (use the backtest index starting from zero).\nTo retrieve plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nseries_id (string, optional) \u2013 The name of the series to retrieve for multiseries projects.\nIf not provided an average plot for the first 1000 series will be retrieved.\nmax_wait (int or None, optional) \u2013 The maximum time to wait for a compute job to complete before retrieving the plots.\nDefault is dr.enums.DEFAULT_MAX_WAIT.\nIf 0 or None, the plots would be retrieved without attempting the computation.\nReturns:\nplot \u2013 a ForecastVsActualPlotPreview\nrepresenting Forecast vs Actual plot preview\nReturn type:\nForecastVsActualPlotPreview\nExamples\nimport datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_forecast_vs_actual_plot_preview()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", [\"actual\", \"predicted\"]).get_figure()\nfigure.savefig(\"forecast_vs_actual_preview.png\")\nget_anomaly_over_time_plots_metadata()\uf0c1\nRetrieve Anomaly over Time plots metadata for this model.\nAdded in version v2.25.\nReturns:\nmetadata \u2013 a AnomalyOverTimePlotsMetadata\nrepresenting Anomaly over Time plots metadata\nReturn type:\nAnomalyOverTimePlotsMetadata\nget_anomaly_over_time_plot(backtest=0, source=SOURCE_TYPE.VALIDATION, series_id=None, resolution=None, max_bin_size=None, start_date=None, end_date=None, max_wait=600)\uf0c1\nRetrieve Anomaly over Time plots for this model.\nAdded in version v2.25.\nParameters:\nbacktest (int or string, optional) \u2013 Retrieve plots for a specific backtest (use the backtest index starting from zero).\nTo retrieve plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nseries_id (string, optional) \u2013 The name of the series to retrieve for multiseries projects.\nIf not provided an average plot for the first 1000 series will be retrieved.\nresolution (string, optional) \u2013 Specifying at which resolution the data should be binned.\nIf not provided an optimal resolution will be used to\nbuild chart data with number of bins <= max_bin_size.\nOne of dr.enums.DATETIME_TREND_PLOTS_RESOLUTION.\nmax_bin_size (Optional[int]) \u2013 An int between 1 and 1000, which specifies\nthe maximum number of bins for the retrieval. Default is 500.\nstart_date (datetime.datetime, optional) \u2013 The start of the date range to return.\nIf not specified, start date for requested plot will be used.\nend_date (datetime.datetime, optional) \u2013 The end of the date range to return.\nIf not specified, end date for requested plot will be used.\nmax_wait (int or None, optional) \u2013 The maximum time to wait for a compute job to complete before retrieving the plots.\nDefault is dr.enums.DEFAULT_MAX_WAIT.\nIf 0 or None, the plots would be retrieved without attempting the computation.\nReturns:\nplot \u2013 a AnomalyOverTimePlot\nrepresenting Anomaly over Time plot\nReturn type:\nAnomalyOverTimePlot\nExamples\nimport datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_anomaly_over_time_plot()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", \"predicted\").get_figure()\nfigure.savefig(\"anomaly_over_time.png\")\nget_anomaly_over_time_plot_preview(prediction_threshold=0.5, backtest=0, source=SOURCE_TYPE.VALIDATION, series_id=None, max_wait=600)\uf0c1\nRetrieve Anomaly over Time preview plots for this model.\nAdded in version v2.25.\nParameters:\nprediction_threshold (Optional[float]) \u2013 Only bins with predictions exceeding this threshold will be returned in the response.\nbacktest (int or string, optional) \u2013 Retrieve plots for a specific backtest (use the backtest index starting from zero).\nTo retrieve plots for holdout, use dr.enums.DATA_SUBSET.HOLDOUT\nsource (string, optional) \u2013 The source of the data for the backtest/holdout.\nAttribute must be one of dr.enums.SOURCE_TYPE\nseries_id (string, optional) \u2013 The name of the series to retrieve for multiseries projects.\nIf not provided an average plot for the first 1000 series will be retrieved.\nmax_wait (int or None, optional) \u2013 The maximum time to wait for a compute job to complete before retrieving the plots.\nDefault is dr.enums.DEFAULT_MAX_WAIT.\nIf 0 or None, the plots would be retrieved without attempting the computation.\nReturns:\nplot \u2013 a AnomalyOverTimePlotPreview\nrepresenting Anomaly over Time plot preview\nReturn type:\nAnomalyOverTimePlotPreview\nExamples\nimport datarobot as dr\nimport pandas as pd\nimport matplotlib.pyplot as plt\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_anomaly_over_time_plot_preview(prediction_threshold=0.01)\ndf = pd.DataFrame.from_dict(plot.bins)\nx = pd.date_range(\nplot.start_date, plot.end_date, freq=df.end_date[0] - df.start_date[0]\n)\nplt.plot(x, [0] * len(x), label=\"Date range\")\nplt.plot(df.start_date, [0] * len(df.start_date), \"ro\", label=\"Anomaly\")\nplt.yticks([])\nplt.legend()\nplt.savefig(\"anomaly_over_time_preview.png\")\ninitialize_anomaly_assessment(backtest, source, series_id=None)\uf0c1\nInitialize the anomaly assessment insight and calculate\nShapley explanations for the most anomalous points in the subset.\nThe insight is available for anomaly detection models in time series unsupervised projects\nwhich also support calculation of Shapley values.\nParameters:\nbacktest (int starting with 0 or \"holdout\") \u2013 The backtest to compute insight for.\nsource (\"training\" or \"validation\") \u2013 The source to compute insight for.\nseries_id (string) \u2013 Required for multiseries projects. The series id to compute insight for.\nSay if there is a series column containing cities,\nthe example of the series name to pass would be \u201cBoston\u201d\nReturn type:\nAnomalyAssessmentRecord\nget_anomaly_assessment_records(backtest=None, source=None, series_id=None, limit=100, offset=0, with_data_only=False)\uf0c1\nRetrieve computed Anomaly Assessment records for this model. Model must be an anomaly\ndetection model in time series unsupervised project which also supports calculation of\nShapley values.\nRecords can be filtered by the data backtest, source and series_id.\nThe results can be limited.\nAdded in version v2.25.\nParameters:\nbacktest (int starting with 0 or \"holdout\") \u2013 The backtest of the data to filter records by.\nsource (\"training\" or \"validation\") \u2013 The source of the data to filter records by.\nseries_id (string) \u2013 The series id to filter records by.\nlimit (Optional[int])\noffset (Optional[int])\nwith_data_only (Optional[bool]) \u2013 Whether to return only records with preview and explanations available.\nFalse by default.\nReturns:\nrecords \u2013 a AnomalyAssessmentRecord\nrepresenting Anomaly Assessment Record\nReturn type:\nlist of AnomalyAssessmentRecord\nget_feature_impact(with_metadata=False, backtest=None, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the computed Feature Impact results, a measure of the relevance of each\nfeature in the model.\nFeature Impact is computed for each column by creating new data with that column randomly\npermuted (but the others left unchanged), and seeing how the error metric score for the\npredictions is affected. The \u2018impactUnnormalized\u2019 is how much worse the error metric score\nis when making predictions on this modified data. The \u2018impactNormalized\u2019 is normalized so\nthat the largest value is 1. In both cases, larger values indicate more important features.\nIf a feature is a redundant feature, i.e. once other features are considered it doesn\u2019t\ncontribute much in addition, the \u2018redundantWith\u2019 value is the name of feature that has the\nhighest correlation with this feature. Note that redundancy detection is only available for\njobs run after the addition of this feature. When retrieving data that predates this\nfunctionality, a NoRedundancyImpactAvailable warning will be used.\nElse where this technique is sometimes called \u2018Permutation Importance\u2019.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nParameters:\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\nbacktest (int or string) \u2013 The index of the backtest unless it is holdout then it is string \u2018holdout\u2019. This is supported\nonly in DatetimeModels\ndata_slice_filter (DataSlice, optional) \u2013 (New in version v3.4) A data slice used to filter the return values based on the dataslice.id.\nBy default, this function will use data_slice_filter.id == None which returns an unsliced insight.\nIf data_slice_filter is None then get_roc_curve will raise a ValueError.\nReturns:\nThe feature impact data response depends on the with_metadata parameter. The response is\neither a dict with metadata and a list with actual data or just a list with that data.\nEach List item is a dict with the keys featureName, impactNormalized, and\nimpactUnnormalized, redundantWith and count.\nFor dict response available keys are:\nfeatureImpacts - Feature Impact data as a dictionary. Each item is a dict withkeys: featureName, impactNormalized, and impactUnnormalized, and\nredundantWith.\nshapBased - A boolean that indicates whether Feature Impact was calculated usingShapley values.\nranRedundancyDetection - A boolean that indicates whether redundant featureidentification was run while calculating this Feature Impact.\nrowCount - An integer or None that indicates the number of rows that was used tocalculate Feature Impact. For the Feature Impact calculated with the default\nlogic, without specifying the rowCount, we return None here.\ncount - An integer with the number of features under the featureImpacts.\nReturn type:\nlist or dict\nRaises:\nClientError \u2013 If the feature impacts have not been computed.\nrequest_feature_impact(row_count=None, with_metadata=False, backtest=None, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRequest feature impacts to be computed for the model.\nSee get_feature_impact for more\ninformation on the result of the job.\nParameters:\nrow_count (int) \u2013 The sample size (specified in rows) to use for Feature Impact computation. This is not\nsupported for unsupervised, multi-class (that has a separate method) and time series\nprojects.\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\nbacktest (int or string) \u2013 The index of the backtest unless it is holdout then it is string \u2018holdout\u2019. This is supported\nonly in DatetimeModels\ndata_slice_filter (DataSlice, optional) \u2013 (New in version v3.4) A data slice used to filter the return values based on the dataslice.id.\nBy default, this function will use data_slice_filter.id == None which returns an unsliced insight.\nIf data_slice_filter is None then get_roc_curve will raise a ValueError.\nReturns:\njob \u2013 A Job representing the feature impact computation. To get the completed feature impact\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nRaises:\nJobAlreadyRequested \u2013 If the feature impacts have already been requested.\nget_or_request_feature_impact(max_wait=600, row_count=None, with_metadata=False, backtest=None, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve feature impact for the model, requesting a job if it hasn\u2019t been run previously\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature impact job to complete before erroring\nrow_count (int) \u2013 The sample size (specified in rows) to use for Feature Impact computation. This is not\nsupported for unsupervised, multi-class (that has a separate method) and time series\nprojects.\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\nbacktest (str) \u2013 Feature Impact backtest. Can be \u2018holdout\u2019 or numbers from 0 up to max number of backtests in project.\ndata_slice_filter (DataSlice, optional) \u2013 (New in version v3.4) A data slice used to filter the return values based on the dataslice.id.\nBy default, this function will use data_slice_filter.id == None which returns an unsliced insight.\nIf data_slice_filter is None then get_roc_curve will raise a ValueError.\nReturns:\nfeature_impacts \u2013 The feature impact data. See\nget_feature_impact for the exact\nschema.\nReturn type:\nlist or dict\nrequest_lift_chart(source=None, backtest_index=None, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\n(New in version v3.4)\nRequest the model Lift Chart for the specified backtest data slice.\nParameters:\nsource (str) \u2013 (Deprecated in version v3.4)\nLift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nIf backtest_index is present then this will be ignored.\nbacktest_index (str) \u2013 Lift chart data backtest. Can be \u2018holdout\u2019 or numbers from 0 up to max number of backtests in project.\ndata_slice_filter (DataSlice, optional) \u2013 A data slice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen request_lift_chart will raise a ValueError.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nget_lift_chart(source=None, backtest_index=None, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\n(New in version v3.4)\nRetrieve the model Lift chart for the specified backtest and data slice.\nParameters:\nsource (str) \u2013 (Deprecated in version v3.4)\nLift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nFor time series and OTV models, also accepts values backtest_2, backtest_3, \u2026,\nup to the number of backtests in the model.\nIf backtest_index is present then this will be ignored.\nbacktest_index (str) \u2013 Lift chart data backtest. Can be \u2018holdout\u2019 or numbers from 0 up to max number of backtests in project.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A data slice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\nReturns:\nModel lift chart data\nReturn type:\nLiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nrequest_roc_curve(source=None, backtest_index=None, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\n(New in version v3.4)\nRequest the binary model Roc Curve for the specified backtest and data slice.\nParameters:\nsource (str) \u2013 (Deprecated in version v3.4)\nRoc Curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nIf backtest_index is present then this will be ignored.\nbacktest_index (str) \u2013 ROC curve data backtest. Can be \u2018holdout\u2019 or numbers from 0 up to max number of backtests in project.\ndata_slice_filter (DataSlice, optional) \u2013 A data slice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen request_roc_curve will raise a ValueError.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nget_roc_curve(source=None, backtest_index=None, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\n(New in version v3.4)\nRetrieve the ROC curve for a binary model for the specified backtest and data slice.\nParameters:\nsource (str) \u2013 (Deprecated in version v3.4)\nROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nFor time series and OTV models, also accepts values backtest_2, backtest_3, \u2026,\nup to the number of backtests in the model.\nIf backtest_index is present then this will be ignored.\nbacktest_index (str) \u2013 ROC curve data backtest. Can be \u2018holdout\u2019 or numbers from 0 up to max number of backtests in project.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A data slice used to filter the return values based on the data slice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_roc_curve will raise a ValueError.\nReturns:\nModel ROC curve data\nReturn type:\nRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\nTypeError \u2013 If the underlying project type is multilabel\nValueError \u2013 If data_slice_filter passed as None\nadvanced_tune(params, description=None)\uf0c1\nGenerate a new model with the specified advanced-tuning parameters\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nParameters:\nparams (dict) \u2013 Mapping of parameter ID to parameter value.\nThe list of valid parameter IDs for a model can be found by calling\nget_advanced_tuning_parameters().\nThis endpoint does not need to include values for all parameters.  If a parameter\nis omitted, its current_value will be used.\ndescription (str) \u2013 Human-readable string describing the newly advanced-tuned model\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ncontinue_incremental_learning_from_incremental_model(chunk_definition_id, early_stopping_rounds=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nchunk_definition_id (str) \u2013 The Mongo ID for the chunking service.\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks that, when no improvement has been shown, triggers the early stopping mechanism.\nReturns:\njob \u2013 The model retraining job that is created.\nReturn type:\nModelJob\ndelete()\uf0c1\nDelete a model from the project\u2019s leaderboard.\nReturn type:\nNone\ndownload_scoring_code(file_name, source_code=False)\uf0c1\nDownload the Scoring Code JAR.\nParameters:\nfile_name (str) \u2013 File path where scoring code will be saved.\nsource_code (Optional[bool]) \u2013 Set to True to download source code archive.\nIt will not be executable.\nReturn type:\nNone\ndownload_training_artifact(file_name)\uf0c1\nRetrieve trained artifact(s) from a model containing one or more custom tasks.\nArtifact(s) will be downloaded to the specified local filepath.\nParameters:\nfile_name (str) \u2013 File path where trained model artifact(s) will be saved.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nget_advanced_tuning_parameters()\uf0c1\nGet the advanced-tuning parameters available for this model.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nA dictionary describing the advanced-tuning parameters for the current model.\nThere are two top-level keys, tuning_description and tuning_parameters.\ntuning_description an optional value. If not None, then it indicates the\nuser-specified description of this set of tuning parameter.\ntuning_parameters is a list of a dicts, each has the following keys\nparameter_name : (str) name of the parameter (unique per task, see below)\nparameter_id : (str) opaque ID string uniquely identifying parameter\ndefault_value : (*) the actual value used to train the model; either\nthe single value of the parameter specified before training, or the best\nvalue from the list of grid-searched values (based on current_value)\ncurrent_value : (*) the single value or list of values of the\nparameter that were grid searched. Depending on the grid search\nspecification, could be a single fixed value (no grid search),\na list of discrete values, or a range.\ntask_name : (str) name of the task that this parameter belongs to\nconstraints: (dict) see the notes below\nvertex_id: (str) ID of vertex that this parameter belongs to\nReturn type:\ndict\nNotes\nThe type of default_value and current_value is defined by the constraints structure.\nIt will be a string or numeric Python type.\nconstraints is a dict with at least one, possibly more, of the following keys.\nThe presence of a key indicates that the parameter may take on the specified type.\n(If a key is absent, this means that the parameter may not take on the specified type.)\nIf a key on constraints is present, its value will be a dict containing\nall of the fields described below for that key.\n\"constraints\": {\n\"select\": {\n\"values\": [<list(basestring or number) : possible values>]\n},\n\"ascii\": {},\n\"unicode\": {},\n\"int\": {\n\"min\": <int : minimum valid value>,\n\"max\": <int : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"float\": {\n\"min\": <float : minimum valid value>,\n\"max\": <float : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"intList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <int : minimum valid value>,\n\"max_val\": <int : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"floatList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <float : minimum valid value>,\n\"max_val\": <float : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n}\n}\nThe keys have meaning as follows:\nselect:\nRather than specifying a specific data type, if present, it indicates that the parameter\nis permitted to take on any of the specified values.  Listed values may be of any string\nor real (non-complex) numeric type.\nascii:\nThe parameter may be a unicode object that encodes simple ASCII characters.\n(A-Z, a-z, 0-9, whitespace, and certain common symbols.)  In addition to listed\nconstraints, ASCII keys currently may not contain either newlines or semicolons.\nunicode:\nThe parameter may be any Python unicode object.\nint:\nThe value may be an object of type int within the specified range (inclusive).\nPlease note that the value will be passed around using the JSON format, and\nsome JSON parsers have undefined behavior with integers outside of the range\n[-(2**53)+1, (2**53)-1].\nfloat:\nThe value may be an object of type float within the specified range (inclusive).\nintList, floatList:\nThe value may be a list of int or float objects, respectively, following constraints\nas specified respectively by the int and float types (above).\nMany parameters only specify one key under constraints.  If a parameter specifies multiple\nkeys, the parameter may take on any value permitted by any key.\nget_all_confusion_charts(fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of all confusion matrices available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent for any source that is not available for this model and if this\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\nReturns:\nData for all available confusion charts for model.\nReturn type:\nlist of ConfusionChart\nget_all_feature_impacts(data_slice_filter=None)\uf0c1\nRetrieve a list of all feature impact results available for the model.\nParameters:\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen no data_slice filtering will be applied when requesting the roc_curve.\nReturns:\nData for all available model feature impacts. Or an empty list if not data found.\nReturn type:\nlist of dicts\nExamples\nmodel = datarobot.Model(id='model-id', project_id='project-id')\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()\nget_all_lift_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (Optional[bool]) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned lift chart by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model lift charts. Or an empty list if no data found.\nReturn type:\nlist of LiftChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()\nget_all_multiclass_lift_charts(fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nData for all available model lift charts.\nReturn type:\nlist of LiftChart\nget_all_residuals_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all residuals charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent\nfor any source that is not available for this model and if this model has a\ndefined parent model. If omitted or False, or this model has no parent, this will\nnot attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned residuals charts by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model residuals charts.\nReturn type:\nlist of ResidualsChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()\nget_all_roc_curves(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all ROC curves available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 filters the returned roc_curve by data_slice_filter.id.  If None (the default) applies no filter based on\ndata_slice_id.\nReturns:\nData for all available model ROC curves. Or an empty list if no RocCurves are found.\nReturn type:\nlist of RocCurve\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()\nget_confusion_chart(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a multiclass model\u2019s confusion matrix for the specified source.\nParameters:\nsource (str) \u2013 Confusion chart source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent if the confusion chart is not available for this model and the\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel ConfusionChart data\nReturn type:\nConfusionChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_cross_class_accuracy_scores()\uf0c1\nRetrieves a list of Cross Class Accuracy scores for the model.\nReturn type:\njson\nget_data_disparity_insights(feature, class_name1, class_name2)\uf0c1\nRetrieve a list of Cross Class Data Disparity insights for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\nclass_name1 (str) \u2013 One of the compared classes\nclass_name2 (str) \u2013 Another compared class\nReturn type:\njson\nget_fairness_insights(fairness_metrics_set=None, offset=0, limit=100)\uf0c1\nRetrieve a list of Per Class Bias insights for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturn type:\njson\nget_features_used()\uf0c1\nQuery the server to determine which features were used.\nNote that the data returned by this method is possibly different\nthan the names of the features in the featurelist used by this model.\nThis method will return the raw features that must be supplied in order\nfor predictions to be generated on a new set of data. The featurelist,\nin contrast, would also include the names of derived features.\nReturns:\nfeatures \u2013 The names of the features used in the model.\nReturn type:\nList[str]\nget_frozen_child_models()\uf0c1\nRetrieve the IDs for all models that are frozen from this model.\nReturn type:\nA list of Models\nget_labelwise_roc_curves(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of LabelwiseRocCurve instances for a multilabel model for the given source and all labels.\nThis method is valid only for multilabel projects. For binary projects, use Model.get_roc_curve API .\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\nReturns:\nLabelwise ROC Curve instances for source and all labels\nReturn type:\nlist of LabelwiseRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_missing_report_info()\uf0c1\nRetrieve a report on missing training data that can be used to understand missing\nvalues treatment in the model. The report consists of missing values resolutions for\nfeatures numeric or categorical features that were part of building the model.\nReturns:\nThe queried model missing report, sorted by missing count (DESCENDING order).\nReturn type:\nAn iterable of MissingReportPerFeature\nget_model_blueprint_chart()\uf0c1\nRetrieve a diagram that can be used to understand\ndata flow in the blueprint.\nReturns:\nThe queried model blueprint chart.\nReturn type:\nModelBlueprintChart\nget_model_blueprint_documents()\uf0c1\nGet documentation for tasks used in this model.\nReturns:\nAll documents available for the model.\nReturn type:\nlist of BlueprintTaskDocument\nget_model_blueprint_json()\uf0c1\nGet the blueprint json representation used by this model.\nReturns:\nJson representation of the blueprint stages.\nReturn type:\nBlueprintJson\nget_multiclass_feature_impact()\uf0c1\nFor multiclass it\u2019s possible to calculate feature impact separately for each target class.\nThe method for calculation is exactly the same, calculated in one-vs-all style for each\ntarget class.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. Each item is a dict with the keys \u2018featureImpacts\u2019 (list),\n\u2018class\u2019 (str). Each item in \u2018featureImpacts\u2019 is a dict with the keys \u2018featureName\u2019,\n\u2018impactNormalized\u2019, and \u2018impactUnnormalized\u2019, and \u2018redundantWith\u2019.\nReturn type:\nlist of dict\nRaises:\nClientError \u2013 If the multiclass feature impacts have not been computed.\nget_multiclass_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_multilabel_lift_charts(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve model Lift charts for the specified source.\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_num_iterations_trained()\uf0c1\nRetrieves the number of estimators trained by early-stopping tree-based models.\n\u2013 versionadded:: v2.22\nReturns:\nprojectId (str) \u2013 id of project containing the model\nmodelId (str) \u2013 id of the model\ndata (array) \u2013 list of numEstimatorsItem objects, one for each modeling stage.\nnumEstimatorsItem will be of the form\nstage (str) \u2013 indicates the modeling stage (for multi-stage models); None of single-stage models\nnumIterations (int) \u2013 the number of estimators or iterations trained by the model\nget_parameters()\uf0c1\nRetrieve model parameters.\nReturns:\nModel parameters for this model.\nReturn type:\nModelParameters\nget_pareto_front()\uf0c1\nRetrieve the Pareto Front for a Eureqa model.\nThis method is only supported for Eureqa models.\nReturns:\nModel ParetoFront data\nReturn type:\nParetoFront\nget_prime_eligibility()\uf0c1\nCheck if this model can be approximated with DataRobot Prime\nReturns:\nprime_eligibility \u2013 a dict indicating whether a model can be approximated with DataRobot Prime\n(key can_make_prime) and why it may be ineligible (key message)\nReturn type:\ndict\nget_residuals_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible\nvalues.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent if\nthe residuals chart is not available for this model and the model has a defined parent\nmodel. If omitted or False, or there is no parent model, will not attempt to return\nresiduals data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_residuals_chart will raise a ValueError.\nReturns:\nModel residuals chart data\nReturn type:\nResidualsChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_rulesets()\uf0c1\nList the rulesets approximating this model generated by DataRobot Prime\nIf this model hasn\u2019t been approximated yet, will return an empty list.  Note that these\nare rulesets approximating this model, not rulesets used to construct this model.\nReturns:\nrulesets\nReturn type:\nlist of Ruleset\nget_supported_capabilities()\uf0c1\nRetrieves a summary of the capabilities supported by a model.\nAdded in version v2.14.\nReturns:\nsupportsBlending (bool) \u2013 whether the model supports blending\nsupportsMonotonicConstraints (bool) \u2013 whether the model supports monotonic constraints\nhasWordCloud (bool) \u2013 whether the model has word cloud data available\neligibleForPrime (bool) \u2013 (Deprecated in version v3.6)\nwhether the model is eligible for Prime\nhasParameters (bool) \u2013 whether the model has parameters that can be retrieved\nsupportsCodeGeneration (bool) \u2013 (New in version v2.18) whether the model supports code generation\nsupportsShap (bool) \u2013\n(New in version v2.18) True if the model supports Shapley package. i.e. Shapley basedfeature Importance\nsupportsEarlyStopping (bool) \u2013 (New in version v2.22) True if this is an early stopping\ntree-based model and number of trained iterations can be retrieved.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this model at leaderboard.\nReturn type:\nstr\nget_word_cloud(exclude_stop_words=False)\uf0c1\nRetrieve word cloud data for the model.\nParameters:\nexclude_stop_words (Optional[bool]) \u2013 Set to True if you want stopwords filtered out of response.\nReturns:\nWord cloud data for the model.\nReturn type:\nWordCloud\nincremental_train(data_stage_id, training_data_name=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model.\nSee train_incremental documentation.\nReturn type:\nModelJob\nclassmethod list(project_id, sort_by_partition='validation', sort_by_metric=None, with_metric=None, search_term=None, featurelists=None, families=None, blueprints=None, labels=None, characteristics=None, training_filters=None, number_of_clusters=None, limit=100, offset=0)\uf0c1\nRetrieve paginated model records, sorted by scores, with optional filtering.\nParameters:\nsort_by_partition (str, one of validation, backtesting, crossValidation or holdout) \u2013 Set the partition to use for sorted (by score) list of models. validation is the default.\nsort_by_metric (str) \u2013 Set the project metric to use for model sorting. DataRobot-selected project optimization metric\nis the default.\nwith_metric (str) \u2013 For a single-metric list of results, specify that project metric.\nsearch_term (str) \u2013 If specified, only models containing the term in their name or processes are returned.\nfeaturelists (List[str]) \u2013 If specified, only models trained on selected featurelists are returned.\nfamilies (List[str]) \u2013 If specified, only models belonging to selected families are returned.\nblueprints (List[str]) \u2013 If specified, only models trained on specified blueprint IDs are returned.\nlabels (List[str], starred or prepared for deployment) \u2013 If specified, only models tagged with all listed labels are returned.\ncharacteristics (List[str]) \u2013 If specified, only models matching all listed characteristics are returned.\ntraining_filters (List[str]) \u2013 If specified, only models matching at least one of the listed training conditions are returned.\nThe following formats are supported for autoML and datetime partitioned projects:\n- number of rows in training subset\nFor datetime partitioned projects:\n- <training duration>, example P6Y0M0D\n- <training_duration>-<time_window_sample_percent>-<sampling_method> Example: P6Y0M0D-78-Random,\n(returns models trained on 6 years of data, sampling rate 78%, random sampling).\n- Start/end date\n- Project settings\nnumber_of_clusters (list of int) \u2013 Filter models by number of clusters. Applicable only in unsupervised clustering projects.\nlimit (int)\noffset (int)\nReturns:\ngeneric_models\nReturn type:\nlist of GenericModel\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nrequest_approximation()\uf0c1\nRequest an approximation of this model using DataRobot Prime\nThis will create several rulesets that could be used to approximate this model.  After\ncomparing their scores and rule counts, the code used in the approximation can be downloaded\nand run locally.\nReturns:\njob \u2013 the job generating the rulesets\nReturn type:\nJob\nrequest_cross_class_accuracy_scores()\uf0c1\nRequest data disparity insights to be computed for the model.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_data_disparity_insights(feature, compared_class_names)\uf0c1\nRequest data disparity insights to be computed for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\ncompared_class_names (list(str)) \u2013 List of two classes to compare\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_external_test(dataset_id, actual_value_column=None)\uf0c1\nRequest external test to compute scores and insights on an external test dataset\nParameters:\ndataset_id (string) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nReturns:\njob \u2013 a Job representing external dataset insights computation\nReturn type:\nJob\nrequest_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest fairness insights to be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_frozen_datetime_model(training_row_count=None, training_duration=None, training_start_date=None, training_end_date=None, time_window_sample_pct=None, sampling_method=None)\uf0c1\nTrain a new frozen model with parameters from this model.\nRequires that this model belongs to a datetime partitioned project.  If it does not, an\nerror will occur when submitting the job.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nIn addition of training_row_count and training_duration, frozen datetime models may be\ntrained on an exact date range.  Only one of training_row_count, training_duration, or\ntraining_start_date and training_end_date should be specified.\nModels specified using training_start_date and training_end_date are the only ones that can\nbe trained into the holdout data (once the holdout is unlocked).\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\ntraining_duration may not be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, training_row_count may not be specified.\ntraining_start_date (datetime.datetime, optional) \u2013 the start date of the data to train to model on.  Only rows occurring at or after\nthis datetime will be used.  If training_start_date is specified, training_end_date\nmust also be specified.\ntraining_end_date (datetime.datetime, optional) \u2013 the end date of the data to train the model on.  Only rows occurring strictly before\nthis datetime will be used.  If training_end_date is specified, training_start_date\nmust also be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates).  An integer between 1 and 99 indicating the percentage to sample by\nwithin the window.  The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_per_class_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest per-class fairness insights be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 The fairness metric used to calculate the fairness scores.\nValue can be any one of <datarobot.enums.FairnessMetricsSet>.\nReturns:\nstatus_check_job \u2013 The returned object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_predictions(dataset_id=None, dataset=None, dataframe=None, file_path=None, file=None, include_prediction_intervals=None, prediction_intervals_size=None, forecast_point=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, explanation_algorithm=None, max_explanations=None, max_ngram_explanations=None)\uf0c1\nRequests predictions against a previously uploaded dataset.\nParameters:\ndataset_id (string, optional) \u2013 The ID of the dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataset (Dataset, optional) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataframe (pd.DataFrame, optional) \u2013 (New in v3.0)\nThe dataframe to make predictions against\nfile_path (Optional[str]) \u2013 (New in v3.0)\nPath to file to make predictions against\nfile (IOBase, optional) \u2013 (New in v3.0)\nFile to make predictions against\ninclude_prediction_intervals (Optional[bool]) \u2013 (New in v2.16) For time series projects only.\nSpecifies whether prediction intervals should be calculated for this request. Defaults\nto True if prediction_intervals_size is specified, otherwise defaults to False.\nprediction_intervals_size (Optional[int]) \u2013 (New in v2.16) For time series projects only.\nRepresents the percentile to use for the size of the prediction intervals. Defaults to\n80 if include_prediction_intervals is True. Prediction intervals size must be\nbetween 1 and 100 (inclusive).\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The end date for bulk\npredictions, exclusive. Note that this parameter is for generating historical\npredictions using the training data. This parameter should be provided in conjunction\nwith predictions_start_date. Can\u2019t be provided with the\nforecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nexplanation_algorithm ((New in version v2.21) optional; If set to 'shap', the) \u2013 response will include prediction explanations based on the SHAP explainer (SHapley\nAdditive exPlanations). Defaults to null (no prediction explanations).\nmax_explanations ((New in version v2.21) int optional; specifies the maximum number of) \u2013 explanation values that should be returned for each row, ordered by absolute value,\ngreatest to least. If null, no limit. In the case of \u2018shap\u2019: if the number of features\nis greater than the limit, the sum of remaining values will also be returned as\nshapRemainingTotal. Defaults to null. Cannot be set if explanation_algorithm is\nomitted.\nmax_ngram_explanations (optional;\u00a0 int or str) \u2013 (New in version v2.29) Specifies the maximum number of text explanation values that\nshould be returned. If set to all, text explanations will be computed and all the\nngram explanations will be returned. If set to a non zero positive integer value, text\nexplanations will be computed and this amount of descendingly sorted ngram explanations\nwill be returned. By default text explanation won\u2019t be triggered to be computed.\nReturns:\njob \u2013 The job computing the predictions\nReturn type:\nPredictJob\nrequest_residuals_chart(source, data_slice_id=None)\uf0c1\nRequest the model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nset_prediction_threshold(threshold)\uf0c1\nSet a custom prediction threshold for the model.\nMay not be used once prediction_threshold_read_only is True for this model.\nParameters:\nthreshold (float) \u2013 only used for binary classification projects. The threshold to when deciding between\nthe positive and negative classes when making predictions.  Should be between 0.0 and\n1.0 (inclusive).\nstar_model()\uf0c1\nMark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nstart_advanced_tuning_session()\uf0c1\nStart an Advanced Tuning session.  Returns an object that helps\nset up arguments for an Advanced Tuning model execution.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nSession for setting up and running Advanced Tuning on a model\nReturn type:\nAdvancedTuningSession\nstart_incremental_learning_from_sample(early_stopping_rounds=None, first_iteration_only=False, chunk_definition_id=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks in which no improvement is observed that triggers the early stopping mechanism.\nfirst_iteration_only (bool) \u2013 Specifies whether incremental learning training should be limited to the first\niteration. If set to True, the training process will be performed only for the first\niteration. If set to False, training will continue until early stopping conditions\nare met or the maximum number of iterations is reached. The default value is False.\nchunk_definition_id (str) \u2013 The id of the chunk definition to be use for incremental training.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\ntrain_datetime(featurelist_id=None, training_row_count=None, training_duration=None, time_window_sample_pct=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, use_project_settings=False, sampling_method=None, n_clusters=None)\uf0c1\nTrains this model on a different featurelist or sample size.\nRequires that this model is part of a datetime partitioned project; otherwise, an error will\noccur.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\nfeaturelist_id (Optional[str]) \u2013 the featurelist to use to train the model.  If not specified, the featurelist of this\nmodel is used.\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\nneither training_duration nor use_project_settings may be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, neither training_row_count nor use_project_settings may be\nspecified.\nuse_project_settings (Optional[bool]) \u2013 (New in version v2.20) defaults to False. If True, indicates that the custom\nbacktest partitioning settings specified by the user will be used to train the model and\nevaluate backtest scores. If specified, neither training_row_count nor\ntraining_duration may be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates). An integer between 1 and 99 indicating the percentage to sample by\nwithin the window. The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nn_clusters (Optional[int]) \u2013 (New in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nReturns:\njob \u2013 the created job to build the model\nReturn type:\nModelJob\ntrain_incremental(data_stage_id, training_data_name=None, data_stage_encoding=None, data_stage_delimiter=None, data_stage_compression=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model using\nadditional data. The id of the additional data to use for training is specified with the data_stage_id.\nOptionally a name for the iteration can be supplied by the user to help identify the contents of data in\nthe iteration.\nThis functionality requires the INCREMENTAL_LEARNING feature flag to be enabled.\nParameters:\ndata_stage_id (str) \u2013 The id of the data stage to use for training.\ntraining_data_name (Optional[str]) \u2013 The name of the iteration or data stage to indicate what the incremental learning was performed on.\ndata_stage_encoding (Optional[str]) \u2013 The encoding type of the data in the data stage (default: UTF-8).\nSupported formats: UTF-8, ASCII, WINDOWS1252\ndata_stage_encoding \u2013 The delimiter used by the data in the data stage (default: \u2018,\u2019).\ndata_stage_compression (Optional[str]) \u2013 The compression type of the data stage file, e.g. \u2018zip\u2019 (default: None).\nSupported formats: zip\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nunstar_model()\uf0c1\nUnmark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nFrozen models\uf0c1\nclass datarobot.models.FrozenModel\uf0c1\nRepresents a model tuned with parameters which are derived from another model\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nid (str) \u2013 the id of the model\nproject_id (str) \u2013 the id of the project the model belongs to\nprocesses (List[str]) \u2013 the processes used by the model\nfeaturelist_name (str) \u2013 the name of the featurelist used by the model\nfeaturelist_id (str) \u2013 the id of the featurelist used by the model\nsample_pct (float) \u2013 the percentage of the project dataset used in training the model\ntraining_row_count (int or None) \u2013 the number of rows of the project dataset used in training the model.  In a datetime\npartitioned project, if specified, defines the number of rows used to train the model and\nevaluate backtest scores; if unspecified, either training_duration or\ntraining_start_date and training_end_date was used to determine that instead.\ntraining_duration (str or None) \u2013 only present for models in datetime partitioned projects.  If specified, a duration string\nspecifying the duration spanned by the data used to train the model and evaluate backtest\nscores.\ntraining_start_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the start\ndate of the data used to train the model.\ntraining_end_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the end\ndate of the data used to train the model.\nmodel_type (str) \u2013 what model this is, e.g. \u2018Nystroem Kernel SVM Regressor\u2019\nmodel_category (str) \u2013 what kind of model this is - \u2018prime\u2019 for DataRobot Prime models, \u2018blend\u2019 for blender models,\nand \u2018model\u2019 for other models\nis_frozen (bool) \u2013 whether this model is a frozen model\nparent_model_id (str) \u2013 the id of the model that tuning parameters are derived from\nblueprint_id (str) \u2013 the id of the blueprint used in this model\nmetrics (dict) \u2013 a mapping from each metric to the model\u2019s scores for that metric\nmonotonic_increasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically increasing relationship to the target.\nIf None, no such constraints are enforced.\nmonotonic_decreasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target.\nIf None, no such constraints are enforced.\nsupports_monotonic_constraints (bool) \u2013 optional, whether this model supports enforcing monotonic constraints\nis_starred (bool) \u2013 whether this model marked as starred\nprediction_threshold (float) \u2013 for binary classification projects, the threshold used for predictions\nprediction_threshold_read_only (bool) \u2013 indicated whether modification of the prediction threshold is forbidden. Threshold\nmodification is forbidden once a model has had a deployment created or predictions made via\nthe dedicated prediction API.\nmodel_number (integer) \u2013 model number assigned to a model\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nwhether this model is supported in the Composable ML.\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve a specific frozen model.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nmodel_id (str) \u2013 The model_id of the leaderboard item to retrieve.\nReturns:\nmodel \u2013 The queried instance.\nReturn type:\nFrozenModel\nRating table models\uf0c1\nclass datarobot.models.RatingTableModel\uf0c1\nA model that has a rating table.\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nid (str) \u2013 the id of the model\nproject_id (str) \u2013 the id of the project the model belongs to\nprocesses (List[str]) \u2013 the processes used by the model\nfeaturelist_name (str) \u2013 the name of the featurelist used by the model\nfeaturelist_id (str) \u2013 the id of the featurelist used by the model\nsample_pct (float or None) \u2013 the percentage of the project dataset used in training the model.  If the project uses\ndatetime partitioning, the sample_pct will be None.  See training_row_count,\ntraining_duration, and training_start_date and training_end_date instead.\ntraining_row_count (int or None) \u2013 the number of rows of the project dataset used in training the model.  In a datetime\npartitioned project, if specified, defines the number of rows used to train the model and\nevaluate backtest scores; if unspecified, either training_duration or\ntraining_start_date and training_end_date was used to determine that instead.\ntraining_duration (str or None) \u2013 only present for models in datetime partitioned projects.  If specified, a duration string\nspecifying the duration spanned by the data used to train the model and evaluate backtest\nscores.\ntraining_start_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the start\ndate of the data used to train the model.\ntraining_end_date (datetime or None) \u2013 only present for frozen models in datetime partitioned projects.  If specified, the end\ndate of the data used to train the model.\nmodel_type (str) \u2013 what model this is, e.g. \u2018Nystroem Kernel SVM Regressor\u2019\nmodel_category (str) \u2013 what kind of model this is - \u2018prime\u2019 for DataRobot Prime models, \u2018blend\u2019 for blender models,\nand \u2018model\u2019 for other models\nis_frozen (bool) \u2013 whether this model is a frozen model\nblueprint_id (str) \u2013 the id of the blueprint used in this model\nmetrics (dict) \u2013 a mapping from each metric to the model\u2019s scores for that metric\nrating_table_id (str) \u2013 the id of the rating table that belongs to this model\nmonotonic_increasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically increasing relationship to the target.\nIf None, no such constraints are enforced.\nmonotonic_decreasing_featurelist_id (str) \u2013 optional, the id of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target.\nIf None, no such constraints are enforced.\nsupports_monotonic_constraints (bool) \u2013 optional, whether this model supports enforcing monotonic constraints\nis_starred (bool) \u2013 whether this model marked as starred\nprediction_threshold (float) \u2013 for binary classification projects, the threshold used for predictions\nprediction_threshold_read_only (bool) \u2013 indicated whether modification of the prediction threshold is forbidden. Threshold\nmodification is forbidden once a model has had a deployment created or predictions made via\nthe dedicated prediction API.\nmodel_number (integer) \u2013 model number assigned to a model\nsupports_composable_ml (bool or None) \u2013 (New in version v2.26)\nwhether this model is supported in the Composable ML.\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve a specific rating table model\nIf the project does not have a rating table, a ClientError will occur.\nParameters:\nproject_id (str) \u2013 the id of the project the model belongs to\nmodel_id (str) \u2013 the id of the model to retrieve\nReturns:\nmodel \u2013 the model\nReturn type:\nRatingTableModel\nclassmethod create_from_rating_table(project_id, rating_table_id)\uf0c1\nCreates a new model from a validated rating table record. The\nRatingTable must not be associated with an existing model.\nParameters:\nproject_id (str) \u2013 the id of the project the rating table belongs to\nrating_table_id (str) \u2013 the id of the rating table to create this model from\nReturns:\njob \u2013 an instance of created async job\nReturn type:\nJob\nRaises:\nClientError \u2013 Raised if creating model from a RatingTable that failed validation\nJobAlreadyRequested \u2013 Raised if creating model from a RatingTable that is already\nassociated with a RatingTableModel\nadvanced_tune(params, description=None)\uf0c1\nGenerate a new model with the specified advanced-tuning parameters\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nParameters:\nparams (dict) \u2013 Mapping of parameter ID to parameter value.\nThe list of valid parameter IDs for a model can be found by calling\nget_advanced_tuning_parameters().\nThis endpoint does not need to include values for all parameters.  If a parameter\nis omitted, its current_value will be used.\ndescription (str) \u2013 Human-readable string describing the newly advanced-tuned model\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ncontinue_incremental_learning_from_incremental_model(chunk_definition_id, early_stopping_rounds=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nchunk_definition_id (str) \u2013 The Mongo ID for the chunking service.\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks that, when no improvement has been shown, triggers the early stopping mechanism.\nReturns:\njob \u2013 The model retraining job that is created.\nReturn type:\nModelJob\ncross_validate()\uf0c1\nRun cross validation on the model.\nNotes\nTo perform Cross Validation on a new model with new parameters, use train instead.\nReturns:\nThe created job to build the model\nReturn type:\nModelJob\ndelete()\uf0c1\nDelete a model from the project\u2019s leaderboard.\nReturn type:\nNone\ndownload_scoring_code(file_name, source_code=False)\uf0c1\nDownload the Scoring Code JAR.\nParameters:\nfile_name (str) \u2013 File path where scoring code will be saved.\nsource_code (Optional[bool]) \u2013 Set to True to download source code archive.\nIt will not be executable.\nReturn type:\nNone\ndownload_training_artifact(file_name)\uf0c1\nRetrieve trained artifact(s) from a model containing one or more custom tasks.\nArtifact(s) will be downloaded to the specified local filepath.\nParameters:\nfile_name (str) \u2013 File path where trained model artifact(s) will be saved.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverrides the inherited method since the model must _not_ recursively change casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (list) \u2013 List of attribute namespaces like: [\u2018top.middle.bottom\u2019], that should be kept\neven if their values are None\nget_advanced_tuning_parameters()\uf0c1\nGet the advanced-tuning parameters available for this model.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nA dictionary describing the advanced-tuning parameters for the current model.\nThere are two top-level keys, tuning_description and tuning_parameters.\ntuning_description an optional value. If not None, then it indicates the\nuser-specified description of this set of tuning parameter.\ntuning_parameters is a list of a dicts, each has the following keys\nparameter_name : (str) name of the parameter (unique per task, see below)\nparameter_id : (str) opaque ID string uniquely identifying parameter\ndefault_value : (*) the actual value used to train the model; either\nthe single value of the parameter specified before training, or the best\nvalue from the list of grid-searched values (based on current_value)\ncurrent_value : (*) the single value or list of values of the\nparameter that were grid searched. Depending on the grid search\nspecification, could be a single fixed value (no grid search),\na list of discrete values, or a range.\ntask_name : (str) name of the task that this parameter belongs to\nconstraints: (dict) see the notes below\nvertex_id: (str) ID of vertex that this parameter belongs to\nReturn type:\ndict\nNotes\nThe type of default_value and current_value is defined by the constraints structure.\nIt will be a string or numeric Python type.\nconstraints is a dict with at least one, possibly more, of the following keys.\nThe presence of a key indicates that the parameter may take on the specified type.\n(If a key is absent, this means that the parameter may not take on the specified type.)\nIf a key on constraints is present, its value will be a dict containing\nall of the fields described below for that key.\n\"constraints\": {\n\"select\": {\n\"values\": [<list(basestring or number) : possible values>]\n},\n\"ascii\": {},\n\"unicode\": {},\n\"int\": {\n\"min\": <int : minimum valid value>,\n\"max\": <int : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"float\": {\n\"min\": <float : minimum valid value>,\n\"max\": <float : maximum valid value>,\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"intList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <int : minimum valid value>,\n\"max_val\": <int : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n},\n\"floatList\": {\n\"min_length\": <int : minimum valid length>,\n\"max_length\": <int : maximum valid length>\n\"min_val\": <float : minimum valid value>,\n\"max_val\": <float : maximum valid value>\n\"supports_grid_search\": <bool : True if Grid Search may be\nrequested for this param>\n}\n}\nThe keys have meaning as follows:\nselect:\nRather than specifying a specific data type, if present, it indicates that the parameter\nis permitted to take on any of the specified values.  Listed values may be of any string\nor real (non-complex) numeric type.\nascii:\nThe parameter may be a unicode object that encodes simple ASCII characters.\n(A-Z, a-z, 0-9, whitespace, and certain common symbols.)  In addition to listed\nconstraints, ASCII keys currently may not contain either newlines or semicolons.\nunicode:\nThe parameter may be any Python unicode object.\nint:\nThe value may be an object of type int within the specified range (inclusive).\nPlease note that the value will be passed around using the JSON format, and\nsome JSON parsers have undefined behavior with integers outside of the range\n[-(2**53)+1, (2**53)-1].\nfloat:\nThe value may be an object of type float within the specified range (inclusive).\nintList, floatList:\nThe value may be a list of int or float objects, respectively, following constraints\nas specified respectively by the int and float types (above).\nMany parameters only specify one key under constraints.  If a parameter specifies multiple\nkeys, the parameter may take on any value permitted by any key.\nget_all_confusion_charts(fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of all confusion matrices available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent for any source that is not available for this model and if this\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\nReturns:\nData for all available confusion charts for model.\nReturn type:\nlist of ConfusionChart\nget_all_feature_impacts(data_slice_filter=None)\uf0c1\nRetrieve a list of all feature impact results available for the model.\nParameters:\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen no data_slice filtering will be applied when requesting the roc_curve.\nReturns:\nData for all available model feature impacts. Or an empty list if not data found.\nReturn type:\nlist of dicts\nExamples\nmodel = datarobot.Model(id='model-id', project_id='project-id')\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()\nget_all_lift_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (Optional[bool]) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned lift chart by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model lift charts. Or an empty list if no data found.\nReturn type:\nlist of LiftChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()\nget_all_multiclass_lift_charts(fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve a list of all Lift charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nData for all available model lift charts.\nReturn type:\nlist of LiftChart\nget_all_residuals_charts(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all residuals charts available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent\nfor any source that is not available for this model and if this model has a\ndefined parent model. If omitted or False, or this model has no parent, this will\nnot attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 Filters the returned residuals charts by data_slice_filter.id.\nIf None (the default) applies no filter based on data_slice_id.\nReturns:\nData for all available model residuals charts.\nReturn type:\nlist of ResidualsChart\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()\nget_all_roc_curves(fallback_to_parent_insights=False, data_slice_filter=None)\uf0c1\nRetrieve a list of all ROC curves available for the model.\nParameters:\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent for any source that is not available for this model and if this model\nhas a defined parent model. If omitted or False, or this model has no parent,\nthis will not attempt to retrieve any data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 filters the returned roc_curve by data_slice_filter.id.  If None (the default) applies no filter based on\ndata_slice_id.\nReturns:\nData for all available model ROC curves. Or an empty list if no RocCurves are found.\nReturn type:\nlist of RocCurve\nExamples\nmodel = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()\nget_confusion_chart(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a multiclass model\u2019s confusion matrix for the specified source.\nParameters:\nsource (str) \u2013 Confusion chart source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return confusion chart data for\nthis model\u2019s parent if the confusion chart is not available for this model and the\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel ConfusionChart data\nReturn type:\nConfusionChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_cross_class_accuracy_scores()\uf0c1\nRetrieves a list of Cross Class Accuracy scores for the model.\nReturn type:\njson\nget_cross_validation_scores(partition=None, metric=None)\uf0c1\nReturn a dictionary, keyed by metric, showing cross validation\nscores per partition.\nCross Validation should already have been performed using\ncross_validate or\ntrain.\nNotes\nModels that computed cross validation before this feature was added will need\nto be deleted and retrained before this method can be used.\nParameters:\npartition (float) \u2013 optional, the id of the partition (1,2,3.0,4.0,etc\u2026) to filter results by\ncan be a whole number positive integer or float value. 0 corresponds to the\nvalidation partition.\nmetric (unicode) \u2013 optional name of the metric to filter to resulting cross validation scores by\nReturns:\ncross_validation_scores \u2013 A dictionary keyed by metric showing cross validation scores per\npartition.\nReturn type:\ndict\nget_data_disparity_insights(feature, class_name1, class_name2)\uf0c1\nRetrieve a list of Cross Class Data Disparity insights for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\nclass_name1 (str) \u2013 One of the compared classes\nclass_name2 (str) \u2013 Another compared class\nReturn type:\njson\nget_fairness_insights(fairness_metrics_set=None, offset=0, limit=100)\uf0c1\nRetrieve a list of Per Class Bias insights for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturn type:\njson\nget_feature_effect(source, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model.\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, retrieve unsliced insight data.\nReturns:\nfeature_effects \u2013 The feature effects data.\nReturn type:\nFeatureEffects\nRaises:\nClientError \u2013 If the feature effects have not been computed or source is not valid value.\nget_feature_effect_metadata()\uf0c1\nRetrieve Feature Effects metadata. Response contains status and available model sources.\nFeature Effect for the training partition is always available, with the exception of older\nprojects that only supported Feature Effect for validation.\nWhen a model is trained into validation or holdout without stacked predictions\n(i.e., no out-of-sample predictions in those partitions),\nFeature Effects is not available for validation or holdout.\nFeature Effects for holdout is not available when holdout was not unlocked for\nthe project.\nUse source to retrieve Feature Effects, selecting one of the provided sources.\nReturns:\nfeature_effect_metadata\nReturn type:\nFeatureEffectMetadata\nget_feature_effects_multiclass(source='training', class_=None)\uf0c1\nRetrieve Feature Effects for the multiclass model.\nFeature Effects provide partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how,\nholding all other variables except the feature of interest as they were,\nthe value of this feature affects your prediction.\nRequires that Feature Effects has already been computed with\nrequest_feature_effect.\nSee get_feature_effect_metadata\nfor retrieving information the available sources.\nParameters:\nsource (str) \u2013 The source Feature Effects are retrieved for.\nclass (str or None) \u2013 The class name Feature Effects are retrieved for.\nReturns:\nThe list of multiclass feature effects.\nReturn type:\nlist\nRaises:\nClientError \u2013 If Feature Effects have not been computed or source is not valid value.\nget_feature_impact(with_metadata=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the computed Feature Impact results, a measure of the relevance of each\nfeature in the model.\nFeature Impact is computed for each column by creating new data with that column randomly\npermuted (but the others left unchanged), and seeing how the error metric score for the\npredictions is affected. The \u2018impactUnnormalized\u2019 is how much worse the error metric score\nis when making predictions on this modified data. The \u2018impactNormalized\u2019 is normalized so\nthat the largest value is 1. In both cases, larger values indicate more important features.\nIf a feature is a redundant feature, i.e. once other features are considered it doesn\u2019t\ncontribute much in addition, the \u2018redundantWith\u2019 value is the name of feature that has the\nhighest correlation with this feature. Note that redundancy detection is only available for\njobs run after the addition of this feature. When retrieving data that predates this\nfunctionality, a NoRedundancyImpactAvailable warning will be used.\nElsewhere this technique is sometimes called \u2018Permutation Importance\u2019.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nParameters:\nwith_metadata (bool) \u2013 The flag indicating if the result should include the metadata as well.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default, this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_feature_impact will raise a ValueError.\nReturns:\nThe feature impact data response depends on the with_metadata parameter. The response is\neither a dict with metadata and a list with actual data or just a list with that data.\nEach List item is a dict with the keys featureName, impactNormalized, and\nimpactUnnormalized, redundantWith and count.\nFor dict response available keys are:\nfeatureImpacts - Feature Impact data as a dictionary. Each item is a dict withkeys: featureName, impactNormalized, and impactUnnormalized, and\nredundantWith.\nshapBased - A boolean that indicates whether Feature Impact was calculated usingShapley values.\nranRedundancyDetection - A boolean that indicates whether redundant featureidentification was run while calculating this Feature Impact.\nrowCount - An integer or None that indicates the number of rows that was used tocalculate Feature Impact. For the Feature Impact calculated with the default\nlogic, without specifying the rowCount, we return None here.\ncount - An integer with the number of features under the featureImpacts.\nReturn type:\nlist or dict\nRaises:\nClientError \u2013 If the feature impacts have not been computed.\nValueError \u2013 If data_slice_filter passed as None\nget_features_used()\uf0c1\nQuery the server to determine which features were used.\nNote that the data returned by this method is possibly different\nthan the names of the features in the featurelist used by this model.\nThis method will return the raw features that must be supplied in order\nfor predictions to be generated on a new set of data. The featurelist,\nin contrast, would also include the names of derived features.\nReturns:\nfeatures \u2013 The names of the features used in the model.\nReturn type:\nList[str]\nget_frozen_child_models()\uf0c1\nRetrieve the IDs for all models that are frozen from this model.\nReturn type:\nA list of Models\nget_labelwise_roc_curves(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve a list of LabelwiseRocCurve instances for a multilabel model for the given source and all labels.\nThis method is valid only for multilabel projects. For binary projects, use Model.get_roc_curve API .\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\nReturns:\nLabelwise ROC Curve instances for source and all labels\nReturn type:\nlist of LabelwiseRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\nReturns:\nModel lift chart data\nReturn type:\nLiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_missing_report_info()\uf0c1\nRetrieve a report on missing training data that can be used to understand missing\nvalues treatment in the model. The report consists of missing values resolutions for\nfeatures numeric or categorical features that were part of building the model.\nReturns:\nThe queried model missing report, sorted by missing count (DESCENDING order).\nReturn type:\nAn iterable of MissingReportPerFeature\nget_model_blueprint_chart()\uf0c1\nRetrieve a diagram that can be used to understand\ndata flow in the blueprint.\nReturns:\nThe queried model blueprint chart.\nReturn type:\nModelBlueprintChart\nget_model_blueprint_documents()\uf0c1\nGet documentation for tasks used in this model.\nReturns:\nAll documents available for the model.\nReturn type:\nlist of BlueprintTaskDocument\nget_model_blueprint_json()\uf0c1\nGet the blueprint json representation used by this model.\nReturns:\nJson representation of the blueprint stages.\nReturn type:\nBlueprintJson\nget_multiclass_feature_impact()\uf0c1\nFor multiclass it\u2019s possible to calculate feature impact separately for each target class.\nThe method for calculation is exactly the same, calculated in one-vs-all style for each\ntarget class.\nRequires that Feature Impact has already been computed with\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. Each item is a dict with the keys \u2018featureImpacts\u2019 (list),\n\u2018class\u2019 (str). Each item in \u2018featureImpacts\u2019 is a dict with the keys \u2018featureName\u2019,\n\u2018impactNormalized\u2019, and \u2018impactUnnormalized\u2019, and \u2018redundantWith\u2019.\nReturn type:\nlist of dict\nRaises:\nClientError \u2013 If the multiclass feature impacts have not been computed.\nget_multiclass_lift_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>, target_class=None)\uf0c1\nRetrieve model Lift chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_lift_chart will raise a ValueError.\ntarget_class (str, optional) \u2013 Lift chart target class name.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_multilabel_lift_charts(source, fallback_to_parent_insights=False)\uf0c1\nRetrieve model Lift charts for the specified source.\nAdded in version v2.24.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return lift chart data for this\nmodel\u2019s parent if the lift chart is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return insight data from this model\u2019s parent.\nReturns:\nModel lift chart data for each saved target class\nReturn type:\nlist of LiftChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nget_num_iterations_trained()\uf0c1\nRetrieves the number of estimators trained by early-stopping tree-based models.\n\u2013 versionadded:: v2.22\nReturns:\nprojectId (str) \u2013 id of project containing the model\nmodelId (str) \u2013 id of the model\ndata (array) \u2013 list of numEstimatorsItem objects, one for each modeling stage.\nnumEstimatorsItem will be of the form\nstage (str) \u2013 indicates the modeling stage (for multi-stage models); None of single-stage models\nnumIterations (int) \u2013 the number of estimators or iterations trained by the model\nget_or_request_feature_effect(source, max_wait=600, row_count=None, data_slice_id=None)\uf0c1\nRetrieve Feature Effects for the model, requesting a new job if it hasn\u2019t been run previously.\nSee get_feature_effect_metadata\nfor retrieving information of source.\nParameters:\nsource (string) \u2013 The source Feature Effects are retrieved for.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effect job to complete before erroring.\nrow_count (Optional[int]) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nfeature_effects \u2013 The Feature Effects data.\nReturn type:\nFeatureEffects\nget_or_request_feature_effects_multiclass(source, top_n_features=None, features=None, row_count=None, class_=None, max_wait=600)\uf0c1\nRetrieve Feature Effects for the multiclass model, requesting a job if it hasn\u2019t been run\npreviously.\nParameters:\nsource (string) \u2013 The source Feature Effects retrieve for.\nclass (str or None) \u2013 The class name Feature Effects retrieve for.\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by Feature Impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested Feature Effects job to complete before\nerroring.\nReturns:\nfeature_effects \u2013 The list of multiclass feature effects data.\nReturn type:\nlist of FeatureEffectsMulticlass\nget_or_request_feature_impact(max_wait=600, **kwargs)\uf0c1\nRetrieve feature impact for the model, requesting a job if it hasn\u2019t been run previously\nParameters:\nmax_wait (Optional[int]) \u2013 The maximum time to wait for a requested feature impact job to complete before erroring\n**kwargs \u2013 Arbitrary keyword arguments passed to\nrequest_feature_impact.\nReturns:\nfeature_impacts \u2013 The feature impact data. See\nget_feature_impact for the exact\nschema.\nReturn type:\nlist or dict\nget_parameters()\uf0c1\nRetrieve model parameters.\nReturns:\nModel parameters for this model.\nReturn type:\nModelParameters\nget_pareto_front()\uf0c1\nRetrieve the Pareto Front for a Eureqa model.\nThis method is only supported for Eureqa models.\nReturns:\nModel ParetoFront data\nReturn type:\nParetoFront\nget_prime_eligibility()\uf0c1\nCheck if this model can be approximated with DataRobot Prime\nReturns:\nprime_eligibility \u2013 a dict indicating whether a model can be approximated with DataRobot Prime\n(key can_make_prime) and why it may be ineligible (key message)\nReturn type:\ndict\nget_residuals_chart(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible\nvalues.\nfallback_to_parent_insights (bool) \u2013 Optional, if True, this will return residuals chart data for this model\u2019s parent if\nthe residuals chart is not available for this model and the model has a defined parent\nmodel. If omitted or False, or there is no parent model, will not attempt to return\nresiduals data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_residuals_chart will raise a ValueError.\nReturns:\nModel residuals chart data\nReturn type:\nResidualsChart\nRaises:\nClientError \u2013 If the insight is not available for this model\nValueError \u2013 If data_slice_filter passed as None\nget_roc_curve(source, fallback_to_parent_insights=False, data_slice_filter=<datarobot.models.model.Sentinel object>)\uf0c1\nRetrieve the ROC curve for a binary model for the specified source.\nThis method is valid only for binary projects. For multilabel projects, use\nModel.get_labelwise_roc_curves.\nParameters:\nsource (str) \u2013 ROC curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\n(New in version v2.23) For time series and OTV models, also accepts values backtest_2,\nbacktest_3, \u2026, up to the number of backtests in the model.\nfallback_to_parent_insights (bool) \u2013 (New in version v2.14) Optional, if True, this will return ROC curve data for this\nmodel\u2019s parent if the ROC curve is not available for this model and the model has a\ndefined parent model. If omitted or False, or there is no parent model, will not\nattempt to return data from this model\u2019s parent.\ndata_slice_filter (DataSlice, optional) \u2013 A dataslice used to filter the return values based on the dataslice.id. By default this function will\nuse data_slice_filter.id == None which returns an unsliced insight. If data_slice_filter is None\nthen get_roc_curve will raise a ValueError.\nReturns:\nModel ROC curve data\nReturn type:\nRocCurve\nRaises:\nClientError \u2013 If the insight is not available for this model\n(New in version v3.0) TypeError \u2013 If the underlying project type is multilabel\nValueError \u2013 If data_slice_filter passed as None\nget_rulesets()\uf0c1\nList the rulesets approximating this model generated by DataRobot Prime\nIf this model hasn\u2019t been approximated yet, will return an empty list.  Note that these\nare rulesets approximating this model, not rulesets used to construct this model.\nReturns:\nrulesets\nReturn type:\nlist of Ruleset\nget_supported_capabilities()\uf0c1\nRetrieves a summary of the capabilities supported by a model.\nAdded in version v2.14.\nReturns:\nsupportsBlending (bool) \u2013 whether the model supports blending\nsupportsMonotonicConstraints (bool) \u2013 whether the model supports monotonic constraints\nhasWordCloud (bool) \u2013 whether the model has word cloud data available\neligibleForPrime (bool) \u2013 (Deprecated in version v3.6)\nwhether the model is eligible for Prime\nhasParameters (bool) \u2013 whether the model has parameters that can be retrieved\nsupportsCodeGeneration (bool) \u2013 (New in version v2.18) whether the model supports code generation\nsupportsShap (bool) \u2013\n(New in version v2.18) True if the model supports Shapley package. i.e. Shapley basedfeature Importance\nsupportsEarlyStopping (bool) \u2013 (New in version v2.22) True if this is an early stopping\ntree-based model and number of trained iterations can be retrieved.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this model at leaderboard.\nReturn type:\nstr\nget_word_cloud(exclude_stop_words=False)\uf0c1\nRetrieve word cloud data for the model.\nParameters:\nexclude_stop_words (Optional[bool]) \u2013 Set to True if you want stopwords filtered out of response.\nReturns:\nWord cloud data for the model.\nReturn type:\nWordCloud\nincremental_train(data_stage_id, training_data_name=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model.\nSee train_incremental documentation.\nReturn type:\nModelJob\nclassmethod list(project_id, sort_by_partition='validation', sort_by_metric=None, with_metric=None, search_term=None, featurelists=None, families=None, blueprints=None, labels=None, characteristics=None, training_filters=None, number_of_clusters=None, limit=100, offset=0)\uf0c1\nRetrieve paginated model records, sorted by scores, with optional filtering.\nParameters:\nsort_by_partition (str, one of validation, backtesting, crossValidation or holdout) \u2013 Set the partition to use for sorted (by score) list of models. validation is the default.\nsort_by_metric (str) \u2013 Set the project metric to use for model sorting. DataRobot-selected project optimization metric\nis the default.\nwith_metric (str) \u2013 For a single-metric list of results, specify that project metric.\nsearch_term (str) \u2013 If specified, only models containing the term in their name or processes are returned.\nfeaturelists (List[str]) \u2013 If specified, only models trained on selected featurelists are returned.\nfamilies (List[str]) \u2013 If specified, only models belonging to selected families are returned.\nblueprints (List[str]) \u2013 If specified, only models trained on specified blueprint IDs are returned.\nlabels (List[str], starred or prepared for deployment) \u2013 If specified, only models tagged with all listed labels are returned.\ncharacteristics (List[str]) \u2013 If specified, only models matching all listed characteristics are returned.\ntraining_filters (List[str]) \u2013 If specified, only models matching at least one of the listed training conditions are returned.\nThe following formats are supported for autoML and datetime partitioned projects:\n- number of rows in training subset\nFor datetime partitioned projects:\n- <training duration>, example P6Y0M0D\n- <training_duration>-<time_window_sample_percent>-<sampling_method> Example: P6Y0M0D-78-Random,\n(returns models trained on 6 years of data, sampling rate 78%, random sampling).\n- Start/end date\n- Project settings\nnumber_of_clusters (list of int) \u2013 Filter models by number of clusters. Applicable only in unsupervised clustering projects.\nlimit (int)\noffset (int)\nReturns:\ngeneric_models\nReturn type:\nlist of GenericModel\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nrequest_approximation()\uf0c1\nRequest an approximation of this model using DataRobot Prime\nThis will create several rulesets that could be used to approximate this model.  After\ncomparing their scores and rule counts, the code used in the approximation can be downloaded\nand run locally.\nReturns:\njob \u2013 the job generating the rulesets\nReturn type:\nJob\nrequest_cross_class_accuracy_scores()\uf0c1\nRequest data disparity insights to be computed for the model.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_data_disparity_insights(feature, compared_class_names)\uf0c1\nRequest data disparity insights to be computed for the model.\nParameters:\nfeature (str) \u2013 Bias and Fairness protected feature name.\ncompared_class_names (list(str)) \u2013 List of two classes to compare\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_external_test(dataset_id, actual_value_column=None)\uf0c1\nRequest external test to compute scores and insights on an external test dataset\nParameters:\ndataset_id (string) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nReturns:\njob \u2013 a Job representing external dataset insights computation\nReturn type:\nJob\nrequest_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest fairness insights to be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 Can be one of <datarobot.enums.FairnessMetricsSet>.\nThe fairness metric used to calculate the fairness scores.\nReturns:\nstatus_id \u2013 A statusId of computation request.\nReturn type:\nstr\nrequest_feature_effect(row_count=None, data_slice_id=None)\uf0c1\nSubmit request to compute Feature Effects for the model.\nSee get_feature_effect for more\ninformation on the result of the job.\nParameters:\nrow_count (int) \u2013 (New in version v2.21) The sample size to use for Feature Impact computation.\nMinimum is 10 rows. Maximum is 100000 rows or the training sample size of the model,\nwhichever is less.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 A Job representing the feature effect computation. To get the completed feature effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nRaises:\nJobAlreadyRequested \u2013 If the feature effect have already been requested.\nrequest_feature_effects_multiclass(row_count=None, top_n_features=None, features=None)\uf0c1\nRequest Feature Effects computation for the multiclass model.\nSee get_feature_effect for\nmore information on the result of the job.\nParameters:\nrow_count (int) \u2013 The number of rows from dataset to use for Feature Impact calculation.\ntop_n_features (int or None) \u2013 Number of top features (ranked by feature impact) used to calculate Feature Effects.\nfeatures (list or None) \u2013 The list of features used to calculate Feature Effects.\nReturns:\njob \u2013 A Job representing Feature Effect computation. To get the completed Feature Effect\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob\nrequest_feature_impact(row_count=None, with_metadata=False, data_slice_id=None)\uf0c1\nRequest feature impacts to be computed for the model.\nSee get_feature_impact for more\ninformation on the result of the job.\nParameters:\nrow_count (Optional[int]) \u2013 The sample size (specified in rows) to use for Feature Impact computation. This is not\nsupported for unsupervised, multiclass (which has a separate method), and time series\nprojects.\nwith_metadata (Optional[bool]) \u2013 Flag indicating whether the result should include the metadata.\nIf true, metadata is included.\ndata_slice_id (Optional[str]) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\njob \u2013 Job representing the Feature Impact computation. To retrieve the completed Feature Impact\ndata, use job.get_result or job.get_result_when_complete.\nReturn type:\nJob or status_id\nRaises:\nJobAlreadyRequested \u2013 If the feature impacts have already been requested.\nrequest_frozen_datetime_model(training_row_count=None, training_duration=None, training_start_date=None, training_end_date=None, time_window_sample_pct=None, sampling_method=None)\uf0c1\nTrain a new frozen model with parameters from this model.\nRequires that this model belongs to a datetime partitioned project.  If it does not, an\nerror will occur when submitting the job.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nIn addition of training_row_count and training_duration, frozen datetime models may be\ntrained on an exact date range.  Only one of training_row_count, training_duration, or\ntraining_start_date and training_end_date should be specified.\nModels specified using training_start_date and training_end_date are the only ones that can\nbe trained into the holdout data (once the holdout is unlocked).\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\ntraining_duration may not be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, training_row_count may not be specified.\ntraining_start_date (datetime.datetime, optional) \u2013 the start date of the data to train to model on.  Only rows occurring at or after\nthis datetime will be used.  If training_start_date is specified, training_end_date\nmust also be specified.\ntraining_end_date (datetime.datetime, optional) \u2013 the end date of the data to train the model on.  Only rows occurring strictly before\nthis datetime will be used.  If training_end_date is specified, training_start_date\nmust also be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates).  An integer between 1 and 99 indicating the percentage to sample by\nwithin the window.  The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_frozen_model(sample_pct=None, training_row_count=None)\uf0c1\nTrain a new frozen model with parameters from this model\nNotes\nThis method only works if project the model belongs to is not datetime\npartitioned.  If it is, use request_frozen_datetime_model instead.\nFrozen models use the same tuning parameters as their parent model instead of independently\noptimizing them to allow efficiently retraining models on larger amounts of the training\ndata.\nParameters:\nsample_pct (float) \u2013 optional, the percentage of the dataset to use with the model.  If not provided, will\nuse the value from this model.\ntraining_row_count (int) \u2013 (New in version v2.9) optional, the integer number of rows of the dataset to use with\nthe model. Only one of sample_pct and training_row_count should be specified.\nReturns:\nmodel_job \u2013 the modeling job training a frozen model\nReturn type:\nModelJob\nrequest_lift_chart(source, data_slice_id=None)\uf0c1\nRequest the model Lift Chart for the specified source.\nParameters:\nsource (str) \u2013 Lift chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_per_class_fairness_insights(fairness_metrics_set=None)\uf0c1\nRequest per-class fairness insights be computed for the model.\nParameters:\nfairness_metrics_set (Optional[str]) \u2013 The fairness metric used to calculate the fairness scores.\nValue can be any one of <datarobot.enums.FairnessMetricsSet>.\nReturns:\nstatus_check_job \u2013 The returned object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_predictions(dataset_id=None, dataset=None, dataframe=None, file_path=None, file=None, include_prediction_intervals=None, prediction_intervals_size=None, forecast_point=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, explanation_algorithm=None, max_explanations=None, max_ngram_explanations=None)\uf0c1\nRequests predictions against a previously uploaded dataset.\nParameters:\ndataset_id (string, optional) \u2013 The ID of the dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataset (Dataset, optional) \u2013 The dataset to make predictions against (as uploaded from Project.upload_dataset)\ndataframe (pd.DataFrame, optional) \u2013 (New in v3.0)\nThe dataframe to make predictions against\nfile_path (Optional[str]) \u2013 (New in v3.0)\nPath to file to make predictions against\nfile (IOBase, optional) \u2013 (New in v3.0)\nFile to make predictions against\ninclude_prediction_intervals (Optional[bool]) \u2013 (New in v2.16) For time series projects only.\nSpecifies whether prediction intervals should be calculated for this request. Defaults\nto True if prediction_intervals_size is specified, otherwise defaults to False.\nprediction_intervals_size (Optional[int]) \u2013 (New in v2.16) For time series projects only.\nRepresents the percentile to use for the size of the prediction intervals. Defaults to\n80 if include_prediction_intervals is True. Prediction intervals size must be\nbetween 1 and 100 (inclusive).\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The end date for bulk\npredictions, exclusive. Note that this parameter is for generating historical\npredictions using the training data. This parameter should be provided in conjunction\nwith predictions_start_date. Can\u2019t be provided with the\nforecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) For time series unsupervised projects only.\nActual value column can be used to calculate the classification metrics and\ninsights on the prediction dataset. Can\u2019t be provided with the forecast_point\nparameter.\nexplanation_algorithm ((New in version v2.21) optional; If set to 'shap', the) \u2013 response will include prediction explanations based on the SHAP explainer (SHapley\nAdditive exPlanations). Defaults to null (no prediction explanations).\nmax_explanations ((New in version v2.21) int optional; specifies the maximum number of) \u2013 explanation values that should be returned for each row, ordered by absolute value,\ngreatest to least. If null, no limit. In the case of \u2018shap\u2019: if the number of features\nis greater than the limit, the sum of remaining values will also be returned as\nshapRemainingTotal. Defaults to null. Cannot be set if explanation_algorithm is\nomitted.\nmax_ngram_explanations (optional;\u00a0 int or str) \u2013 (New in version v2.29) Specifies the maximum number of text explanation values that\nshould be returned. If set to all, text explanations will be computed and all the\nngram explanations will be returned. If set to a non zero positive integer value, text\nexplanations will be computed and this amount of descendingly sorted ngram explanations\nwill be returned. By default text explanation won\u2019t be triggered to be computed.\nReturns:\njob \u2013 The job computing the predictions\nReturn type:\nPredictJob\nrequest_residuals_chart(source, data_slice_id=None)\uf0c1\nRequest the model residuals chart for the specified source.\nParameters:\nsource (str) \u2013 Residuals chart data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_roc_curve(source, data_slice_id=None)\uf0c1\nRequest the model Roc Curve for the specified source.\nParameters:\nsource (str) \u2013 Roc Curve data source. Check datarobot.enums.CHART_DATA_SOURCE for possible values.\ndata_slice_id (string, optional) \u2013 ID for the data slice used in the request. If None, request unsliced insight data.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nrequest_training_predictions(data_subset, explanation_algorithm=None, max_explanations=None)\uf0c1\nStart a job to build training predictions\nParameters:\ndata_subset (str) \u2013 data set definition to build predictions on.\nChoices are:\ndr.enums.DATA_SUBSET.ALL or string all for all data available. Not valid formodels in datetime partitioned projects\ndr.enums.DATA_SUBSET.VALIDATION_AND_HOLDOUT or string validationAndHoldout forall data except training set. Not valid for models in datetime partitioned\nprojects\ndr.enums.DATA_SUBSET.HOLDOUT or string holdout for holdout data set only\ndr.enums.DATA_SUBSET.ALL_BACKTESTS or string allBacktests for downloadingthe predictions for all backtest validation folds. Requires the model to have\nsuccessfully scored all backtests. Datetime partitioned projects only.\nexplanation_algorithm (dr.enums.EXPLANATIONS_ALGORITHM) \u2013 (New in v2.21) Optional. If set to dr.enums.EXPLANATIONS_ALGORITHM.SHAP, the response\nwill include prediction explanations based on the SHAP explainer (SHapley Additive\nexPlanations). Defaults to None (no prediction explanations).\nmax_explanations (int) \u2013 (New in v2.21) Optional. Specifies the maximum number of explanation values that should\nbe returned for each row, ordered by absolute value, greatest to least. In the case of\ndr.enums.EXPLANATIONS_ALGORITHM.SHAP:  If not set, explanations are returned for all\nfeatures. If the number of features is greater than the max_explanations, the sum of\nremaining values will also be returned as shap_remaining_total. Max 100. Defaults to\nnull for datasets narrower than 100 columns, defaults to 100 for datasets wider than 100\ncolumns. Is ignored if explanation_algorithm is not set.\nReturns:\nan instance of created async job\nReturn type:\nJob\nretrain(sample_pct=None, featurelist_id=None, training_row_count=None, n_clusters=None)\uf0c1\nSubmit a job to the queue to train a blender model.\nParameters:\nsample_pct (Optional[float]) \u2013 The sample size in percents (1 to 100) to use in training. If this parameter is used\nthen training_row_count should not be given.\nfeaturelist_id (Optional[str]) \u2013 The featurelist id\ntraining_row_count (Optional[int]) \u2013 The number of rows used to train the model. If this parameter is used, then sample_pct\nshould not be given.\nn_clusters (Optional[int]) \u2013 (new in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that do not determine\nthe number of clusters automatically.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nset_prediction_threshold(threshold)\uf0c1\nSet a custom prediction threshold for the model.\nMay not be used once prediction_threshold_read_only is True for this model.\nParameters:\nthreshold (float) \u2013 only used for binary classification projects. The threshold to when deciding between\nthe positive and negative classes when making predictions.  Should be between 0.0 and\n1.0 (inclusive).\nstar_model()\uf0c1\nMark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nstart_advanced_tuning_session()\uf0c1\nStart an Advanced Tuning session.  Returns an object that helps\nset up arguments for an Advanced Tuning model execution.\nAs of v2.17, all models other than blenders, open source, prime, baseline and\nuser-created support Advanced Tuning.\nReturns:\nSession for setting up and running Advanced Tuning on a model\nReturn type:\nAdvancedTuningSession\nstart_incremental_learning_from_sample(early_stopping_rounds=None, first_iteration_only=False, chunk_definition_id=None)\uf0c1\nSubmit a job to the queue to perform the first incremental learning iteration training on an existing\nsample model. This functionality requires the SAMPLE_DATA_TO_START_PROJECT feature flag to be enabled.\nParameters:\nearly_stopping_rounds (Optional[int]) \u2013 The number of chunks in which no improvement is observed that triggers the early stopping mechanism.\nfirst_iteration_only (bool) \u2013 Specifies whether incremental learning training should be limited to the first\niteration. If set to True, the training process will be performed only for the first\niteration. If set to False, training will continue until early stopping conditions\nare met or the maximum number of iterations is reached. The default value is False.\nchunk_definition_id (str) \u2013 The id of the chunk definition to be use for incremental training.\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\ntrain(sample_pct=None, featurelist_id=None, scoring_type=None, training_row_count=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>)\uf0c1\nTrain the blueprint used in model on a particular featurelist or amount of data.\nThis method creates a new training job for worker and appends it to\nthe end of the queue for this project.\nAfter the job has finished you can get the newly trained model by retrieving\nit from the project leaderboard, or by retrieving the result of the job.\nEither sample_pct or training_row_count can be used to specify the amount of data to\nuse, but not both.  If neither are specified, a default of the maximum amount of data that\ncan safely be used to train any blueprint without going into the validation data will be\nselected.\nIn smart-sampled projects, sample_pct and training_row_count are assumed to be in terms\nof rows of the minority class.\nNotes\nFor datetime partitioned projects, see train_datetime instead.\nParameters:\nsample_pct (Optional[float]) \u2013 The amount of data to use for training, as a percentage of the project dataset from\n0 to 100.\nfeaturelist_id (Optional[str]) \u2013 The identifier of the featurelist to use. If not defined, the\nfeaturelist of this model is used.\nscoring_type (Optional[str]) \u2013 Either validation or crossValidation (also dr.SCORING_TYPE.validation\nor dr.SCORING_TYPE.cross_validation). validation is available for every\npartitioning type, and indicates that the default model validation should be\nused for the project.\nIf the project uses a form of cross-validation partitioning,\ncrossValidation can also be used to indicate\nthat all of the available training/validation combinations\nshould be used to evaluate the model.\ntraining_row_count (Optional[int]) \u2013 The number of rows to use to train the requested model.\nmonotonic_increasing_featurelist_id (str) \u2013 (new in version 2.11) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (str) \u2013 (new in version 2.11) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nReturns:\nmodel_job_id \u2013 id of created job, can be used as parameter to ModelJob.get\nmethod or wait_for_async_model_creation function\nReturn type:\nstr\nExamples\nproject = Project.get('project-id')\nmodel = Model.get('project-id', 'model-id')\nmodel_job_id = model.train(training_row_count=project.max_train_rows)\ntrain_datetime(featurelist_id=None, training_row_count=None, training_duration=None, time_window_sample_pct=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, use_project_settings=False, sampling_method=None, n_clusters=None)\uf0c1\nTrains this model on a different featurelist or sample size.\nRequires that this model is part of a datetime partitioned project; otherwise, an error will\noccur.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\nfeaturelist_id (Optional[str]) \u2013 the featurelist to use to train the model.  If not specified, the featurelist of this\nmodel is used.\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\nneither training_duration nor use_project_settings may be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, neither training_row_count nor use_project_settings may be\nspecified.\nuse_project_settings (Optional[bool]) \u2013 (New in version v2.20) defaults to False. If True, indicates that the custom\nbacktest partitioning settings specified by the user will be used to train the model and\nevaluate backtest scores. If specified, neither training_row_count nor\ntraining_duration may be specified.\ntime_window_sample_pct (Optional[int]) \u2013 may only be specified when the requested model is a time window (e.g. duration or start\nand end dates). An integer between 1 and 99 indicating the percentage to sample by\nwithin the window. The points kept are determined by a random uniform sample.\nIf specified, training_duration must be specified otherwise, the number of rows used\nto train the model and evaluate backtest scores and an error will occur.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nn_clusters (Optional[int]) \u2013 (New in version 2.27) number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nReturns:\njob \u2013 the created job to build the model\nReturn type:\nModelJob\ntrain_incremental(data_stage_id, training_data_name=None, data_stage_encoding=None, data_stage_delimiter=None, data_stage_compression=None)\uf0c1\nSubmit a job to the queue to perform incremental training on an existing model using\nadditional data. The id of the additional data to use for training is specified with the data_stage_id.\nOptionally a name for the iteration can be supplied by the user to help identify the contents of data in\nthe iteration.\nThis functionality requires the INCREMENTAL_LEARNING feature flag to be enabled.\nParameters:\ndata_stage_id (str) \u2013 The id of the data stage to use for training.\ntraining_data_name (Optional[str]) \u2013 The name of the iteration or data stage to indicate what the incremental learning was performed on.\ndata_stage_encoding (Optional[str]) \u2013 The encoding type of the data in the data stage (default: UTF-8).\nSupported formats: UTF-8, ASCII, WINDOWS1252\ndata_stage_encoding \u2013 The delimiter used by the data in the data stage (default: \u2018,\u2019).\ndata_stage_compression (Optional[str]) \u2013 The compression type of the data stage file, e.g. \u2018zip\u2019 (default: None).\nSupported formats: zip\nReturns:\njob \u2013 The created job that is retraining the model\nReturn type:\nModelJob\nunstar_model()\uf0c1\nUnmark the model as starred.\nModel stars propagate to the web application and the API, and can be used to filter when\nlisting models.\nReturn type:\nNone\nClustering\uf0c1\nclass datarobot.models.ClusteringModel\uf0c1\nClusteringModel extends Model class.\nIt provides provides properties and methods specific to clustering projects.\ncompute_insights(max_wait=600)\uf0c1\nCompute and retrieve cluster insights for model. This method awaits completion of\njob computing cluster insights and returns results after it is finished. If computation\ntakes longer than specified max_wait exception will be raised.\nParameters:\nproject_id (str) \u2013 Project to start creation in.\nmodel_id (str) \u2013 Project\u2019s model to start creation in.\nmax_wait (int) \u2013 Maximum number of seconds to wait before giving up\nReturn type:\nList of ClusterInsight\nRaises:\nClientError \u2013 Server rejected creation due to client error.\nMost likely cause is bad project_id or model_id.\nAsyncFailureError \u2013 If any of the responses from the server are unexpected\nAsyncProcessUnsuccessfulError \u2013 If the cluster insights computation has failed or was cancelled.\nAsyncTimeoutError \u2013 If the cluster insights computation did not resolve in time\nproperty insights: List[ClusterInsight]\uf0c1\nReturn actual list of cluster insights if already computed.\nReturn type:\nList of ClusterInsight\nproperty clusters: List[Cluster]\uf0c1\nReturn actual list of Clusters.\nReturn type:\nList of Cluster\nupdate_cluster_names(cluster_name_mappings)\uf0c1\nChange many cluster names at once based on list of name mappings.\nParameters:\ncluster_name_mappings (List of tuples) \u2013 Cluster names mapping consisting of current cluster name and old cluster name.\nExample:\ncluster_name_mappings = [\n(\"current cluster name 1\", \"new cluster name 1\"),\n(\"current cluster name 2\", \"new cluster name 2\")]\nReturn type:\nList of Cluster\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected update of cluster names.\nPossible reasons include: incorrect format of mapping, mapping introduces duplicates.\nupdate_cluster_name(current_name, new_name)\uf0c1\nChange cluster name from current_name to new_name.\nParameters:\ncurrent_name (str) \u2013 Current cluster name.\nnew_name (str) \u2013 New cluster name.\nReturn type:\nList of Cluster\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected update of cluster names.\nclass datarobot.models.cluster.Cluster\uf0c1\nRepresentation of a single cluster.\nVariables:\nname (str) \u2013 Current cluster name\npercent (float) \u2013 Percent of data contained in the cluster. This value is reported after cluster insights\nare computed for the model.\nclassmethod list(project_id, model_id)\uf0c1\nRetrieve a list of clusters in the model.\nParameters:\nproject_id (str) \u2013 ID of the project that the model is part of.\nmodel_id (str) \u2013 ID of the model.\nReturn type:\nList of clusters\nclassmethod update_multiple_names(project_id, model_id, cluster_name_mappings)\uf0c1\nUpdate many clusters at once based on list of name mappings.\nParameters:\nproject_id (str) \u2013 ID of the project that the model is part of.\nmodel_id (str) \u2013 ID of the model.\ncluster_name_mappings (List of tuples) \u2013 Cluster name mappings, consisting of current and previous names for each cluster.\nExample:\ncluster_name_mappings = [\n(\"current cluster name 1\", \"new cluster name 1\"),\n(\"current cluster name 2\", \"new cluster name 2\")]\nReturn type:\nList of clusters\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected update of cluster names.\nValueError \u2013 Invalid cluster name mapping provided.\nclassmethod update_name(project_id, model_id, current_name, new_name)\uf0c1\nChange cluster name from current_name to new_name\nParameters:\nproject_id (str) \u2013 ID of the project that the model is part of.\nmodel_id (str) \u2013 ID of the model.\ncurrent_name (str) \u2013 Current cluster name\nnew_name (str) \u2013 New cluster name\nReturn type:\nList of Cluster\nclass datarobot.models.cluster_insight.ClusterInsight\uf0c1\nHolds data on all insights related to feature as well as breakdown per cluster.\nParameters:\nfeature_name (str) \u2013 Name of a feature from the dataset.\nfeature_type (str) \u2013 Type of feature.\ninsights (List[ClusterInsight]) \u2013 List provides information regarding the importance of a specific feature in relation\nto each cluster. Results help understand how the model is grouping data and what each\ncluster represents.\nfeature_impact (float) \u2013 Impact of a feature ranging from 0 to 1.\nclassmethod compute(project_id, model_id, max_wait=600)\uf0c1\nStarts creation of cluster insights for the model and if successful, returns computed\nClusterInsights. This method allows calculation to continue for a specified time and\nif not complete, cancels the request.\nParameters:\nproject_id (str) \u2013 ID of the project to begin creation of cluster insights for.\nmodel_id (str) \u2013 ID of the project model to begin creation of cluster insights for.\nmax_wait (int) \u2013 Maximum number of seconds to wait canceling the request.\nReturn type:\nList[ClusterInsight]\nRaises:\nClientError \u2013 Server rejected creation due to client error.\nMost likely cause is bad project_id or model_id.\nAsyncFailureError \u2013 Indicates whether any of the responses from the server are unexpected.\nAsyncProcessUnsuccessfulError \u2013 Indicates whether the cluster insights computation failed or was cancelled.\nAsyncTimeoutError \u2013 Indicates whether the cluster insights computation did not resolve within the specified\ntime limit (max_wait).\nPareto front\uf0c1\nclass datarobot.models.pareto_front.ParetoFront\uf0c1\nPareto front data for a Eureqa model.\nThe pareto front reflects the tradeoffs between error and complexity for particular model. The\nsolutions reflect possible Eureqa models that are different levels of complexity.  By default,\nonly one solution will have a corresponding model, but models can be created for each solution.\nVariables:\nproject_id (str) \u2013 the ID of the project the model belongs to\nerror_metric (str) \u2013 Eureqa error-metric identifier used to compute error metrics for this search. Note that\nEureqa error metrics do NOT correspond 1:1 with DataRobot error metrics \u2013 the available\nmetrics are not the same, and are computed from a subset of the training data rather than\nfrom the validation data.\nhyperparameters (dict) \u2013 Hyperparameters used by this run of the Eureqa blueprint\ntarget_type (str) \u2013 Indicating what kind of modeling is being done in this project, either \u2018Regression\u2019,\n\u2018Binary\u2019 (Binary classification), or \u2018Multiclass\u2019 (Multiclass classification).\nsolutions (list(Solution)) \u2013 Solutions that Eureqa has found to model this data.\nSome solutions will have greater accuracy.  Others will have slightly\nless accuracy but will use simpler expressions.\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (list) \u2013 List of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nclass datarobot.models.pareto_front.Solution\uf0c1\nEureqa Solution.\nA solution represents a possible Eureqa model; however not all solutions\nhave models associated with them.  It must have a model created before\nit can be used to make predictions, etc.\nVariables:\neureqa_solution_id (str) \u2013 ID of this Solution\ncomplexity (int) \u2013 Complexity score for this solution. Complexity score is a function\nof the mathematical operators used in the current solution.\nThe Complexity calculation can be tuned via model hyperparameters.\nerror (float or None) \u2013 Error for the current solution, as computed by Eureqa using the\n\u2018error_metric\u2019 error metric. It will be None if model refitted existing solution.\nexpression (str) \u2013 Eureqa model equation string.\nexpression_annotated (str) \u2013 Eureqa model equation string with variable names tagged for easy identification.\nbest_model (bool) \u2013 True, if the model is determined to be the best\ncreate_model()\uf0c1\nAdd this solution to the leaderboard, if it is not already present.\nCombined models\uf0c1\nSee API reference for Combined Model in Segmented Modeling API Reference\nAdvanced tuning\uf0c1\nclass datarobot.models.advanced_tuning.AdvancedTuningSession\uf0c1\nA session enabling users to configure and run advanced tuning for a model.\nEvery model contains a set of one or more tasks.  Every task contains a set of\nzero or more parameters.  This class allows tuning the values of each parameter\non each task of a model, before running that model.\nThis session is client-side only and is not persistent.\nOnly the final model, constructed when run is called, is persisted on the DataRobot server.\nVariables:\ndescription (str) \u2013 Description for the new advance-tuned model.\nDefaults to the same description as the base model.\nget_task_names()\uf0c1\nGet the list of task names that are available for this model\nReturns:\nList of task names\nReturn type:\nlist(str)\nget_parameter_names(task_name)\uf0c1\nGet the list of parameter names available for a specific task\nReturns:\nList of parameter names\nReturn type:\nlist(str)\nset_parameter(value, task_name=None, parameter_name=None, parameter_id=None)\uf0c1\nSet the value of a parameter to be used\nThe caller must supply enough of the optional arguments to this function\nto uniquely identify the parameter that is being set.\nFor example, a less-common parameter name such as\n\u2018building_block__complementary_error_function\u2019 might only be used once (if at all)\nby a single task in a model.  In which case it may be sufficient to simply specify\n\u2018parameter_name\u2019.  But a more-common name such as \u2018random_seed\u2019 might be used by\nseveral of the model\u2019s tasks, and it may be necessary to also specify \u2018task_name\u2019\nto clarify which task\u2019s random seed is to be set.\nThis function only affects client-side state. It will not check that the new parameter\nvalue(s) are valid.\nParameters:\ntask_name (str) \u2013 Name of the task whose parameter needs to be set\nparameter_name (str) \u2013 Name of the parameter to set\nparameter_id (str) \u2013 ID of the parameter to set\nvalue (int, float, list, or str) \u2013 New value for the parameter, with legal values determined by the parameter being set\nRaises:\nNoParametersFoundException \u2013 if no matching parameters are found.\nNonUniqueParametersException \u2013 if multiple parameters matched the specified filtering criteria\nReturn type:\nNone\nget_parameters()\uf0c1\nReturns the set of parameters available to this model\nThe returned parameters have one additional key, \u201cvalue\u201d, reflecting any new values that\nhave been set in this AdvancedTuningSession.  When the session is run, \u201cvalue\u201d will be used,\nor if it is unset, \u201ccurrent_value\u201d.\nReturn type:\nAdvancedTuningParamsType\nReturns:\nparameters (dict) \u2013 \u201cParameters\u201d dictionary, same as specified on Model.get_advanced_tuning_params.\nAn additional field is added per parameter to the 'tuning_parameters' list in the dictionary\nvalue (int, float, list, or str) \u2013 The current value of the parameter.  None if none has been specified.\nrun()\uf0c1\nSubmit this model for Advanced Tuning.\nReturns:\nThe created job to build the model\nReturn type:\ndatarobot.models.modeljob.ModelJob\nRecommended models\uf0c1\nclass datarobot.models.ModelRecommendation\uf0c1\nA collection of information about a recommended model for a project.\nVariables:\nproject_id (str) \u2013 the id of the project the model belongs to\nmodel_id (str) \u2013 the id of the recommended model\nrecommendation_type (str) \u2013 the type of model recommendation\nclassmethod get(project_id, recommendation_type=None)\uf0c1\nRetrieves the default or specified by recommendation_type recommendation.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nrecommendation_type (enums.RECOMMENDED_MODEL_TYPE) \u2013 The type of recommendation to get. If None, returns the default recommendation.\nReturns:\nrecommended_model\nReturn type:\nModelRecommendation\nclassmethod get_all(project_id)\uf0c1\nRetrieves all of the current recommended models for the project.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nReturns:\nrecommended_models\nReturn type:\nlist of ModelRecommendation\nclassmethod get_recommendation(recommended_models, recommendation_type)\uf0c1\nReturns the model in the given list with the requested type.\nParameters:\nrecommended_models (list of ModelRecommendation)\nrecommendation_type (enums.RECOMMENDED_MODEL_TYPE) \u2013 the type of model to extract from the recommended_models list\nReturns:\nrecommended_model\nReturn type:\nModelRecommendation or None if no model with the requested type exists\nget_model()\uf0c1\nReturns the Model associated with this ModelRecommendation.\nReturns:\nrecommended_model\nReturn type:\nModel or DatetimeModel if the project is datetime-partitioned\nClass mapping aggregation settings\uf0c1\nFor multiclass projects with a lot of unique values in target column you can\nspecify the parameters for aggregation of rare values to improve the modeling\nperformance and decrease the runtime and resource usage of resulting models.\nclass datarobot.helpers.ClassMappingAggregationSettings\uf0c1\nClass mapping aggregation settings.\nFor multiclass projects allows fine control over which target values will be\npreserved as classes. Classes which aren\u2019t preserved will be\n- aggregated into a single \u201ccatch everything else\u201d class in case of multiclass\n- or will be ignored in case of multilabel.\nAll attributes are optional, if not specified - server side defaults will be used.\nVariables:\nmax_unaggregated_class_values (Optional[int]) \u2013 Maximum amount of unique values allowed before aggregation kicks in.\nmin_class_support (Optional[int]) \u2013 Minimum number of instances necessary for each target value in the dataset.\nAll values with less instances will be aggregated.\nexcluded_from_aggregation (Optional[List]) \u2013 List of target values that should be guaranteed to kept as is,\nregardless of other settings.\naggregation_class_name (Optional[str]) \u2013 If some of the values will be aggregated - this is the name of the aggregation class\nthat will replace them.\nModel jobs\uf0c1\ndatarobot.models.modeljob.wait_for_async_model_creation(project_id, model_job_id, max_wait=600)\uf0c1\nGiven a Project id and ModelJob id poll for status of process\nresponsible for model creation until model is created.\nParameters:\nproject_id (str) \u2013 The identifier of the project\nmodel_job_id (str) \u2013 The identifier of the ModelJob\nmax_wait (Optional[int]) \u2013 Time in seconds after which model creation is considered\nunsuccessful\nReturns:\nmodel \u2013 Newly created model\nReturn type:\nModel\nRaises:\nAsyncModelCreationError \u2013 Raised if status of fetched ModelJob object is error\nAsyncTimeoutError \u2013 Model wasn\u2019t created in time, specified by max_wait parameter\nclass datarobot.models.ModelJob\uf0c1\nTracks asynchronous work being done within a project\nVariables:\nid (int) \u2013 the id of the job\nproject_id (str) \u2013 the id of the project the job belongs to\nstatus (str) \u2013 the status of the job - will be one of datarobot.enums.QUEUE_STATUS\njob_type (str) \u2013 what kind of work the job is doing - will be \u2018model\u2019 for modeling jobs\nis_blocked (bool) \u2013 if true, the job is blocked (cannot be executed) until its dependencies are resolved\nsample_pct (float) \u2013 the percentage of the project\u2019s dataset used in this modeling job\nmodel_type (str) \u2013 the model this job builds (e.g. \u2018Nystroem Kernel SVM Regressor\u2019)\nprocesses (List[str]) \u2013 the processes used by the model\nfeaturelist_id (str) \u2013 the id of the featurelist used in this modeling job\nblueprint (Blueprint) \u2013 the blueprint used in this modeling job\nclassmethod from_job(job)\uf0c1\nTransforms a generic Job into a ModelJob\nParameters:\njob (Job) \u2013 A generic job representing a ModelJob\nReturns:\nmodel_job \u2013 A fully populated ModelJob with all the details of the job\nReturn type:\nModelJob\nRaises:\nValueError: \u2013 If the generic Job was not a model job, e.g. job_type != JOB_TYPE.MODEL\nclassmethod get(project_id, model_job_id)\uf0c1\nFetches one ModelJob. If the job finished, raises PendingJobFinished\nexception.\nParameters:\nproject_id (str) \u2013 The identifier of the project the model belongs to\nmodel_job_id (str) \u2013 The identifier of the model_job\nReturns:\nmodel_job \u2013 The pending ModelJob\nReturn type:\nModelJob\nRaises:\nPendingJobFinished \u2013 If the job being queried already finished, and the server is\nre-routing to the finished model.\nAsyncFailureError \u2013 Querying this resource gave a status code other than 200 or 303\nclassmethod get_model(project_id, model_job_id)\uf0c1\nFetches a finished model from the job used to create it.\nParameters:\nproject_id (str) \u2013 The identifier of the project the model belongs to\nmodel_job_id (str) \u2013 The identifier of the model_job\nReturns:\nmodel \u2013 The finished model\nReturn type:\nModel\nRaises:\nJobNotFinished \u2013 If the job has not finished yet\nAsyncFailureError \u2013 Querying the model_job in question gave a status code other than 200 or\n303\ncancel()\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nget_result(params=None)\uf0c1\nParameters:\nparams (dict or None) \u2013 Query parameters to be added to request to get results.\nNotes\nFor featureEffects, source param is required to define source,\notherwise the default is training.\nReturns:\nresult \u2013\nReturn type depends on the job type\nfor model jobs, a Model is returned\nfor predict jobs, a pandas.DataFrame (with predictions) is returned\nfor featureImpact jobs, a list of dicts by default (see with_metadata\nparameter of the FeatureImpactJob class and its get() method).\nfor primeRulesets jobs, a list of Rulesets\nfor primeModel jobs, a PrimeModel\nfor primeDownloadValidation jobs, a PrimeFile\nfor predictionExplanationInitialization jobs, a PredictionExplanationsInitialization\nfor predictionExplanations jobs, a PredictionExplanations\nfor featureEffects, a FeatureEffects.\nReturn type:\nobject\nRaises:\nJobNotFinished \u2013 If the job is not finished, the result is not available.\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nget_result_when_complete(max_wait=600, params=None)\uf0c1\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nparams (dict, optional) \u2013 Query parameters to be added to request.\nReturns:\nresult \u2013 Return type is the same as would be returned by Job.get_result.\nReturn type:\nobject\nRaises:\nAsyncTimeoutError \u2013 If the job does not finish in time\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nrefresh()\uf0c1\nUpdate this object with the latest job data from the server.\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nReturn type:\nNone\nRegistry jobs\uf0c1\nclass datarobot.models.registry.job.Job\uf0c1\nA DataRobot job.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the job.\nname (str) \u2013 The name of the job.\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the version was created\nitems (List[JobFileItem]) \u2013 A list of file items attached to the job.\ndescription (Optional[str]) \u2013 A job description.\nenvironment_id (Optional[str]) \u2013 The ID of the environment to use with the job.\nenvironment_version_id (Optional[str]) \u2013 The ID of the environment version to use with the job.\nclassmethod create(name, environment_id=None, environment_version_id=None, folder_path=None, files=None, file_data=None, runtime_parameter_values=None)\uf0c1\nCreate a job.\nAdded in version v3.4.\nParameters:\nname (str) \u2013 The name of the job.\nenvironment_id (Optional[str]) \u2013 The environment ID to use for job runs.\nThe ID must be specified in order to run the job.\nenvironment_version_id (Optional[str]) \u2013 The environment version ID to use for job runs.\nIf not specified, the latest version of the execution environment will be used.\nfolder_path (Optional[str]) \u2013 The path to a folder containing files to be uploaded.\nEach file in the folder is uploaded under path relative\nto a folder path.\nfiles (Optional[Union[List[Tuple[str, str]], List[str]]]) \u2013 The files to be uploaded to the job.\nThe files can be defined in 2 ways:\n1. List of tuples where 1st element is the local path of the file to be uploaded\nand the 2nd element is the file path in the job file system.\n2. List of local paths of the files to be uploaded.\nIn this case files are added to the root of the model file system.\nfile_data (Optional[Dict[str, str]]) \u2013 The files content to be uploaded to the job.\nDefined as a dictionary where keys are the file paths in the job file system.\nand values are the files content.\nruntime_parameter_values (Optional[List[RuntimeParameterValue]]) \u2013 Additional parameters to be injected into a model at runtime. The fieldName\nmust match a fieldName that is listed in the runtimeParameterDefinitions section\nof the model-metadata.yaml file.\nReturns:\ncreated job\nReturn type:\nJob\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod list()\uf0c1\nList jobs.\nAdded in version v3.4.\nReturns:\na list of jobs\nReturn type:\nList[Job]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(job_id)\uf0c1\nGet job by id.\nAdded in version v3.4.\nParameters:\njob_id (str) \u2013 The ID of the job.\nReturns:\nretrieved job\nReturn type:\nJob\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(name=None, entry_point=None, environment_id=None, environment_version_id=None, description=None, folder_path=None, files=None, file_data=None, runtime_parameter_values=None)\uf0c1\nUpdate job properties.\nAdded in version v3.4.\nParameters:\nname (str) \u2013 The job name.\nentry_point (Optional[str]) \u2013 The job file item ID to use as an entry point of the job.\nenvironment_id (Optional[str]) \u2013 The environment ID to use for job runs.\nMust be specified in order to run the job.\nenvironment_version_id (Optional[str]) \u2013 The environment version ID to use for job runs.\nIf not specified, the latest version of the execution environment will be used.\ndescription (str) \u2013 The job description.\nfolder_path (Optional[str]) \u2013 The path to a folder containing files to be uploaded.\nEach file in the folder is uploaded under path relative\nto a folder path.\nfiles (Optional[Union[List[Tuple[str, str]], List[str]]]) \u2013 The files to be uploaded to the job.\nThe files can be defined in 2 ways:\n1. List of tuples where 1st element is the local path of the file to be uploaded\nand the 2nd element is the file path in the job file system.\n2. List of local paths of the files to be uploaded.\nIn this case files are added to the root of the job file system.\nfile_data (Optional[Dict[str, str]]) \u2013 The files content to be uploaded to the job.\nDefined as a dictionary where keys are the file paths in the job file system.\nand values are the files content.\nruntime_parameter_values (Optional[List[RuntimeParameterValue]]) \u2013 Additional parameters to be injected into a model at runtime. The fieldName\nmust match a fieldName that is listed in the runtimeParameterDefinitions section\nof the model-metadata.yaml file.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\ndelete()\uf0c1\nDelete job.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nrefresh()\uf0c1\nUpdate job with the latest data from server.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create_from_custom_metric_gallery_template(template_id, name, description=None, sidecar_deployment_id=None)\uf0c1\nCreate a job from a custom metric gallery template.\nParameters:\ntemplate_id (str) \u2013 ID of the template.\nname (str) \u2013 Name of the job.\ndescription (Optional[str]) \u2013 Description of the job.\nsidecar_deployment_id (Optional[str]) \u2013 ID of the sidecar deployment. Only relevant for templates that use sidecar deployments.\nReturns:\nretrieved job\nReturn type:\nJob\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nlist_schedules()\uf0c1\nList schedules for the job.\nReturns:\na list of schedules for the job.\nReturn type:\nList[JobSchedule]\nclass datarobot.models.registry.job.JobFileItem\uf0c1\nA file item attached to a DataRobot job.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the file item.\nfile_name (str) \u2013 The name of the file item.\nfile_path (str) \u2013 The path of the file item.\nfile_source (str) \u2013 The source of the file item.\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the version was created.\nclass datarobot.models.registry.job_run.JobRun\uf0c1\nA DataRobot job run.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 The ID of the job run.\ncustom_job_id (str) \u2013 The ID of the parent job.\ndescription (str) \u2013 A description of the job run.\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the version was created\nitems (List[JobFileItem]) \u2013 A list of file items attached to the job.\nstatus (JobRunStatus) \u2013 The status of the job run.\nduration (float) \u2013 The duration of the job run.\nclassmethod create(job_id, max_wait=600, runtime_parameter_values=None)\uf0c1\nCreate a job run.\nAdded in version v3.4.\nParameters:\njob_id (str) \u2013 The ID of the job.\nmax_wait (Optional[int]) \u2013 max time to wait for a terminal status (\u201csucceeded\u201d, \u201cfailed\u201d, \u201cinterrupted\u201d, \u201ccanceled\u201d).\nIf set to None - method will return without waiting.\nruntime_parameter_values (Optional[List[RuntimeParameterValue]]) \u2013 Additional parameters to be injected into a model at runtime. The fieldName\nmust match a fieldName that is listed in the runtimeParameterDefinitions section\nof the model-metadata.yaml file.\nReturns:\ncreated job\nReturn type:\nJob\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nValueError \u2013 if execution environment or entry point is not specified for the job\nclassmethod list(job_id)\uf0c1\nList job runs.\nAdded in version v3.4.\nParameters:\njob_id (str) \u2013 The ID of the job.\nReturns:\nA list of job runs.\nReturn type:\nList[Job]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(job_id, job_run_id)\uf0c1\nGet job run by id.\nAdded in version v3.4.\nParameters:\njob_id (str) \u2013 The ID of the job.\njob_run_id (str) \u2013 The ID of the job run.\nReturns:\nThe retrieved job run.\nReturn type:\nJob\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(description=None)\uf0c1\nUpdate job run properties.\nAdded in version v3.4.\nParameters:\ndescription (str) \u2013 new job run description\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\ncancel()\uf0c1\nCancel job run.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nrefresh()\uf0c1\nUpdate job run with the latest data from server.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nget_logs()\uf0c1\nGet log of the job run.\n:rtype: Optional[str]\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndelete_logs()\uf0c1\nGet log of the job run.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclass datarobot.models.registry.job_run.JobRunStatus\uf0c1\nEnum of the job run statuses\nclass datarobot.models.registry.job.JobSchedule\uf0c1\nA job schedule.\nAdded in version v3.5.\nVariables:\nid (str) \u2013 The ID of the job schedule.\ncustom_job_id (str) \u2013 The ID of the custom job.\nupdated_at (str) \u2013 ISO-8601 formatted timestamp of when the schedule was updated.\nupdated_by (Dict[str, Any]) \u2013 The user who updated the schedule.\ncreated_at (str) \u2013 ISO-8601 formatted timestamp of when the schedule was created.\ncreated_by (Dict[str, Any]) \u2013 The user who created the schedule.\nscheduled_job_id (str) \u2013 The ID of the scheduled job.\ndeployment (Dict[str, Any]) \u2013 The deployment of the scheduled job.\nschedule (Schedule) \u2013 The schedule of the job.\nparameter_overrides (List[RuntimeParameterValue]) \u2013 The parameter overrides for this schedule.\nupdate(schedule=None, parameter_overrides=None)\uf0c1\nUpdate the job schedule.\nParameters:\nschedule (Optional[Schedule]) \u2013 The schedule of the job.\nparameter_overrides (Optional[List[RuntimeParameterValue]]) \u2013 The parameter overrides for this schedule.\nReturn type:\nJobSchedule\ndelete()\uf0c1\nDelete the job schedule.\n:rtype: None\nclassmethod create(custom_job_id, schedule, parameter_overrides=None)\uf0c1\nCreate a job schedule.\nParameters:\ncustom_job_id (str) \u2013 The ID of the custom job.\nschedule (Schedule) \u2013 The schedule of the job.\nparameter_overrides (Optional[List[RuntimeParameterValue]]) \u2013 The parameter overrides for this schedule.\nReturn type:\nJobSchedule\nMissing values report\uf0c1\nclass datarobot.models.missing_report.MissingValuesReport\uf0c1\nMissing values report for model, contains list of reports per feature sorted by missing\ncount in descending order.\nNotes\nReport per feature contains:\nfeature : feature name.\ntype : feature type \u2013 \u2018Numeric\u2019 or \u2018Categorical\u2019.\nmissing_count :  missing values count in training data.\nmissing_percentage : missing values percentage in training data.\ntasks : list of information per each task, which was applied to feature.\ntask information contains:\nid : a number of task in the blueprint diagram.\nname : task name.\ndescriptions : human readable aggregated information about how the task handles\nmissing values.  The following descriptions may be present: what value is imputed for\nmissing values, whether the feature being missing is treated as a feature by the task,\nwhether missing values are treated as infrequent values,\nwhether infrequent values are treated as missing values,\nand whether missing values are ignored.\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve a missing report.\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\nmodel_id (str) \u2013 The model\u2019s id.\nReturns:\nThe queried missing report.\nReturn type:\nMissingValuesReport\nRegistered models\uf0c1\nclass datarobot.models.RegisteredModel\uf0c1\nA registered model is a logical grouping of model packages (versions) that are related to each other.\nVariables:\nid (str) \u2013 The ID of the registered model.\nname (str) \u2013 The name of the registered model.\ndescription (str) \u2013 The description of the registered model.\ncreated_at (str) \u2013 The creation time of the registered model.\nmodified_at (str) \u2013 The last modification time for the registered model.\nmodified_by (datarobot.models.model_registry.common.UserMetadata) \u2013 Information on the user who last modified the registered model.\ntarget (Target) \u2013 Information on the target variable.\ncreated_by (datarobot.models.model_registry.common.UserMetadata) \u2013 Information on the creator of the registered model.\nlast_version_num (int) \u2013 The latest version number associated to this registered model.\nis_archived (bool) \u2013 Determines whether the registered model is archived.\nclassmethod get(registered_model_id)\uf0c1\nGet a registered model by ID.\nParameters:\nregistered_model_id (str) \u2013 ID of the registered model to retrieve\nReturns:\nregistered_model \u2013 Registered Model Object\nReturn type:\nRegisteredModel\nExamples\nfrom datarobot import RegisteredModel\nregistered_model = RegisteredModel.get(registered_model_id='5c939e08962d741e34f609f0')\nregistered_model.id\n>>>'5c939e08962d741e34f609f0'\nregistered_model.name\n>>>'My Registered Model'\nclassmethod list(limit=100, offset=None, sort_key=None, sort_direction=None, search=None, filters=None)\uf0c1\nList all registered models a user can view.\nParameters:\nlimit (Optional[int]) \u2013 Maximum number of registered models to return\noffset (Optional[int]) \u2013 Number of registered models to skip before returning results\nsort_key (RegisteredModelSortKey, optional) \u2013 Key to order result by\nsort_direction (RegisteredModelSortDirection, optional) \u2013 Sort direction\nsearch (Optional[str]) \u2013 A term to search for in registered model name, description, or target name\nfilters (RegisteredModelListFilters, optional) \u2013 An object containing all filters that you\u2019d like to apply to the\nresulting list of registered models.\nReturns:\nregistered_models \u2013 A list of registered models user can view.\nReturn type:\nList[RegisteredModel]\nExamples\nfrom datarobot import RegisteredModel\nregistered_models = RegisteredModel.list()\n>>> [RegisteredModel('My Registered Model'), RegisteredModel('My Other Registered Model')]\nfrom datarobot import RegisteredModel\nfrom datarobot.models.model_registry import RegisteredModelListFilters\nfrom datarobot.enums import RegisteredModelSortKey, RegisteredModelSortDirection\nfilters = RegisteredModelListFilters(target_type='Regression')\nregistered_models = RegisteredModel.list(\nfilters=filters,\nsort_key=RegisteredModelSortKey.NAME.value,\nsort_direction=RegisteredModelSortDirection.DESC.value\nsearch='other')\n>>> [RegisteredModel('My Other Registered Model')]\nclassmethod archive(registered_model_id)\uf0c1\nPermanently archive a registered model and all of its versions.\nParameters:\nregistered_model_id (str) \u2013 ID of the registered model to be archived\nReturn type:\nNone\nclassmethod update(registered_model_id, name)\uf0c1\nUpdate the name of a registered model.\nParameters:\nregistered_model_id (str) \u2013 ID of the registered model to be updated\nname (str) \u2013 New name for the registered model\nReturns:\nregistered_model \u2013 Updated registered model object\nReturn type:\nRegisteredModel\nget_shared_roles(offset=None, limit=None, id=None)\uf0c1\nRetrieve access control information for this registered model.\nParameters:\noffset (Optional[int]) \u2013 The number of records to skip over. Optional. Default is 0.\nlimit (Optional[int]) \u2013 The number of records to return. Optional. Default is 100.\nid (Optional[str]) \u2013 Return the access control information for a user with this user ID. Optional.\nReturn type:\nList[SharingRole]\nshare(roles)\uf0c1\nShare this registered model or remove access from one or more user(s).\nParameters:\nroles (List[SharingRole]) \u2013 A list of SharingRole instances, each of which\nreferences a user and a role to be assigned.\nReturn type:\nNone\nExamples\n>>> from datarobot import RegisteredModel, SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>> registered_model = RegisteredModel.get('5c939e08962d741e34f609f0')\n>>> sharing_role = SharingRole(\n...    role=SHARING_ROLE.CONSUMER,\n...    recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...    id='5c939e08962d741e34f609f0',\n...    can_share=True,\n...    )\n>>> registered_model.share(roles=[sharing_role])\nget_version(version_id)\uf0c1\nRetrieve a registered model version.\nParameters:\nversion_id (str) \u2013 The ID of the registered model version to retrieve.\nReturns:\nregistered_model_version \u2013 A registered model version object.\nReturn type:\nRegisteredModelVersion\nExamples\nfrom datarobot import RegisteredModel\nregistered_model = RegisteredModel.get('5c939e08962d741e34f609f0')\nregistered_model_version = registered_model.get_version('5c939e08962d741e34f609f0')\n>>> RegisteredModelVersion('My Registered Model Version')\nlist_versions(filters=None, search=None, sort_key=None, sort_direction=None, limit=None, offset=None)\uf0c1\nRetrieve a list of registered model versions.\nParameters:\nfilters (Optional[RegisteredModelVersionsListFilters]) \u2013 A RegisteredModelVersionsListFilters instance used to filter the list of registered model versions returned.\nsearch (Optional[str]) \u2013 A search string used to filter the list of registered model versions returned.\nsort_key (Optional[RegisteredModelVersionSortKey]) \u2013 The key to use to sort the list of registered model versions returned.\nsort_direction (Optional[RegisteredModelSortDirection]) \u2013 The direction to use to sort the list of registered model versions returned.\nlimit (Optional[int]) \u2013 The maximum number of registered model versions to return. Default is 100.\noffset (Optional[int]) \u2013 The number of registered model versions to skip over. Default is 0.\nReturns:\nregistered_model_versions \u2013 A list of registered model version objects.\nReturn type:\nList[RegisteredModelVersion]\nExamples\nfrom datarobot import RegisteredModel\nfrom datarobot.models.model_registry import RegisteredModelVersionsListFilters\nfrom datarobot.enums import RegisteredModelSortKey, RegisteredModelSortDirection\nregistered_model = RegisteredModel.get('5c939e08962d741e34f609f0')\nfilters = RegisteredModelVersionsListFilters(tags=['tag1', 'tag2'])\nregistered_model_versions = registered_model.list_versions(filters=filters)\n>>> [RegisteredModelVersion('My Registered Model Version')]\nlist_associated_deployments(search=None, sort_key=None, sort_direction=None, limit=None, offset=None)\uf0c1\nRetrieve a list of deployments associated with this registered model.\nParameters:\nsearch (Optional[str])\nsort_key (Optional[RegisteredModelDeploymentSortKey])\nsort_direction (Optional[RegisteredModelSortDirection])\nlimit (Optional[int])\noffset (Optional[int])\nReturns:\ndeployments \u2013 A list of deployments associated with this registered model.\nReturn type:\nList[VersionAssociatedDeployment]\nclass datarobot.models.RegisteredModelVersion\uf0c1\nRepresents a version of a registered model.\nParameters:\nid (str) \u2013 The ID of the registered model version.\nregistered_model_id (str) \u2013 The ID of the parent registered model.\nregistered_model_version (int) \u2013 The version of the registered model.\nname (str) \u2013 The name of the registered model version.\nmodel_id (str) \u2013 The ID of the model.\nmodel_execution_type (str) \u2013 Type of model package (version). dedicated (native DataRobot models) and\ncustom_inference_model` (user added inference models) both execute on DataRobot\nprediction servers, external do not\nis_archived (bool) \u2013\nWhether the model package (version) is permanently archived (cannot be used in deployment orreplacement)\nimport_meta (ImportMeta) \u2013 Information from when this Model Package (version) was first saved.\nsource_meta (SourceMeta) \u2013 Meta information from where this model was generated\nmodel_kind (ModelKind) \u2013 Model attribute information.\ntarget (Target) \u2013 Target information for the registered model version.\nmodel_description (ModelDescription) \u2013 Model description information.\ndatasets (Dataset) \u2013 Dataset information for the registered model version.\ntimeseries (Timeseries) \u2013 Timeseries information for the registered model version.\nbias_and_fairness (BiasAndFairness) \u2013 Bias and fairness information for the registered model version.\nis_deprecated (bool) \u2013\nWhether the model package (version) is deprecated (cannot be used in deployment orreplacement)\npermissions (List[str]) \u2013 Permissions for the registered model version.\nactive_deployment_count (int or None) \u2013 Number of the active deployments associated with the registered model version.\nbuild_status (str or None) \u2013 Model package (version) build status. One of complete, inProgress, failed.\nuser_provided_id (str or None) \u2013 User provided ID for the registered model version.\nupdated_at (str or None) \u2013 The time the registered model version was last updated.\nupdated_by (UserMetadata or None) \u2013 The user who last updated the registered model version.\ntags (List[TagWithId] or None) \u2013 The tags associated with the registered model version.\nmlpkg_file_contents (str or None) \u2013 The contents of the model package file.\nclassmethod create_for_leaderboard_item(model_id, name=None, prediction_threshold=None, distribution_prediction_model_id=None, description=None, compute_all_ts_intervals=None, registered_model_name=None, registered_model_id=None, tags=None, registered_model_tags=None, registered_model_description=None)\uf0c1\nParameters:\nmodel_id (str) \u2013 ID of the DataRobot model.\nname (str or None) \u2013 Name of the version (model package).\nprediction_threshold (float or None) \u2013 Threshold used for binary classification in predictions.\ndistribution_prediction_model_id (str or None) \u2013 ID of the DataRobot distribution prediction model\ntrained on predictions from the DataRobot model.\ndescription (str or None) \u2013 Description of the version (model package).\ncompute_all_ts_intervals (bool or None) \u2013 Whether to compute all time series prediction intervals (1-100 percentiles).\nregistered_model_name (Optional[str]) \u2013 Name of the new registered model that will be created from this model package (version).\nThe model package (version) will be created as version 1 of the created registered model.\nIf neither registeredModelName nor registeredModelId is provided,\nit defaults to the model package (version) name. Mutually exclusive with registeredModelId.\nregistered_model_id (Optional[str]) \u2013 Creates a model package (version) as a new version for the provided registered model ID.\nMutually exclusive with registeredModelName.\ntags (Optional[List[Tag]]) \u2013 Tags for the registered model version.\nregistered_model_tags (Optional[List[Tag]]) \u2013 Tags for the registered model.\nregistered_model_description (Optional[str]) \u2013 Description for the registered model.\nReturns:\nregitered_model_version \u2013 A new registered model version object.\nReturn type:\nRegisteredModelVersion\nclassmethod create_for_external(name, target, model_id=None, model_description=None, datasets=None, timeseries=None, registered_model_name=None, registered_model_id=None, tags=None, registered_model_tags=None, registered_model_description=None, geospatial_monitoring=None)\uf0c1\nCreate a new registered model version from an external model.\nParameters:\nname (str) \u2013 Name of the registered model version.\ntarget (ExternalTarget) \u2013 Target information for the registered model version.\nmodel_id (Optional[str]) \u2013 Model ID of the registered model version.\nmodel_description (Optional[ModelDescription]) \u2013 Information about the model.\ndatasets (Optional[ExternalDatasets]) \u2013 Dataset information for the registered model version.\ntimeseries (Optional[Timeseries]) \u2013 Timeseries properties for the registered model version.\nregistered_model_name (Optional[str]) \u2013 Name of the new registered model that will be created from this model package (version).\nThe model package (version) will be created as version 1 of the created registered model.\nIf neither registeredModelName nor registeredModelId is provided,\nit defaults to the model package (version) name. Mutually exclusive with registeredModelId.\nregistered_model_id (Optional[str]) \u2013 Creates a model package (version) as a new version for the provided registered model ID.\nMutually exclusive with registeredModelName.\ntags (Optional[List[Tag]]) \u2013 Tags for the registered model version.\nregistered_model_tags (Optional[List[Tag]]) \u2013 Tags for the registered model.\nregistered_model_description (Optional[str]) \u2013 Description for the registered model.\ngeospatial_monitoring (Optional[ExternalGeospatialMonitoring]) \u2013 Geospatial monitoring settings for the registered model version.\nReturns:\nregistered_model_version \u2013 A new registered model version object.\nReturn type:\nRegisteredModelVersion\nclassmethod create_for_custom_model_version(custom_model_version_id, name=None, description=None, registered_model_name=None, registered_model_id=None, tags=None, registered_model_tags=None, registered_model_description=None)\uf0c1\nCreate a new registered model version from a custom model version.\nParameters:\ncustom_model_version_id (str) \u2013 ID of the custom model version.\nname (Optional[str]) \u2013 Name of the registered model version.\ndescription (Optional[str]) \u2013 Description of the registered model version.\nregistered_model_name (Optional[str]) \u2013 Name of the new registered model that will be created from this model package (version).\nThe model package (version) will be created as version 1 of the created registered model.\nIf neither registeredModelName nor registeredModelId is provided,\nit defaults to the model package (version) name. Mutually exclusive with registeredModelId.\nregistered_model_id (Optional[str]) \u2013 Creates a model package (version) as a new version for the provided registered model ID.\nMutually exclusive with registeredModelName.\ntags (Optional[List[Tag]]) \u2013 Tags for the registered model version.\nregistered_model_tags (Optional[List[Tag]]) \u2013 Tags for the registered model.\nregistered_model_description (Optional[str]) \u2013 Description for the registered model.\nReturns:\nregistered_model_version \u2013 A new registered model version object.\nReturn type:\nRegisteredModelVersion\nlist_associated_deployments(search=None, sort_key=None, sort_direction=None, limit=None, offset=None)\uf0c1\nRetrieve a list of deployments associated with this registered model version.\nParameters:\nsearch (Optional[str])\nsort_key (Optional[RegisteredModelDeploymentSortKey])\nsort_direction (Optional[RegisteredModelSortDirection])\nlimit (Optional[int])\noffset (Optional[int])\nReturns:\ndeployments \u2013 A list of deployments associated with this registered model version.\nReturn type:\nList[VersionAssociatedDeployment]\nclass datarobot.models.model_registry.deployment.VersionAssociatedDeployment\uf0c1\nRepresents a deployment associated with a registered model version.\nParameters:\nid (str) \u2013 The ID of the deployment.\ncurrently_deployed (bool) \u2013 Whether this version is currently deployed.\nregistered_model_version (int) \u2013 The version of the registered model associated with this deployment.\nis_challenger (bool) \u2013 Whether the version associated with this deployment is a challenger.\nstatus (str) \u2013 The status of the deployment.\nlabel (Optional[str]) \u2013 The label of the deployment.\nfirst_deployed_at (datetime.datetime, optional) \u2013 The time the version was first deployed.\nfirst_deployed_by (UserMetadata, optional) \u2013 The user who first deployed the version.\ncreated_by (UserMetadata, optional) \u2013 The user who created the deployment.\nprediction_environment (DeploymentPredictionEnvironment, optional) \u2013 The prediction environment of the deployment.\nclass datarobot.models.model_registry.RegisteredModelVersionsListFilters\uf0c1\nFilters for listing of registered model versions.\nParameters:\ntarget_name (str or None) \u2013 Name of the target to filter by.\ntarget_type (str or None) \u2013 Type of the target to filter by.\ncompatible_with_leaderboard_model_id (str or None.) \u2013 If specified, limit results to versions (model packages) of the Leaderboard model with the specified ID.\ncompatible_with_model_package_id (str or None.) \u2013 Returns versions compatible with the given model package (version) ID. If used, it will only return versions\nthat match target.name, target.type, target.classNames (for classification models),\nmodelKind.isTimeSeries and modelKind.isMultiseries for the specified model package (version).\nfor_challenger (bool or None) \u2013 Can be used with compatibleWithModelPackageId to request similar versions that can be used as challenger\nmodels; for external model packages (versions), instead of returning similar external model packages (versions),\nsimilar DataRobot and Custom model packages (versions) will be retrieved.\nprediction_threshold (float or None) \u2013 Return versions with the specified prediction threshold used for binary classification models.\nimported (bool or None) \u2013 If specified, return either imported (true) or non-imported (false) versions (model packages).\nprediction_environment_id (str or None) \u2013 Can be used to filter versions (model packages) by what is supported by the prediction environment\nmodel_kind (str or None) \u2013 Can be used to filter versions (model packages) by model kind.\nbuild_status (str or None) \u2013 If specified, filter versions by the build status.\nclass datarobot.models.model_registry.RegisteredModelListFilters\uf0c1\nFilters for listing registered models.\nParameters:\ncreated_at_start (datetime.datetime) \u2013 Registered models created on or after this timestamp.\ncreated_at_end (datetime.datetime) \u2013 Registered models created before this timestamp. Defaults to the current time.\nmodified_at_start (datetime.datetime) \u2013 Registered models modified on or after this timestamp.\nmodified_at_end (datetime.datetime) \u2013 Registered models modified before this timestamp. Defaults to the current time.\ntarget_name (str) \u2013 Name of the target to filter by.\ntarget_type (str) \u2013 Type of the target to filter by.\ncreated_by (str) \u2013 Email of the user that created registered model to filter by.\ncompatible_with_leaderboard_model_id (str) \u2013 If specified, limit results to registered models containing versions (model packages)\nfor the leaderboard model with the specified ID.\ncompatible_with_model_package_id (str) \u2013 Return registered models that have versions (model packages) compatible with given model package (version) ID.\nIf used, will only return registered models which have versions that match target.name, target.type,\ntarget.classNames (for classification models), modelKind.isTimeSeries, and modelKind.isMultiseries\nof the specified model package (version).\nfor_challenger (bool) \u2013 Can be used with compatibleWithModelPackageId to request similar registered models that contain\nversions (model packages) that can be used as challenger models; for external model packages (versions),\ninstead of returning similar external model packages (versions), similar DataRobot and Custom model packages\nwill be retrieved.\nprediction_threshold (float) \u2013 If specified, return any registered models containing one or more versions matching the prediction\nthreshold used for binary classification models.\nimported (bool) \u2013 If specified, return any registered models that contain either imported (true) or non-imported (false)\nversions (model packages).\nprediction_environment_id (str) \u2013 Can be used to filter registered models by what is supported by the prediction environment.\nmodel_kind (str) \u2013 Return models that contain versions matching a specific format.\nbuild_status (str) \u2013 If specified, only return models that have versions with specified build status.\nRulesets\uf0c1\nclass datarobot.models.Ruleset\uf0c1\nRepresents an approximation of a model with DataRobot Prime\nVariables:\nid (str) \u2013 the id of the ruleset\nrule_count (int) \u2013 the number of rules used to approximate the model\nscore (float) \u2013 the validation score of the approximation\nproject_id (str) \u2013 the project the approximation belongs to\nparent_model_id (str) \u2013 the model being approximated\nmodel_id (str or None) \u2013 the model using this ruleset (if it exists).  Will be None if no such model has been\ntrained.\nrequest_model()\uf0c1\nRequest training for a model using this ruleset\nTraining a model using a ruleset is a necessary prerequisite for being able to download\nthe code for a ruleset.\nReturns:\njob \u2013 the job fitting the new Prime model\nReturn type:\nJob",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/datetime_partition.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/insights.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/blueprints.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "model = datarobot.Model(id='model-id', project_id='project-id')\n\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()",
        "request_frozen_datetime_model",
        "dr.enums.EXPLANATIONS_ALGORITHM",
        "dr.SCORING_TYPE.validation",
        "dr.SCORING_TYPE.cross_validation",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "wait_for_async_model_creation",
        "project = Project.get('project-id')\nmodel = Model.get('project-id', 'model-id')\nmodel_job_id = model.train(training_row_count=project.max_train_rows)",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "datarobot.enums.PRIME_LANGUAGE",
        "model = datarobot.Model(id='model-id', project_id='project-id')\n\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()",
        "dr.enums.EXPLANATIONS_ALGORITHM",
        "model = datarobot.Model(id='model-id', project_id='project-id')\n\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()",
        "request_frozen_datetime_model",
        "dr.enums.EXPLANATIONS_ALGORITHM",
        "dr.SCORING_TYPE.validation",
        "dr.SCORING_TYPE.cross_validation",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "wait_for_async_model_creation",
        "project = Project.get('project-id')\nmodel = Model.get('project-id', 'model-id')\nmodel_job_id = model.train(training_row_count=project.max_train_rows)",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "datarobot.enums.SERIES_ACCURACY_ORDER_BY",
        "datarobot.enums.SERIES_ACCURACY_ORDER_BY",
        "datarobot.enums.SERIES_ACCURACY_ORDER_BY",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "dr.enums.DEFAULT_MAX_WAIT",
        "import datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_accuracy_over_time_plot()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", [\"actual\", \"predicted\"]).get_figure()\nfigure.savefig(\"accuracy_over_time.png\")",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DEFAULT_MAX_WAIT",
        "import datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_accuracy_over_time_plot_preview()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", [\"actual\", \"predicted\"]).get_figure()\nfigure.savefig(\"accuracy_over_time_preview.png\")",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "dr.enums.DEFAULT_MAX_WAIT",
        "import datarobot as dr\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_forecast_vs_actual_plot()\ndf = pd.DataFrame.from_dict(plot.bins)\n\n# As an example, get the forecasts for the 10th point\nforecast_point_index = 10\n# Pad the forecasts for plotting. The forecasts length must match the df length\nforecasts = [None] * forecast_point_index + df.forecasts[forecast_point_index]\nforecasts = forecasts + [None] * (len(df) - len(forecasts))\n\nplt.plot(df.start_date, df.actual, label=\"Actual\")\nplt.plot(df.start_date, forecasts, label=\"Forecast\")\nforecast_point = df.start_date[forecast_point_index]\nplt.title(\"Forecast vs Actual (Forecast Point {})\".format(forecast_point))\nplt.legend()\nplt.savefig(\"forecast_vs_actual.png\")",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DEFAULT_MAX_WAIT",
        "import datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_forecast_vs_actual_plot_preview()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", [\"actual\", \"predicted\"]).get_figure()\nfigure.savefig(\"forecast_vs_actual_preview.png\")",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "dr.enums.DEFAULT_MAX_WAIT",
        "import datarobot as dr\nimport pandas as pd\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_anomaly_over_time_plot()\ndf = pd.DataFrame.from_dict(plot.bins)\nfigure = df.plot(\"start_date\", \"predicted\").get_figure()\nfigure.savefig(\"anomaly_over_time.png\")",
        "dr.enums.DATA_SUBSET.HOLDOUT",
        "dr.enums.DEFAULT_MAX_WAIT",
        "import datarobot as dr\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nmodel = dr.DatetimeModel(project_id=project_id, id=model_id)\nplot = model.get_anomaly_over_time_plot_preview(prediction_threshold=0.01)\ndf = pd.DataFrame.from_dict(plot.bins)\nx = pd.date_range(\n    plot.start_date, plot.end_date, freq=df.end_date[0] - df.start_date[0]\n)\nplt.plot(x, [0] * len(x), label=\"Date range\")\nplt.plot(df.start_date, [0] * len(df.start_date), \"ro\", label=\"Anomaly\")\nplt.yticks([])\nplt.legend()\nplt.savefig(\"anomaly_over_time_preview.png\")",
        "model = datarobot.Model(id='model-id', project_id='project-id')\n\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "model = datarobot.Model(id='model-id', project_id='project-id')\n\n# Get feature impact insights for sliced data\ndata_slice = datarobot.DataSlice(id='data-slice-id')\nsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get feature impact insights for unsliced data\ndata_slice = datarobot.DataSlice()\nunsliced_fi = model.get_all_feature_impacts(data_slice_filter=data_slice)\n\n# Get all feature impact insights\nall_fi = model.get_all_feature_impacts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get lift chart insights for sliced data\nsliced_lift_charts = model.get_all_lift_charts(data_slice_id='data-slice-id')\n\n# Get lift chart insights for unsliced data\nunsliced_lift_charts = model.get_all_lift_charts(unsliced_only=True)\n\n# Get all lift chart insights\nall_lift_charts = model.get_all_lift_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\n\n# Get residuals chart insights for sliced data\nsliced_residuals_charts = model.get_all_residuals_charts(data_slice_id='data-slice-id')\n\n# Get residuals chart insights for unsliced data\nunsliced_residuals_charts = model.get_all_residuals_charts(unsliced_only=True)\n\n# Get all residuals chart insights\nall_residuals_charts = model.get_all_residuals_charts()",
        "model = datarobot.Model.get('project-id', 'model-id')\nds_filter=DataSlice(id='data-slice-id')\n\n# Get roc curve insights for sliced data\nsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get roc curve insights for unsliced data\ndata_slice_filter=DataSlice(id=None)\nunsliced_roc = model.get_all_roc_curves(data_slice_filter=ds_filter)\n\n# Get all roc curve insights\nall_roc_curves = model.get_all_roc_curves()",
        "request_frozen_datetime_model",
        "dr.enums.EXPLANATIONS_ALGORITHM",
        "dr.SCORING_TYPE.validation",
        "dr.SCORING_TYPE.cross_validation",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "wait_for_async_model_creation",
        "project = Project.get('project-id')\nmodel = Model.get('project-id', 'model-id')\nmodel_job_id = model.train(training_row_count=project.max_train_rows)",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "datarobot.models.modeljob.ModelJob",
        "enums.RECOMMENDED_MODEL_TYPE",
        "enums.RECOMMENDED_MODEL_TYPE",
        "None if no model with the requested type exists",
        "DatetimeModel if the project is datetime-partitioned",
        "datarobot.enums.QUEUE_STATUS",
        "datarobot.models.model_registry.common.UserMetadata",
        "datarobot.models.model_registry.common.UserMetadata",
        "from datarobot import RegisteredModel\nregistered_model = RegisteredModel.get(registered_model_id='5c939e08962d741e34f609f0')\nregistered_model.id\n>>>'5c939e08962d741e34f609f0'\nregistered_model.name\n>>>'My Registered Model'",
        "RegisteredModelSortKey",
        "RegisteredModelSortDirection",
        "RegisteredModelListFilters",
        "List[RegisteredModel]",
        "from datarobot import RegisteredModel\nregistered_models = RegisteredModel.list()\n>>> [RegisteredModel('My Registered Model'), RegisteredModel('My Other Registered Model')]",
        "from datarobot import RegisteredModel\nfrom datarobot.models.model_registry import RegisteredModelListFilters\nfrom datarobot.enums import RegisteredModelSortKey, RegisteredModelSortDirection\nfilters = RegisteredModelListFilters(target_type='Regression')\nregistered_models = RegisteredModel.list(\n    filters=filters,\n    sort_key=RegisteredModelSortKey.NAME.value,\n    sort_direction=RegisteredModelSortDirection.DESC.value\n    search='other')\n>>> [RegisteredModel('My Other Registered Model')]",
        ">>> from datarobot import RegisteredModel, SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>> registered_model = RegisteredModel.get('5c939e08962d741e34f609f0')\n>>> sharing_role = SharingRole(\n...    role=SHARING_ROLE.CONSUMER,\n...    recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...    id='5c939e08962d741e34f609f0',\n...    can_share=True,\n...    )\n>>> registered_model.share(roles=[sharing_role])",
        "RegisteredModelVersion",
        "from datarobot import RegisteredModel\nregistered_model = RegisteredModel.get('5c939e08962d741e34f609f0')\nregistered_model_version = registered_model.get_version('5c939e08962d741e34f609f0')\n>>> RegisteredModelVersion('My Registered Model Version')",
        "Optional[RegisteredModelVersionsListFilters]",
        "Optional[RegisteredModelVersionSortKey]",
        "Optional[RegisteredModelSortDirection]",
        "List[RegisteredModelVersion]",
        "from datarobot import RegisteredModel\nfrom datarobot.models.model_registry import RegisteredModelVersionsListFilters\nfrom datarobot.enums import RegisteredModelSortKey, RegisteredModelSortDirection\nregistered_model = RegisteredModel.get('5c939e08962d741e34f609f0')\nfilters = RegisteredModelVersionsListFilters(tags=['tag1', 'tag2'])\nregistered_model_versions = registered_model.list_versions(filters=filters)\n>>> [RegisteredModelVersion('My Registered Model Version')]",
        "Optional[RegisteredModelDeploymentSortKey]",
        "Optional[RegisteredModelSortDirection]",
        "RegisteredModelVersion",
        "Optional[ModelDescription]",
        "RegisteredModelVersion",
        "RegisteredModelVersion",
        "Optional[RegisteredModelDeploymentSortKey]",
        "Optional[RegisteredModelSortDirection]"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-prompting.html",
      "title": "Prompting\uf0c1",
      "description": "",
      "content": "Prompting\uf0c1\nclass datarobot.models.genai.chat.Chat\uf0c1\nMetadata for a DataRobot GenAI chat.\nVariables:\nid (str) \u2013 The chat ID.\nname (str) \u2013 The chat name.\nllm_blueprint_id (str) \u2013 The ID of the LLM blueprint associated with the chat.\nis_frozen (bool) \u2013 Checks whether the chat is frozen. Prompts cannot be submitted to frozen chats.\ncreation_date (str) \u2013 The date when the chat was created.\ncreation_user_id (str) \u2013 The ID of the creating user.\nwarning (str or None, optional) \u2013 The warning about the contents of the chat.\nprompts_count (int) \u2013 The number of chat prompts in the chat.\nclassmethod create(name, llm_blueprint)\uf0c1\nCreates a new chat.\nParameters:\nname (str) \u2013 The chat name.\nllm_blueprint (LLMBlueprint or str) \u2013 The LLM blueprint associated with the created chat, either LLM blueprint or ID.\nReturns:\nchat \u2013 The created chat.\nReturn type:\nChat\nclassmethod get(chat)\uf0c1\nRetrieve a single chat.\nParameters:\nchat (Chat or str) \u2013 The chat you want to retrieve. Accepts chat or chat ID.\nReturns:\nchat \u2013 The requested chat.\nReturn type:\nChat\nclassmethod list(llm_blueprint=None, sort=None)\uf0c1\nList all chats available to the user. If the LLM blueprint is specified,\nresults are restricted to only those chats associated with the LLM blueprint.\nParameters:\nllm_blueprint (Optional[Union[LLMBlueprint, str]], optional) \u2013 Returns only those chats associated with a particular LLM blueprint,\nspecified by either the entity or the ID.\nsort (Optional[str]) \u2013 The property to sort chats by. Prefix the attribute name with a dash ( - )\nto sort responses in descending order, (for example, \u2018-name\u2019).\nSupported options are listed in ListChatsSortQueryParams,\nbut the values can differ depending on platform version.\nThe default sort parameter is None, which results in\nchats returning in order of creation time, descending.\nReturns:\nchats \u2013 Returns a list of chats.\nReturn type:\nlist[Chat]\ndelete()\uf0c1\nDelete the single chat.\nReturn type:\nNone\nupdate(name)\uf0c1\nUpdate the chat.\nParameters:\nname (str) \u2013 The new name for the chat.\nReturns:\nchat \u2013 The updated chat.\nReturn type:\nChat\nclass datarobot.models.genai.chat_prompt.ChatPrompt\uf0c1\nMetadata for a DataRobot GenAI chat prompt.\nVariables:\nid (str) \u2013 Chat prompt ID.\ntext (str) \u2013 The prompt text.\nllm_blueprint_id (str) \u2013 ID of the LLM blueprint associated with the chat prompt.\nllm_id (str) \u2013 ID of the LLM type. This must be one of the IDs returned by LLMDefinition.list\nfor this user.\nllm_settings (dict or None) \u2013 The LLM settings for the LLM blueprint. The specific keys allowed and the\nconstraints on the values are defined in the response from LLMDefinition.list,\nbut this typically has dict fields. Either:\n- system_prompt - The system prompt that influences the LLM responses.\n- max_completion_length - The maximum number of tokens in the completion.\n- temperature - Controls the variability in the LLM response.\n- top_p - Sets whether the model considers next tokens with top_p probability mass.\nor\n- system_prompt - The system prompt that influences the LLM responses.\n- validation_id - The ID of the external model LLM validation.\n- external_llm_context_size - The external LLM\u2019s context size, in tokens,\nfor external model-based LLM blueprints.\ncreation_date (str) \u2013 The date the chat prompt was created.\ncreation_user_id (str) \u2013 ID of the creating user.\nvector_database_id (str or None) \u2013 ID of the vector database associated with the LLM blueprint, if any.\nvector_database_settings (VectorDatabaseSettings or None) \u2013 The settings for the vector database associated with the LLM blueprint, if any.\nresult_metadata (ResultMetadata or None) \u2013 Metadata for the result of the chat prompt submission.\nresult_text (str or None) \u2013 The result text from the chat prompt submission.\nconfidence_scores (ConfidenceScores or None) \u2013 The confidence scores if there is a vector database associated with the chat prompt.\ncitations (list[Citation]) \u2013 List of citations from text retrieved from the vector database, if any.\nexecution_status (str) \u2013 The execution status of the chat prompt.\nchat_id (Optional[str]) \u2013 ID of the chat associated with the chat prompt.\nchat_context_id (Optional[str]) \u2013 The ID of the chat context for the chat prompt.\nchat_prompt_ids_included_in_history (Optional[list[str]]) \u2013 The IDs of the chat prompts included in the chat history for this chat prompt.\nmetadata_filter (Optional[Dict[str, Any] | None]) \u2013 The metadata filter to apply to the vector database.\nSupports:\n- None or empty dict (no filters): Considers all documents\n- Multiple field filters (implicit AND): {\u201ca\u201d: 1, \u201cb\u201d: \u201cb\u201d}\n- Comparison operators: {\u201cfield\u201d: {\u201c$gt\u201d: 5}}\n- Logical operators: {\u201c$and\u201d: [\u2026], \u201c$or\u201d: [\u2026]}\n- Nested combinations of the above\nComparison operators:\n- $eq: equal to (string, int, float, bool)\n- $ne: not equal to (string, int, float, bool)\n- $gt: greater than (int, float)\n- $gte: greater than or equal to (int, float)\n- $lt: less than (int, float)\n- $lte: less than or equal to (int, float)\n- $in: a value is in list (string, int, float, bool)\n- $nin: a value is not in list (string, int, float, bool)\n- $contains: a string contains a value (string)\n- $not_contains: a string does not contain a value (string)\nclassmethod create(text, llm_blueprint=None, chat=None, llm=None, llm_settings=None, vector_database=None, vector_database_settings=None, wait_for_completion=False, metadata_filter=None)\uf0c1\nCreate a new ChatPrompt. This submits the prompt text to the LLM. Either llm_blueprint\nor chat is required.\nParameters:\ntext (str) \u2013 The prompt text.\nllm_blueprint (LLMBlueprint or str or None, optional) \u2013 The LLM blueprint associated with the created chat prompt, either LLMBlueprint or\nLLM blueprint ID.\nchat (Chat or str or None, optional) \u2013 The chat associated with the created chat prompt, either Chat or chat ID.\nllm (LLMDefinition, str, or None, optional) \u2013 The LLM to use for the chat prompt, either LLMDefinition or LLM blueprint ID.\nllm_settings (dict or None) \u2013 LLM settings to use for the chat prompt. The specific keys allowed and the\nconstraints on the values are defined in the response from LLMDefinition.list\nbut this typically has dict fields:\n- system_prompt - The system prompt that tells the LLM how to behave.\n- max_completion_length - The maximum number of tokens in the completion.\n- temperature - Controls the variability in the LLM response.\n- top_p - Whether the model considers next tokens with top_p probability mass.\nOr\n- system_prompt - The system prompt that tells the LLM how to behave.\n- validation_id - The ID of the custom model LLM validation\nfor custom model LLM blueprints.\nvector_database (VectorDatabase, str, or None, optional) \u2013 The vector database to use with this chat prompt submission, either\nVectorDatabase or vector database ID.\nvector_database_settings (VectorDatabaseSettings or None, optional) \u2013 Settings for the vector database, if any.\nwait_for_completion (bool) \u2013 If set to True, chat prompt result response limit is up to 10 minutes,\nraising a timeout error after that.\nOtherwise, check current status by using ChatPrompt.get with returned ID.\nmetadata_filter (Optional[Dict[str, Any] | None]) \u2013 The metadata filter to apply to the vector database.\nSupports:\n- None or empty dict (no filters): Considers all documents\n- Multiple field filters (implicit AND): {\u201ca\u201d: 1, \u201cb\u201d: \u201cb\u201d}\n- Comparison operators: {\u201cfield\u201d: {\u201c$gt\u201d: 5}}\n- Logical operators: {\u201c$and\u201d: [\u2026], \u201c$or\u201d: [\u2026]}\n- Nested combinations of the above\nComparison operators:\n- $eq: equal to (string, int, float, bool)\n- $ne: not equal to (string, int, float, bool)\n- $gt: greater than (int, float)\n- $gte: greater than or equal to (int, float)\n- $lt: less than (int, float)\n- $lte: less than or equal to (int, float)\n- $in: a value is in list (string, int, float, bool)\n- $nin: a value is not in list (string, int, float, bool)\n- $contains: a string contains a value (string)\n- $not_contains: a string does not contain a value (string)\nReturns:\nchat_prompt \u2013 The created chat prompt.\nReturn type:\nChatPrompt\nupdate(custom_metrics=None, feedback_metadata=None)\uf0c1\nUpdate the chat prompt.\nParameters:\ncustom_metrics (Optional[list[MetricMetadata]], optional) \u2013 The new custom metrics to add to the chat prompt.\nfeedback_metadata (Optional[FeedbackMetadata], optional) \u2013 The new feedback to add to the chat prompt.\nReturns:\nchat_prompt \u2013 The updated chat prompt.\nReturn type:\nChatPrompt\nclassmethod get(chat_prompt)\uf0c1\nRetrieve a single chat prompt.\nParameters:\nchat_prompt (ChatPrompt or str) \u2013 The chat prompt you want to retrieve, either ChatPrompt or chat prompt ID.\nReturns:\nchat_prompt \u2013 The requested chat prompt.\nReturn type:\nChatPrompt\nclassmethod list(llm_blueprint=None, playground=None, chat=None)\uf0c1\nList all chat prompts available to the user. If the llm_blueprint, playground, or chat\nis specified then the results are restricted to the chat prompts associated with that\nentity.\nParameters:\nllm_blueprint (Optional[Union[LLMBlueprint, str]], optional) \u2013 The returned chat prompts are filtered to those associated with a specific LLM blueprint\nif it is specified. Accepts either LLMBlueprint or LLM blueprint ID.\nplayground (Optional[Union[Playground, str]], optional) \u2013 The returned chat prompts are filtered to those associated with a specific playground\nif it is specified. Accepts either Playground or playground ID.\nchat (Optional[Union[Chat, str]], optional) \u2013 The returned chat prompts are filtered to those associated with a specific chat\nif it is specified. Accepts either Chat or chat ID.\nReturns:\nchat_prompts \u2013 A list of chat prompts available to the user.\nReturn type:\nlist[ChatPrompt]\ndelete()\uf0c1\nDelete the single chat prompt.\nReturn type:\nNone\ncreate_llm_blueprint(name, description='')\uf0c1\nCreate a new LLM blueprint from an existing chat prompt.\nParameters:\nname (str) \u2013 LLM blueprint name.\ndescription (Optional[str]) \u2013 Description of the LLM blueprint, by default \u201c\u201d.\nReturns:\nllm_blueprint \u2013 The created LLM blueprint.\nReturn type:\nLLMBlueprint\nclass datarobot.models.genai.comparison_chat.ComparisonChat\uf0c1\nMetadata for a DataRobot GenAI comparison chat.\nVariables:\nid (str) \u2013 The comparison chat ID.\nname (str) \u2013 The comparison chat name.\nplayground_id (str) \u2013 The ID of the playground associated with the comparison chat.\ncreation_date (str) \u2013 The date when the comparison chat was created.\ncreation_user_id (str) \u2013 The ID of the creating user.\nclassmethod create(name, playground)\uf0c1\nCreates a new comparison chat.\nParameters:\nname (str) \u2013 The comparison chat name.\nplayground (Playground or str) \u2013 The playground associated with the created comparison chat, either Playground\nor playground ID.\nReturns:\ncomparison_chat \u2013 The created comparison chat.\nReturn type:\nComparisonChat\nclassmethod get(comparison_chat)\uf0c1\nRetrieve a single comparison chat.\nParameters:\ncomparison_chat (ComparisonChat or str) \u2013 The comparison chat you want to retrieve. Accepts ComparisonChat or\ncomparison chat ID.\nReturns:\ncomparison_chat \u2013 The requested comparison chat.\nReturn type:\nComparisonChat\nclassmethod list(playground=None, sort=None)\uf0c1\nList all comparison chats available to the user. If the playground is specified,\nresults are restricted to only those comparison chats associated with the playground.\nParameters:\nplayground (Optional[Union[Playground, str]], optional) \u2013 Returns only those comparison chats associated with a particular playground,\nspecified by either the Playground or the playground ID.\nsort (Optional[str]) \u2013 The property to sort comparison chats by. Prefix the attribute name with a dash ( - )\nto sort responses in descending order, (for example, \u2018-name\u2019).\nSupported options are listed in ListComparisonChatsSortQueryParams,\nbut the values can differ depending on platform version.\nThe default sort parameter is None, which results in\ncomparison chats returning in order of creation time, descending.\nReturns:\ncomparison_chats \u2013 Returns a list of comparison chats.\nReturn type:\nlist[ComparisonChat]\ndelete()\uf0c1\nDelete the single comparison chat.\nReturn type:\nNone\nupdate(name)\uf0c1\nUpdate the comparison chat.\nParameters:\nname (str) \u2013 The new name for the comparison chat.\nReturns:\ncomparison_chat \u2013 The updated comparison chat.\nReturn type:\nComparisonChat\nclass datarobot.models.genai.comparison_prompt.ComparisonPrompt\uf0c1\nMetadata for a DataRobot GenAI comparison prompt.\nVariables:\nid (str) \u2013 Comparison prompt ID.\ntext (str) \u2013 The prompt text.\nresults (list[ComparisonPromptResult]) \u2013 The list of results for individual LLM blueprints that are part of the comparison prompt.\ncreation_date (str) \u2013 The date when the playground was created.\ncreation_user_id (str) \u2013 ID of the creating user.\ncomparison_chat_id (str) \u2013 The ID of the comparison chat this comparison prompt is associated with.\nmetadata_filter (Optional[Dict[str, Any] | None]) \u2013 The metadata filter to apply to the vector database.\nSupports:\n- None or empty dict (no filters): Considers all documents\n- Multiple field filters (implicit AND): {\u201ca\u201d: 1, \u201cb\u201d: \u201cb\u201d}\n- Comparison operators: {\u201cfield\u201d: {\u201c$gt\u201d: 5}}\n- Logical operators: {\u201c$and\u201d: [\u2026], \u201c$or\u201d: [\u2026]}\n- Nested combinations of the above\nComparison operators:\n- $eq: equal to (string, int, float, bool)\n- $ne: not equal to (string, int, float, bool)\n- $gt: greater than (int, float)\n- $gte: greater than or equal to (int, float)\n- $lt: less than (int, float)\n- $lte: less than or equal to (int, float)\n- $in: a value is in list (string, int, float, bool)\n- $nin: a value is not in list (string, int, float, bool)\n- $contains: a string contains a value (string)\n- $not_contains: a string does not contain a value (string)\nupdate(additional_llm_blueprints=None, wait_for_completion=False, feedback_result=None, **kwargs)\uf0c1\nUpdate the comparison prompt.\nParameters:\nadditional_llm_blueprints (list[LLMBlueprint or str]) \u2013 The additional LLM blueprints you want to submit the comparison prompt.\nReturns:\ncomparison_prompt \u2013 The updated comparison prompt.\nReturn type:\nComparisonPrompt\nclassmethod create(llm_blueprints, text, comparison_chat=None, wait_for_completion=False, metadata_filter=None)\uf0c1\nCreate a new ComparisonPrompt. This submits the prompt text to the LLM blueprints that\nare specified.\nParameters:\nllm_blueprints (list[LLMBlueprint or str]) \u2013 The LLM blueprints associated with the created comparison prompt.\nAccepts LLM blueprints or IDs.\ntext (str) \u2013 The prompt text.\ncomparison_chat (Optional[ComparisonChat or str], optional) \u2013 The comparison chat to add the comparison prompt to. Accepts ComparisonChat or\ncomparison chat ID.\nwait_for_completion (bool) \u2013 If set to True code will wait for the chat prompt job to complete before\nreturning the result (up to 10 minutes, raising timeout error after that).\nOtherwise, you can check current status by using ChatPrompt.get with returned ID.\nmetadata_filter (Optional[Dict[str, Any] | None]) \u2013 The metadata filter to apply to the vector database.\nSupports:\n- None or empty dict (no filters): Considers all documents\n- Multiple field filters (implicit AND): {\u201ca\u201d: 1, \u201cb\u201d: \u201cb\u201d}\n- Comparison operators: {\u201cfield\u201d: {\u201c$gt\u201d: 5}}\n- Logical operators: {\u201c$and\u201d: [\u2026], \u201c$or\u201d: [\u2026]}\n- Nested combinations of the above\nComparison operators:\n- $eq: equal to (string, int, float, bool)\n- $ne: not equal to (string, int, float, bool)\n- $gt: greater than (int, float)\n- $gte: greater than or equal to (int, float)\n- $lt: less than (int, float)\n- $lte: less than or equal to (int, float)\n- $in: a value is in list (string, int, float, bool)\n- $nin: a value is not in list (string, int, float, bool)\n- $contains: a string contains a value (string)\n- $not_contains: a string does not contain a value (string)\nReturns:\ncomparison_prompt \u2013 The created comparison prompt.\nReturn type:\nComparisonPrompt\nclassmethod get(comparison_prompt)\uf0c1\nRetrieve a single comparison prompt.\nParameters:\ncomparison_prompt (str) \u2013 The comparison prompt you want to retrieve. Accepts entity or ID.\nReturns:\ncomparison_prompt \u2013 The requested comparison prompt.\nReturn type:\nComparisonPrompt\nclassmethod list(llm_blueprints=None, comparison_chat=None)\uf0c1\nList all comparison prompts available to the user that include the specified LLM blueprints\nor from the specified comparison chat.\nParameters:\nllm_blueprints (Optional[List[Union[LLMBlueprint, str]]], optional) \u2013 The returned comparison prompts are only those associated with the specified LLM\nblueprints. Accepts either LLMBlueprint or LLM blueprint ID.\ncomparison_chat (Optional[Union[ComparisonChat, str]], optional) \u2013 The returned comparison prompts are only those associated with the specified comparison\nchat. Accepts either ComparisonChat or comparison chat ID.\nReturns:\ncomparison_prompts \u2013 A list of comparison prompts available to the user that use the specified LLM\nblueprints.\nReturn type:\nlist[ComparisonPrompt]\ndelete()\uf0c1\nDelete the single comparison prompt.\nReturn type:\nNone\nclass datarobot.models.genai.playground.Playground\uf0c1\nMetadata for a DataRobot GenAI playground.\nVariables:\nid (str) \u2013 Playground ID.\nname (str) \u2013 Playground name.\ndescription (str) \u2013 Description of the playground.\nuse_case_id (str) \u2013 Linked use case ID.\ncreation_date (str) \u2013 The date when the playground was created.\ncreation_user_id (str) \u2013 ID of the creating user.\nlast_update_date (str) \u2013 Date when the playground was most recently updated.\nlast_update_user_id (str) \u2013 ID of the user who most recently updated the playground.\nsaved_llm_blueprints_count (int) \u2013 Number of saved LLM blueprints in the playground.\nllm_blueprints_count (int) \u2013 Number of LLM blueprints in the playground.\nuser_name (str) \u2013 The name of the user who created the playground.\nplayground_type (Optional[PlaygroundType])\nclassmethod create(name, description='', use_case=None, copy_insights=None, playground_type=PlaygroundType.RAG)\uf0c1\nCreate a new playground.\nParameters:\nname (str) \u2013 Playground name.\ndescription (Optional[str]) \u2013 Description of the playground, by default \u201c\u201d.\nuse_case (Optional[Union[UseCase, str]], optional) \u2013 Use case to link to the created playground.\ncopy_insights (CopyInsightsRequest, optional) \u2013 If present, copies insights from the source playground to the created playground.\nReturns:\nplayground \u2013 The created playground.\nReturn type:\nPlayground\nclassmethod get(playground_id)\uf0c1\nRetrieve a single playground.\nParameters:\nplayground_id (str) \u2013 The ID of the playground you want to retrieve.\nReturns:\nplayground \u2013 The requested playground.\nReturn type:\nPlayground\nclassmethod list(use_case=None, search=None, sort=None)\uf0c1\nList all playgrounds available to the user. If the use_case is specified or can be\ninferred from the Context then the results are restricted to the playgrounds\nassociated with the UseCase.\nParameters:\nuse_case (Optional[UseCaseLike], optional) \u2013 The returned playgrounds are filtered to those associated with a specific Use Case\nor Cases if specified or can be inferred from the Context.\nAccepts either the entity or the ID.\nsearch (Optional[str]) \u2013 String for filtering playgrounds.\nPlaygrounds that contain the string in name will be returned.\nIf not specified, all playgrounds will be returned.\nsort (Optional[str]) \u2013 Property to sort playgrounds by.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. sort=\u2019-creationDate\u2019.\nCurrently supported options are listed in ListPlaygroundsSortQueryParams\nbut the values can differ with different platform versions.\nBy default, the sort parameter is None which will result in\nplaygrounds being returned in order of creation time descending.\nReturns:\nplaygrounds \u2013 A list of playgrounds available to the user.\nReturn type:\nlist[Playground]\nupdate(name=None, description=None)\uf0c1\nUpdate the playground.\nParameters:\nname (str) \u2013 The new name for the playground.\ndescription (str) \u2013 The new description for the playground.\nReturns:\nplayground \u2013 The updated playground.\nReturn type:\nPlayground\ndelete()\uf0c1\nDelete the playground.\nReturn type:\nNone\nclass datarobot.enums.PromptType\uf0c1\nSupported LLM blueprint prompting types.\nclass datarobot.models.genai.user_limits.UserLimits\uf0c1\nCounts for user limits for LLM APIs and vector databases.\nclassmethod get_vector_database_count()\uf0c1\nGet the count of vector databases for the user.\nReturn type:\nAPIObject\nclassmethod get_llm_requests_count()\uf0c1\nGet the count of LLMs requests made by the user.\nReturn type:\nAPIObject\nclass datarobot.models.genai.chat_prompt.ResultMetadata\uf0c1\nMetadata for the result of a chat prompt submission.\nVariables:\noutput_token_count (int) \u2013 The number of tokens in the output.\ninput_token_count (int) \u2013 The number of tokens in the input. This includes the chat history and documents\nretrieved from a vector database, if any.\ntotal_token_count (int) \u2013 The total number of tokens processed.\nestimated_docs_token_count (int) \u2013 The estimated number of tokens from the documents retrieved from a vector database, if any.\nlatency_milliseconds (int) \u2013 The latency of the chat prompt submission in milliseconds.\nfeedback_result (FeedbackResult) \u2013 The lists of user_ids providing positive and negative feedback.\nmetrics (MetricMetadata) \u2013 The evaluation metrics for this prompt.\nfinal_prompt (Optional[Union[str, dict]], optional) \u2013 Representation of the final prompt sent to the LLM.\nerror_message (str or None, optional) \u2013 The error message from the LLM response.\ncost (float or None, optional) \u2013 The cost of the chat prompt submission.\nclass datarobot.models.genai.prompt_trace.PromptTrace\uf0c1\nPrompt trace contains aggregated information about a prompt execution.\nVariables:\ntimestamp (str) \u2013 The timestamp of the trace (ISO 8601 formatted).\nuser (dict) \u2013 The user who submitted the prompt.\nchat_prompt_id (str) \u2013 The ID of the chat prompt associated with the trace.\nuse_case_id (str) \u2013 The ID of the Use Case the playground is in.\ncomparison_prompt_id (str) \u2013 The ID of the comparison prompts associated with the trace.\nllm_blueprint_id (str) \u2013 The ID of the LLM blueprint that the prompt was submitted to.\nllm_blueprint_name (str) \u2013 The name of the LLM blueprint.\nllm_name (str) \u2013 The name of the LLM in the LLM blueprint.\nllm_vendor (str) \u2013 The vendor name of the LLM.\nllm_license (str) \u2013 What type of license the LLM has.\nllm_settings (dict or None) \u2013 The LLM settings for the LLM blueprint. The specific keys allowed and the\nconstraints on the values are defined in the response from LLMDefinition.list,\nbut this typically has dict fields. Either:\n- system_prompt - The system prompt that influences the LLM responses.\n- max_completion_length - The maximum number of tokens in the completion.\n- temperature - Controls the variability in the LLM response.\n- top_p - Sets whether the model considers next tokens with top_p probability mass.\nor\n- system_prompt - The system prompt that influences the LLM responses.\n- validation_id - The ID of the external model LLM validation.\n- external_llm_context_size - The external LLM\u2019s context size, in tokens,\nfor external model-based LLM blueprints.\nchat_name (str or None) \u2013 The name of the chat associated with the Trace.\nchat_id (str or None) \u2013 The ID of the chat associated with the Trace.\nvector_database_id (str or None) \u2013 ID of the vector database associated with the LLM blueprint, if any.\nvector_database_settings (VectorDatabaseSettings or None) \u2013 The settings for the vector database associated with the LLM blueprint, if any.\nresult_metadata (ResultMetadata or None) \u2013 Metadata for the result of the prompt submission.\nresult_text (str or None) \u2013 The result text from the prompt submission.\nconfidence_scores (ConfidenceScores or None) \u2013 The confidence scores if there is a vector database associated with the prompt.\ntext (str) \u2013 The prompt text submitted to the LLM.\nexecution_status (str) \u2013 The execution status of the chat prompt.\nprompt_type (str or None) \u2013 The type of prompting strategy, for example history aware.\nevaluation_dataset_configuration_id (str or None) \u2013 The ID of the evaluation dataset configuration associated with the trace.\nwarning (str or None) \u2013 Any warnings associated with the trace.\nclassmethod list(playground)\uf0c1\nList all prompt traces for a playground.\nParameters:\nplayground (str) \u2013 The ID of the playground to list prompt traces for.\nReturns:\nprompt_traces \u2013 List of prompt traces for the playground.\nReturn type:\nlist[PromptTrace]\nclassmethod export_to_ai_catalog(playground)\uf0c1\nExport prompt traces to AI Catalog as a CSV.\nParameters:\nplayground (str) \u2013 The ID of the playground to export prompt traces for.\nReturns:\nstatus_url \u2013 The URL where the status of the job can be monitored\nReturn type:\nstr\nclass datarobot.models.genai.prompt_trace.TraceMetadata\uf0c1\nTrace metadata contains information about all the users and chats that are relevant to\nthis playground.\nVariables:\nusers (list[dict]) \u2013 The users who submitted the prompt.\nclassmethod get(playground)\uf0c1\nGet trace metadata for a playground.\nParameters:\nplayground (str) \u2013 The ID of the playground to get trace metadata for.\nReturns:\ntrace_metadata \u2013 The trace metadata for the playground.\nReturn type:\nTraceMetadata",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/api-object.html"
      ],
      "page_type": "documentation",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-testing.html",
      "title": "AI Robustness Tests\uf0c1",
      "description": "",
      "content": "AI Robustness Tests\uf0c1\nclass datarobot.models.genai.insights_configuration.InsightsConfiguration\uf0c1\nConfiguration information for a specific insight.\nVariables:\ninsight_name (str) \u2013 The name of the insight.\ninsight_type (InsightTypes, optional) \u2013 The type of the insight.\ndeployment_id (Optional[str]) \u2013 The deployment ID the insight is applied to.\nmodel_id (Optional[str]) \u2013 The model ID for the insight.\nsidecar_model_metric_validation_id (Optional[str]) \u2013 Validation ID for the sidecar model metric.\ncustom_metric_id (Optional[str]) \u2013 The ID for a custom model metric.\nevaluation_dataset_configuration_id (Optional[str]) \u2013 The ID for the evaluation dataset configuration.\ncost_configuration_id (Optional[str]) \u2013 The ID for the cost configuration information.\nresult_unit (Optional[str]) \u2013 The unit of the result, for example \u201cUSD\u201d.\nootb_metric_id (Optional[str]) \u2013 The ID of the Datarobot-provided metric that does not require additional configuration.\nootb_metric_name (Optional[str]) \u2013 The name of the Datarobot-provided metric that does not require additional configuration.\nguard_conditions (list[dict], optional) \u2013 The guard conditions to be used with the insight.\nmoderation_configuration (dict, optional) \u2013 The moderation configuration for the insight.\nexecution_status (Optional[str]) \u2013 The execution status of the insight.\nerror_message (Optional[str]) \u2013 The error message for the insight, for example if it is missing specific configuration\nfor deployed models.\nerror_resolution (Optional[str]) \u2013 An indicator of which field must be edited to resolve an error state.\nnemo_metric_id (Optional[str]) \u2013 The ID for the NEMO metric.\nllm_id (Optional[str]) \u2013 The LLM ID for OOTB metrics that use LLMs.\ncustom_model_llm_validation_id (Optional[str]) \u2013 The ID for the custom model LLM validation if using a custom model LLM for OOTB metrics.\naggregation_types (list[str], optional) \u2013 The aggregation types to be used for the insight.\nstage (Optional[str]) \u2013 The stage (prompt or response) when the metric is calculated.\nsidecar_model_metric_metadata (dict, optional) \u2013 Metadata specific to sidecar model metrics.\nguard_template_id (Optional[str]) \u2013 The ID for the guard template that applies to the insight.\nguard_configuration_id (Optional[str]) \u2013 The ID for the guard configuration that applies to the insight.\nmodel_package_registered_model_id (Optional[str]) \u2013 The ID of the registered model package associated with deploymentId.\ncustom_model_guard (Optional[CustomModelGuard]) \u2013 The custom model guard configuration, if applicable.\nextra_metric_settings (Optional[ExtraMetricSettings]) \u2013 Additional settings for the insight.\nclassmethod from_data(data)\uf0c1\nProperly convert composition classes.\nReturn type:\nInsightsConfiguration\nclass datarobot.models.genai.cost_metric_configurations.LLMCostConfiguration\uf0c1\nCost configuration for a specific LLM model; used for cost metric calculation.\nPrice-per-token is price/reference token count.\nVariables:\n(float) (output_token_price)\n(int) (reference_output_token_count)\n(float)\n(int)\n(str) (llm_id)\n(str)\n(Optional[str]) (custom_model_llm_validation_id)\nclass datarobot.models.genai.cost_metric_configurations.CostMetricConfiguration\uf0c1\nCost metric configuration for a use case.\nVariables:\n(str) (use_case_id)\n(str)\n(List[LLMCostConfiguration]) (cost_metric_configurations)\nclassmethod get(cost_metric_configuration_id)\uf0c1\nGet cost metric configuration by ID.\nReturn type:\nCostMetricConfiguration\nupdate(cost_metric_configurations, name=None)\uf0c1\nUpdate the cost configurations.\nReturn type:\nCostMetricConfiguration\nclassmethod create(use_case_id, playground_id, name, cost_metric_configurations)\uf0c1\nCreate a new cost metric configuration.\nReturn type:\nCostMetricConfiguration\ndelete()\uf0c1\nDelete the cost metric configuration.\nReturn type:\nNone\nclass datarobot.models.genai.evaluation_dataset_configuration.EvaluationDatasetConfiguration\uf0c1\nAn evaluation dataset configuration used to evaluate the performance of LLMs.\nVariables:\nid (str) \u2013 The evaluation dataset configuration ID.\nname (str) \u2013 The name of the evaluation dataset configuration.\nsize (int) \u2013 The size of the evaluation dataset (in bytes).\nrows_count (int) \u2013 The row count of the evaluation dataset.\nuse_case_id (str) \u2013 The ID of the Use Case associated with the evaluation dataset configuration.\nplayground_id (Optional[str]) \u2013 The ID of the playground associated with the evaluation dataset configuration.\ndataset_id (str) \u2013 The ID of the evaluation dataset.\ndataset_name (str) \u2013 The name of the evaluation dataset.\nprompt_column_name (str) \u2013 The name of the dataset column containing the prompt text.\nresponse_column_name (Optional[str]) \u2013 The name of the dataset column containing the response text.\ntool_calls_column_name (Optional[str]) \u2013 The name of the dataset column containing the expected tool calls.  It is required to evaluate\nthe tool call accuracy metric for agentic workflows.\nagent_goals_column_name (Optional[str]) \u2013 The name of the dataset column containing the expected agent goals. It is required to\nevaluate the agent goal accuracy with reference metrics for agentic workflows.\ncorrectness_enabled (Optional[bool]) \u2013 Whether correctness is enabled for the evaluation dataset configuration.\ncreation_user_id (str) \u2013 The ID of the user who created the evaluation dataset configuration.\ncreation_date (str) \u2013 The creation date of the evaluation dataset configuration (ISO-8601 formatted).\ntenant_id (str) \u2013 The ID of the DataRobot tenant this evaluation dataset configuration belongs to.\nexecution_status (str) \u2013 The execution status of the evaluation dataset configuration.\nerror_message (Optional[str]) \u2013 The error message associated with the evaluation dataset configuration.\nclassmethod get(id)\uf0c1\nGet an evaluation dataset configuration by ID.\nParameters:\nid (str) \u2013 The evaluation dataset configuration ID to fetch.\nReturns:\nevaluation_dataset_configuration \u2013 The evaluation dataset configuration.\nReturn type:\nEvaluationDatasetConfiguration\nclassmethod list(use_case_id, playground_id, evaluation_dataset_configuration_id=None, offset=0, limit=100, sort=None, search=None, correctness_only=False, completed_only=False)\uf0c1\nList all evaluation dataset configurations for a Use Case.\nParameters:\nuse_case_id (str) \u2013 The ID of the Use Case that evaluation datasets are returned for.\nplayground_id (str) \u2013 The ID of the playground that evaluation datasets are returned for. Default is None.\nevaluation_dataset_configuration_id (Optional[str]) \u2013 The ID of the evaluation dataset configuration to fetch. Default is None.\noffset (Optional[int]) \u2013 The offset to start fetching evaluation datasets from. Default is 0.\nlimit (Optional[int]) \u2013 The maximum number of evaluation datasets to return. Default is 100.\nsort (Optional[str]) \u2013 The order of return for evaluation datasets. Default is None, which returns sorting\nby creation time.\nsearch (Optional[str]) \u2013 A search term that filters results so that only evaluation datasets with names\nmatching the string are returned. Default is None.\ncorrectness_only (Optional[bool]) \u2013 Whether to return only completed datasets (particularly applicable to completion of generated\nsynthetic datasets). Default is False.\ncompleted_only (Optional[bool]) \u2013 Whether to return only completed datasets. Default is False.\nReturns:\nevaluation_dataset_configurations \u2013 A list of evaluation dataset configurations.\nReturn type:\nList[EvaluationDatasetConfiguration]\nclassmethod create(name, use_case_id, dataset_id, prompt_column_name, playground_id, is_synthetic_dataset=False, response_column_name=None, tool_calls_column_name=None, agent_goals_column_name=None)\uf0c1\nCreate an evaluation dataset configuration for an existing dataset.\nParameters:\nname (str) \u2013 The name of the evaluation dataset configuration.\nuse_case_id (str) \u2013 The Use Case ID that the evaluation dataset configuration will be added to.\ndataset_id (str) \u2013 An ID, to add to the configuration, that identifies the evaluation dataset.\nplayground_id (str) \u2013 The ID of the playground that the evaluation dataset configuration will be added to.\nDefault is None.\nprompt_column_name (str) \u2013 The name of the prompt column in the dataset.\nresponse_column_name (str) \u2013 The name of the response column in the dataset.\ntool_calls_column_name (Optional[str]) \u2013 The name of the dataset column containing the expected tool calls.  It is required to evaluate\nthe tool call accuracy metric for agentic workflows.\nagent_goals_column_name (Optional[str]) \u2013 The name of the dataset column containing the expected agent goals. It is required to\nevaluate the agent goal accuracy with reference metrics for agentic workflows.\nis_synthetic_dataset (bool) \u2013 Whether the evaluation dataset is synthetic.\nReturns:\nevaluation_dataset_configuration \u2013 The created evaluation dataset configuration.\nReturn type:\nEvaluationDatasetConfiguration\nupdate(name=None, dataset_id=None, prompt_column_name=None, response_column_name=None, tool_calls_column_name=None, agent_goals_column_name=None)\uf0c1\nUpdate the evaluation dataset configuration.\nParameters:\nname (Optional[str]) \u2013 The name of the evaluation dataset configuration.\ndataset_id (Optional[str]) \u2013 The ID of the dataset used in this configuration.\nprompt_column_name (Optional[str]) \u2013 The name of the prompt column in the dataset.\nresponse_column_name (Optional[str]) \u2013 The name of the response column in the dataset.\ntool_calls_column_name (Optional[str]) \u2013 The name of the dataset column containing the expected tool calls.  It is required to evaluate\nthe tool call accuracy metric for agentic workflows.\nagent_goals_column_name (Optional[str]) \u2013 The name of the dataset column containing the expected agent goals. It is required to\nevaluate the agent goal accuracy with reference metrics for agentic workflows.\nReturns:\nevaluation_dataset_configuration \u2013 The updated evaluation dataset configuration.\nReturn type:\nEvaluationDatasetConfiguration\ndelete()\uf0c1\nDelete the evaluation dataset configuration.\nReturn type:\nNone\nclass datarobot.models.genai.evaluation_dataset_metric_aggregation.EvaluationDatasetMetricAggregation\uf0c1\nInformation about an evaluation dataset metric aggregation job.This job runs a metric against LLMs using an evaluation dataset and aggregates the results.\nVariables:\nllm_blueprint_id (str) \u2013 The LLM blueprint ID.\nevaluation_dataset_configuration_id (str) \u2013 The evaluation dataset configuration ID.\nootb_dataset_name (str | None) \u2013 The name of the Datarobot-provided dataset that does not require additional configuration.\nmetric_name (str) \u2013 The name of the metric.\ndeployment_id (str | None) \u2013 A deployment ID if the evaluation was run against a deployment.\ndataset_id (str | None) \u2013 The ID of the dataset used in the evaluation.\ndataset_name (str | None) \u2013 The name of the dataset used in the evaluation.\nchat_id (str) \u2013 The ID of the chat created to run the evaluation.\nchat_name (str) \u2013 The name of the chat that was created to run the evaluation.\naggregation_value (float | List[Dict[str, float]]) \u2013 The aggregated metric result.\naggregation_type (AggregationType) \u2013 The type of aggregation used for the metric results.\ncreation_date (str) \u2013 The date the evaluation job was created.\ncreation_user_id (str) \u2013 The ID of the user who created the evaluation job.\ntenant_id (str) \u2013 The ID of the tenant that owns the evaluation job.\ncustom_model_guard_id (str | None) \u2013 The ID of the custom model\u2019s guard associated with the metric aggregation, if applicable.\nclassmethod create(chat_name, llm_blueprint_ids, evaluation_dataset_configuration_id, insights_configuration)\uf0c1\nCreate a new evaluation dataset metric aggregation job.  The job will run the\nspecified metric for the specified LLM blueprint IDs using the prompt-response pairs in\nthe evaluation dataset.\nParameters:\nchat_name (str) \u2013 The name of the chat that will be created to run the evaluation in.\nllm_blueprint_ids (List[str]) \u2013 The LLM blueprint IDs to evaluate.\nevaluation_dataset_configuration_id (str) \u2013 The ID evaluation dataset configuration to use during the evaluation.\ninsights_configuration (List[InsightsConfiguration]) \u2013 The insights configurations to use during the evaluation.\nReturns:\nThe ID of the evaluation dataset metric aggregation job.\nReturn type:\nstr\nclassmethod list(llm_blueprint_ids=None, chat_ids=None, evaluation_dataset_configuration_ids=None, metric_names=None, aggregation_types=None, current_configuration_only=False, sort=None, offset=0, limit=100, non_errored_only=True)\uf0c1\nList evaluation dataset metric aggregations.  The results will be filtered by the provided\nLLM blueprint IDs and chat IDs.\nParameters:\nllm_blueprint_ids (List[str]) \u2013 The LLM blueprint IDs to filter on.\nchat_ids (List[str]) \u2013 The chat IDs to filter on.\nevaluation_dataset_configuration_ids (List[str]) \u2013 The evaluation dataset configuration IDs to filter on.\nmetric_names (List[str]) \u2013 The metric names to filter on.\naggregation_types (List[str]) \u2013 The aggregation types to filter on.\ncurrent_configuration_only (Optional[bool]) \u2013 If True, only results that are associated with the current configuration of the LLM blueprint\nwill be returned.  Defaults to False.\nsort (Optional[str]) \u2013 The field to sort on.  Defaults to None.\noffset (Optional[int]) \u2013 The offset to start at.  Defaults to 0.\nlimit (Optional[int]) \u2013 The maximum number of results to return.  Defaults to 100.\nnon_errored_only (Optional[bool]) \u2013 If True, only results that did not encounter an error will be returned.  Defaults to True.\nReturns:\nA list of evaluation dataset metric aggregations.\nReturn type:\nList[EvaluationDatasetMetricAggregation]\nclassmethod delete(llm_blueprint_ids, chat_ids)\uf0c1\nDelete the associated evaluation dataset metric aggregations.  Either llm_blueprint_ids\nor chat_ids must be provided.  If both are provided, only results matching both will be removed.\nParameters:\nllm_blueprint_ids (List[str]) \u2013 The LLM blueprint IDs to filter on.\nchat_ids (List[str]) \u2013 The chat IDs to filter on.\nReturn type:\nNone\nclass datarobot.models.genai.synthetic_evaluation_dataset_generation.SyntheticEvaluationDataset\uf0c1\nA synthetically generated evaluation dataset for LLMs.\nVariables:\n(str) (response_column_name)\n(str)\n(str)\nclassmethod create(llm_id, vector_database_id, llm_settings=None, dataset_name=None, language=None)\uf0c1\nCreate a synthetic evaluation dataset generation job.  This will\ncreate a synthetic dataset to be used for evaluation of a language model.\nParameters:\n(str) (language)\n(Dict[Optional[str][Union[bool (llm_settings) \u2013 model used for dataset generation.\nint (The settings to use for the language) \u2013 model used for dataset generation.\nfloat (The settings to use for the language) \u2013 model used for dataset generation.\nstr]]]) (The settings to use for the language) \u2013 model used for dataset generation.\n(str)\n(str)\n(str)\nReturns:\nSyntheticEvaluationDataset\nReturn type:\nReference to the synthetic evaluation dataset that was created.\nclass datarobot.models.genai.sidecar_model_metric.SidecarModelMetricValidation\uf0c1\nA sidecar model metric validation for LLMs.\nVariables:\nid (str) \u2013 The ID of the sidecar model metric validation.\nprompt_column_name (str) \u2013 The name of the prompt column for the sidecar model.\ndeployment_id (str) \u2013 The ID of the deployment associated with the sidecar model.\nmodel_id (str) \u2013 The ID of the sidecar model.\nvalidation_status (str) \u2013 The status of the validation job.\ndeployment_access_data (dict) \u2013 The data that will be used for accessing the deployment prediction server.\nThis field is only available for deployments that pass validation.\nDict fields are as follows:\n- prediction_api_url - The URL for the deployment prediction server.\n- datarobot_key - The first of two auth headers for the prediction server.\n- authorization_header - The second of two auth headers for the prediction server.\n- input_type - The input type the model expects, either JSON or CSV.\n- model_type - The target type of the deployed custom model.\ntenant_id (str) \u2013 The ID of the tenant that created the sidecar model metric validation.\nname (str) \u2013 The name of the sidecar model metric.\ncreation_date (str) \u2013 The date the sidecar model metric validation was created.\nuser_id (str) \u2013 The ID of the user that created the sidecar model metric validation.\ndeployment_name (str) \u2013 The name of the deployment associated with the sidecar model.\nuser_name (str) \u2013 The name of the user that created the sidecar model metric validation.\nuse_case_id (str) \u2013 The ID of the Use Case associated with the sidecar model metric validation.\nprediction_timeout (int) \u2013 The timeout in seconds for the prediction API used in this sidecar model metric validation.\nerror_message (str) \u2013 Additional information for the errored validation.\ncitations_prefix_column_name (str) \u2013 The name of the prefix in the citations column for the sidecar model.\nresponse_column_name (str) \u2013 The name of the response column for the sidecar model.\nexpected_response_column_name (str) \u2013 The name of the expected response column for the sidecar model.\ntarget_column_name (str) \u2013 The name of the target column for the sidecar model.\nclassmethod create(deployment_id, name, prediction_timeout, model_id=None, use_case_id=None, playground_id=None, prompt_column_name=None, target_column_name=None, response_column_name=None, citation_prefix_column_name=None, expected_response_column_name=None)\uf0c1\nCreate a sidecar model metric validation.\nParameters:\ndeployment_id (str) \u2013 The ID of the deployment to validate.\nname (str) \u2013 The name of the validation.\nprediction_timeout (int) \u2013 The timeout in seconds for the prediction API used in this validation.\nmodel_id (Optional[str]) \u2013 The ID of the model to validate.\nuse_case_id (Optional[str]) \u2013 The ID of the Use Case associated with the validation.\nplayground_id (Optional[str]) \u2013 The ID of the playground associated with the validation.\nprompt_column_name (Optional[str]) \u2013 The name of the prompt column for the sidecar model.\ntarget_column_name (Optional[str]) \u2013 The name of the target column for the sidecar model.\nresponse_column_name (Optional[str]) \u2013 The name of the response column for the sidecar model.\ncitation_prefix_column_name (Optional[str]) \u2013 The name of the prefix for citations column for the sidecar model.\nexpected_response_column_name (Optional[str]) \u2013 The name of the expected response column for the sidecar model.\nReturns:\nThe created sidecar model metric validation.\nReturn type:\nSidecarModelMetricValidation\nclassmethod list(use_case_ids=None, offset=None, limit=None, search=None, sort=None, completed_only=True, deployment_id=None, model_id=None, prompt_column_name=None, target_column_name=None, citation_prefix_column_name=None)\uf0c1\nList sidecar model metric validations.\nParameters:\nuse_case_ids (List[str], optional) \u2013 The IDs of the use cases to filter by.\noffset (Optional[int]) \u2013 The number of records to skip.\nlimit (Optional[int]) \u2013 The maximum number of records to return.\nsearch (Optional[str]) \u2013 The search string.\nsort (Optional[str]) \u2013 The sort order.\ncompleted_only (Optional[bool]) \u2013 Whether to return only completed validations.\ndeployment_id (Optional[str]) \u2013 The ID of the deployment to filter by.\nmodel_id (Optional[str]) \u2013 The ID of the model to filter by.\nprompt_column_name (Optional[str]) \u2013 The name of the prompt column to filter by.\ntarget_column_name (Optional[str]) \u2013 The name of the target column to filter by.\ncitation_prefix_column_name (Optional[str]) \u2013 The name of the prefix for citations column to filter by.\nReturns:\nThe list of sidecar model metric validations.\nReturn type:\nList[SidecarModelMetricValidation]\nclassmethod get(validation_id)\uf0c1\nGet a sidecar model metric validation by ID.\nParameters:\nvalidation_id (str) \u2013 The ID of the validation to get.\nReturns:\nThe sidecar model metric validation.\nReturn type:\nSidecarModelMetricValidation\nrevalidate()\uf0c1\nRevalidate the sidecar model metric validation.\nReturns:\nThe sidecar model metric validation.\nReturn type:\nSidecarModelMetricValidation\nupdate(name=None, prompt_column_name=None, target_column_name=None, response_column_name=None, expected_response_column_name=None, citation_prefix_column_name=None, deployment_id=None, model_id=None, prediction_timeout=None)\uf0c1\nUpdate the sidecar model metric validation.\nParameters:\nname (Optional[str]) \u2013 The name of the validation.\nprompt_column_name (Optional[str]) \u2013 The name of the prompt column for the sidecar model.\ntarget_column_name (Optional[str]) \u2013 The name of the target column for the sidecar model.\nresponse_column_name (Optional[str]) \u2013 The name of the response column for the sidecar model.\nexpected_response_column_name (Optional[str]) \u2013 The name of the expected response column for the sidecar model.\ncitation_prefix_column_name (Optional[str]) \u2013 The name of the prefix for citations column for the sidecar model.\ndeployment_id (Optional[str]) \u2013 The ID of the deployment to validate.\nmodel_id (Optional[str]) \u2013 The ID of the model to validate.\nprediction_timeout (Optional[int]) \u2013 The timeout in seconds for the prediction API used in this validation.\nReturns:\nThe updated sidecar model metric validation.\nReturn type:\nSidecarModelMetricValidation\ndelete()\uf0c1\nDelete the sidecar model metric validation.\nReturn type:\nNone\nclass datarobot.models.genai.llm_test_configuration.LLMTestConfiguration\uf0c1\nMetadata for a DataRobot GenAI LLM test configuration.\nVariables:\nid (str) \u2013 The LLM test configuration ID.\nname (str) \u2013 The LLM test configuration name.\ndescription (str) \u2013 The LLM test configuration description.\ndataset_evaluations (list[DatasetEvaluation]) \u2013 The dataset/insight combinations that make up the LLM test configuration.\nllm_test_grading_criteria (LLMTestGradingCriteria) \u2013 The criteria used to grade the result of the LLM test configuration.\nis_out_of_the_box_test_configuration (bool) \u2013 Whether this is an out-of-the-box configuration.\nuse_case_id (Optional[str]) \u2013 The ID of the linked Use Case, if any.\ncreation_date (Optional[str]) \u2013 The date the LLM test configuration was created, if any.\ncreation_user_id (Optional[str]) \u2013 The ID of the creating user, if any.\nwarnings (Optional[list[Dict[str, str]]]) \u2013 The warnings for the LLM test configuration, if any.\nclassmethod create(name, dataset_evaluations, llm_test_grading_criteria, use_case=None, description=None)\uf0c1\nCreates a new LLM test configuration.\nParameters:\nname (str) \u2013 The LLM test configuration name.\ndataset_evaluations (list[DatasetEvaluationRequestDict]) \u2013 The LLM test dataset evaluation requests.\nllm_test_grading_criteria (LLMTestGradingCriteria) \u2013 The LLM test grading criteria.\nuse_case (Optional[Union[UseCase, str]], optional) \u2013 Use case to link to the created llm test configuration.\ndescription (Optional[str]) \u2013 The LLM test configuration description. If None, the default,\ndescription returns an empty string.\nReturns:\nllm_test_configuration \u2013 The created LLM test configuration.\nReturn type:\nLLMTestConfiguration\nclassmethod get(llm_test_configuration)\uf0c1\nRetrieve a single LLM Test configuration.\nParameters:\nllm_test_configuration (LLMTestConfiguration or str) \u2013 The LLM test configuration to retrieve, either LLMTestConfiguration or LLMTestConfiguration ID.\nReturns:\nllm_test_configuration \u2013 The requested LLM Test configuration.\nReturn type:\nLLMTestConfiguration\nclassmethod list(use_case=None, test_config_type=None)\uf0c1\nList all LLM test configurations available to the user. If a Use Case is specified,\nresults are restricted to only those configurations associated with that Use Case.\nParameters:\nuse_case (Optional[UseCaseLike], optional) \u2013 Returns only those configurations associated with a particular Use Case,\nspecified by either the Use Case name or ID.\ntest_config_type (Optional[LLMTestConfigurationType], optional) \u2013 Returns only configurations of the specified type. If not specified,\nthe custom test configurations are returned.\nReturns:\nllm_test_configurations \u2013 Returns a list of LLM test configurations.\nReturn type:\nlist[LLMTestConfiguration]\nupdate(name=None, description=None, dataset_evaluations=None, llm_test_grading_criteria=None)\uf0c1\nUpdate the LLM test configuration.\nParameters:\nname (Optional[str]) \u2013 The new LLM test configuration name.\ndescription (Optional[str]) \u2013 The new LLM test configuration description.\ndataset_evaluations (list[DatasetEvaluationRequestDict], optional) \u2013 The new dataset evaluation requests.\nllm_test_grading_criteria (LLMTestGradingCriteria, optional) \u2013 The new grading criteria.\nReturns:\nllm_test_configuration \u2013 The updated LLM test configuration.\nReturn type:\nLLMTestConfiguration\ndelete()\uf0c1\nDelete a single LLM test configuration.\nReturn type:\nNone\nclass datarobot.models.genai.llm_test_configuration.LLMTestConfigurationSupportedInsights\uf0c1\nMetadata for a DataRobot GenAI LLM test configuration supported insights.\nVariables:\nsupported_insight_configurations (list[InsightsConfiguration]) \u2013 The supported insights for LLM test configurations.\nclassmethod list(use_case=None, playground=None)\uf0c1\nList all supported insights for a LLM test configuration.\nParameters:\nuse_case (Optional[Union[UseCase, str]], optional) \u2013 Returns only those supported insight configurations\nassociated with a particular Use Case, specified by\neither the Use Case name or ID.\nplayground (Optional[Union[Playground, str]], optional) \u2013 Returns only those supported insight configurations\nassociated with a particular playground, specified by\neither the Playground or ID.\nReturns:\nllm_test_configuration_supported_insights \u2013 Returns the supported insight configurations for the\nLLM test configuration.\nReturn type:\nLLMTestConfigurationSupportedInsights\nclass datarobot.models.genai.llm_test_result.LLMTestResult\uf0c1\nMetadata for a DataRobot GenAI LLM test result.\nVariables:\nid (str) \u2013 The LLM test result ID.\nllm_test_configuration_id (str) \u2013 The LLM test configuration ID associated with this LLM test result.\nllm_test_configuration_name (str) \u2013 The LLM test configuration name associated with this LLM test result.\nuse_case_id (str) \u2013 The ID of the Use Case associated with this LLM test result.\nllm_blueprint_id (str) \u2013 The ID of the LLM blueprint for this LLM test result.\nllm_test_grading_criteria (LLMTestGradingCriteria) \u2013 The criteria used to grade the result of the LLM test configuration.\ngrading_result (GradingResult) \u2013 The overall grading result for the LLM test.\npass_percentage (float) \u2013 The percentage of insight evaluation results that passed the grading criteria.\nexecution_status (str) \u2013 The execution status of the job that evaluated the LLM test result.\ninsight_evaluation_result (list[InsightEvaluationResult]) \u2013 The results for the individual insights that make up the LLM test result.\ncreation_date (str) \u2013 The date of the LLM test result.\ncreation_user_id (str) \u2013 The ID of the user who executed the LLM test.\ncreation_user_name (str) \u2013 The name of the user who executed the LLM test.\nclassmethod create(llm_test_configuration, llm_blueprint)\uf0c1\nCreate a new LLMTestResult. This executes the LLM test configuration using the\nspecified LLM blueprint. To check the status of the LLM test, use the\nLLMTestResult.get method with the returned ID.\nParameters:\nllm_test_configuration (LLMTestConfiguration or str) \u2013 The LLM test configuration to execute, either LLMTestConfiguration or\nthe LLM test configuration ID.\nllm_blueprint (LLMBlueprint or str) \u2013 The LLM blueprint to test, either LLMBlueprint or\nthe LLM blueprint ID.\nReturns:\nllm_test_result \u2013 The created LLM test result.\nReturn type:\nLLMTestResult\nclassmethod get(llm_test_result)\uf0c1\nRetrieve a single LLM test result.\nParameters:\nllm_test_result (LLMTestResult or str) \u2013 The LLM test result to retrieve, specified by either LLM test result or test ID.\nReturns:\nllm_test_result \u2013 The requested LLM test result.\nReturn type:\nLLMTestResult\nclassmethod list(llm_test_configuration=None, llm_blueprint=None)\uf0c1\nList all LLM test results available to the user. If the LLM test configuration or LLM\nblueprint is specified, results are restricted to only those LLM test results associated\nwith the LLM test configuration or LLM blueprint.\nParameters:\nllm_test_configuration (Optional[Union[LLMTestConfiguration, str]]) \u2013 The returned LLM test results are filtered to those associated with a specific\nLLM test configuration, if specified.\nllm_blueprint (Optional[Union[LLMBlueprint, str]]) \u2013 The returned LLM test results, filtered by those associated with a specific\nLLM blueprint, if specified.\nReturns:\nllm_test_results \u2013 Returns a list of LLM test results.\nReturn type:\nList[LLMTestResult]\ndelete()\uf0c1\nDelete a single LLM test result.\nReturn type:\nNone\nclass datarobot.models.genai.llm_test_configuration.DatasetEvaluation\uf0c1\nMetadata for a DataRobot GenAI dataset evaluation.\nVariables:\nevaluation_name (str) \u2013 The name of the evaluation.\nevaluation_dataset_configuration_id (str or None, optional) \u2013 The ID of the evaluation dataset configuration for custom datasets.\nevaluation_dataset_name (str) \u2013 The name of the evaluation dataset.\nootb_dataset (OOTBDataset or None, optional) \u2013 Out-of-the-box dataset.\ninsight_configuration (InsightsConfiguration) \u2013 The insight to calculate for this dataset.\ninsight_grading_criteria (InsightGradingCriteria) \u2013 The criteria to use for grading the results.\nmax_num_prompts (int) \u2013 The maximum number of prompts to use for the evaluation.\nprompt_sampling_strategy (PromptSamplingStrategy) \u2013 The prompt sampling strategy for the dataset evaluation.\nclass datarobot.models.genai.llm_test_result.InsightEvaluationResult\uf0c1\nMetadata for a DataRobot GenAI insight evaluation result.\nVariables:\nid (str) \u2013 The ID of the insight evaluation result.\nllm_test_result_id (str) \u2013 The ID of the LLM test result associated with this insight evaluation result.\nevaluation_dataset_configuration_id (str) \u2013 The ID of the evaluation dataset configuration.\nevaluation_dataset_name (str) \u2013 The name of the evaluation dataset.\nmetric_name (str) \u2013 The name of the metric.\nchat_id (str) \u2013 The ID of the chat containing the prompts and responses.\nchat_name (str) \u2013 The name of the chat containing the prompts and responses.\naggregation_type (AggregationType) \u2013 The type of aggregation used for the metric results.\ngrading_result (GradingResult) \u2013 The overall grade for the LLM test.\nexecution_status (str) \u2013 The execution status of the LLM test.\nevaluation_name (str) \u2013 The name of the evaluation.\ninsight_grading_criteria (InsightGradingCriteria) \u2013 The criteria to grade the results.\nlast_update_date (str) \u2013 The date the result was most recently updated.\naggregation_value (float | List[Dict[str, float]] | None) \u2013 The aggregated metric result.\nclass datarobot.models.genai.llm_test_configuration.OOTBDatasetDict\uf0c1\nclass datarobot.models.genai.llm_test_configuration.DatasetEvaluationRequestDict\uf0c1\nclass datarobot.models.genai.llm_test_configuration.DatasetEvaluationDict\uf0c1\nclass datarobot.models.genai.nemo_configuration.NemoConfiguration\uf0c1\nConfiguration for the Nemo Pipeline.\nVariables:\nprompt_pipeline_metric_name (Optional[str]) \u2013 The name of the metric for the prompt pipeline.\nprompt_pipeline_files (NemoFileContentsResponse, optional) \u2013 The files used in the prompt pipeline.\nprompt_llm_configuration (NemoLLMConfiguration, optional) \u2013 The LLM configuration for the prompt pipeline.\nprompt_moderation_configuration (ModerationConfigurationWithoutID, optional) \u2013 The moderation configuration for the prompt pipeline.\nprompt_pipeline_template_id (Optional[str]) \u2013 The ID of the prompt pipeline template. This parameter defines the actions.py file.\nresponse_pipeline_metric_name (Optional[str]) \u2013 The name of the metric for the response pipeline.\nresponse_pipeline_files (NemoFileContentsResponse, optional) \u2013 The files used in the response pipeline.\nresponse_llm_configuration (NemoLLMConfiguration, optional) \u2013 The LLM configuration for the response pipeline.\nresponse_moderation_configuration (ModerationConfigurationWithoutID, optional) \u2013 The moderation configuration for the response pipeline.\nresponse_pipeline_template_id (Optional[str]) \u2013 The ID of the response pipeline template. This parameter defines the actions.py file.\nblocked_terms_file_contents (str) \u2013 The contents of the blocked terms file.  This is shared between the prompt and response pipelines.\nclassmethod get(playground)\uf0c1\nGet the Nemo configuration for a playground.\nParameters:\nplayground (str or Playground) \u2013 The playground to get the configuration for\nReturns:\nThe Nemo configuration for the playground.\nReturn type:\nNemoConfiguration\nclassmethod upsert(playground, blocked_terms_file_contents, prompt_pipeline_metric_name=None, prompt_pipeline_files=None, prompt_llm_configuration=None, prompt_moderation_configuration=None, prompt_pipeline_template_id=None, response_pipeline_metric_name=None, response_pipeline_files=None, response_llm_configuration=None, response_moderation_configuration=None, response_pipeline_template_id=None)\uf0c1\nCreate or update the nemo configuration for a playground.\nParameters:\nplayground (str or Playground) \u2013 The playground for the configuration\nblocked_terms_file_contents (str) \u2013 The contents of the blocked terms file.\nprompt_pipeline_metric_name (Optional[str]) \u2013 The name of the metric for the prompt pipeline.\nprompt_pipeline_files (NemoFileContents, optional) \u2013 The files used in the prompt pipeline.\nprompt_llm_configuration (NemoLLMConfiguration, optional) \u2013 The LLM configuration for the prompt pipeline.\nprompt_moderation_configuration (ModerationConfigurationWithoutID, optional) \u2013 The moderation configuration for the prompt pipeline.\nprompt_pipeline_template_id (Optional[str]) \u2013 The ID of the prompt pipeline template, this will define the action.py file.\nresponse_pipeline_metric_name (Optional[str]) \u2013 The name of the metric for the response pipeline.\nresponse_pipeline_files (NemoFileContents, optional) \u2013 The files used in the response pipeline.\nresponse_llm_configuration (NemoLLMConfiguration, optional) \u2013 The LLM configuration for the response pipeline.\nresponse_moderation_configuration (ModerationConfigurationWithoutID, optional) \u2013 The moderation configuration for the response pipeline.\nresponse_pipeline_template_id (Optional[str]) \u2013 The ID of the response pipeline template, this will define the action.py file.\nReturns:\nThe Nemo configuration for the playground.\nReturn type:\nNemoConfiguration\nclass datarobot.models.genai.llm_test_configuration.OOTBDataset\uf0c1\nMetadata for a DataRobot GenAI out-of-the-box LLM compliance test dataset.\nVariables:\ndataset_name (str) \u2013 The name of the dataset.\nprompt_column_name (str) \u2013 The name of the prompt column.\nresponse_column_name (str or None, optional) \u2013 The name of the response column, if any.\ndataset_url (str or None, optional) \u2013 The URL of the dataset.\nrows_count (int) \u2013 The number of rows in the dataset.\nwarning (str or None, optional) \u2013 A warning message regarding the contents of the dataset, if any.\nclassmethod list()\uf0c1\nList all out-of-the-box datasets available to the user.\nReturns:\nootb_datasets \u2013 Returns a list of out-of-the-box datasets.\nReturn type:\nlist[OOTBDataset]\nclass datarobot.models.genai.llm_test_configuration.NonOOTBDataset\uf0c1\nMetadata for a DataRobot GenAI non out-of-the-box (OOTB) LLM compliance test dataset.\nclassmethod list(use_case=None)\uf0c1\nList all non out-of-the-box datasets available to the user.\nReturns:\nnon_ootb_datasets \u2013 Returns a list of non out-of-the-box datasets.\nReturn type:\nlist[NonOOTBDataset]\nclass datarobot.models.genai.metric_insights.MetricInsights\uf0c1\nMetric insights for playground.\nclassmethod list(playground, llm_blueprint_ids=None)\uf0c1\nGet metric insights for playground.\nParameters:\nplayground (str or Playground) \u2013 Playground to get the supported metrics from.\nllm_blueprint_ids (Optional[Sequence[str]]) \u2013 LLM Blueprint IDs to check for additional metrics support for.\nReturns:\ninsights \u2013 Metric insights for playground.\nReturn type:\nlist[InsightsConfiguration]\nclassmethod copy_to_playground(source_playground, target_playground, add_to_existing=True, with_evaluation_datasets=False)\uf0c1\nCopy metric insights from one playground to another.\nParameters:\nsource_playground (str or Playground) \u2013 Playground to copy metric insights from.\ntarget_playground (str or Playground) \u2013 Playground to copy metric insights to.\nadd_to_existing (Optional[bool]) \u2013 Add metric insights to existing ones in the target playground, by default True.\nwith_evaluation_datasets (Optional[bool]) \u2013 Copy evaluation datasets from the source playground.\nReturn type:\nNone\nclass datarobot.models.genai.ootb_metric_configuration.PlaygroundOOTBMetricConfiguration\uf0c1\nOOTB metric configurations for a playground.\nVariables:\nootb_metric_configurations ((List[OOTBMetricConfigurationResponse]): The list of the OOTB metric configurations.)\nclassmethod get(playground_id)\uf0c1\nGet OOTB metric configurations for the playground.\nReturn type:\nPlaygroundOOTBMetricConfiguration\nclassmethod create(playground_id, ootb_metric_configurations)\uf0c1\nCreate a new OOTB metric configurations.\nReturn type:\nPlaygroundOOTBMetricConfiguration\nclass datarobot.models.genai.evaluation_dataset_utils.ReferenceToolCall\uf0c1\nReference tool call for an evaluation dataset.  This is a convenience stand in\nfor the Ragas ToolCall class.\njson()\uf0c1\nConvert the tool call to a JSON string.\nReturn type:\nstr\nclassmethod from_json(json_str)\uf0c1\nCreate a ReferenceToolCall object from a JSON string.\nReturn type:\nReferenceToolCall\nclass datarobot.models.genai.evaluation_dataset_utils.ReferenceToolCalls\uf0c1\nUtility for creating a list of reference tool calls for an evaluation dataset. This\nclass represents a list of tool calls for a single row in the evaluation dataset.\nExample usage:\n>>> df = pandas.DataFrame()\n>>> tool_calls_1 = ReferenceToolCalls([\n>>>     ReferenceToolCall(name=\u201dget_weather\u201d, args={\u201clocation\u201d: \u201cNew York\u201d}),\n>>>     ReferenceToolCall(name=\u201dget_news\u201d, args={\u201ctopic\u201d: \u201ctechnology\u201d})\n>>> ])\n>>> tool_calls_2 = ReferenceToolCalls([\n>>>     ReferenceToolCall(name=\u201dget_weather\u201d, args={\u201clocation\u201d: \u201cLos Angeles\u201d}),\n>>>     ReferenceToolCall(name=\u201dget_news\u201d, args={\u201ctopic\u201d: \u201csports\u201d})\n>>> ])\n>>> df[\u2018prompts\u2019] = [\u2018what is the weather for the tech conference in NYC?\u2019,\n>>> \u2018what is the weather in LA?, and will it affect the game?\u2019]\n>>> df[\u2018reference_tool_calls\u2019] = [tool_calls_1.json(), tool_calls_2.json()]\nclassmethod from_json(json_str)\uf0c1\nCreate a ReferenceToolCalls object from a JSON string.\nReturn type:\nReferenceToolCalls",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "Optional[CustomModelGuard]",
        "SidecarModelMetricValidation",
        "List[SidecarModelMetricValidation]",
        "SidecarModelMetricValidation",
        "SidecarModelMetricValidation",
        "SidecarModelMetricValidation"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/gen-vector-databases.html",
      "title": "Vector Databases\uf0c1",
      "description": "Validation record checking the ability of the deployment to serve as a vector database.",
      "content": "Vector Databases\uf0c1\nclass datarobot.models.genai.vector_database.CustomModelVectorDatabaseValidation\uf0c1\nValidation record checking the ability of the deployment to serve as a vector database.\nVariables:\nid (str) \u2013 The ID of the validation.\nprompt_column_name (str) \u2013 The column name the deployed model expect as the input.\ntarget_column_name (str) \u2013 The target name deployed model will output.\ndeployment_id (str) \u2013 ID of the deployment.\nmodel_id (str) \u2013 ID of the underlying deployment model.\nCan be found from the API as Deployment.model[\u201cid\u201d].\nvalidation_status (str) \u2013 Can be TESTING, FAILED and PASSED. Only PASSED allowed for use.\ndeployment_access_data (dict, optional) \u2013 The data that will be used for accessing the deployment prediction server.\nThis field is only available for deployments that pass validation.\nDict fields are as follows:\n- prediction_api_url - The URL for the deployment prediction server.\n- datarobot_key - The first of two auth headers for the prediction server.\n- authorization_header - The second of two auth headers for the prediction server.\n- input_type - The input type the model expects, either JSON or CSV.\n- model_type - The target type of the deployed custom model.\ntenant_id (str) \u2013 The creating user\u2019s tenant ID.\nname (str) \u2013 The display name of the validated custom model.\ncreation_date (str) \u2013 The creation date of the validation (ISO 8601 formatted).\nuser_id (str) \u2013 The ID of the creating user.\nerror_message (Optional[str]) \u2013 Additional information for the errored validation.\ndeployment_name (Optional[str]) \u2013 The name of the validated deployment.\nuser_name (Optional[str]) \u2013 The name of the creating user.\nuse_case_id (Optional[str]) \u2013 The ID of the Use Case associated with the validation.\nclass datarobot.models.genai.vector_database.SupportedEmbeddings\uf0c1\nAll supported embedding models including the recommended default model.\nVariables:\nembedding_models (list[EmbeddingModel]) \u2013 All supported embedding models.\ndefault_embedding_model (str) \u2013 Name of the default recommended text embedding model.\nCurrently supported options are listed in VectorDatabaseEmbeddingModel\nbut the values can differ with different platform versions.\ncustom_model_embedding_validations (List[str]) \u2013 External embedding models that have been validated\nclass datarobot.models.genai.vector_database.SupportedTextChunkings\uf0c1\nSupported text chunking configurations which includes a set of\nrecommended chunking parameters for each supported embedding model.\nVariables:\ntext_chunking_configs \u2013 All supported text chunking configurations.\nclass datarobot.models.genai.vector_database.VectorDatabase\uf0c1\nMetadata for a DataRobot vector database accessible to the user.\nVariables:\nid (str) \u2013 Vector database ID.\nname (str) \u2013 Vector database name.\nsize (int) \u2013 Size of the vector database assets in bytes.\nuse_case_id (str) \u2013 Linked use case ID.\ndataset_id (str) \u2013 ID of the dataset used for creation.\nembedding_model (str) \u2013 Name of the text embedding model.\nCurrently supported options are listed in VectorDatabaseEmbeddingModel\nbut the values can differ with different platform versions.\nchunking_method (str or None) \u2013 Name of the method to split dataset documents.\nCurrently supported options are listed in VectorDatabaseChunkingMethod\nbut the values can differ with different platform versions.\nchunk_size (int or None) \u2013 Size of each text chunk in number of tokens.\nchunk_overlap_percentage (int or None) \u2013 Overlap percentage between chunks.\nchunks_count (int) \u2013 Total number of text chunks.\ncustom_chunking (bool) \u2013 Determines if the chunking is custom. With custom chunking,\ndataset rows are not split into chunks automatically;\ninstead, the user provides the chunks.\nseparators (list[string] or None) \u2013 Separators for document splitting.\ncreation_date (str) \u2013 Date when the database was created.\ncreation_user_id (str) \u2013 The ID of the creating user.\norganization_id (str) \u2013 The creating user\u2019s organization ID.\ntenant_id (str) \u2013 The creating user\u2019s tenant ID.\nlast_update_date (str) \u2013 Last update date for the database.\nexecution_status (str) \u2013 Database execution status.\nCurrently supported options are listed in VectorDatabaseExecutionStatus\nbut the values can differ with different platform versions.\nplaygrounds_count (int) \u2013 Number of using playgrounds.\ndataset_name (str) \u2013 Name of the used dataset.\nuser_name (str) \u2013 Name of the creating user.\nsource (str) \u2013 Source of the vector database.\nCurrently supported options are listed in VectorDatabaseSource\nbut the values can differ with different platform versions.\nvalidation_id (Optional[str]) \u2013 ID of custom model vector database validation.\nOnly filled for external vector databases.\nerror_message (Optional[str]) \u2013 Additional information for errored vector database.\nembedding_validation_id (Optional[str]) \u2013 ID of the custom embedding validation, if any.\nis_separator_regex (bool) \u2013 Whether the separators should be treated as regular expressions.\nexternal_vector_database_connection (Optional[dict]) \u2013 Parameters defining the external vector database connection to use.\nmetadata_dataset_id (Optional[str]) \u2013 The ID of the dataset used to add additional metadata to the vector database.\nmetadata_dataset_name (Optional[str]) \u2013 The name of the dataset used to add additional metadata to the vector database.\nmetadata_combination_strategy (Optional[VectorDatabaseMetadataCombinationStrategy]) \u2013 The strategy used to combine metadata when there is duplication between the dataset and\nthe metadata dataset.\nadded_metadata_dataset_pairs (Optional[List[Dict[str, str]]) \u2013 Pairs of dataset_id and metadata_dataset_id that have been added to the vector database.\nclassmethod get_supported_embeddings(dataset_id=None, use_case=None)\uf0c1\nGet all supported and the recommended embedding models.\nParameters:\ndataset_id (Optional[str]) \u2013 ID of a dataset for which the recommended model is returned\nbased on the detected language of that dataset.\nuse_case (Optional[UseCase, str]) \u2013 May be Use Case ID or the Use Case entity.\nReturns:\nsupported_embeddings \u2013 The supported embedding models.\nReturn type:\nSupportedEmbeddings\nsubmit_export_dataset_job()\uf0c1\nSubmit the vector database dataset export job.\nReturns:\nresult \u2013 The result of the vector database dataset export job containing the exported dataset id.\nReturn type:\nVectorDatabaseDatasetExportJob\nclassmethod get_supported_retrieval_settings()\uf0c1\nGet supported retrieval settings.\nReturns:\nsupported_retrieval_settings \u2013 The supported retriever settings.\nReturn type:\nSupportedRetrievalSettings\nclassmethod create(dataset_id, chunking_parameters=None, use_case=None, name=None, parent_vector_database_id=None, update_llm_blueprints=None, update_deployments=None, external_vector_database_connection=None, metadata_dataset_id=None, metadata_combination_strategy=None)\uf0c1\nCreate a new vector database.\nParameters:\ndataset_id (str) \u2013 ID of the dataset used for creation.\nchunking_parameters (ChunkingParameters) \u2013 Parameters defining how documents are split and embedded.\nuse_case (Optional[Union[UseCase, str]], optional) \u2013 Use case to link to the created vector database.\nname (Optional[str]) \u2013 Vector database name, by default None\nwhich leads to the default name \u2018Vector Database for <dataset name>\u2019.\nparent_vector_database_id (Optional[str]) \u2013 ID of the parent vector database to base the update on.\nupdate_llm_blueprints (Optional[bool]) \u2013 Whether to update LLM blueprints related to the parent vector database.\nupdate_deployments (Optional[bool]) \u2013 Whether to update deployments related to the parent vector database.\nexternal_vector_database_connection (Optional[dict]) \u2013 Parameters defining the external vector database connection to use.\nmetadata_dataset_id (Optional[str]) \u2013 The ID of the dataset used to provide additional metadata.\nmetadata_combination_strategy (Optional[VectorDatabaseMetadataCombinationStrategy]) \u2013 Strategy used to combine the metadata columns if there are duplicates between the\ndataset and the metadata dataset.\nReturns:\nvector database \u2013 The created vector database with execution status \u2018new\u2019.\nReturn type:\nVectorDatabase\nclassmethod create_from_custom_model(name, use_case=None, validation_id=None, prompt_column_name=None, target_column_name=None, deployment_id=None, model_id=None)\uf0c1\nCreate a new vector database from validated custom model deployment.\nParameters:\nname (str) \u2013 Vector database name.\nuse_case (Optional[Union[UseCase, str]], optional) \u2013 Use case to link to the created vector database.\nvalidation_id (Optional[str]) \u2013 ID of CustomModelVectorDatabaseValidation for the deployment.\nAlternatively, you can specify ALL the following fields.\nprompt_column_name (Optional[str]) \u2013 The column name the deployed model expect as the input.\ntarget_column_name (Optional[str]) \u2013 The target name deployed model will output.\ndeployment_id (Optional[str]) \u2013 ID of the deployment.\nmodel_id (Optional[str]) \u2013 ID of the underlying deployment model.\nCan be found from the API as Deployment.model[\u201cid\u201d].\nReturns:\nvector database \u2013 The created vector database.\nReturn type:\nVectorDatabase\nclassmethod get(vector_database_id)\uf0c1\nRetrieve a single vector database.\nParameters:\nvector_database_id (str) \u2013 The ID of the vector database you want to retrieve.\nReturns:\nvector database \u2013 The requested vector database.\nReturn type:\nVectorDatabase\nclassmethod list(use_case=None, playground=None, search=None, sort=None, completed_only=None)\uf0c1\nList all vector databases associated with a specific use case available to the user.\nParameters:\nuse_case (Optional[UseCaseLike], optional) \u2013 The returned vector databases are filtered to those associated with a specific Use Case\nor Cases if specified or can be inferred from the Context.\nAccepts either the entity or the ID.\nplayground (Optional[Union[Playground, str]], optional) \u2013 The returned vector databases are filtered to those associated with a specific playground\nif it is specified. Accepts either the entity or the ID.\nsearch (Optional[str]) \u2013 String for filtering vector databases.\nVector databases that contain the string in name will be returned.\nIf not specified, all vector databases will be returned.\nsort (Optional[str]) \u2013 Property to sort vector databases by.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. sort=\u2019-creationDate\u2019.\nCurrently supported options are listed in ListVectorDatabasesSortQueryParams\nbut the values can differ with different platform versions.\nBy default, the sort parameter is None which will result in\nvector databases being returned in order of creation time descending.\ncompleted_only (Optional[bool]) \u2013 A filter to retrieve only vector databases that have been successfully created.\nBy default, all vector databases regardless of execution status are retrieved.\nReturns:\nvectorbases \u2013 A list of vector databases available to the user.\nReturn type:\nlist[VectorDatabase]\nupdate(name=None, credential_id=None)\uf0c1\nUpdate the vector database.\nParameters:\nname (Optional[str]) \u2013 The new name for the vector database.\ncredential_id (Optional[str]) \u2013 The new credential id to access the connected vector database.\nReturns:\nvector database \u2013 The updated vector database.\nReturn type:\nVectorDatabase\nupdate_connected(dataset_id, metadata_dataset_id=None, metadata_combination_strategy=None)\uf0c1\nUpdate a connected vector database.\nParameters:\ndataset_id (str) \u2013 The ID of the dataset to add to the vector database.\nmetadata_dataset_id (Optional[str]) \u2013 The ID of the dataset used to provide additional metadata.\nmetadata_combination_strategy (Optional[VectorDatabaseMetadataCombinationStrategy]) \u2013 The strategy used to combine the metadata columns if there are duplicates between the\ndataset and the metadata dataset.\nReturns:\nvector database \u2013 The updated vector database.\nReturn type:\nVectorDatabase\ndelete()\uf0c1\nDelete the vector database.\nReturn type:\nNone\nclassmethod get_supported_text_chunkings()\uf0c1\nGet all supported text chunking configurations which includes\na set of recommended chunking parameters for each supported embedding model.\nReturns:\nsupported_text_chunkings \u2013 The supported text chunking configurations.\nReturn type:\nSupportedTextChunkings\ndownload_text_and_embeddings_asset(file_path=None, part=None)\uf0c1\nDownload a parquet file with text chunks and corresponding embeddings created\nby a vector database.\nParameters:\nfile_path (Optional[str]) \u2013 File path to save the asset. By default, it saves in the current directory\nautogenerated by server name.\npart (Optional[int]) \u2013 Part of the text chunks to download. Connected vector databases have a\npart for each dataset that is added.\nReturn type:\nNone\nsend_to_custom_model_workshop(maximum_memory=None, resource_bundle_id=None, replicas=None, network_egress_policy=None)\uf0c1\nCreate a new CustomModelVersion for this vector database.\nParameters:\nmaximum_memory (Optional[int]) \u2013 The maximum memory that will be allocated to this custom model.\nresource_bundle_id (Optional[str]) \u2013 The ID of a datarobot.models.resource_bundle.ResourceBundle that will be used by this\ncustom model.\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed for this custom model.\nnetwork_egress_policy (Optional[str]) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE,\ndatarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nReturn type:\nCustomModelVersion\ndeploy(default_prediction_server_id=None, prediction_environment_id=None, credential_id=None, maximum_memory=None, resource_bundle_id=None, replicas=None, network_egress_policy=None)\uf0c1\nCreate a new Custom Model for this vector database and deploy it on a new Deployment.\nParameters:\ndefault_prediction_server_id (Optional[str]) \u2013 An identifier of a prediction server to be used as the default prediction server.\nWhen working with prediction environments, the default prediction server ID should not\nbe provided.\nprediction_environment_id (Optional[str]) \u2013 An identifier of a prediction environment to be used for model deployment.\ncredential_id (Optional[str]:) \u2013 The ID of credentials to access a connected vector database. This is only needed for vector\ndatabases with an external source when the user does not have access to the credentials\nassociated with this vector database.\nmaximum_memory (Optional[int]) \u2013 The maximum memory that will be allocated to the new custom model.\nresource_bundle_id (Optional[str]) \u2013 The ID of a datarobot.models.resource_bundle.ResourceBundle that will be used by the new\ncustom model.\nreplicas (Optional[int]) \u2013 A fixed number of replicas that will be deployed for this custom model.\nnetwork_egress_policy (Optional[str]) \u2013 Determines whether the given custom model is isolated, or can access the public network.\nValues: [datarobot.NETWORK_EGRESS_POLICY.NONE,\ndatarobot.NETWORK_EGRESS_POLICY.PUBLIC].\nReturn type:\nDeployment\nclass datarobot.models.genai.vector_database.SupportedRetrievalSetting\uf0c1\nA single supported retrieval setting.\nVariables:\nname (str) \u2013 The name of the setting.\ntype (str or list[str]) \u2013 The type of the setting.\ndescription (str) \u2013 The description of the setting.\ntitle (str) \u2013 The title of the setting.\ndefault (str, int, bool, or None) \u2013 The default value of the setting.\nminimum (int or None) \u2013 The minimum value of the setting.\nmaximum (int or None) \u2013 The maximum value of the setting.\nenum (list[str] or None) \u2013 The enum values of the setting.\nsettings (list[SupportedRetrievalSetting] or None) \u2013 The supported retriever settings.\ngroup_id (str or None) \u2013 The group ID of the setting.\nclass datarobot.models.genai.vector_database.VectorDatabaseDatasetExportJob\uf0c1\nResponse for the vector database dataset export job.\nVariables:\njob_id (str) \u2013 ID of the export job.\nvector_database_id (str) \u2013 ID of the vector database.\nexport_dataset_id (str) \u2013 ID of the exported dataset.\nclass datarobot.models.genai.chat_prompt.Citation\uf0c1\nCitation for documents retrieved from a vector database.\nVariables:\ntext (str) \u2013 The text retrieved from a vector database.\nsource (str or None, optional) \u2013 The source of the retrieved text.\nsimilarity_score \u2013 The similarity score between the citation and the user prompt.\nmetadata (dict or None, optional) \u2013 Additional metadata for the citation.\nclass datarobot.models.genai.llm_blueprint.VectorDatabaseSettings\uf0c1\nSettings for a DataRobot GenAI vector database associated with an LLM blueprint.\nVariables:\nmax_documents_retrieved_per_prompt (int or None, optional) \u2013 The maximum number of documents to retrieve for each prompt.\nmax_tokens (int or None, optional) \u2013 The maximum number of tokens to retrieve for each document.\nretriever (VectorDatabaseRetrievers) \u2013 The vector database retriever name.\nadd_neighbor_chunks \u2013 Whether to add neighboring documents to the retrieved documents.\nclass datarobot.models.genai.vector_database.ChunkingParameters\uf0c1\nParameters defining how documents are split and embedded.\nVariables:\nembedding_model (Optional[str]) \u2013 Name of the text embedding model.\nCurrently supported options are listed in VectorDatabaseEmbeddingModel\nbut the values can differ with different platform versions.\nchunking_method (str) \u2013 Name of the method to split dataset documents.\nCurrently supported options are listed in VectorDatabaseChunkingMethod\nbut the values can differ with different platform versions.\nchunk_size (int) \u2013 Size of each text chunk in number of tokens.\nchunk_overlap_percentage (int) \u2013 Overlap percentage between chunks.\nseparators (list[str]) \u2013 Strings used to split documents into text chunks.\nembedding_validation (Optional[CustomModelEmbeddingValidation, SupportedCustomModelEmbedding, str]) \u2013 ID or object for custom embedding validation.\ncustom_chunking (bool) \u2013 Determines if the chunking is custom. With custom chunking,\ndataset rows are not split into chunks automatically;\ninstead, the user provides the chunks.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/custom-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "Optional[CustomModelEmbeddingValidation",
        "SupportedCustomModelEmbedding"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/key_values.html",
      "title": "Key-Values\uf0c1",
      "description": "",
      "content": "Key-Values\uf0c1\nclass datarobot.models.key_values.KeyValue\uf0c1\nA DataRobot Key-Value.\nAdded in version v3.4.\nVariables:\nid (str) \u2013 ID of the Key-Value\ncreated_at (str) \u2013 creation time of the Key-Value\nentity_id (str) \u2013 ID of the related Entity\nentity_type (KeyValueEntityType) \u2013 type of the related Entity\nname (str) \u2013 Key-Value name\nvalue (str) \u2013 Key-Value value\nnumeric_value (float) \u2013 Key-Value numeric value\nboolean_value (bool) \u2013 Key-Value boolean value\nvalue_type (KeyValueType) \u2013 Key-Value type\ndescription (str) \u2013 Key-Value description\ncreator_id (str) \u2013 ID of the user who created the Key-Value\ncreator_name (str) \u2013 ID of the user who created the Key-Value\ncategory (KeyValueCategory) \u2013 Key-Value category\nartifact_size (int) \u2013 size in bytes of associated image, if applicable\noriginal_file_name (str) \u2013 name of uploaded original image or dataset file\nis_editable (bool) \u2013 true if a user with permissions can edit or delete\nis_dataset_missing (bool) \u2013 true if the key-value type is \u201cdataset\u201d and its dataset is not visible to the user\nerror_message (str) \u2013 additional information if \u201cisDataSetMissing\u201d is true. Blank if there are no errors\nclassmethod get(key_value_id)\uf0c1\nGet Key-Value by id.\nAdded in version v3.4.\nParameters:\nkey_value_id (str) \u2013 ID of the Key-Value\nReturns:\nretrieved Key-Value\nReturn type:\nKeyValue\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nclassmethod list(entity_id, entity_type)\uf0c1\nList Key-Values.\nAdded in version v3.4.\nParameters:\nentity_id (str) \u2013 ID of the related Entity\nentity_type (KeyValueEntityType) \u2013 type of the related Entity\nReturns:\na list of Key-Values\nReturn type:\nList[KeyValue]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod find(entity_id, entity_type, name)\uf0c1\nFind Key-Value by name.\nAdded in version v3.4.\nParameters:\nentity_id (str) \u2013 ID of the related Entity\nentity_type (KeyValueEntityType) \u2013 type of the related Entity\nname (str) \u2013 name of the Key-Value\nReturns:\na list of Key-Values\nReturn type:\nList[KeyValue]\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod create(entity_id, entity_type, name, category, value_type, value=None, description=None)\uf0c1\nCreate a Key-Value.\nAdded in version v3.4.\nParameters:\nentity_id (str) \u2013 ID of the associated resource\nentity_type (KeyValueEntityType) \u2013 type of the associated resource\nname (str) \u2013 name of the Key-Value. Cannot contain: { } ; |\ncategory (KeyValueCategory) \u2013 category of the Key-Value\nvalue_type (KeyValueType) \u2013 type of the Key-Value value\nvalue (Optional[Union[str, float, bool]]) \u2013 value of Key-Value\ndescription (Optional[str]) \u2013 description of the Key-Value\nReturns:\ncreated Key-Value\nReturn type:\nKeyValue\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nupdate(entity_id=None, entity_type=None, name=None, category=None, value_type=None, value=None, description=None, comment=None)\uf0c1\nUpdate Key-Value.\nAdded in version v3.4.\nParameters:\nentity_id (Optional[str]) \u2013 ID of the associated resource\nentity_type (Optional[KeyValueEntityType]) \u2013 type of the associated resource\nname (Optional[str]) \u2013 name of the Key-Value. Cannot contain: { } ; |\ncategory (Optional[KeyValueCategory]) \u2013 category of the Key-Value\nvalue_type (Optional[KeyValueType]) \u2013 type of the Key-Value value\nvalue (Optional[[Union[str, float, bool]]) \u2013 value of Key-Value\ndescription (Optional[str]) \u2013 description of the Key-Value\ncomment (Optional[str]) \u2013 user comment explaining the change\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nReturn type:\nNone\nrefresh()\uf0c1\nUpdate Key-Value with the latest data from server.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\ndelete()\uf0c1\nDelete Key-Value.\n:rtype: None\nAdded in version v3.4.\nRaises:\ndatarobot.errors.ClientError \u2013 If the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 If the server responded with 5xx status.\nget_value()\uf0c1\nGet a value of Key-Value.\nAdded in version v3.4.\nReturns:\nvalue depending on the value type\nReturn type:\nUnion[str, float, boolean]\nclass datarobot.enums.KeyValueCategory\uf0c1\nKey-Value category\nclass datarobot.enums.KeyValueEntityType\uf0c1\nKey-Value entity type\nclass datarobot.enums.KeyValueType\uf0c1\nKey-Value type",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html"
      ],
      "page_type": "documentation",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html",
      "title": "Job\uf0c1",
      "description": "Tracks asynchronous work being done within a project",
      "content": "Job\uf0c1\nclass datarobot.models.Job\uf0c1\nTracks asynchronous work being done within a project\nVariables:\nid (int) \u2013 the id of the job\nproject_id (str) \u2013 the id of the project the job belongs to\nstatus (str) \u2013 the status of the job - will be one of datarobot.enums.QUEUE_STATUS\njob_type (str) \u2013 what kind of work the job is doing - will be one of datarobot.enums.JOB_TYPE\nis_blocked (bool) \u2013 if true, the job is blocked (cannot be executed) until its dependencies are resolved\nclassmethod get(project_id, job_id)\uf0c1\nFetches one job.\nParameters:\nproject_id (str) \u2013 The identifier of the project in which the job resides\njob_id (str) \u2013 The job id\nReturns:\njob \u2013 The job\nReturn type:\nJob\nRaises:\nAsyncFailureError \u2013 Querying this resource gave a status code other than 200 or 303\ncancel()\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nget_result(params=None)\uf0c1\nParameters:\nparams (dict or None) \u2013 Query parameters to be added to request to get results.\nNotes\nFor featureEffects, source param is required to define source,\notherwise the default is training.\nReturns:\nresult \u2013\nReturn type depends on the job type\nfor model jobs, a Model is returned\nfor predict jobs, a pandas.DataFrame (with predictions) is returned\nfor featureImpact jobs, a list of dicts by default (see with_metadata\nparameter of the FeatureImpactJob class and its get() method).\nfor primeRulesets jobs, a list of Rulesets\nfor primeModel jobs, a PrimeModel\nfor primeDownloadValidation jobs, a PrimeFile\nfor predictionExplanationInitialization jobs, a PredictionExplanationsInitialization\nfor predictionExplanations jobs, a PredictionExplanations\nfor featureEffects, a FeatureEffects.\nReturn type:\nobject\nRaises:\nJobNotFinished \u2013 If the job is not finished, the result is not available.\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nget_result_when_complete(max_wait=600, params=None)\uf0c1\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nparams (dict, optional) \u2013 Query parameters to be added to request.\nReturns:\nresult \u2013 Return type is the same as would be returned by Job.get_result.\nReturn type:\nobject\nRaises:\nAsyncTimeoutError \u2013 If the job does not finish in time\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nrefresh()\uf0c1\nUpdate this object with the latest job data from the server.\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nReturn type:\nNone\nclass datarobot.models.TrainingPredictionsJob\uf0c1\nclassmethod get(project_id, job_id, model_id=None, data_subset=None)\uf0c1\nFetches one training predictions job.\nThe resulting\nTrainingPredictions\nobject will be annotated with model_id and data_subset.\nParameters:\nproject_id (str) \u2013 The identifier of the project in which the job resides\njob_id (str) \u2013 The job id\nmodel_id (str) \u2013 The identifier of the model used for computing training predictions\ndata_subset (dr.enums.DATA_SUBSET, optional) \u2013 Data subset used for computing training predictions\nReturns:\njob \u2013 The job\nReturn type:\nTrainingPredictionsJob\nrefresh()\uf0c1\nUpdate this object with the latest job data from the server.\ncancel()\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nget_result(params=None)\uf0c1\nParameters:\nparams (dict or None) \u2013 Query parameters to be added to request to get results.\nNotes\nFor featureEffects, source param is required to define source,\notherwise the default is training.\nReturns:\nresult \u2013\nReturn type depends on the job type\nfor model jobs, a Model is returned\nfor predict jobs, a pandas.DataFrame (with predictions) is returned\nfor featureImpact jobs, a list of dicts by default (see with_metadata\nparameter of the FeatureImpactJob class and its get() method).\nfor primeRulesets jobs, a list of Rulesets\nfor primeModel jobs, a PrimeModel\nfor primeDownloadValidation jobs, a PrimeFile\nfor predictionExplanationInitialization jobs, a PredictionExplanationsInitialization\nfor predictionExplanations jobs, a PredictionExplanations\nfor featureEffects, a FeatureEffects.\nReturn type:\nobject\nRaises:\nJobNotFinished \u2013 If the job is not finished, the result is not available.\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nget_result_when_complete(max_wait=600, params=None)\uf0c1\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nparams (dict, optional) \u2013 Query parameters to be added to request.\nReturns:\nresult \u2013 Return type is the same as would be returned by Job.get_result.\nReturn type:\nobject\nRaises:\nAsyncTimeoutError \u2013 If the job does not finish in time\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nReturn type:\nNone\nclass datarobot.models.ShapMatrixJob\uf0c1\nclassmethod get(project_id, job_id, model_id=None, dataset_id=None)\uf0c1\nFetches one SHAP matrix job.\nParameters:\nproject_id (str) \u2013 The identifier of the project in which the job resides\njob_id (str) \u2013 The job identifier\nmodel_id (str) \u2013 The identifier of the model used for computing prediction explanations\ndataset_id (str) \u2013 The identifier of the dataset against which prediction explanations should be computed\nReturns:\njob \u2013 The job\nReturn type:\nShapMatrixJob\nRaises:\nAsyncFailureError \u2013 Querying this resource gave a status code other than 200 or 303\nrefresh()\uf0c1\nUpdate this object with the latest job data from the server.\nReturn type:\nNone\ncancel()\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nget_result(params=None)\uf0c1\nParameters:\nparams (dict or None) \u2013 Query parameters to be added to request to get results.\nNotes\nFor featureEffects, source param is required to define source,\notherwise the default is training.\nReturns:\nresult \u2013\nReturn type depends on the job type\nfor model jobs, a Model is returned\nfor predict jobs, a pandas.DataFrame (with predictions) is returned\nfor featureImpact jobs, a list of dicts by default (see with_metadata\nparameter of the FeatureImpactJob class and its get() method).\nfor primeRulesets jobs, a list of Rulesets\nfor primeModel jobs, a PrimeModel\nfor primeDownloadValidation jobs, a PrimeFile\nfor predictionExplanationInitialization jobs, a PredictionExplanationsInitialization\nfor predictionExplanations jobs, a PredictionExplanations\nfor featureEffects, a FeatureEffects.\nReturn type:\nobject\nRaises:\nJobNotFinished \u2013 If the job is not finished, the result is not available.\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nget_result_when_complete(max_wait=600, params=None)\uf0c1\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nparams (dict, optional) \u2013 Query parameters to be added to request.\nReturns:\nresult \u2013 Return type is the same as would be returned by Job.get_result.\nReturn type:\nobject\nRaises:\nAsyncTimeoutError \u2013 If the job does not finish in time\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nReturn type:\nNone\nclass datarobot.models.FeatureImpactJob\uf0c1\nCustom Feature Impact job to handle different return value structures.\nThe original implementation had just the the data and the new one also includes some metadata.\nIn general, we aim to keep the number of Job classes low by just utilizing the job_type\nattribute to control any specific formatting; however in this case when we needed to support\na new representation with the _same_ job_type, customizing the behavior of\n_make_result_from_location allowed us to achieve our ends without complicating the\n_make_result_from_json method.\nclassmethod get(project_id, job_id, with_metadata=False)\uf0c1\nFetches one job.\nParameters:\nproject_id (str) \u2013 The identifier of the project in which the job resides\njob_id (str) \u2013 The job id\nwith_metadata (bool) \u2013 To make this job return the metadata (i.e. the full object of the completed resource)\nset the with_metadata flag to True.\nReturns:\njob \u2013 The job\nReturn type:\nJob\nRaises:\nAsyncFailureError \u2013 Querying this resource gave a status code other than 200 or 303\ncancel()\uf0c1\nCancel this job. If this job has not finished running, it will be\nremoved and canceled.\nget_result(params=None)\uf0c1\nParameters:\nparams (dict or None) \u2013 Query parameters to be added to request to get results.\nNotes\nFor featureEffects, source param is required to define source,\notherwise the default is training.\nReturns:\nresult \u2013\nReturn type depends on the job type\nfor model jobs, a Model is returned\nfor predict jobs, a pandas.DataFrame (with predictions) is returned\nfor featureImpact jobs, a list of dicts by default (see with_metadata\nparameter of the FeatureImpactJob class and its get() method).\nfor primeRulesets jobs, a list of Rulesets\nfor primeModel jobs, a PrimeModel\nfor primeDownloadValidation jobs, a PrimeFile\nfor predictionExplanationInitialization jobs, a PredictionExplanationsInitialization\nfor predictionExplanations jobs, a PredictionExplanations\nfor featureEffects, a FeatureEffects.\nReturn type:\nobject\nRaises:\nJobNotFinished \u2013 If the job is not finished, the result is not available.\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nget_result_when_complete(max_wait=600, params=None)\uf0c1\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nparams (dict, optional) \u2013 Query parameters to be added to request.\nReturns:\nresult \u2013 Return type is the same as would be returned by Job.get_result.\nReturn type:\nobject\nRaises:\nAsyncTimeoutError \u2013 If the job does not finish in time\nAsyncProcessUnsuccessfulError \u2013 If the job errored or was aborted\nrefresh()\uf0c1\nUpdate this object with the latest job data from the server.\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish.\nReturn type:\nNone",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/training_predictions.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.QUEUE_STATUS",
        "datarobot.enums.JOB_TYPE"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/mlops_event.html",
      "title": "MLOps event\uf0c1",
      "description": "An MLOps Event Object: An object representing an important MLOps activity that\nhappened.  For example, health, service issues with the DataRobot deployment\nor a prediction environment or a particular phase in a long operation (like\ncreation of deployment or processing training data) is completed or errored.",
      "content": "MLOps event\uf0c1\nclass datarobot.mlops.events.MLOpsEvent\uf0c1\nAn MLOps Event Object: An object representing an important MLOps activity that\nhappened.  For example, health, service issues with the DataRobot deployment\nor a prediction environment or a particular phase in a long operation (like\ncreation of deployment or processing training data) is completed or errored.\nThis class allows the client to report such event to the DataRobot service.\nNotes\nDataRobot backend support lots of events and all these events are categorized\ninto different categories.  This class does not yet support ALL events, but\nwe will gradually add support for them\nSupported Event Categories:\nmoderation\nclassmethod report_moderation_event(event_type, timestamp=None, title=None, message=None, deployment_id=None, org_id=None, guard_name=None, metric_name=None)\uf0c1\nReports a moderation event\nParameters:\nevent_type (str) \u2013 The type of the moderation event.\ntimestamp (Optional[str]) \u2013 The timestamp of the event, datetime, or string in RFC3339 format. If the datetime provided\ndoes not have a timezone, DataRobot assumes it is UTC.\ntitle (Optional[str]) \u2013 The title of the moderation event.\nmessage (Optional[str]) \u2013 A description of the moderation event.\ndeployment_id (Optional[str]) \u2013 The ID of the deployment associated with the event.\norg_id (Optional[str]) \u2013 The ID of the organization associated with the event.\nguard_name (Optional[str]) \u2013 The name or label of the guard.\nmetric_name (Optional[str]) \u2013 The name or label of the metric.\nReturn type:\nNone\nRaises:\nValueError \u2013 If event_type is not one of the moderation event types.\nIf fails to create the event.\nExamples\n>>> from datarobot.mlops.events import MLOpsEvent\n>>> MLOpsEvent.report_moderation_event(\n...     event_type=\"moderationMetricCreationError\",\n...     title=\"Failed to create moderation metric\",\n...     message=\"Maximum number of custom metrics reached\",\n...     deployment_id=\"5c939e08962d741e34f609f0\",\n...     metric_name=\"Blocked Prompts\",\n... )",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        ">>> from datarobot.mlops.events import MLOpsEvent\n>>> MLOpsEvent.report_moderation_event(\n...     event_type=\"moderationMetricCreationError\",\n...     title=\"Failed to create moderation metric\",\n...     message=\"Maximum number of custom metrics reached\",\n...     deployment_id=\"5c939e08962d741e34f609f0\",\n...     metric_name=\"Blocked Prompts\",\n... )"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/insights.html",
      "title": "Insights\uf0c1",
      "description": "Class for SHAP Matrix calculations. Use the standard methods of BaseInsight to compute\nand retrieve: compute, create, list, get.",
      "content": "Insights\uf0c1\nclass datarobot.insights.ShapMatrix\uf0c1\nClass for SHAP Matrix calculations. Use the standard methods of BaseInsight to compute\nand retrieve: compute, create, list, get.\nproperty matrix: Any\uf0c1\nSHAP matrix values.\nproperty base_value: float\uf0c1\nSHAP base value for the matrix values\nproperty columns: List[str]\uf0c1\nList of columns associated with the SHAP matrix\nproperty link_function: str\uf0c1\nLink function used to generate the SHAP matrix\nclassmethod compute(entity_id, source=INSIGHTS_SOURCES.VALIDATION, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, **kwargs)\uf0c1\nSubmit an insight compute request. You can use create if you want to\nwait synchronously for the completion of the job. May be overridden by insight subclasses to\naccept additional parameters.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nReturns:\nStatus check job entity for the asynchronous insight calculation.\nReturn type:\nStatusCheckJob\nclassmethod create(entity_id, source=INSIGHTS_SOURCES.VALIDATION, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, max_wait=600, **kwargs)\uf0c1\nCreate an insight and wait for completion. May be overridden by insight subclasses to\naccept additional parameters.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nmax_wait (int) \u2013 The number of seconds to wait for the result.\nReturns:\nEntity of the newly or already computed insights.\nReturn type:\nSelf\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverride from_server_data to handle paginated responses\nReturn type:\nSelf\nclassmethod get(entity_id, source=INSIGHTS_SOURCES.VALIDATION, quick_compute=None, **kwargs)\uf0c1\nReturn the first matching insight based on the entity id and kwargs.\nParameters:\nentity_id (str) \u2013 The ID of the entity to retrieve generated insights.\nsource (str) \u2013 The source type to use when retrieving the insight.\nquick_compute (Optional[bool]) \u2013 Sets whether to retrieve the insight that was computed using quick-compute. If not\nspecified, quick_compute is not used for matching.\nReturns:\nPreviously computed insight.\nReturn type:\nSelf\nclassmethod get_as_csv(entity_id, **kwargs)\uf0c1\nRetrieve a specific insight represented in CSV format.\nParameters:\nentity_id (str) \u2013 ID of the entity to retrieve the insight.\n**kwargs (Any) \u2013 Additional keyword arguments to pass to the retrieve function.\nReturns:\nThe retrieved insight.\nReturn type:\nstr\nclassmethod get_as_dataframe(entity_id, **kwargs)\uf0c1\nRetrieve a specific insight represented as a pandas DataFrame.\nParameters:\nentity_id (str) \u2013 ID of the entity to retrieve the insight.\n**kwargs (Any) \u2013 Additional keyword arguments to pass to the retrieve function.\nReturns:\nThe retrieved insight.\nReturn type:\nDataFrame\nget_uri()\uf0c1\nThis should define the URI to their browser based interactions\nReturn type:\nstr\nclassmethod list(entity_id)\uf0c1\nList all generated insights.\nParameters:\nentity_id (str) \u2013 The ID of the entity queried for listing all generated insights.\nReturns:\nList of newly or previously computed insights.\nReturn type:\nList[Self]\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nsort(key_name)\uf0c1\nSorts insights data\nReturn type:\nNone\nclass datarobot.insights.ShapPreview\uf0c1\nClass for SHAP Preview calculations. Use the standard methods of BaseInsight to compute\nand retrieve: compute, create, list, get.\nproperty previews: List[Dict[str, Any]]\uf0c1\nSHAP preview values.\nReturns:\npreview \u2013 A list of the ShapPreview values for each row.\nReturn type:\nList[Dict[str, Any]]\nproperty previews_count: int\uf0c1\nThe number of shap preview rows.\nReturn type:\nint\nclassmethod get(entity_id, source=INSIGHTS_SOURCES.VALIDATION, quick_compute=None, prediction_filter_row_count=None, prediction_filter_percentiles=None, prediction_filter_operand_first=None, prediction_filter_operand_second=None, prediction_filter_operator=None, feature_filter_count=None, feature_filter_name=None, **kwargs)\uf0c1\nReturn the first matching ShapPreview insight based on the entity id and kwargs.\nParameters:\nentity_id (str) \u2013 The ID of the entity to retrieve generated insights.\nsource (str) \u2013 The source type to use when retrieving the insight.\nquick_compute (Optional[bool]) \u2013 Sets whether to retrieve the insight that was computed using quick-compute. If not\nspecified, quick_compute is not used for matching.\nprediction_filter_row_count (Optional[int]) \u2013 The maximum number of preview rows to return.\nprediction_filter_percentiles (Optional[int]) \u2013 The number of percentile intervals to select from the total number of rows.\nThis field will supersede predictionFilterRowCount if both are present.\nprediction_filter_operand_first (Optional[float]) \u2013 The first operand to apply to filtered predictions.\nprediction_filter_operand_second (Optional[float]) \u2013 The second operand to apply to filtered predictions.\nprediction_filter_operator (Optional[str]) \u2013 The operator to apply to filtered predictions.\nfeature_filter_count (Optional[int]) \u2013 The maximum number of features to return for each preview.\nfeature_filter_name (Optional[str]) \u2013 The names of specific features to return for each preview.\nReturns:\nList of newly or already computed insights.\nReturn type:\nList[Any]\nclassmethod compute(entity_id, source=INSIGHTS_SOURCES.VALIDATION, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, **kwargs)\uf0c1\nSubmit an insight compute request. You can use create if you want to\nwait synchronously for the completion of the job. May be overridden by insight subclasses to\naccept additional parameters.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nReturns:\nStatus check job entity for the asynchronous insight calculation.\nReturn type:\nStatusCheckJob\nclassmethod create(entity_id, source=INSIGHTS_SOURCES.VALIDATION, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, max_wait=600, **kwargs)\uf0c1\nCreate an insight and wait for completion. May be overridden by insight subclasses to\naccept additional parameters.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nmax_wait (int) \u2013 The number of seconds to wait for the result.\nReturns:\nEntity of the newly or already computed insights.\nReturn type:\nSelf\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverride from_server_data to handle paginated responses\nReturn type:\nSelf\nget_uri()\uf0c1\nThis should define the URI to their browser based interactions\nReturn type:\nstr\nclassmethod list(entity_id)\uf0c1\nList all generated insights.\nParameters:\nentity_id (str) \u2013 The ID of the entity queried for listing all generated insights.\nReturns:\nList of newly or previously computed insights.\nReturn type:\nList[Self]\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nsort(key_name)\uf0c1\nSorts insights data\nReturn type:\nNone\nclass datarobot.insights.ShapImpact\uf0c1\nClass for SHAP Impact calculations. Use the standard methods of BaseInsight to compute\nand retrieve: compute, create, list, get.\nclassmethod compute(entity_id, source=INSIGHTS_SOURCES.TRAINING, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, **kwargs)\uf0c1\nSubmit an insight compute request. You can use create if you want to\nwait synchronously for the completion of the job.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nReturns:\nStatus check job entity for the asynchronous insight calculation.\nReturn type:\nStatusCheckJob\nclassmethod create(entity_id, source=INSIGHTS_SOURCES.TRAINING, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, max_wait=600, **kwargs)\uf0c1\nCreate an insight and wait for completion.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nmax_wait (int) \u2013 The number of seconds to wait for the result.\nReturns:\nEntity of the newly or already computed insights.\nReturn type:\nSelf\nsort(key_name='-impact_normalized')\uf0c1\nSorts insights data by key name.\nParameters:\nkey_name (str) \u2013 item key name to sort data.\nOne of \u2018feature_name\u2019, \u2018impact_normalized\u2019 or \u2018impact_unnormalized\u2019.\nStarting with \u2018-\u2019 reverses sort order. Default \u2018-impact_normalized\u2019\nReturn type:\nNone\nproperty shap_impacts: List[List[Any]]\uf0c1\nSHAP impact values\nReturns:\nA list of the SHAP impact values\nReturn type:\nshap impacts\nproperty base_value: List[float]\uf0c1\nA list of base prediction values\nproperty capping: Dict[str, Any] | None\uf0c1\nCapping for the models in the blender\nproperty link: str | None\uf0c1\nShared link function of the models in the blender\nproperty row_count: int | None\uf0c1\nNumber of SHAP impact rows. This is deprecated.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverride from_server_data to handle paginated responses\nReturn type:\nSelf\nclassmethod get(entity_id, source=INSIGHTS_SOURCES.VALIDATION, quick_compute=None, **kwargs)\uf0c1\nReturn the first matching insight based on the entity id and kwargs.\nParameters:\nentity_id (str) \u2013 The ID of the entity to retrieve generated insights.\nsource (str) \u2013 The source type to use when retrieving the insight.\nquick_compute (Optional[bool]) \u2013 Sets whether to retrieve the insight that was computed using quick-compute. If not\nspecified, quick_compute is not used for matching.\nReturns:\nPreviously computed insight.\nReturn type:\nSelf\nget_uri()\uf0c1\nThis should define the URI to their browser based interactions\nReturn type:\nstr\nclassmethod list(entity_id)\uf0c1\nList all generated insights.\nParameters:\nentity_id (str) \u2013 The ID of the entity queried for listing all generated insights.\nReturns:\nList of newly or previously computed insights.\nReturn type:\nList[Self]\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nclass datarobot.insights.ShapDistributions\uf0c1\nClass for SHAP Distributions calculations. Use the standard methods of BaseInsight to compute\nand retrieve: compute, create, list, get.\nproperty features: List[Dict[str, Any]]\uf0c1\nSHAP feature values\nReturns:\nfeatures \u2013 A list of the ShapDistributions values for each row\nReturn type:\nList[Dict[str, Any]]\nproperty total_features_count: int\uf0c1\nNumber of shap distributions features\nReturn type:\nint\nclassmethod compute(entity_id, source=INSIGHTS_SOURCES.VALIDATION, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, **kwargs)\uf0c1\nSubmit an insight compute request. You can use create if you want to\nwait synchronously for the completion of the job. May be overridden by insight subclasses to\naccept additional parameters.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nReturns:\nStatus check job entity for the asynchronous insight calculation.\nReturn type:\nStatusCheckJob\nclassmethod create(entity_id, source=INSIGHTS_SOURCES.VALIDATION, data_slice_id=None, external_dataset_id=None, entity_type=ENTITY_TYPES.DATAROBOT_MODEL, quick_compute=None, max_wait=600, **kwargs)\uf0c1\nCreate an insight and wait for completion. May be overridden by insight subclasses to\naccept additional parameters.\nParameters:\nentity_id (str) \u2013 The ID of the entity to compute the insight.\nsource (str) \u2013 The source type to use when computing the insight.\ndata_slice_id (Optional[str]) \u2013 Data slice ID to use when computing the insight.\nexternal_dataset_id (Optional[str]) \u2013 External dataset ID to use when computing the insight.\nentity_type (Optional[ENTITY_TYPES]) \u2013 The type of the entity associated with the insight. Select one of the ENTITY_TYPE enum\nvalues, or accept the default, \u201cdatarobotModel\u201d.\nquick_compute (Optional[bool]) \u2013 Sets whether to use quick-compute for the insight. If True or unspecified, the insight\nis computed using a 2500-row data sample. If False, the insight is computed using all\nrows in the chosen source.\nmax_wait (int) \u2013 The number of seconds to wait for the result.\nReturns:\nEntity of the newly or already computed insights.\nReturn type:\nSelf\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nOverride from_server_data to handle paginated responses\nReturn type:\nSelf\nclassmethod get(entity_id, source=INSIGHTS_SOURCES.VALIDATION, quick_compute=None, **kwargs)\uf0c1\nReturn the first matching insight based on the entity id and kwargs.\nParameters:\nentity_id (str) \u2013 The ID of the entity to retrieve generated insights.\nsource (str) \u2013 The source type to use when retrieving the insight.\nquick_compute (Optional[bool]) \u2013 Sets whether to retrieve the insight that was computed using quick-compute. If not\nspecified, quick_compute is not used for matching.\nReturns:\nPreviously computed insight.\nReturn type:\nSelf\nget_uri()\uf0c1\nThis should define the URI to their browser based interactions\nReturn type:\nstr\nclassmethod list(entity_id)\uf0c1\nList all generated insights.\nParameters:\nentity_id (str) \u2013 The ID of the entity queried for listing all generated insights.\nReturns:\nList of newly or previously computed insights.\nReturn type:\nList[Self]\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nsort(key_name)\uf0c1\nSorts insights data\nReturn type:\nNone\nTypes\uf0c1\nclass datarobot.models.RocCurveEstimatedMetric\uf0c1\nTyped dict for estimated metric\nclass datarobot.models.AnomalyAssessmentRecordMetadata\uf0c1\nTyped dict for record metadata\nclass datarobot.models.AnomalyAssessmentPreviewBin\uf0c1\nTyped dict for preview bin\nclass datarobot.models.ShapleyFeatureContribution\uf0c1\nTyped dict for shapley feature contribution\nclass datarobot.models.AnomalyAssessmentDataPoint\uf0c1\nTyped dict for data points\nclass datarobot.models.RegionExplanationsData\uf0c1\nTyped dict for region explanations\nAnomaly assessment\uf0c1\nclass datarobot.models.anomaly_assessment.AnomalyAssessmentRecord\uf0c1\nObject which keeps metadata about anomaly assessment insight for the particular\nsubset, backtest and series and the links to proceed to get the anomaly assessment data.\nAdded in version v2.25.\nVariables:\nrecord_id (str) \u2013 The ID of the record.\nproject_id (str) \u2013 The ID of the project record belongs to.\nmodel_id (str) \u2013 The ID of the model record belongs to.\nbacktest (int or \"holdout\") \u2013 The backtest of the record.\nsource (\"training\" or \"validation\") \u2013 The source of the record\nseries_id (str or None) \u2013 The series id of the record for the multiseries projects. Defined only for the multiseries\nprojects.\nstatus (str) \u2013 The status of the insight. One of datarobot.enums.AnomalyAssessmentStatus\nstatus_details (str) \u2013 The explanation of the status.\nstart_date (str or None) \u2013 The ISO-formatted timestamp of the first prediction in the subset. Will be None if status is\nnot AnomalyAssessmentStatus.COMPLETED.\nend_date (str or None) \u2013 The ISO-formatted timestamp of the last prediction in the subset. Will be None if status is\nnot AnomalyAssessmentStatus.COMPLETED.\nprediction_threshold (float or None) \u2013 The threshold, all rows with anomaly scores greater or equal to it have shap explanations computed.\npreview_location (str or None) \u2013 The URL to retrieve predictions preview for the subset. Will be None if status is\nnot AnomalyAssessmentStatus.COMPLETED.\nlatest_explanations_location (str or None) \u2013 The URL to retrieve the latest predictions with the shap explanations. Will be None if status is\nnot AnomalyAssessmentStatus.COMPLETED.\ndelete_location (str) \u2013 The URL to delete anomaly assessment record and relevant insight data.\nclassmethod list(project_id, model_id, backtest=None, source=None, series_id=None, limit=100, offset=0, with_data_only=False)\uf0c1\nRetrieve the list of the anomaly assessment records for the project and model.\nOutput can be filtered and limited.\nParameters:\nproject_id (str) \u2013 The ID of the project record belongs to.\nmodel_id (str) \u2013 The ID of the model record belongs to.\nbacktest (int or \"holdout\") \u2013 The backtest to filter records by.\nsource (\"training\" or \"validation\") \u2013 The source to filter records by.\nseries_id (Optional[str]) \u2013 The series id to filter records by. Can be specified for multiseries projects.\nlimit (Optional[int]) \u2013 100 by default. At most this many results are returned.\noffset (Optional[int]) \u2013 This many results will be skipped.\nwith_data_only (bool, False by default) \u2013 Filter by status == AnomalyAssessmentStatus.COMPLETED. If True, records with\nno data or not supported will be omitted.\nReturns:\nThe anomaly assessment record.\nReturn type:\nAnomalyAssessmentRecord\nclassmethod compute(project_id, model_id, backtest, source, series_id=None)\uf0c1\nRequest anomaly assessment insight computation on the specified subset.\nParameters:\nproject_id (str) \u2013 The ID of the project to compute insight for.\nmodel_id (str) \u2013 The ID of the model to compute insight for.\nbacktest (int or \"holdout\") \u2013 The backtest to compute insight for.\nsource (\"training\" or \"validation\") \u2013 The source  to compute insight for.\nseries_id (Optional[str]) \u2013 The series id to compute insight for. Required for multiseries projects.\nReturns:\nThe anomaly assessment record.\nReturn type:\nAnomalyAssessmentRecord\ndelete()\uf0c1\nDelete anomaly assessment record with preview and explanations.\nReturn type:\nNone\nget_predictions_preview()\uf0c1\nRetrieve aggregated predictions statistics for the anomaly assessment record.\nReturn type:\nAnomalyAssessmentPredictionsPreview\nget_latest_explanations()\uf0c1\nRetrieve latest predictions along with shap explanations for the most anomalous records.\nReturn type:\nAnomalyAssessmentExplanations\nget_explanations(start_date=None, end_date=None, points_count=None)\uf0c1\nRetrieve predictions along with shap explanations for the most anomalous records\nin the specified date range/for defined number of points.\nTwo out of three parameters: start_date, end_date or points_count must be specified.\nParameters:\nstart_date (Optional[str]) \u2013 The start of the date range to get explanations in.\nExample: 2020-01-01T00:00:00.000000Z\nend_date (Optional[str]) \u2013 The end of the date range to get explanations in.\nExample: 2020-10-01T00:00:00.000000Z\npoints_count (Optional[int]) \u2013 The number of the rows to return.\nReturn type:\nAnomalyAssessmentExplanations\nget_explanations_data_in_regions(regions, prediction_threshold=0.0)\uf0c1\nGet predictions along with explanations for the specified regions, sorted by\npredictions in descending order.\nParameters:\nregions (list of AnomalyAssessmentPreviewBin) \u2013 For each region explanations will be retrieved and merged.\nprediction_threshold (Optional[float]) \u2013 If specified, only points with score greater or equal to the threshold will be returned.\nReturns:\ndict in a form of {\u2018explanations\u2019: explanations, \u2018shap_base_value\u2019: shap_base_value}\nReturn type:\nRegionExplanationsData\nclass datarobot.models.anomaly_assessment.AnomalyAssessmentExplanations\uf0c1\nObject which keeps predictions along with shap explanations for the most anomalous records\nin the specified date range/for defined number of points.\nAdded in version v2.25.\nVariables:\nrecord_id (str) \u2013 The ID of the record.\nproject_id (str) \u2013 The ID of the project record belongs to.\nmodel_id (str) \u2013 The ID of the model record belongs to.\nbacktest (int or \"holdout\") \u2013 The backtest of the record.\nsource (\"training\" or \"validation\") \u2013 The source of the record.\nseries_id (str or None) \u2013 The series id of the record for the multiseries projects. Defined only for the multiseries\nprojects.\nstart_date (str or None) \u2013 The ISO-formatted datetime of the first row in the data. Will be None of there is no data\nin the specified range.\nend_date (str or None) \u2013 The ISO-formatted datetime of the last row in the data. Will be None of there is no data\nin the specified range.\nshap_base_value (float) \u2013 Shap base value.\ncount (int) \u2013 The number of points in data.\ndata (array of DataPoint objects or None) \u2013 The list of DataPoint objects in the specified date range.\nNotes\nDataPoint contains:\nshap_explanation : None or an array of up to 10 ShapleyFeatureContribution objects.\nOnly rows with the highest anomaly scores have Shapley explanations calculated.\nValue is None if prediction is lower than prediction_threshold.\ntimestamp (str) : ISO-formatted timestamp for the row.\nprediction (float) : The output of the model for this row.\nShapleyFeatureContribution contains:\nfeature_value (str) : the feature value for this row. First 50 characters are returned.\nstrength (float) : the shap value for this feature and row.\nfeature (str) : the feature name.\nclassmethod get(project_id, record_id, start_date=None, end_date=None, points_count=None)\uf0c1\nRetrieve predictions along with shap explanations for the most anomalous records\nin the specified date range/for defined number of points.\nTwo out of three parameters: start_date, end_date or points_count must be specified.\nParameters:\nproject_id (str) \u2013 The ID of the project.\nrecord_id (str) \u2013 The ID of the anomaly assessment record.\nstart_date (Optional[str]) \u2013 The start of the date range to get explanations in.\nExample: 2020-01-01T00:00:00.000000Z\nend_date (Optional[str]) \u2013 The end of the date range to get explanations in.\nExample: 2020-10-01T00:00:00.000000Z\npoints_count (Optional[int]) \u2013 The number of the rows to return.\nReturn type:\nAnomalyAssessmentExplanations\nclass datarobot.models.anomaly_assessment.AnomalyAssessmentPredictionsPreview\uf0c1\nAggregated predictions over time for the corresponding anomaly assessment record.\nIntended to find the bins with highest anomaly scores.\nAdded in version v2.25.\nVariables:\nrecord_id (str) \u2013 The ID of the record.\nproject_id (str) \u2013 The ID of the project record belongs to.\nmodel_id (str) \u2013 The ID of the model record belongs to.\nbacktest (int or \"holdout\") \u2013 The backtest of the record.\nsource (\"training\" or \"validation\") \u2013 The source of the record\nseries_id (str or None) \u2013 The series id of the record for the multiseries projects. Defined only for the multiseries\nprojects.\nstart_date (str) \u2013 the ISO-formatted timestamp of the first prediction in the subset.\nend_date (str) \u2013 the ISO-formatted timestamp of the last prediction in the subset.\npreview_bins (list of preview_bin objects.) \u2013 The aggregated predictions for the subset.  Bins boundaries may differ from actual start/end\ndates because this is an aggregation.\nNotes\nPreviewBin contains:\nstart_date (str) : the ISO-formatted datetime of the start of the bin.\nend_date (str) : the ISO-formatted datetime of the end of the bin.\navg_predicted (float or None) : the average prediction of the model in the bin. None if\nthere are no entries in the bin.\nmax_predicted (float or None) : the maximum prediction of the model in the bin. None if\nthere are no entries in the bin.\nfrequency (int) : the number of the rows in the bin.\nclassmethod get(project_id, record_id)\uf0c1\nRetrieve aggregated predictions over time.\nParameters:\nproject_id (str) \u2013 The ID of the project.\nrecord_id (str) \u2013 The ID of the anomaly assessment record.\nReturn type:\nAnomalyAssessmentPredictionsPreview\nfind_anomalous_regions(max_prediction_threshold=0.0)\uf0c1\nSort preview bins by max_predicted value and select those with max predicted valuegreater or equal to max prediction threshold.\nSort the result by max predicted value in descending order.\nParameters:\nmax_prediction_threshold (Optional[float]) \u2013 Return bins with maximum anomaly score greater or equal to max_prediction_threshold.\nReturns:\npreview_bins \u2013 Filtered and sorted preview bins\nReturn type:\nlist of preview_bin\nConfusion chart\uf0c1\nclass datarobot.models.confusion_chart.ConfusionChart\uf0c1\nConfusion Chart data for model.\nNotes\nClassMetrics is a dict containing the following:\nclass_name (string) name of the class\nactual_count (int) number of times this class is seen in the validation data\npredicted_count (int) number of times this class has been predicted for the           validation data\nf1 (float) F1 score\nrecall (float) recall score\nprecision (float) precision score\nwas_actual_percentages (list of dict) one vs all actual percentages in format           specified below.\nother_class_name (string) the name of the other class\npercentage (float) the percentage of the times this class was predicted when is               was actually class (from 0 to 1)\nwas_predicted_percentages (list of dict) one vs all predicted percentages in format           specified below.\nother_class_name (string) the name of the other class\npercentage (float) the percentage of the times this class was actual predicted               (from 0 to 1)\nconfusion_matrix_one_vs_all (list of list) 2d list representing 2x2 one vs all matrix.\nThis represents the True/False Negative/Positive rates as integer for each class.               The data structure looks like:\n[ [ True Negative, False Positive ], [ False Negative, True Positive ] ]\nVariables:\nsource (str) \u2013 Confusion Chart data source. Can be \u2018validation\u2019, \u2018crossValidation\u2019 or \u2018holdout\u2019.\nraw_data (dict) \u2013 All of the raw data for the Confusion Chart\nconfusion_matrix (list of list) \u2013 The N x N confusion matrix\nclasses (list) \u2013 The names of each of the classes\nclass_metrics (list of dicts) \u2013 List of dicts with schema described as ClassMetrics above.\nsource_model_id (str) \u2013 ID of the model this Confusion chart represents; in some cases,\ninsights from the parent of a frozen model may be used\nLift chart\uf0c1\nclass datarobot.models.lift_chart.LiftChart\uf0c1\nLift chart data for model.\nNotes\nLiftChartBin is a dict containing the following:\nactual (float) Sum of actual target values in bin\npredicted (float) Sum of predicted target values in bin\nbin_weight (float) The weight of the bin. For weighted projects, it is the sum of           the weights of the rows in the bin. For unweighted projects, it is the number of rows in           the bin.\nVariables:\nsource (str) \u2013 Lift chart data source. Can be \u2018validation\u2019, \u2018crossValidation\u2019 or \u2018holdout\u2019.\nbins (list of dict) \u2013 List of dicts with schema described as LiftChartBin above.\nsource_model_id (str) \u2013 ID of the model this lift chart represents; in some cases,\ninsights from the parent of a frozen model may be used\ntarget_class (Optional[str]) \u2013 For multiclass lift - target class for this lift chart data.\ndata_slice_id (string or None) \u2013 The slice to retrieve Lift Chart for; if None, retrieve unsliced data.\nclassmethod from_server_data(data, keep_attrs=None, use_insights_format=False, **kwargs)\uf0c1\nOverwrite APIObject.from_server_data to handle lift chart data retrieved\nfrom either legacy URL or /insights/ new URL.\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nuse_insights_format (Optional[bool]) \u2013 Whether to repack the data from the format used in the GET /insights/liftChart/ URL\nto the format used in the legacy URL.\nData slices\uf0c1\nclass datarobot.models.data_slice.DataSlice\uf0c1\nDefinition of a data slice\nVariables:\nid (str) \u2013 ID of the data slice.\nname (str) \u2013 Name of the data slice definition.\nfilters (list[DataSliceFiltersType]) \u2013\nList of DataSliceFiltersType with params\noperand (str)\nName of the feature to use in the filter.\noperator (str)\nOperator to use in the filter - eq, in, <, or >.\nvalues (Union[str, int, float])\nValues to use from the feature.\nproject_id (str) \u2013 ID of the project that the model is part of.\nclassmethod list(project, offset=0, limit=100)\uf0c1\nList the data slices in the same project\nParameters:\nproject (Union[str, Project]) \u2013 ID of the project or Project object from which to list data slices.\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturns:\ndata_slices\nReturn type:\nlist[DataSlice]\nExamples\n>>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slices = dr.DataSlice.list(\"646d0ea0cd8eb2355a68b0e5\")\n>>> data_slices\n[DataSlice(...), DataSlice(...), ...]\nclassmethod create(name, filters, project)\uf0c1\nCreates a data slice in the project with the given name and filters\nParameters:\nname (str) \u2013 Name of the data slice definition.\nfilters (list[DataSliceFiltersType]) \u2013\nList of filters (dict) with params:\noperand (str)Name of the feature to use in filter.\noperator (str)Operator to use: \u2018eq\u2019, \u2018in\u2019, \u2018<\u2019, or \u2018>\u2019.\nvalues (Union[str, int, float])Values to use from the feature.\nproject (Union[str, Project]) \u2013 Project ID or Project object from which to list data slices.\nReturns:\ndata_slice \u2013 The data slice object created\nReturn type:\nDataSlice\nExamples\n>>> import datarobot as dr\n>>> ...  # set up your Client and retrieve a project\n>>> data_slice = dr.DataSlice.create(\n>>> ...    name='yes',\n>>> ...    filters=[{'operand': 'binary_target', 'operator': 'eq', 'values': ['Yes']}],\n>>> ...    project=project,\n>>> ...  )\n>>> data_slice\nDataSlice(\nfilters=[{'operand': 'binary_target', 'operator': 'eq', 'values': ['Yes']}],\nid=646d1296bd0c543d88923c9d,\nname=yes,\nproject_id=646d0ea0cd8eb2355a68b0e5\n)\ndelete()\uf0c1\nDeletes the data slice from storage\n:rtype: None\nExamples\n>>> import datarobot as dr\n>>> data_slice = dr.DataSlice.get('5a8ac9ab07a57a0001be501f')\n>>> data_slice.delete()\n>>> import datarobot as dr\n>>> ... # get project or project_id\n>>> data_slices = dr.DataSlice.list(project)  # project object or project_id\n>>> data_slice = data_slices[0]  # choose a data slice from the list\n>>> data_slice.delete()\nrequest_size(source, model=None)\uf0c1\nSubmits a request to validate the data slice\u2019s filters and\ncalculate the data slice\u2019s number of rows on a given source\nParameters:\nsource (INSIGHTS_SOURCES) \u2013 Subset of data (partition or \u201csource\u201d) on which to apply the data slice\nfor estimating available rows.\nmodel (Optional[Union[str, Model]]) \u2013 Model object or ID of the model. It is only required when source is \u201ctraining\u201d.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nExamples\n>>> import datarobot as dr\n>>> ... # get project or project_id\n>>> data_slices = dr.DataSlice.list(project)  # project object or project_id\n>>> data_slice = data_slices[0]  # choose a data slice from the list\n>>> status_check_job = data_slice.request_size(\"validation\")\nModel is required when source is \u2018training\u2019\n>>> import datarobot as dr\n>>> ... # get project or project_id\n>>> data_slices = dr.DataSlice.list(project)  # project object or project_id\n>>> data_slice = data_slices[0]  # choose a data slice from the list\n>>> status_check_job = data_slice.request_size(\"training\", model)\nget_size_info(source, model=None)\uf0c1\nGet information about the data slice applied to a source\nParameters:\nsource (INSIGHTS_SOURCES) \u2013 Source (partition or subset) to which the data slice was applied\nmodel (Optional[Union[str, Model]]) \u2013 ID for the model whose training data was sliced with this data slice.\nRequired when the source is \u201ctraining\u201d, and not used for other sources.\nReturns:\nslice_size_info \u2013 Information of the data slice applied to a source\nReturn type:\nDataSliceSizeInfo\nExamples\n>>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slices = dr.DataSlice.list(\"646d0ea0cd8eb2355a68b0e5\")\n>>> data_slice = slices[0]  # can be any slice in the list\n>>> data_slice_size_info = data_slice.get_size_info(\"validation\")\n>>> data_slice_size_info\nDataSliceSizeInfo(\ndata_slice_id=6493a1776ea78e6644382535,\nmessages=[\n{\n'level': 'WARNING',\n'description': 'Low Observation Count',\n'additional_info': 'Insufficient number of observations to compute some insights.'\n}\n],\nmodel_id=None,\nproject_id=646d0ea0cd8eb2355a68b0e5,\nslice_size=1,\nsource=validation,\n)\n>>> data_slice_size_info.to_dict()\n{\n'data_slice_id': '6493a1776ea78e6644382535',\n'messages': [\n{\n'level': 'WARNING',\n'description': 'Low Observation Count',\n'additional_info': 'Insufficient number of observations to compute some insights.'\n}\n],\n'model_id': None,\n'project_id': '646d0ea0cd8eb2355a68b0e5',\n'slice_size': 1,\n'source': 'validation',\n}\n>>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slice = dr.DataSlice.get(\"6493a1776ea78e6644382535\")\n>>> data_slice_size_info = data_slice.get_size_info(\"validation\")\nWhen using source=\u2019training\u2019, the model param is required.\n>>> import datarobot as dr\n>>> ...  # set up your Client\n>>> model = dr.Model.get(project_id, model_id)\n>>> data_slice = dr.DataSlice.get(\"6493a1776ea78e6644382535\")\n>>> data_slice_size_info = data_slice.get_size_info(\"training\", model)\n>>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slice = dr.DataSlice.get(\"6493a1776ea78e6644382535\")\n>>> data_slice_size_info = data_slice.get_size_info(\"training\", model_id)\nclassmethod get(data_slice_id)\uf0c1\nRetrieve a specific data slice.\nParameters:\ndata_slice_id (str) \u2013 The identifier of the data slice to retrieve.\nReturns:\ndata_slice \u2013 The required data slice.\nReturn type:\nDataSlice\nExamples\n>>> import datarobot as dr\n>>> dr.DataSlice.get('648b232b9da812a6aaa0b7a9')\nDataSlice(filters=[{'operand': 'binary_target', 'operator': 'eq', 'values': ['Yes']}],\nid=648b232b9da812a6aaa0b7a9,\nname=test,\nproject_id=644bc575572480b565ca42cd\n)\nclass datarobot.models.data_slice.DataSliceSizeInfo\uf0c1\nDefinition of a data slice applied to a source\nVariables:\ndata_slice_id (str) \u2013 ID of the data slice\nproject_id (str) \u2013 ID of the project\nsource (str) \u2013 Data source used to calculate the number of rows (slice size) after applying the data slice\u2019s filters\nmodel_id (Optional[str]) \u2013 ID of the model, required when source (subset) is \u2018training\u2019\nslice_size (int) \u2013 Number of rows in the data slice for a given source\nmessages (list[DataSliceSizeMessageType]) \u2013 List of user-relevant messages related to a data slice\nDatetime trend plots\uf0c1\nclass datarobot.models.datetime_trend_plots.AccuracyOverTimePlotsMetadata\uf0c1\nAccuracy over Time metadata for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nforecast_distance (int or None) \u2013 The forecast distance for which the metadata was retrieved. None for OTV projects.\nresolutions (list of string) \u2013 A list of datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION, which represents\navailable time resolutions for which plots can be retrieved.\nbacktest_metadata (list of dict) \u2013 List of backtest metadata dicts.\nThe list index of metadata dict is the backtest index.\nSee backtest/holdout metadata info in Notes for more details.\nholdout_metadata (dict) \u2013 Holdout metadata dict. See backtest/holdout metadata info in Notes for more details.\nbacktest_statuses (list of dict) \u2013 List of backtest statuses dict. The list index of status dict is the backtest index.\nSee backtest/holdout status info in Notes for more details.\nholdout_statuses (dict) \u2013 Holdout status dict. See backtest/holdout status info in Notes for more details.\nNotes\nBacktest/holdout status is a dict containing the following:\ntraining: stringStatus backtest/holdout training. One of datarobot.enums.DATETIME_TREND_PLOTS_STATUS\nvalidation: stringStatus backtest/holdout validation. One of datarobot.enums.DATETIME_TREND_PLOTS_STATUS\nBacktest/holdout metadata is a dict containing the following:\ntraining: dictStart and end dates for the backtest/holdout training.\nvalidation: dictStart and end dates for the backtest/holdout validation.\nEach dict in the training and validation in backtest/holdout metadata is structured like:\nstart_date: datetime.datetime or NoneThe datetime of the start of the chart data (inclusive). None if chart data is not computed.\nend_date: datetime.datetime or NoneThe datetime of the end of the chart data (exclusive). None if chart data is not computed.\nclass datarobot.models.datetime_trend_plots.AccuracyOverTimePlot\uf0c1\nAccuracy over Time plot for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nresolution (string) \u2013 The resolution that is used for binning.\nOne of datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION\nstart_date (datetime.datetime) \u2013 The datetime of the start of the chart data (inclusive).\nend_date (datetime.datetime) \u2013 The datetime of the end of the chart data (exclusive).\nbins (list of dict) \u2013 List of plot bins. See bin info in Notes for more details.\nstatistics (dict) \u2013 Statistics for plot. See statistics info in Notes for more details.\ncalendar_events (list of dict) \u2013 List of calendar events for the plot. See calendar events info in Notes for more details.\nNotes\nBin is a dict containing the following:\nstart_date: datetime.datetimeThe datetime of the start of the bin (inclusive).\nend_date: datetime.datetimeThe datetime of the end of the bin (exclusive).\nactual: float or NoneAverage actual value of the target in the bin. None if there are no entries in the bin.\npredicted: float or NoneAverage prediction of the model in the bin. None if there are no entries in the bin.\nfrequency: int or NoneIndicates number of values averaged in bin.\nStatistics is a dict containing the following:\ndurbin_watson: float or NoneThe Durbin-Watson statistic for the chart data.\nValue is between 0 and 4. Durbin-Watson statistic\nis a test statistic used to detect the presence of\nautocorrelation at lag 1 in the residuals (prediction errors)\nfrom a regression analysis. More info\nhttps://wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic\nCalendar event is a dict containing the following:\nname: stringName of the calendar event.\ndate: datetimeDate of the calendar event.\nseries_id: string or NoneThe series ID for the event. If this event does not specify a series ID,\nthen this will be None, indicating that the event applies to all series.\nclass datarobot.models.datetime_trend_plots.AccuracyOverTimePlotPreview\uf0c1\nAccuracy over Time plot preview for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nstart_date (datetime.datetime) \u2013 The datetime of the start of the chart data (inclusive).\nend_date (datetime.datetime) \u2013 The datetime of the end of the chart data (exclusive).\nbins (list of dict) \u2013 List of plot bins. See bin info in Notes for more details.\nNotes\nBin is a dict containing the following:\nstart_date: datetime.datetimeThe datetime of the start of the bin (inclusive).\nend_date: datetime.datetimeThe datetime of the end of the bin (exclusive).\nactual: float or NoneAverage actual value of the target in the bin. None if there are no entries in the bin.\npredicted: float or NoneAverage prediction of the model in the bin. None if there are no entries in the bin.\nclass datarobot.models.datetime_trend_plots.ForecastVsActualPlotsMetadata\uf0c1\nForecast vs Actual plots metadata for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nresolutions (list of string) \u2013 A list of datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION, which represents\navailable time resolutions for which plots can be retrieved.\nbacktest_metadata (list of dict) \u2013 List of backtest metadata dicts.\nThe list index of metadata dict is the backtest index.\nSee backtest/holdout metadata info in Notes for more details.\nholdout_metadata (dict) \u2013 Holdout metadata dict. See backtest/holdout metadata info in Notes for more details.\nbacktest_statuses (list of dict) \u2013 List of backtest statuses dict. The list index of status dict is the backtest index.\nSee backtest/holdout status info in Notes for more details.\nholdout_statuses (dict) \u2013 Holdout status dict. See backtest/holdout status info in Notes for more details.\nNotes\nBacktest/holdout status is a dict containing the following:\ntraining: dictDict containing each of datarobot.enums.DATETIME_TREND_PLOTS_STATUS as dict key,\nand list of forecast distances for particular status as dict value.\nvalidation: dictDict containing each of datarobot.enums.DATETIME_TREND_PLOTS_STATUS as dict key,\nand list of forecast distances for particular status as dict value.\nBacktest/holdout metadata is a dict containing the following:\ntraining: dictStart and end dates for the backtest/holdout training.\nvalidation: dictStart and end dates for the backtest/holdout validation.\nEach dict in the training and validation in backtest/holdout metadata is structured like:\nstart_date: datetime.datetime or NoneThe datetime of the start of the chart data (inclusive). None if chart data is not computed.\nend_date: datetime.datetime or NoneThe datetime of the end of the chart data (exclusive). None if chart data is not computed.\nclass datarobot.models.datetime_trend_plots.ForecastVsActualPlot\uf0c1\nForecast vs Actual plot for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nforecast_distances (list of int) \u2013 A list of forecast distances that were retrieved.\nresolution (string) \u2013 The resolution that is used for binning.\nOne of datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION\nstart_date (datetime.datetime) \u2013 The datetime of the start of the chart data (inclusive).\nend_date (datetime.datetime) \u2013 The datetime of the end of the chart data (exclusive).\nbins (list of dict) \u2013 List of plot bins. See bin info in Notes for more details.\ncalendar_events (list of dict) \u2013 List of calendar events for the plot. See calendar events info in Notes for more details.\nNotes\nBin is a dict containing the following:\nstart_date: datetime.datetimeThe datetime of the start of the bin (inclusive).\nend_date: datetime.datetimeThe datetime of the end of the bin (exclusive).\nactual: float or NoneAverage actual value of the target in the bin. None if there are no entries in the bin.\nforecasts: list of floatA list of average forecasts for the model for each forecast distance.\nEmpty if there are no forecasts in the bin.\nEach index in the forecasts list maps to forecastDistances list index.\nerror: float or NoneAverage absolute residual value of the bin.\nNone if there are no entries in the bin.\nnormalized_error: float or NoneNormalized average absolute residual value of the bin.\nNone if there are no entries in the bin.\nfrequency: int or NoneIndicates number of values averaged in bin.\nCalendar event is a dict containing the following:\nname: stringName of the calendar event.\ndate: datetimeDate of the calendar event.\nseries_id: string or NoneThe series ID for the event. If this event does not specify a series ID,\nthen this will be None, indicating that the event applies to all series.\nclass datarobot.models.datetime_trend_plots.ForecastVsActualPlotPreview\uf0c1\nForecast vs Actual plot preview for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nstart_date (datetime.datetime) \u2013 The datetime of the start of the chart data (inclusive).\nend_date (datetime.datetime) \u2013 The datetime of the end of the chart data (exclusive).\nbins (list of dict) \u2013 List of plot bins. See bin info in Notes for more details.\nNotes\nBin is a dict containing the following:\nstart_date: datetime.datetimeThe datetime of the start of the bin (inclusive).\nend_date: datetime.datetimeThe datetime of the end of the bin (exclusive).\nactual: float or NoneAverage actual value of the target in the bin. None if there are no entries in the bin.\npredicted: float or NoneAverage prediction of the model in the bin. None if there are no entries in the bin.\nclass datarobot.models.datetime_trend_plots.AnomalyOverTimePlotsMetadata\uf0c1\nAnomaly over Time metadata for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nresolutions (list of string) \u2013 A list of datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION, which represents\navailable time resolutions for which plots can be retrieved.\nbacktest_metadata (list of dict) \u2013 List of backtest metadata dicts.\nThe list index of metadata dict is the backtest index.\nSee backtest/holdout metadata info in Notes for more details.\nholdout_metadata (dict) \u2013 Holdout metadata dict. See backtest/holdout metadata info in Notes for more details.\nbacktest_statuses (list of dict) \u2013 List of backtest statuses dict. The list index of status dict is the backtest index.\nSee backtest/holdout status info in Notes for more details.\nholdout_statuses (dict) \u2013 Holdout status dict. See backtest/holdout status info in Notes for more details.\nNotes\nBacktest/holdout status is a dict containing the following:\ntraining: stringStatus backtest/holdout training. One of datarobot.enums.DATETIME_TREND_PLOTS_STATUS\nvalidation: stringStatus backtest/holdout validation. One of datarobot.enums.DATETIME_TREND_PLOTS_STATUS\nBacktest/holdout metadata is a dict containing the following:\ntraining: dictStart and end dates for the backtest/holdout training.\nvalidation: dictStart and end dates for the backtest/holdout validation.\nEach dict in the training and validation in backtest/holdout metadata is structured like:\nstart_date: datetime.datetime or NoneThe datetime of the start of the chart data (inclusive). None if chart data is not computed.\nend_date: datetime.datetime or NoneThe datetime of the end of the chart data (exclusive). None if chart data is not computed.\nclass datarobot.models.datetime_trend_plots.AnomalyOverTimePlot\uf0c1\nAnomaly over Time plot for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nresolution (string) \u2013 The resolution that is used for binning.\nOne of datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION\nstart_date (datetime.datetime) \u2013 The datetime of the start of the chart data (inclusive).\nend_date (datetime.datetime) \u2013 The datetime of the end of the chart data (exclusive).\nbins (list of dict) \u2013 List of plot bins. See bin info in Notes for more details.\ncalendar_events (list of dict) \u2013 List of calendar events for the plot. See calendar events info in Notes for more details.\nNotes\nBin is a dict containing the following:\nstart_date: datetime.datetimeThe datetime of the start of the bin (inclusive).\nend_date: datetime.datetimeThe datetime of the end of the bin (exclusive).\npredicted: float or NoneAverage prediction of the model in the bin. None if there are no entries in the bin.\nfrequency: int or NoneIndicates number of values averaged in bin.\nCalendar event is a dict containing the following:\nname: stringName of the calendar event.\ndate: datetimeDate of the calendar event.\nseries_id: string or NoneThe series ID for the event. If this event does not specify a series ID,\nthen this will be None, indicating that the event applies to all series.\nclass datarobot.models.datetime_trend_plots.AnomalyOverTimePlotPreview\uf0c1\nAnomaly over Time plot preview for datetime model.\nAdded in version v2.25.\nVariables:\nproject_id (string) \u2013 The project ID.\nmodel_id (string) \u2013 The model ID.\nprediction_threshold (float) \u2013 Only bins with predictions exceeding\nthis threshold are returned in the response.\nstart_date (datetime.datetime) \u2013 The datetime of the start of the chart data (inclusive).\nend_date (datetime.datetime) \u2013 The datetime of the end of the chart data (exclusive).\nbins (list of dict) \u2013 List of plot bins. See bin info in Notes for more details.\nNotes\nBin is a dict containing the following:\nstart_date: datetime.datetimeThe datetime of the start of the bin (inclusive).\nend_date: datetime.datetimeThe datetime of the end of the bin (exclusive).\nExternal scores and insights\uf0c1\nclass datarobot.ExternalScores\uf0c1\nMetric scores on prediction dataset with target or actual value column in unsupervised\ncase. Contains project metrics for supervised and special classification metrics set for\nunsupervised projects.\nAdded in version v2.21.\nVariables:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model\ndataset_id (str) \u2013 id of the prediction dataset with target or actual value column for unsupervised case\nactual_value_column (Optional[str]) \u2013 For unsupervised projects only.\nActual value column which was used to calculate the classification metrics and\ninsights on the prediction dataset.\nscores (list of dicts in a form of {'label': metric_name, 'value': score}) \u2013 Scores on the dataset.\nExamples\nList all scores for a dataset\nfrom datarobot.models.external_dataset_scores_insights.external_scores import ExternalScores\nscores = ExternalScores.list(project_id, dataset_id=dataset_id)\nclassmethod create(project_id, model_id, dataset_id, actual_value_column=None)\uf0c1\nCompute an external dataset insights for the specified model.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model for which insights is requested\ndataset_id (str) \u2013 id of the dataset for which insights is requested\nactual_value_column (Optional[str]) \u2013 actual values column label, for unsupervised projects only\nReturns:\njob \u2013 an instance of created async job\nReturn type:\nJob\nclassmethod list(project_id, model_id=None, dataset_id=None, offset=0, limit=100)\uf0c1\nFetch external scores list for the project and optionally for model and dataset.\nParameters:\nproject_id (str) \u2013 id of the project\nmodel_id (Optional[str]) \u2013 if specified, only scores for this model will be retrieved\ndataset_id (Optional[str]) \u2013 if specified, only scores for this dataset will be retrieved\noffset (Optional[int]) \u2013 this many results will be skipped, default: 0\nlimit (Optional[int]) \u2013 at most this many results are returned, default: 100, max 1000.\nTo return all results, specify 0\nReturn type:\nList[ExternalScores]\nReturns:\nA list of External Scores objects\nclassmethod get(project_id, model_id, dataset_id)\uf0c1\nRetrieve external scores for the project, model and dataset.\nParameters:\nproject_id (str) \u2013 id of the project\nmodel_id (str) \u2013 if specified, only scores for this model will be retrieved\ndataset_id (str) \u2013 if specified, only scores for this dataset will be retrieved\nReturn type:\nExternalScores\nReturns:\nExternal Scores object\nclass datarobot.ExternalLiftChart\uf0c1\nLift chart for the model and prediction dataset with target or actual value column in\nunsupervised case.\nAdded in version v2.21.\nLiftChartBin is a dict containing the following:\nactual (float) Sum of actual target values in bin\npredicted (float) Sum of predicted target values in bin\nbin_weight (float) The weight of the bin. For weighted projects, it is the sum of           the weights of the rows in the bin. For unweighted projects, it is the number of rows in           the bin.\nVariables:\ndataset_id (str) \u2013 id of the prediction dataset with target or actual value column for unsupervised case\nbins (list of dict) \u2013 List of dicts with schema described as LiftChartBin above.\nclassmethod list(project_id, model_id, dataset_id=None, offset=0, limit=100)\uf0c1\nRetrieve list of the lift charts for the model.\nParameters:\nproject_id (str) \u2013 id of the project\nmodel_id (str) \u2013 if specified, only lift chart for this model will be retrieved\ndataset_id (Optional[str]) \u2013 if specified, only lift chart for this dataset will be retrieved\noffset (Optional[int]) \u2013 this many results will be skipped, default: 0\nlimit (Optional[int]) \u2013 at most this many results are returned, default: 100, max 1000.\nTo return all results, specify 0\nReturn type:\nList[ExternalLiftChart]\nReturns:\nA list of ExternalLiftChart objects\nclassmethod get(project_id, model_id, dataset_id)\uf0c1\nRetrieve lift chart for the model and prediction dataset.\nParameters:\nproject_id (str) \u2013 project id\nmodel_id (str) \u2013 model id\ndataset_id (str) \u2013 prediction dataset id with target or actual value column for unsupervised case\nReturn type:\nExternalLiftChart\nReturns:\nExternalLiftChart object\nclass datarobot.ExternalRocCurve\uf0c1\nROC curve data for the model and prediction dataset with target or actual value column in\nunsupervised case.\nAdded in version v2.21.\nVariables:\ndataset_id (str) \u2013 id of the prediction dataset with target or actual value column for unsupervised case\nroc_points (list of dict) \u2013 List of precalculated metrics associated with thresholds for ROC curve.\nnegative_class_predictions (list of float) \u2013 List of predictions from example for negative class\npositive_class_predictions (list of float) \u2013 List of predictions from example for positive class\nclassmethod list(project_id, model_id, dataset_id=None, offset=0, limit=100)\uf0c1\nRetrieve list of the roc curves for the model.\nParameters:\nproject_id (str) \u2013 id of the project\nmodel_id (str) \u2013 if specified, only lift chart for this model will be retrieved\ndataset_id (Optional[str]) \u2013 if specified, only lift chart for this dataset will be retrieved\noffset (Optional[int]) \u2013 this many results will be skipped, default: 0\nlimit (Optional[int]) \u2013 at most this many results are returned, default: 100, max 1000.\nTo return all results, specify 0\nReturn type:\nList[ExternalRocCurve]\nReturns:\nA list of ExternalRocCurve objects\nclassmethod get(project_id, model_id, dataset_id)\uf0c1\nRetrieve ROC curve chart for the model and prediction dataset.\nParameters:\nproject_id (str) \u2013 project id\nmodel_id (str) \u2013 model id\ndataset_id (str) \u2013 prediction dataset id with target or actual value column for unsupervised case\nReturn type:\nExternalRocCurve\nReturns:\nExternalRocCurve object\nFeature association\uf0c1\nclass datarobot.models.FeatureAssociationMatrix\uf0c1\nFeature association statistics for a project.\nNotes\nProjects created prior to v2.17 are not supported by this feature.\nVariables:\nproject_id (str) \u2013 Id of the associated project.\nstrengths (list of dict) \u2013 Pairwise statistics for the available features as structured below.\nfeatures (list of dict) \u2013 Metadata for each feature and where it goes in the matrix.\nExamples\nimport datarobot as dr\n# retrieve feature association matrix\nfeature_association_matrix = dr.FeatureAssociationMatrix.get(project_id)\nfeature_association_matrix.strengths\nfeature_association_matrix.features\n# retrieve feature association matrix for a metric, association type or a feature list\nfeature_association_matrix = dr.FeatureAssociationMatrix.get(\nproject_id,\nmetric=enums.FEATURE_ASSOCIATION_METRIC.SPEARMAN,\nassociation_type=enums.FEATURE_ASSOCIATION_TYPE.CORRELATION,\nfeaturelist_id=featurelist_id,\n)\nclassmethod get(project_id, metric=None, association_type=None, featurelist_id=None)\uf0c1\nGet feature association statistics.\nParameters:\nproject_id (str) \u2013 Id of the project that contains the requested associations.\nmetric (enums.FEATURE_ASSOCIATION_METRIC) \u2013 The name of a metric to get pairwise data for. Since \u2018v2.19\u2019 this is optional and\ndefaults to enums.FEATURE_ASSOCIATION_METRIC.MUTUAL_INFO.\nassociation_type (enums.FEATURE_ASSOCIATION_TYPE) \u2013 The type of dependence for the data. Since \u2018v2.19\u2019 this is optional and defaults to\nenums.FEATURE_ASSOCIATION_TYPE.ASSOCIATION.\nfeaturelist_id (str or None) \u2013 Optional, the feature list to lookup FAM data for. By default, depending on the type of\nthe project \u201cInformative Features\u201d or \u201cTimeseries Informative Features\u201d list will be\nused.\n(New in version v2.19)\nReturns:\nFeature association pairwise metric strength data, feature clustering data, and\nordering data for Feature Association Matrix visualization.\nReturn type:\nFeatureAssociationMatrix\nclassmethod create(project_id, featurelist_id)\uf0c1\nCompute the Feature Association Matrix for a Feature List\nParameters:\nproject_id (str) \u2013 The ID of the project that the feature list belongs to.\nfeaturelist_id (str) \u2013 The ID of the feature list for which insights are requested.\nReturns:\nstatus_check_job \u2013 Object contains all needed logic for a periodical status check of an async job.\nReturn type:\nStatusCheckJob\nFeature association matrix details\uf0c1\nclass datarobot.models.FeatureAssociationMatrixDetails\uf0c1\nPlotting details for a pair of passed features present in the feature association matrix.\nNotes\nProjects created prior to v2.17 are not supported by this feature.\nVariables:\nproject_id (str) \u2013 Id of the project that contains the requested associations.\nchart_type (str) \u2013 Which type of plotting the pair of features gets in the UI.\ne.g. \u2018HORIZONTAL_BOX\u2019, \u2018VERTICAL_BOX\u2019, \u2018SCATTER\u2019 or \u2018CONTINGENCY\u2019\nvalues (list) \u2013 The data triplets for pairwise plotting e.g.\n{\u201cvalues\u201d: [[460.0, 428.5, 0.001], [1679.3, 259.0, 0.001], \u2026]\nThe first entry of each list is a value of feature1, the second entry of each list is a\nvalue of feature2, and the third is the relative frequency of the pair of datapoints in the\nsample.\nfeatures (list) \u2013 A list of the requested features, [feature1, feature2]\ntypes (list) \u2013 The type of feature1 and feature2. Possible values: \u201cCATEGORICAL\u201d, \u201cNUMERIC\u201d\nfeaturelist_id (str) \u2013 Id of the feature list to lookup FAM details for.\nclassmethod get(project_id, feature1, feature2, featurelist_id=None)\uf0c1\nGet a sample of the actual values used to measure the association between a pair of features\nAdded in version v2.17.\nParameters:\nproject_id (str) \u2013 Id of the project of interest.\nfeature1 (str) \u2013 Feature name for the first feature of interest.\nfeature2 (str) \u2013 Feature name for the second feature of interest.\nfeaturelist_id (str) \u2013 Optional, the feature list to lookup FAM data for. By default, depending on the type of\nthe project \u201cInformative Features\u201d or \u201cTimeseries Informative Features\u201d list will be\nused.\nReturns:\nThe feature association plotting for provided pair of features.\nReturn type:\nFeatureAssociationMatrixDetails\nFeature association featurelists\uf0c1\nclass datarobot.models.FeatureAssociationFeaturelists\uf0c1\nFeaturelists with feature association matrix availability flags for a project.\nVariables:\nproject_id (str) \u2013 Id of the project that contains the requested associations.\nfeaturelists (list fo dict) \u2013 The featurelists with the featurelist_id, title and the has_fam flag.\nclassmethod get(project_id)\uf0c1\nGet featurelists with feature association status for each.\nParameters:\nproject_id (str) \u2013 Id of the project of interest.\nReturns:\nFeaturelist with feature association status for each.\nReturn type:\nFeatureAssociationFeaturelists\nFeature effects\uf0c1\nclass datarobot.models.FeatureEffects\uf0c1\nFeature Effects provides partial dependence and predicted vs actual values for top-500\nfeatures ordered by feature impact score.\nThe partial dependence shows marginal effect of a feature on the target variable after\naccounting for the average effects of all other predictive features. It indicates how, holding\nall other variables except the feature of interest as they were, the value of this feature\naffects your prediction.\nVariables:\nproject_id (string) \u2013 The project that contains requested model\nmodel_id (string) \u2013 The model to retrieve Feature Effects for\nsource (string) \u2013 The source to retrieve Feature Effects for\ndata_slice_id (string or None) \u2013 The slice to retrieve Feature Effects for; if None, retrieve unsliced data\nfeature_effects (list) \u2013 Feature Effects for every feature\nbacktest_index (string, required only for DatetimeModels,) \u2013 The backtest index to retrieve Feature Effects for.\nNotes\nfeatureEffects is a dict containing the following:\nfeature_name (string) Name of the feature\nfeature_type (string) dr.enums.FEATURE_TYPE,           Feature type either numeric, categorical or datetime\nfeature_impact_score (float) Feature impact score\nweight_label (string) optional, Weight label if configured for the project else null\npartial_dependence (List) Partial dependence results\npredicted_vs_actual (List) optional, Predicted versus actual results,           may be omitted if there are insufficient qualified samples\npartial_dependence is a dict containing the following:\nis_capped (bool) Indicates whether the data for computation is capped\ndata (List) partial dependence results in the following format\ndata is a list of dict containing the following:\nlabel (string) Contains label for categorical and numeric features as string\ndependence (float) Value of partial dependence\npredicted_vs_actual is a dict containing the following:\nis_capped (bool) Indicates whether the data for computation is capped\ndata (List) pred vs actual results in the following format\ndata is a list of dict containing the following:\nlabel (string) Contains label for categorical features           for numeric features contains range or numeric value.\nbin (List) optional, For numeric features contains           labels for left and right bin limits\npredicted (float) Predicted value\nactual (float) Actual value. Actual value is null           for unsupervised timeseries models\nrow_count (int or float) Number of rows for the label and bin.           Type is float if weight or exposure is set for the project.\nclassmethod from_server_data(data, *args, use_insights_format=False, **kwargs)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing.\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nuse_insights_format (Optional[bool]) \u2013 Whether to repack the data from the format used in the GET /insights/featureEffects/ URL\nto the format used in the legacy URL.\nclass datarobot.models.FeatureEffectMetadata\uf0c1\nFeature Effect Metadata for model, contains status and available model sources.\nNotes\nsource is expected parameter to retrieve Feature Effect. One of provided sources\nshall be used.\nclass datarobot.models.FeatureEffectMetadataDatetime\uf0c1\nFeature Effect Metadata for datetime model, contains list of\nfeature effect metadata per backtest.\nNotes\nfeature effect metadata per backtest contains:\nstatus : str.\nbacktest_index : str.\nsources : List[str].\nsource is expected parameter to retrieve Feature Effect. One of provided sources\nshall be used.\nbacktest_index is expected parameter to submit compute request and retrieve Feature Effect.\nOne of provided backtest indexes shall be used.\nVariables:\ndata (list[FeatureEffectMetadataDatetimePerBacktest]) \u2013 List feature effect metadata per backtest\nclass datarobot.models.FeatureEffectMetadataDatetimePerBacktest\uf0c1\nConvert dictionary into feature effect metadata per backtest which contains backtest_index,\nstatus and sources.\nPayoff matrix\uf0c1\nclass datarobot.models.PayoffMatrix\uf0c1\nRepresents a Payoff Matrix, a costs/benefit scenario used for creating a profit curve.\nVariables:\nproject_id (str) \u2013 id of the project with which the payoff matrix is associated.\nid (str) \u2013 id of the payoff matrix.\nname (str) \u2013 User-supplied label for the payoff matrix.\ntrue_positive_value (float) \u2013 Cost or benefit of a true positive classification\ntrue_negative_value (float) \u2013 Cost or benefit of a true negative classification\nfalse_positive_value (float) \u2013 Cost or benefit of a false positive classification\nfalse_negative_value (float) \u2013 Cost or benefit of a false negative classification\nExamples\nimport datarobot as dr\n# create a payoff matrix\npayoff_matrix = dr.PayoffMatrix.create(\nproject_id,\nname,\ntrue_positive_value=100,\ntrue_negative_value=10,\nfalse_positive_value=0,\nfalse_negative_value=-10,\n)\n# list available payoff matrices\npayoff_matrices = dr.PayoffMatrix.list(project_id)\npayoff_matrix = payoff_matrices[0]\nclassmethod create(project_id, name, true_positive_value=1, true_negative_value=1, false_positive_value=-1, false_negative_value=-1)\uf0c1\nCreate a payoff matrix associated with a specific project.\nParameters:\nproject_id (str) \u2013 id of the project with which the payoff matrix will be associated\nReturns:\npayoff_matrix \u2013 The newly created payoff matrix\nReturn type:\nPayoffMatrix\nclassmethod list(project_id)\uf0c1\nFetch all the payoff matrices for a project.\nParameters:\nproject_id (str) \u2013 id of the project\nReturns:\nA list of PayoffMatrix objects\nReturn type:\nList of PayoffMatrix\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(project_id, id)\uf0c1\nRetrieve a specified payoff matrix.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nid (str) \u2013 id of the payoff matrix\nReturn type:\nPayoffMatrix\nReturns:\nPayoffMatrix object representing specified\npayoff matrix\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod update(project_id, id, name, true_positive_value, true_negative_value, false_positive_value, false_negative_value)\uf0c1\nUpdate (replace) a payoff matrix. Note that all data fields are required.\nParameters:\nproject_id (str) \u2013 id of the project to which the payoff matrix belongs\nid (str) \u2013 id of the payoff matrix\nname (str) \u2013 User-supplied label for the payoff matrix\ntrue_positive_value (float) \u2013 True positive payoff value to use for the profit curve\ntrue_negative_value (float) \u2013 True negative payoff value to use for the profit curve\nfalse_positive_value (float) \u2013 False positive payoff value to use for the profit curve\nfalse_negative_value (float) \u2013 False negative payoff value to use for the profit curve\nReturns:\nPayoffMatrix with updated values\nReturn type:\npayoff_matrix\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod delete(project_id, id)\uf0c1\nDelete a specified payoff matrix.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nid (str) \u2013 id of the payoff matrix\nReturns:\nresponse \u2013 Empty response (204)\nReturn type:\nrequests.Response\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nPrediction explanations\uf0c1\nclass datarobot.PredictionExplanationsInitialization\uf0c1\nRepresents a prediction explanations initialization of a model.\nVariables:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model the prediction explanations initialization is for\nprediction_explanations_sample (list of dict) \u2013 a small sample of prediction explanations that could be generated for the model\nclassmethod get(project_id, model_id)\uf0c1\nRetrieve the prediction explanations initialization for a model.\nPrediction explanations initializations are a prerequisite for computing prediction\nexplanations, and include a sample what the computed prediction explanations for a\nprediction dataset would look like.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model the prediction explanations initialization is for\nReturns:\nprediction_explanations_initialization \u2013 The queried instance.\nReturn type:\nPredictionExplanationsInitialization\nRaises:\nClientError \u2013 If the project or model does not exist or the initialization has not been computed.\nclassmethod create(project_id, model_id)\uf0c1\nCreate a prediction explanations initialization for the specified model.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model for which initialization is requested\nReturns:\njob \u2013 an instance of created async job\nReturn type:\nJob\ndelete()\uf0c1\nDelete this prediction explanations initialization.\nclass datarobot.PredictionExplanations\uf0c1\nRepresents prediction explanations metadata and provides access to computation results.\nExamples\nprediction_explanations = dr.PredictionExplanations.get(project_id, explanations_id)\nfor row in prediction_explanations.get_rows():\nprint(row)  # row is an instance of PredictionExplanationsRow\nVariables:\nid (str) \u2013 id of the record and prediction explanations computation result\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model the prediction explanations are for\ndataset_id (str) \u2013 id of the prediction dataset prediction explanations were computed for\nmax_explanations (int) \u2013 maximum number of prediction explanations to supply per row of the dataset\nthreshold_low (float) \u2013 the lower threshold, below which a prediction must score in order for prediction\nexplanations to be computed for a row in the dataset\nthreshold_high (float) \u2013 the high threshold, above which a prediction must score in order for prediction\nexplanations to be computed for a row in the dataset\nnum_columns (int) \u2013 the number of columns prediction explanations were computed for\nfinish_time (float) \u2013 timestamp referencing when computation for these prediction explanations finished\nprediction_explanations_location (str) \u2013 where to retrieve the prediction explanations\nsource (str) \u2013 For OTV/TS in-training predictions. Holds the portion of the training dataset used to generate\npredictions.\nclassmethod get(project_id, prediction_explanations_id)\uf0c1\nRetrieve a specific prediction explanations metadata.\nParameters:\nproject_id (str) \u2013 id of the project the explanations belong to\nprediction_explanations_id (str) \u2013 id of the prediction explanations\nReturns:\nprediction_explanations \u2013 The queried instance.\nReturn type:\nPredictionExplanations\nclassmethod create(project_id, model_id, dataset_id, max_explanations=None, threshold_low=None, threshold_high=None, mode=None)\uf0c1\nCreate prediction explanations for the specified dataset.\nIn order to create PredictionExplanations for a particular model and dataset, you must\nfirst:\nCompute feature impact for the model via datarobot.Model.get_feature_impact()\nCompute a PredictionExplanationsInitialization for the model via\ndatarobot.PredictionExplanationsInitialization.create(project_id, model_id)\nCompute predictions for the model and dataset via\ndatarobot.Model.request_predictions(dataset_id)\nthreshold_high and threshold_low are optional filters applied to speed up\ncomputation.  When at least one is specified, only the selected outlier rows will have\nprediction explanations computed. Rows are considered to be outliers if their predicted\nvalue (in case of regression projects) or probability of being the positive\nclass (in case of classification projects) is less than threshold_low or greater than\nthresholdHigh.  If neither is specified, prediction explanations will be computed for\nall rows.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model for which prediction explanations are requested\ndataset_id (str) \u2013 id of the prediction dataset for which prediction explanations are requested\nthreshold_low (Optional[float]) \u2013 the lower threshold, below which a prediction must score in order for prediction\nexplanations to be computed for a row in the dataset. If neither threshold_high nor\nthreshold_low is specified, prediction explanations will be computed for all rows.\nthreshold_high (Optional[float]) \u2013 the high threshold, above which a prediction must score in order for prediction\nexplanations to be computed. If neither threshold_high nor threshold_low is\nspecified, prediction explanations will be computed for all rows.\nmax_explanations (Optional[int]) \u2013 the maximum number of prediction explanations to supply per row of the dataset,\ndefault: 3.\nmode (PredictionExplanationsMode, optional) \u2013 mode of calculation for multiclass models, if not specified - server default is\nto explain only the predicted class, identical to passing TopPredictionsMode(1).\nReturns:\njob \u2013 an instance of created async job\nReturn type:\nJob\nclassmethod create_on_training_data(project_id, model_id, dataset_id, max_explanations=None, threshold_low=None, threshold_high=None, mode=None, datetime_prediction_partition=None)\uf0c1\nCreate prediction explanations for the the dataset used to train the model.\nThis can be retrieved by calling dr.Model.get().featurelist_id.\nFor OTV and timeseries projects, datetime_prediction_partition is required and limited to the\nfirst backtest (\u20180\u2019) or holdout (\u2018holdout\u2019).\nIn order to create PredictionExplanations for a particular model and dataset, you must\nfirst:\nCompute Feature Impact for the model via datarobot.Model.get_feature_impact()/\nCompute a PredictionExplanationsInitialization for the model via\ndatarobot.PredictionExplanationsInitialization.create(project_id, model_id).\nCompute predictions for the model and dataset via\ndatarobot.Model.request_predictions(dataset_id).\nthreshold_high and threshold_low are optional filters applied to speed up\ncomputation.  When at least one is specified, only the selected outlier rows will have\nprediction explanations computed. Rows are considered to be outliers if their predicted\nvalue (in case of regression projects) or probability of being the positive\nclass (in case of classification projects) is less than threshold_low or greater than\nthresholdHigh.  If neither is specified, prediction explanations will be computed for\nall rows.\nParameters:\nproject_id (str) \u2013 The ID of the project the model belongs to.\nmodel_id (str) \u2013 The ID of the model for which prediction explanations are requested.\ndataset_id (str) \u2013 The ID of the prediction dataset for which prediction explanations are requested.\nthreshold_low (Optional[float]) \u2013 The lower threshold, below which a prediction must score in order for prediction\nexplanations to be computed for a row in the dataset. If neither threshold_high nor\nthreshold_low is specified, prediction explanations will be computed for all rows.\nthreshold_high (Optional[float]) \u2013 The high threshold, above which a prediction must score in order for prediction\nexplanations to be computed. If neither threshold_high nor threshold_low is\nspecified, prediction explanations will be computed for all rows.\nmax_explanations (Optional[int]) \u2013 The maximum number of prediction explanations to supply per row of the dataset\n(default: 3).\nmode (PredictionExplanationsMode, optional) \u2013 The mode of calculation for multiclass models. If not specified, the server default is\nto explain only the predicted class, identical to passing TopPredictionsMode(1).\ndatetime_prediction_partition (str) \u2013 Options: \u20180\u2019, \u2018holdout\u2019 or None.\nUsed only by time series and OTV projects to indicate what part of the dataset\nwill be used to generate predictions for computing prediction explanation. Current\noptions are \u20180\u2019 (first backtest) and \u2018holdout\u2019.\nNote that only the validation partition of the first backtest will be used to\ngeneration predictions.\nReturns:\njob \u2013 An instance of created async job.\nReturn type:\nJob\nclassmethod list(project_id, model_id=None, limit=None, offset=None)\uf0c1\nList of prediction explanations metadata for a specified project.\nParameters:\nproject_id (str) \u2013 id of the project to list prediction explanations for\nmodel_id (Optional[str]) \u2013 if specified, only prediction explanations computed for this model will be returned\nlimit (int or None) \u2013 at most this many results are returned, default: no limit\noffset (int or None) \u2013 this many results will be skipped, default: 0\nReturns:\nprediction_explanations\nReturn type:\nlist[PredictionExplanations]\nget_rows(batch_size=None, exclude_adjusted_predictions=True)\uf0c1\nRetrieve prediction explanations rows.\nParameters:\nbatch_size (int or None, optional) \u2013 maximum number of prediction explanations rows to retrieve per request\nexclude_adjusted_predictions (bool) \u2013 Optional, defaults to True. Set to False to include adjusted predictions, which will\ndiffer from the predictions on some projects, e.g. those with an exposure column\nspecified.\nYields:\nprediction_explanations_row (PredictionExplanationsRow) \u2013 Represents prediction explanations computed for a prediction row.\nis_multiclass()\uf0c1\nWhether these explanations are for a multiclass project or a non-multiclass project\nis_unsupervised_clustering_or_multiclass()\uf0c1\nClustering and multiclass XEMP always has either one of num_top_classes or class_names\nparameters set\nget_number_of_explained_classes()\uf0c1\nHow many classes we attempt to explain for each row\nget_all_as_dataframe(exclude_adjusted_predictions=True)\uf0c1\nRetrieve all prediction explanations rows and return them as a pandas.DataFrame.\nReturned dataframe has the following structure:\nrow_id : row id from prediction dataset\nprediction : the output of the model for this row\nadjusted_prediction : adjusted prediction values (only appears for projects that\nutilize prediction adjustments, e.g. projects with an exposure column)\nclass_0_label : a class level from the target (only appears for classification\nprojects)\nclass_0_probability : the probability that the target is this class (only appears for\nclassification projects)\nclass_1_label : a class level from the target (only appears for classification\nprojects)\nclass_1_probability : the probability that the target is this class (only appears for\nclassification projects)\nexplanation_0_feature : the name of the feature contributing to the prediction for\nthis explanation\nexplanation_0_feature_value : the value the feature took on\nexplanation_0_label : the output being driven by this explanation.  For regression\nprojects, this is the name of the target feature.  For classification projects, this\nis the class label whose probability increasing would correspond to a positive\nstrength.\nexplanation_0_qualitative_strength : a human-readable description of how strongly the\nfeature affected the prediction (e.g. \u2018+++\u2019, \u2018\u2013\u2019, \u2018+\u2019) for this explanation\nexplanation_0_per_ngram_text_explanations : Text prediction explanations data in json\nformatted string.\nexplanation_0_strength : the amount this feature\u2019s value affected the prediction\n\u2026\nexplanation_N_feature : the name of the feature contributing to the prediction for\nthis explanation\nexplanation_N_feature_value : the value the feature took on\nexplanation_N_label : the output being driven by this explanation.  For regression\nprojects, this is the name of the target feature.  For classification projects, this\nis the class label whose probability increasing would correspond to a positive\nstrength.\nexplanation_N_qualitative_strength : a human-readable description of how strongly the\nfeature affected the prediction (e.g. \u2018+++\u2019, \u2018\u2013\u2019, \u2018+\u2019) for this explanation\nexplanation_N_per_ngram_text_explanations : Text prediction explanations data in json\nformatted string.\nexplanation_N_strength : the amount this feature\u2019s value affected the prediction\nFor classification projects, the server does not guarantee any ordering on the prediction\nvalues, however within this function we sort the values so that class_X corresponds to\nthe same class from row to row.\nParameters:\nexclude_adjusted_predictions (bool) \u2013 Optional, defaults to True. Set this to False to include adjusted prediction values in\nthe returned dataframe.\nReturns:\ndataframe\nReturn type:\npandas.DataFrame\ndownload_to_csv(filename, encoding='utf-8', exclude_adjusted_predictions=True)\uf0c1\nSave prediction explanations rows into CSV file.\nParameters:\nfilename (str or file object) \u2013 path or file object to save prediction explanations rows\nencoding (string, optional) \u2013 A string representing the encoding to use in the output file, defaults to \u2018utf-8\u2019\nexclude_adjusted_predictions (bool) \u2013 Optional, defaults to True. Set to False to include adjusted predictions, which will\ndiffer from the predictions on some projects, e.g. those with an exposure column\nspecified.\nget_prediction_explanations_page(limit=None, offset=None, exclude_adjusted_predictions=True)\uf0c1\nGet prediction explanations.\nIf you don\u2019t want use a generator interface, you can access paginated prediction\nexplanations directly.\nParameters:\nlimit (int or None) \u2013 the number of records to return, the server will use a (possibly finite) default if not\nspecified\noffset (int or None) \u2013 the number of records to skip, default 0\nexclude_adjusted_predictions (bool) \u2013 Optional, defaults to True. Set to False to include adjusted predictions, which will\ndiffer from the predictions on some projects, e.g. those with an exposure column\nspecified.\nReturns:\nprediction_explanations\nReturn type:\nPredictionExplanationsPage\ndelete()\uf0c1\nDelete these prediction explanations.\nclass datarobot.models.prediction_explanations.PredictionExplanationsRow\uf0c1\nRepresents prediction explanations computed for a prediction row.\nNotes\nPredictionValue contains:\nlabel : describes what this model output corresponds to.  For regression projects,\nit is the name of the target feature.  For classification projects, it is a level from\nthe target feature.\nvalue : the output of the prediction.  For regression projects, it is the predicted\nvalue of the target.  For classification projects, it is the predicted probability the\nrow belongs to the class identified by the label.\nPredictionExplanation contains:\nlabel : described what output was driven by this explanation.  For regression\nprojects, it is the name of the target feature.  For classification projects, it is the\nclass whose probability increasing would correspond to a positive strength of this\nprediction explanation.\nfeature : the name of the feature contributing to the prediction\nfeature_value : the value the feature took on for this row\nstrength : the amount this feature\u2019s value affected the prediction\nqualitative_strength : a human-readable description of how strongly the feature\naffected the prediction. A large positive effect is denoted \u2018+++\u2019, medium \u2018++\u2019, small \u2018+\u2019,\nvery small \u2018<+\u2019. A large negative effect is denoted \u2018\u2014\u2019, medium \u2018\u2013\u2019, small \u2018-\u2019, very\nsmall \u2018<-\u2018.\nVariables:\nrow_id (int) \u2013 which row this PredictionExplanationsRow describes\nprediction (float) \u2013 the output of the model for this row\nadjusted_prediction (float or None) \u2013 adjusted prediction value for projects that provide this information, None otherwise\nprediction_values (list) \u2013 an array of dictionaries with a schema described as PredictionValue\nadjusted_prediction_values (list) \u2013 same as prediction_values but for adjusted predictions\nprediction_explanations (list) \u2013 an array of dictionaries with a schema described as PredictionExplanation\nclass datarobot.models.prediction_explanations.PredictionExplanationsPage\uf0c1\nRepresents a batch of prediction explanations received by one request.\nVariables:\nid (str) \u2013 id of the prediction explanations computation result\ndata (list[dict]) \u2013 list of raw prediction explanations; each row corresponds to a row of the prediction dataset\ncount (int) \u2013 total number of rows computed\nprevious_page (str) \u2013 where to retrieve previous page of prediction explanations, None if current page is the\nfirst\nnext_page (str) \u2013 where to retrieve next page of prediction explanations, None if current page is the last\nprediction_explanations_record_location (str) \u2013 where to retrieve the prediction explanations metadata\nadjustment_method (str) \u2013 Adjustment method that was applied to predictions, or \u2018N/A\u2019 if no adjustments were done.\nclassmethod get(project_id, prediction_explanations_id, limit=None, offset=0, exclude_adjusted_predictions=True)\uf0c1\nRetrieve prediction explanations.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nprediction_explanations_id (str) \u2013 id of the prediction explanations\nlimit (int or None) \u2013 the number of records to return; the server will use a (possibly finite) default if not\nspecified\noffset (int or None) \u2013 the number of records to skip, default 0\nexclude_adjusted_predictions (bool) \u2013 Optional, defaults to True. Set to False to include adjusted predictions, which will\ndiffer from the predictions on some projects, e.g. those with an exposure column\nspecified.\nReturns:\nprediction_explanations \u2013 The queried instance.\nReturn type:\nPredictionExplanationsPage\nclass datarobot.models.ShapMatrix\uf0c1\nRepresents SHAP based prediction explanations and provides access to score values.\nVariables:\nproject_id (str) \u2013 id of the project the model belongs to\nshap_matrix_id (str) \u2013 id of the generated SHAP matrix\nmodel_id (str) \u2013 id of the model used to\ndataset_id (str) \u2013 id of the prediction dataset SHAP values were computed for\nExamples\nimport datarobot as dr\n# request SHAP matrix calculation\nshap_matrix_job = dr.ShapMatrix.create(project_id, model_id, dataset_id)\nshap_matrix = shap_matrix_job.get_result_when_complete()\n# list available SHAP matrices\nshap_matrices = dr.ShapMatrix.list(project_id)\nshap_matrix = shap_matrices[0]\n# get SHAP matrix as dataframe\nshap_matrix_values = shap_matrix.get_as_dataframe()\nclassmethod create(cls, project_id, model_id, dataset_id)\uf0c1\nCalculate SHAP based prediction explanations against previously uploaded dataset.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model for which prediction explanations are requested\ndataset_id (str) \u2013 id of the prediction dataset for which prediction explanations are requested (as\nuploaded from Project.upload_dataset)\nReturns:\njob \u2013 The job computing the SHAP based prediction explanations\nReturn type:\nShapMatrixJob\nRaises:\nClientError \u2013 If the server responded with 4xx status. Possible reasons are project, model or dataset\ndon\u2019t exist, user is not allowed or model doesn\u2019t support SHAP based prediction\nexplanations\nServerError \u2013 If the server responded with 5xx status\nclassmethod list(cls, project_id)\uf0c1\nFetch all the computed SHAP prediction explanations for a project.\nParameters:\nproject_id (str) \u2013 id of the project\nReturns:\nA list of ShapMatrix objects\nReturn type:\nList of ShapMatrix\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status\nclassmethod get(cls, project_id, id)\uf0c1\nRetrieve the specific SHAP matrix.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nid (str) \u2013 id of the SHAP matrix\nReturn type:\nShapMatrix object representing specified record\nget_as_dataframe(read_timeout=60)\uf0c1\nRetrieve SHAP matrix values as dataframe.\nReturn type:\nDataFrame\nReturns:\ndataframe (pandas.DataFrame) \u2013 A dataframe with SHAP scores\nread_timeout (int (optional, default 60)) \u2013 .. versionadded:: 2.29\nWait this many seconds for the server to respond.\nRaises:\ndatarobot.errors.ClientError \u2013 if the server responded with 4xx status.\ndatarobot.errors.ServerError \u2013 if the server responded with 5xx status.\nclass datarobot.models.ClassListMode\uf0c1\nCalculate prediction explanations for the specified classes in each row.\nVariables:\nclass_names (list) \u2013 List of class names that will be explained for each dataset row.\nget_api_parameters(batch_route=False)\uf0c1\nGet parameters passed in corresponding API call\nParameters:\nbatch_route (bool) \u2013 Batch routes describe prediction calls with all possible parameters, so to\ndistinguish explanation parameters from others they have prefix in parameters.\nReturn type:\ndict\nclass datarobot.models.TopPredictionsMode\uf0c1\nCalculate prediction explanations for the number of top predicted classes in each row.\nVariables:\nnum_top_classes (int) \u2013 Number of top predicted classes [1..10] that will be explained for each dataset row.\nget_api_parameters(batch_route=False)\uf0c1\nGet parameters passed in corresponding API call\nParameters:\nbatch_route (bool) \u2013 Batch routes describe prediction calls with all possible parameters, so to\ndistinguish explanation parameters from others they have prefix in parameters.\nReturn type:\ndict\nRating table\uf0c1\nclass datarobot.models.RatingTable\uf0c1\nInterface to modify and download rating tables.\nVariables:\nid (str) \u2013 The id of the rating table.\nproject_id (str) \u2013 The id of the project this rating table belongs to.\nrating_table_name (str) \u2013 The name of the rating table.\noriginal_filename (str) \u2013 The name of the file used to create the rating table.\nparent_model_id (str) \u2013 The model id of the model the rating table was validated against.\nmodel_id (str) \u2013 The model id of the model that was created from the rating table.\nCan be None if a model has not been created from the rating table.\nmodel_job_id (str) \u2013 The id of the job to create a model from this rating table.\nCan be None if a model has not been created from the rating table.\nvalidation_job_id (str) \u2013 The id of the created job to validate the rating table.\nCan be None if the rating table has not been validated.\nvalidation_error (str) \u2013 Contains a description of any errors caused during validation.\nclassmethod from_server_data(data, should_warn=True, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nshould_warn (bool) \u2013 Whether or not to issue a warning if an invalid rating table is being retrieved.\nReturn type:\nRatingTable\nclassmethod get(project_id, rating_table_id)\uf0c1\nRetrieve a single rating table\nParameters:\nproject_id (str) \u2013 The ID of the project the rating table is associated with.\nrating_table_id (str) \u2013 The ID of the rating table\nReturns:\nrating_table \u2013 The queried instance\nReturn type:\nRatingTable\nclassmethod create(project_id, parent_model_id, filename, rating_table_name='Uploaded Rating Table')\uf0c1\nUploads and validates a new rating table CSV\nParameters:\nproject_id (str) \u2013 id of the project the rating table belongs to\nparent_model_id (str) \u2013 id of the model for which this rating table should be validated against\nfilename (str) \u2013 The path of the CSV file containing the modified rating table.\nrating_table_name (Optional[str]) \u2013 A human friendly name for the new rating table. The string may be\ntruncated and a suffix may be added to maintain unique names of all\nrating tables.\nReturns:\njob \u2013 an instance of created async job\nReturn type:\nJob\nRaises:\nInputNotUnderstoodError \u2013 Raised if filename isn\u2019t one of supported types.\nClientError \u2013 Raised if parent_model_id is invalid.\ndownload(filepath)\uf0c1\nDownload a csv file containing the contents of this rating table\nParameters:\nfilepath (str) \u2013 The path at which to save the rating table file.\nReturn type:\nNone\nrename(rating_table_name)\uf0c1\nRenames a rating table to a different name.\nParameters:\nrating_table_name (str) \u2013 The new name to rename the rating table to.\nReturn type:\nNone\ncreate_model()\uf0c1\nCreates a new model from this rating table record. This rating table\nmust not already be associated with a model and must be valid.\nReturns:\njob \u2013 an instance of created async job\nReturn type:\nJob\nRaises:\nClientError \u2013 Raised if creating model from a RatingTable that failed validation\nJobAlreadyRequested \u2013 Raised if creating model from a RatingTable that is already\nassociated with a RatingTableModel\nROC curve\uf0c1\nclass datarobot.models.roc_curve.RocCurve\uf0c1\nROC curve data for model.\nVariables:\nsource (str) \u2013 ROC curve data source. Can be \u2018validation\u2019, \u2018crossValidation\u2019 or \u2018holdout\u2019.\nroc_points (list of dict) \u2013 List of precalculated metrics associated with thresholds for ROC curve.\nnegative_class_predictions (list of float) \u2013 List of predictions from example for negative class\npositive_class_predictions (list of float) \u2013 List of predictions from example for positive class\nsource_model_id (str) \u2013 ID of the model this ROC curve represents; in some cases,\ninsights from the parent of a frozen model may be used\ndata_slice_id (str) \u2013 ID of the data slice this ROC curve represents.\nclassmethod from_server_data(data, keep_attrs=None, use_insights_format=False, **kwargs)\uf0c1\nOverwrite APIObject.from_server_data to handle roc curve data retrieved\nfrom either legacy URL or /insights/ new URL.\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place.\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nuse_insights_format (Optional[bool]) \u2013 Whether to repack the data from the format used in the GET /insights/RocCur/ URL\nto the format used in the legacy URL.\nReturn type:\nRocCurve\nclass datarobot.models.roc_curve.LabelwiseRocCurve\uf0c1\nLabelwise ROC curve data for one label and one source.\nVariables:\nsource (str) \u2013 ROC curve data source. Can be \u2018validation\u2019, \u2018crossValidation\u2019 or \u2018holdout\u2019.\nroc_points (list of dict) \u2013 List of precalculated metrics associated with thresholds for ROC curve.\nnegative_class_predictions (list of float) \u2013 List of predictions from example for negative class\npositive_class_predictions (list of float) \u2013 List of predictions from example for positive class\nsource_model_id (str) \u2013 ID of the model this ROC curve represents; in some cases,\ninsights from the parent of a frozen model may be used\nlabel (str) \u2013 Label name for\nkolmogorov_smirnov_metric (float) \u2013 Kolmogorov-Smirnov metric value for label\nauc (float) \u2013 AUC metric value for label\nWord Cloud\uf0c1\nclass datarobot.models.word_cloud.WordCloud\uf0c1\nWord cloud data for the model.\nNotes\nWordCloudNgram is a dict containing the following:\nngram (str) Word or ngram value.\ncoefficient (float) Value from [-1.0, 1.0] range, describes effect of this ngram on           the target. Large negative value means strong effect toward negative class in           classification and smaller target value in regression models. Large positive - toward           positive class and bigger value respectively.\ncount (int) Number of rows in the training sample where this ngram appears.\nfrequency (float) Value from (0.0, 1.0] range, relative frequency of given ngram to           most frequent ngram.\nis_stopword (bool) True for ngrams that DataRobot evaluates as stopwords.\nclass (str or None) For classification - values of the target class for\ncorresponding word or ngram. For regression - None.\nVariables:\nngrams (list of dict) \u2013 List of dicts with schema described as WordCloudNgram above.\nmost_frequent(top_n=5)\uf0c1\nReturn most frequent ngrams in the word cloud.\nParameters:\ntop_n (int) \u2013 Number of ngrams to return\nReturns:\nUp to top_n top most frequent ngrams in the word cloud.\nIf top_n bigger then total number of ngrams in word cloud - return all sorted by\nfrequency in descending order.\nReturn type:\nlist of dict\nmost_important(top_n=5)\uf0c1\nReturn most important ngrams in the word cloud.\nParameters:\ntop_n (int) \u2013 Number of ngrams to return\nReturns:\nUp to top_n top most important ngrams in the word cloud.\nIf top_n bigger then total number of ngrams in word cloud - return all sorted by\nabsolute coefficient value in descending order.\nReturn type:\nlist of dict\nngrams_per_class()\uf0c1\nSplit ngrams per target class values. Useful for multiclass models.\nReturns:\nDictionary in the format of (class label) -> (list of ngrams for that class)\nReturn type:\ndict\nclass datarobot.models.word_cloud.WordCloudNgram\uf0c1",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.AnomalyAssessmentStatus",
        ">>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slices = dr.DataSlice.list(\"646d0ea0cd8eb2355a68b0e5\")\n>>> data_slices\n[DataSlice(...), DataSlice(...), ...]",
        ">>> import datarobot as dr\n>>> ...  # set up your Client and retrieve a project\n>>> data_slice = dr.DataSlice.create(\n>>> ...    name='yes',\n>>> ...    filters=[{'operand': 'binary_target', 'operator': 'eq', 'values': ['Yes']}],\n>>> ...    project=project,\n>>> ...  )\n>>> data_slice\nDataSlice(\n    filters=[{'operand': 'binary_target', 'operator': 'eq', 'values': ['Yes']}],\n    id=646d1296bd0c543d88923c9d,\n    name=yes,\n    project_id=646d0ea0cd8eb2355a68b0e5\n)",
        ">>> import datarobot as dr\n>>> data_slice = dr.DataSlice.get('5a8ac9ab07a57a0001be501f')\n>>> data_slice.delete()",
        ">>> import datarobot as dr\n>>> ... # get project or project_id\n>>> data_slices = dr.DataSlice.list(project)  # project object or project_id\n>>> data_slice = data_slices[0]  # choose a data slice from the list\n>>> data_slice.delete()",
        ">>> import datarobot as dr\n>>> ... # get project or project_id\n>>> data_slices = dr.DataSlice.list(project)  # project object or project_id\n>>> data_slice = data_slices[0]  # choose a data slice from the list\n>>> status_check_job = data_slice.request_size(\"validation\")",
        ">>> import datarobot as dr\n>>> ... # get project or project_id\n>>> data_slices = dr.DataSlice.list(project)  # project object or project_id\n>>> data_slice = data_slices[0]  # choose a data slice from the list\n>>> status_check_job = data_slice.request_size(\"training\", model)",
        ">>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slices = dr.DataSlice.list(\"646d0ea0cd8eb2355a68b0e5\")\n>>> data_slice = slices[0]  # can be any slice in the list\n>>> data_slice_size_info = data_slice.get_size_info(\"validation\")\n>>> data_slice_size_info\nDataSliceSizeInfo(\n    data_slice_id=6493a1776ea78e6644382535,\n    messages=[\n        {\n            'level': 'WARNING',\n            'description': 'Low Observation Count',\n            'additional_info': 'Insufficient number of observations to compute some insights.'\n        }\n    ],\n    model_id=None,\n    project_id=646d0ea0cd8eb2355a68b0e5,\n    slice_size=1,\n    source=validation,\n)\n>>> data_slice_size_info.to_dict()\n{\n    'data_slice_id': '6493a1776ea78e6644382535',\n    'messages': [\n        {\n            'level': 'WARNING',\n            'description': 'Low Observation Count',\n            'additional_info': 'Insufficient number of observations to compute some insights.'\n        }\n    ],\n    'model_id': None,\n    'project_id': '646d0ea0cd8eb2355a68b0e5',\n    'slice_size': 1,\n    'source': 'validation',\n}",
        ">>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slice = dr.DataSlice.get(\"6493a1776ea78e6644382535\")\n>>> data_slice_size_info = data_slice.get_size_info(\"validation\")",
        ">>> import datarobot as dr\n>>> ...  # set up your Client\n>>> model = dr.Model.get(project_id, model_id)\n>>> data_slice = dr.DataSlice.get(\"6493a1776ea78e6644382535\")\n>>> data_slice_size_info = data_slice.get_size_info(\"training\", model)",
        ">>> import datarobot as dr\n>>> ...  # set up your Client\n>>> data_slice = dr.DataSlice.get(\"6493a1776ea78e6644382535\")\n>>> data_slice_size_info = data_slice.get_size_info(\"training\", model_id)",
        ">>> import datarobot as dr\n>>> dr.DataSlice.get('648b232b9da812a6aaa0b7a9')\nDataSlice(filters=[{'operand': 'binary_target', 'operator': 'eq', 'values': ['Yes']}],\n          id=648b232b9da812a6aaa0b7a9,\n          name=test,\n          project_id=644bc575572480b565ca42cd\n          )",
        "datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "datarobot.enums.DATETIME_TREND_PLOTS_STATUS",
        "datarobot.enums.DATETIME_TREND_PLOTS_STATUS",
        "datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "datarobot.enums.DATETIME_TREND_PLOTS_STATUS",
        "datarobot.enums.DATETIME_TREND_PLOTS_STATUS",
        "datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "datarobot.enums.DATETIME_TREND_PLOTS_STATUS",
        "datarobot.enums.DATETIME_TREND_PLOTS_STATUS",
        "datarobot.enums.DATETIME_TREND_PLOTS_RESOLUTION",
        "from datarobot.models.external_dataset_scores_insights.external_scores import ExternalScores\nscores = ExternalScores.list(project_id, dataset_id=dataset_id)",
        "import datarobot as dr\n\n# retrieve feature association matrix\nfeature_association_matrix = dr.FeatureAssociationMatrix.get(project_id)\nfeature_association_matrix.strengths\nfeature_association_matrix.features\n\n# retrieve feature association matrix for a metric, association type or a feature list\nfeature_association_matrix = dr.FeatureAssociationMatrix.get(\n    project_id,\n    metric=enums.FEATURE_ASSOCIATION_METRIC.SPEARMAN,\n    association_type=enums.FEATURE_ASSOCIATION_TYPE.CORRELATION,\n    featurelist_id=featurelist_id,\n)",
        "required only for DatetimeModels,",
        "import datarobot as dr\n\n# create a payoff matrix\npayoff_matrix = dr.PayoffMatrix.create(\n    project_id,\n    name,\n    true_positive_value=100,\n    true_negative_value=10,\n    false_positive_value=0,\n    false_negative_value=-10,\n)\n\n# list available payoff matrices\npayoff_matrices = dr.PayoffMatrix.list(project_id)\npayoff_matrix = payoff_matrices[0]",
        "prediction_explanations = dr.PredictionExplanations.get(project_id, explanations_id)\nfor row in prediction_explanations.get_rows():\n    print(row)  # row is an instance of PredictionExplanationsRow",
        "datarobot.Model.get_feature_impact()",
        "datarobot.PredictionExplanationsInitialization.create(project_id, model_id)",
        "datarobot.Model.request_predictions(dataset_id)",
        "dr.Model.get().featurelist_id",
        "datarobot.Model.get_feature_impact()",
        "datarobot.PredictionExplanationsInitialization.create(project_id, model_id)",
        "datarobot.Model.request_predictions(dataset_id)",
        "import datarobot as dr\n\n# request SHAP matrix calculation\nshap_matrix_job = dr.ShapMatrix.create(project_id, model_id, dataset_id)\nshap_matrix = shap_matrix_job.get_result_when_complete()\n\n# list available SHAP matrices\nshap_matrices = dr.ShapMatrix.list(project_id)\nshap_matrix = shap_matrices[0]\n\n# get SHAP matrix as dataframe\nshap_matrix_values = shap_matrix.get_as_dataframe()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/notebooks.html",
      "title": "Notebooks\uf0c1",
      "description": "",
      "content": "Notebooks\uf0c1\nclass datarobot.models.notebooks.enums.NotebookType\uf0c1\nTypes of notebooks.\nclass datarobot.models.notebooks.enums.RunType\uf0c1\nTypes of notebook job runs.\nclass datarobot.models.notebooks.enums.ManualRunType\uf0c1\nA subset of RunType\nTo be used in API schemas.\nclass datarobot.models.notebooks.enums.SessionType\uf0c1\nTypes of notebook sessions. Triggered sessions include notebook job runs whether manually triggered or scheduled.\nclass datarobot.models.notebooks.enums.ScheduleStatus\uf0c1\nPossible statuses for notebook schedules.\nclass datarobot.models.notebooks.enums.ScheduledRunStatus\uf0c1\nPossible statuses for scheduled notebook runs.\nclass datarobot.models.notebooks.enums.NotebookPermissions\uf0c1\nPermissions for notebooks.\nclass datarobot.models.notebooks.enums.NotebookStatus\uf0c1\nPossible statuses for notebook sessions.\nclass datarobot.models.notebooks.enums.KernelExecutionStatus\uf0c1\nPossible statuses for kernel execution.\nclass datarobot.models.notebooks.enums.CellType\uf0c1\nTypes of cells in a notebook.\nclass datarobot.models.notebooks.enums.RuntimeLanguage\uf0c1\nLanguages as used in notebook jupyter kernels.\nclass datarobot.models.notebooks.enums.ImageLanguage\uf0c1\nLanguages as used and supported in notebook images.\nclass datarobot.models.notebooks.enums.KernelSpec\uf0c1\nKernel specifications for Jupyter notebook kernels.\nclass datarobot.models.notebooks.enums.KernelState\uf0c1\nPossible states for notebook kernels.\nexception datarobot.models.notebooks.exceptions.KernelNotAssignedError\uf0c1\nRaised when a Codespace notebook does not have a kernel assigned.\nclass datarobot.models.notebooks.notebook.ManualRunPayload\uf0c1\nclass datarobot.models.notebooks.notebook.Notebook\uf0c1\nMetadata for a DataRobot Notebook accessible to the user.\nVariables:\nid (str) \u2013 The ID of the Notebook.\nname (str) \u2013 The name of the Notebook.\ntype (NotebookType) \u2013 The type of the Notebook. Can be \u201cplain\u201d or \u201ccodespace\u201d.\npermissions (List[NotebookPermissions]) \u2013 The permissions the user has for the Notebook.\ntags (List[str]) \u2013 Any tags that have been added to the Notebook. Default is an empty list.\ncreated (NotebookActivity) \u2013 Information on when the Notebook was created and who created it.\nupdated (NotebookActivity) \u2013 Information on when the Notebook was updated and who updated it.\nlast_viewed (NotebookActivity) \u2013 Information on when the Notebook was last viewed and who viewed it.\nsettings (NotebookSettings) \u2013 Information on global settings applied to the Notebook.\norg_id (Optional[str]) \u2013 The organization ID associated with the Notebook.\ntenant_id (Optional[str]) \u2013 The tenant ID associated with the Notebook.\ndescription (Optional[str]) \u2013 The description of the Notebook. Optional.\nsession (Optional[NotebookSession]) \u2013 Metadata on the current status of the Notebook and its kernel. Optional.\nuse_case_id (Optional[str]) \u2013 The ID of the Use Case the Notebook is associated with. Optional.\nuse_case_name (Optional[str]) \u2013 The name of the Use Case the Notebook is associated with. Optional.\nhas_schedule (bool) \u2013 Whether or not the notebook has a schedule.\nhas_enabled_schedule (bool) \u2013 Whether or not the notebook has a currently enabled schedule.\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this Notebook in its Use Case or standalone.\nReturn type:\nstr\nclassmethod get(notebook_id)\uf0c1\nRetrieve a single notebook.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook you want to retrieve.\nReturns:\nnotebook \u2013 The requested notebook.\nReturn type:\nNotebook\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\ncreate_revision(name=None, notebook_path=None, is_auto=False)\uf0c1\nCreate a new revision for the notebook.\nParameters:\nname (Optional[str]) \u2013 The name of the revision. Optional.\nnotebook_path (Optional[str]) \u2013 The path of the notebook to execute within the codespace. Required if notebook is in a codespace.\nis_auto (bool) \u2013 Indicates whether the revision was auto-saved versus a user interaction. Default is False.\nReturns:\nnotebook_revision \u2013 Information about the created notebook revision.\nReturn type:\nNotebookRevision\ndownload_revision(revision_id, file_path=None, filelike=None)\uf0c1\nDownloads the notebook as a JSON (.ipynb) file for the specified revision.\nParameters:\nfile_path (string, optional) \u2013 The destination to write the file to.\nfilelike (file, optional) \u2013 A file-like object to write to.  The object must be able to write bytes. The user is\nresponsible for closing the object.\nReturn type:\nNone\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nmanual_run = notebook.run_as_job()\nrevision_id = manual_run.wait_for_completion()\nnotebook.download_revision(revision_id=revision_id, file_path=\"./results.ipynb\")\ndelete()\uf0c1\nDelete a single notebook\n:rtype: None\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nnotebook.delete()\nclassmethod list(created_before=None, created_after=None, order_by=None, tags=None, owners=None, query=None, use_cases=None)\uf0c1\nList all Notebooks available to the user.\nParameters:\ncreated_before (Optional[str]) \u2013 List Notebooks created before a certain date. Optional.\ncreated_after (Optional[str]) \u2013 List Notebooks created after a certain date. Optional.\norder_by (Optional[str]) \u2013 Property to sort returned Notebooks. Optional.\nSupported properties are \u201cname\u201d, \u201ccreated\u201d, \u201cupdated\u201d, \u201ctags\u201d, and \u201clastViewed\u201d.\nPrefix the attribute name with a dash to sort in descending order,\ne.g. order_by=\u2019-created\u2019.\nBy default, the order_by parameter is None.\ntags (Optional[List[str]]) \u2013 A list of tags that returned Notebooks should be associated with. Optional.\nowners (Optional[List[str]]) \u2013 A list of user IDs used to filter returned Notebooks.\nThe respective users share ownership of the Notebooks. Optional.\nquery (Optional[str]) \u2013 A specific regex query to use when filtering Notebooks. Optional.\nuse_cases (Optional[UseCase or List[UseCase] or str or List[str]]) \u2013 Filters returned Notebooks by a specific Use Case or Cases. Accepts either the entity or the ID. Optional.\nIf set to [None], the method filters the notebook\u2019s datasets by those not linked to a UseCase.\nReturns:\nnotebooks \u2013 A list of Notebooks available to the user.\nReturn type:\nList[Notebook]\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebooks = Notebook.list()\nis_running()\uf0c1\nCheck if the notebook session is currently running.\nReturn type:\nbool\nget_session_status()\uf0c1\nGet the status of the notebook session.\nReturn type:\nNotebookStatus\nstart_session(is_triggered_run=False, parameters=None, open_file_paths=None, clone_repository=None)\uf0c1\nStart a new session for the notebook.\nParameters:\nis_triggered_run (bool) \u2013 Whether the session being started is considered an \u201cinteractive\u201d or \u201ctriggered\u201d session. Default is False.\nparameters (Optional[List[StartSessionParameters]]) \u2013 A list of dictionaries in the format {\u201cname\u201d: \u201cFOO\u201d, \u201cvalue\u201d: \u201cmy_value\u201d}  representing environment\nvariables propagated to the notebook session.\nopen_file_paths (Optional[List[str]]) \u2013 A list of file paths to open upon instantiation of the notebook session.\nclone_repository (Optional[CloneRepositorySchema]) \u2013 Information used to clone a remote repository as part of the environment setup flow.\nReturns:\nnotebook_session \u2013 The created notebook session.\nReturn type:\nNotebookSession\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nsession = notebook.start_session()\nstop_session()\uf0c1\nStop the current session for the notebook.\nReturns:\nnotebook_session \u2013 The stopped notebook session.\nReturn type:\nNotebookSession\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nsession = notebook.stop_session()\nexecute(notebook_path=None, cell_ids=None)\uf0c1\nExecute the notebook. Assumes session is already started.\nParameters:\nnotebook_path (Optional[str]) \u2013 The path of the notebook to execute within the Codespace. Required if the notebook is in a Codespace.\ncell_ids (Optional[List[str]]) \u2013 The list of cell IDs to execute for a notebook. Not supported if the notebook is in a Codespace. Optional.\nIf not provided, the whole notebook will be executed.\nReturn type:\nNone\nget_execution_status()\uf0c1\nGet the execution status information of the notebook.\nReturns:\nexecution_status \u2013 The notebook execution status information.\nReturn type:\nNotebookExecutionStatus\nis_finished_executing(notebook_path=None)\uf0c1\nCheck if the notebook is finished executing.\nParameters:\nnotebook_path (Optional[str]) \u2013 The path of the notebook the Codespace. Required only if the notebook is in a Codespace.\nWill raise an error if working with a standalone notebook.\nReturns:\nis_finished_executing \u2013 Whether or not the notebook has finished executing.\nReturn type:\nbool\nRaises:\nInvalidUsageError \u2013 If attempting to check if a standalone notebook has finished executing and incorrectly\npassing a notebook path.\nIf attempting to check if a codespace notebook has finished executing without passing a\nnotebook path.\nKernelNotAssignedError \u2013 If attempting to check if a codespace notebook has finished executing but the notebook\ndoes not have a kernel assigned.\nrun_as_job(title=None, notebook_path=None, parameters=None, manual_run_type=ManualRunType.MANUAL)\uf0c1\nCreate a manual scheduled job that runs the notebook.\nNotes\nThe notebook must be part of a Use Case.\nIf the notebook is in a Codespace then notebook_path is required.\nParameters:\ntitle (Optional[str]) \u2013 The title of the background job. Optional.\nnotebook_path (Optional[str]) \u2013 The path of the notebook to execute within the Codespace. Required if notebook is in a Codespace.\nparameters (Optional[List[StartSessionParameters]]) \u2013 A list of dictionaries in the format {\u201cname\u201d: \u201cFOO\u201d, \u201cvalue\u201d: \u201cmy_value\u201d}  representing environment\nvariables predefined in the notebook session. Optional.\nmanual_run_type (Optional[ManualRunType]) \u2013 The type of manual run being triggered. Defaults to \u201cmanual\u201d as opposed to \u201cpipeline\u201d.\nReturns:\nnotebook_scheduled_job \u2013 The created notebook schedule job.\nReturn type:\nNotebookScheduledJob\nRaises:\nInvalidUsageError \u2013 If attempting to create a manual scheduled run for a Codespace without a notebook path.\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nmanual_run = notebook.run_as_job()\n# Alternatively, with title and parameters:\n# manual_run = notebook.run_as_job(title=\"My Run\", parameters=[{\"name\": \"FOO\", \"value\": \"bar\"}])\nrevision_id = manual_run.wait_for_completion()\nlist_schedules(enabled_only=False)\uf0c1\nList all NotebookScheduledJobs associated with the notebook.\nParameters:\nenabled_only (bool) \u2013 Whether or not to return only enabled schedules.\nReturns:\nnotebook_schedules \u2013 A list of schedules for the notebook.\nReturn type:\nList[NotebookScheduledJob]\nRaises:\nInvalidUsageError \u2013 If attempting to list schedules for a notebook not associated with a Use Case.\nExamples\nfrom datarobot.models.notebooks import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nenabled_schedules = notebook.list_schedules(enabled_only=True)\nclass datarobot.models.notebooks.execution_environment.ExecutionEnvironmentAssignPayload\uf0c1\nPayload for assigning an execution environment to a notebook.\nclass datarobot.models.notebooks.execution_environment.Image\uf0c1\nExecution environment image information.\nVariables:\nid (str) \u2013 The ID of the image.\nname (str) \u2013 The name of the image.\ndefault (bool) \u2013 Whether the image is the default image.\ndescription (str) \u2013 The description of the image.\nenvironment_id (str) \u2013 The ID of the environment.\ngpu_optimized (bool) \u2013 Whether the image is GPU optimized.\nlanguage (ImageLanguage) \u2013 The runtime language of the image. For example \u201cPython\u201d or \u201cR\u201d\nlanguage_version (str) \u2013 The version of the language. For example \u201c3.11\u201d or \u201c4.3\u201d\nlibraries (list[str]) \u2013 A list of pre-installed libraries on the image.\nclass datarobot.models.notebooks.execution_environment.Machine\uf0c1\nExecution environment machine information.\nVariables:\nid (str) \u2013 The ID of the machine.\nname (str) \u2013 The name of the machine. Values include \u201cXS\u201d, \u201cS\u201d, \u201cM\u201d, \u201cL\u201d etc.\ndefault (bool) \u2013 Whether the machine is the default machine.\ncpu (str) \u2013 The CPU of the machine. For example a value like \u201c2000m\u201d.\ncpu_cores (int) \u2013 The number of CPU cores.\nephemeral_storage (str) \u2013 The ephemeral storage of the machine. For example a value like \u201c15Gi\u201d.\nhas_gpu (bool) \u2013 Whether the machine has a GPU.\nmemory (str) \u2013 The memory of the machine. For example a value like \u201c8Gi\u201d.\nram_gb (int) \u2013 The amount of RAM of the machine.\nclass datarobot.models.notebooks.execution_environment.ExecutionEnvironment\uf0c1\nAn execution environment associated with a notebook.\nVariables:\nimage (Image) \u2013 The image associated with the execution environment.\nmachine (Machine) \u2013 The machine associated with the execution environment.\ntime_to_live (int) \u2013 The inactivity timeout for notebook session.\nclassmethod get(notebook_id)\uf0c1\nGet a notebook execution environment by its notebook ID.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\nReturns:\nThe notebook execution environment.\nReturn type:\nExecutionEnvironment\nclassmethod assign_environment(notebook_id, payload)\uf0c1\nAssign execution environment values to a notebook.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\npayload (ExecutionEnvironmentAssignPayload) \u2013 The payload for the assignment/update.\nReturns:\nThe assigned execution environment.\nReturn type:\nExecutionEnvironment\nExamples\nfrom datarobot.models.notebooks import ExecutionEnvironment, ExecutionEnvironmentAssignPayload\npayload = ExecutionEnvironmentAssignPayload(machine_slug='medium', time_to_live=10)\nexec_env = ExecutionEnvironment.assign_environment('67914bfab0279fd832dc3fd1', payload)\nclass datarobot.models.notebooks.kernel.NotebookKernel\uf0c1\nA kernel associated with a codespace notebook.\nVariables:\nid (str) \u2013 The kernel ID.\nname (str) \u2013 The kernel name.\nlanguage (RuntimeLanguage) \u2013 The kernel language. Supports Python and R.\nrunning (bool) \u2013 Whether the kernel is running.\nexecution_state (KernelState) \u2013 The kernel execution state.\nclass datarobot.models.notebooks.revision.CreateRevisionPayload\uf0c1\nPayload for creating a notebook revision.\nclass datarobot.models.notebooks.revision.NotebookRevision\uf0c1\nRepresents a notebook revision.\nVariables:\nrevision_id (str) \u2013 The ID of the notebook revision.\nnotebook_id (str) \u2013 The ID of the notebook.\nis_auto (bool) \u2013 Whether the revision was auto-saved.\nclassmethod create(notebook_id, payload=None)\uf0c1\nCreate a new notebook revision.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\npayload (CreateRevisionPayload) \u2013 The payload to create the revision.\nReturns:\nInformation about the created notebook revision.\nReturn type:\nNotebookRevision\nclass datarobot.models.notebooks.scheduled_job.NotebookScheduledJob\uf0c1\nDataRobot Notebook Schedule. A scheduled job that runs a notebook.\nVariables:\nid (str) \u2013 The ID of the scheduled notebook job.\nenabled (bool) \u2013 Whether job is enabled or not.\nrun_type (RunType) \u2013 The type of the run - either manual (triggered via UI or API) or scheduled.\nnotebook_type (NotebookType) \u2013 The type of the notebook - either plain or codespace.\njob_payload (ScheduledJobPayload) \u2013 The payload used for the background job.\nnext_run_time (Optional[str]) \u2013 The next time the job is scheduled to run (assuming it is enabled).\ntitle (Optional[str]) \u2013 The title of the job. Optional.\nschedule (Optional[str]) \u2013 Cron-like string to define how frequently job should be run. Optional.\nschedule_localized (Optional[str]) \u2013 A human-readable localized version of the schedule. Example in English is \u2018At 42 minutes past the hour\u2019.\nOptional.\nlast_successful_run (Optional[str]) \u2013 The last time the job was run successfully. Optional.\nlast_failed_run (Optional[str]) \u2013 The last time the job failed. Optional.\nlast_run_time (Optional[str]) \u2013 The last time the job was run (failed or successful). Optional.\nclassmethod get(use_case_id, scheduled_job_id)\uf0c1\nRetrieve a single notebook schedule.\nParameters:\nscheduled_job_id (str) \u2013 The ID of the notebook schedule you want to retrieve.\nReturns:\nnotebook_schedule \u2013 The requested notebook schedule.\nReturn type:\nNotebookScheduledJob\nExamples\nfrom datarobot.models.notebooks import NotebookScheduledJob\nnotebook_schedule = NotebookScheduledJob.get(\nuse_case_id=\"654ad653c6c1e889e8eab12e\",\nscheduled_job_id=\"65734fe637157200e28bf688\",\n)\nclassmethod list(notebook_ids=None, statuses=None)\uf0c1\nList all NotebookScheduledJobs available to the user.\nParameters:\nnotebook_ids (Optional[List[str]]) \u2013 Notebook IDs to filter listed schedules by. Optional.\nstatuses (Optional[List[ScheduleStatus]]) \u2013 Statuses to filter listed schedules by. Includes values \u201cdisabled\u201d and \u201cenabled\u201d. Optional.\nReturns:\nnotebook_schedules \u2013 A list of NotebookScheduledJobs available to the user.\nReturn type:\nList[NotebookScheduledJob]\ncancel()\uf0c1\nCancel a running notebook schedule.\nReturn type:\nNone\nget_most_recent_run()\uf0c1\nRetrieve the most recent run for the notebook schedule.\nReturns:\nnotebook_scheduled_run \u2013 The most recent run for the notebook schedule, or None if no runs have been made.\nReturn type:\nOptional[NotebookScheduledRun]\nExamples\nfrom datarobot.models.notebooks import NotebookScheduledJob\nnotebook_schedule = NotebookScheduledJob.get(\nuse_case_id=\"654ad653c6c1e889e8eab12e\",\nscheduled_job_id=\"65734fe637157200e28bf688\",\n)\nmost_recent_run = notebook_schedule.get_most_recent_run()\nget_job_history()\uf0c1\nRetrieve list of historical runs for the notebook schedule. Gets the most recent runs first.\nReturns:\nnotebook_scheduled_runs \u2013 The list of historical runs for the notebook schedule.\nReturn type:\nList[NotebookScheduledRun]\nExamples\nfrom datarobot.models.notebooks import NotebookScheduledJob\nnotebook_schedule = NotebookScheduledJob.get(\nuse_case_id=\"654ad653c6c1e889e8eab12e\",\nscheduled_job_id=\"65734fe637157200e28bf688\",\n)\nnotebook_scheduled_runs = notebook_schedule.get_job_history()\nwait_for_completion(max_wait=600)\uf0c1\nWait for the completion of a scheduled notebook and return the revision ID corresponding to the run\u2019s output.\nParameters:\nmax_wait (int) \u2013 The number of seconds to wait before giving up.\nReturns:\nrevision_id \u2013 Returns either revision ID or message describing current state.\nReturn type:\nstr\nExamples\nfrom datarobot.models.notebooks.notebook import Notebook\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nmanual_run = notebook.run_as_job()\nrevision_id = manual_run.wait_for_completion()\nclass datarobot.models.notebooks.scheduled_run.ScheduledJobParam\uf0c1\nDataRobot Schedule Job Parameter.\nVariables:\nname (str) \u2013 The name of the parameter.\nvalue (str) \u2013 The value of the parameter.\nclass datarobot.models.notebooks.scheduled_run.ScheduledJobPayload\uf0c1\nDataRobot Schedule Job Payload.\nVariables:\nuid (str) \u2013 The ID of the user who created the notebook schedule.\norg_id (str) \u2013 The ID of the user\u2019s organization who created the notebook schedule.\nuse_case_id (str) \u2013 The ID of the Use Case that the notebook belongs to.\nnotebook_id (str) \u2013 The ID of the notebook being run on a schedule.\nnotebook_name (str) \u2013 The name of the notebook being run on a schedule.\nrun_type (RunType) \u2013 The type of the run - either manual (triggered via UI or API) or scheduled.\nnotebook_type (NotebookType) \u2013 The type of the notebook - either plain or codespace.\nparameters (List[ScheduledJobParam]) \u2013 The parameters being used in the notebook schedule. Can be an empty list.\nnotebook_path (Optional[str]) \u2013 The path of the notebook to execute within the codespace. Optional. Required if notebook is in a codespace.\nuse_case_name (Optional[str]) \u2013 The name of the Use Case that the notebook belongs to.\nclass datarobot.models.notebooks.scheduled_run.ScheduledRunRevisionMetadata\uf0c1\nDataRobot Notebook Revision Metadata specifically for a scheduled run.\nBoth id and name can be null if for example the job is still running or has failed.\nVariables:\nid (Optional[str]) \u2013 The ID of the Notebook Revision. Optional.\nname (Optional[str]) \u2013 The name of the Notebook Revision. Optional.\nclass datarobot.models.notebooks.scheduled_run.NotebookScheduledRun\uf0c1\nDataRobot Notebook Scheduled Run. A historical run of a notebook schedule.\nVariables:\nid (str) \u2013 The ID of the scheduled notebook job.\nuse_case_id (str) \u2013 The Use Case ID of the scheduled notebook job.\nstatus (str) \u2013 The status of the run.\npayload (ScheduledJobPayload) \u2013 The payload used for the background job.\ntitle (Optional[str]) \u2013 The title of the job. Optional.\nstart_time (Optional[str]) \u2013 The start time of the job. Optional.\nend_time (Optional[str]) \u2013 The end time of the job. Optional.\nrevision (ScheduledRunRevisionMetadata) \u2013 Notebook revision data - ID and name.\nduration (Optional[int]) \u2013 The job duration in seconds. May be None for example while the job is running. Optional.\nrun_type (Optional[RunType]) \u2013 The type of the run - either manual (triggered via UI or API) or scheduled. Optional.\nnotebook_type (Optional[NotebookType]) \u2013 The type of the notebook - either plain or codespace. Optional.\nclass datarobot.models.notebooks.session.CloneRepositorySchema\uf0c1\nSchema for cloning a repository when starting a notebook session.\nclass datarobot.models.notebooks.session.StartSessionParameters\uf0c1\nParameters used as environment variables in a notebook session.\nclass datarobot.models.notebooks.session.StartSessionPayload\uf0c1\nPayload for starting a notebook session.\nclass datarobot.models.notebooks.session.NotebookExecutionStatus\uf0c1\nNotebook execution status information.\nVariables:\nstatus (str) \u2013 The status of the notebook execution.\ncell_id (Optional[bson.ObjectId]) \u2013 The ID of the cell being executed. Optional.\nqueued_cell_ids (Optional[List[bson.ObjectId]]) \u2013 The list of cell IDs that are queued for execution. Optional.\nclass datarobot.models.notebooks.session.CodespaceNotebookCell\uf0c1\nRepresents a cell in a codespace notebook.\nclass datarobot.models.notebooks.session.CodespaceNotebookState\uf0c1\nNotebook state information for a codespace notebook.\nVariables:\nname (str) \u2013 The name of the notebook.\npath (str) \u2013 The path of the notebook.\ngeneration (int) \u2013 The generation of the notebook.\nnbformat (int) \u2013 The notebook format version.\nnbformat_minor (int) \u2013 The notebook format minor version.\nmetadata (dict) \u2013 The metadata of the notebook.\ncells (List[CodespaceNotebookCell]) \u2013 The list of cells in the notebook.\nkernel_id (Optional[str]) \u2013 The ID of the kernel. Optional.\nclass datarobot.models.notebooks.session.NotebookSession\uf0c1\nNotebook session information.\nVariables:\nstatus (NotebookStatus) \u2013 The current status of the notebook kernel.\nnotebook_id (str) \u2013 The ID of the notebook.\nsession_id (str) \u2013 The ID of the session. Incorporates the notebook_id as part of this ID.\nstarted_at (Optional[str]) \u2013 The date and time when the notebook was started. Optional.\nsession_type (Optional[SessionType]) \u2013 The type of the run - either manual (triggered via UI or API) or scheduled. Optional.\nephemeral_session_key (Optional[str]) \u2013 The ID specific to ephemeral session if being used. Optional.\nclassmethod get(notebook_id)\uf0c1\nGet a notebook session by its notebook ID.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\nReturns:\nThe notebook session information.\nReturn type:\nNotebookSession\nclassmethod start(notebook_id, payload)\uf0c1\nStart a notebook session.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\npayload (StartSessionPayload) \u2013 The payload to start the session.\nReturns:\nThe notebook session information.\nReturn type:\nNotebookSession\nclassmethod stop(notebook_id)\uf0c1\nStop a notebook session.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\nReturns:\nThe notebook session information.\nReturn type:\nNotebookSession\nclassmethod execute_notebook(notebook_id, cell_ids=None)\uf0c1\nExecute a notebook.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\ncell_ids (Optional[List[bson.ObjectId]]) \u2013 The list of cell IDs to execute. Optional. If not provided, the whole notebook will be executed.\nReturn type:\nNone\nclassmethod execute_codespace_notebook(notebook_id, notebook_path, generation, cells)\uf0c1\nExecute a notebook.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\nnotebook_path (str) \u2013 The path of the notebook.\ngeneration (int) \u2013 The generation of the notebook.\ncells (List[CodespaceNotebookCell]) \u2013 The list of cells to execute.\nReturn type:\nNone\nclassmethod get_execution_status(notebook_id)\uf0c1\nGet the execution status information of a notebook.\nParameters:\nnotebook_id (str) \u2013 The ID of the notebook.\nReturns:\nThe execution status information of the notebook.\nReturn type:\nNotebookExecutionStatus\nclass datarobot.models.notebooks.settings.NotebookSettings\uf0c1\nSettings for a DataRobot Notebook.\nVariables:\nshow_line_numbers (bool) \u2013 Whether line numbers in cells should be displayed.\nhide_cell_titles (bool) \u2013 Whether cell titles should be displayed.\nhide_cell_outputs (bool) \u2013 Whether the cell outputs should be displayed.\nshow_scrollers (bool) \u2013 Whether scroll bars should be shown on cells.\nhide_cell_footers (bool) \u2013 Whether footers should be shown on cells.\nhighlight_whitespace (bool) \u2013 Whether whitespace should be highlighted or not.\nclass datarobot.models.notebooks.user.NotebookUser\uf0c1\nA user associated with a Notebook.\nVariables:\nid (str) \u2013 The ID of the user.\nactivated (bool) \u2013 Whether or not the user is enabled.\nusername (str) \u2013 The username of the user, usually their email address.\nfirst_name (str) \u2013 The first name of the user.\nlast_name (str) \u2013 The last name of the user.\ngravatar_hash (Optional[str]) \u2013 The gravatar hash of the user. Optional.\ntenant_phase (Optional[str]) \u2013 The phase that the user\u2019s tenant is in. Optional.\nclass datarobot.models.notebooks.user.NotebookActivity\uf0c1\nA record of activity (i.e. last run, updated, etc.) in a Notebook.\nVariables:\nat (str) \u2013 The time of the activity in the notebook.\nby (NotebookUser) \u2013 The user who performed the activity.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')",
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nmanual_run = notebook.run_as_job()\nrevision_id = manual_run.wait_for_completion()\nnotebook.download_revision(revision_id=revision_id, file_path=\"./results.ipynb\")",
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nnotebook.delete()",
        "from datarobot.models.notebooks import Notebook\n\nnotebooks = Notebook.list()",
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nsession = notebook.start_session()",
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nsession = notebook.stop_session()",
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nmanual_run = notebook.run_as_job()\n\n# Alternatively, with title and parameters:\n# manual_run = notebook.run_as_job(title=\"My Run\", parameters=[{\"name\": \"FOO\", \"value\": \"bar\"}])\n\nrevision_id = manual_run.wait_for_completion()",
        "from datarobot.models.notebooks import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nenabled_schedules = notebook.list_schedules(enabled_only=True)",
        "from datarobot.models.notebooks import ExecutionEnvironment, ExecutionEnvironmentAssignPayload\n\npayload = ExecutionEnvironmentAssignPayload(machine_slug='medium', time_to_live=10)\nexec_env = ExecutionEnvironment.assign_environment('67914bfab0279fd832dc3fd1', payload)",
        "from datarobot.models.notebooks import NotebookScheduledJob\n\nnotebook_schedule = NotebookScheduledJob.get(\n    use_case_id=\"654ad653c6c1e889e8eab12e\",\n    scheduled_job_id=\"65734fe637157200e28bf688\",\n)",
        "from datarobot.models.notebooks import NotebookScheduledJob\n\nnotebook_schedule = NotebookScheduledJob.get(\n    use_case_id=\"654ad653c6c1e889e8eab12e\",\n    scheduled_job_id=\"65734fe637157200e28bf688\",\n)\nmost_recent_run = notebook_schedule.get_most_recent_run()",
        "from datarobot.models.notebooks import NotebookScheduledJob\n\nnotebook_schedule = NotebookScheduledJob.get(\n    use_case_id=\"654ad653c6c1e889e8eab12e\",\n    scheduled_job_id=\"65734fe637157200e28bf688\",\n)\nnotebook_scheduled_runs = notebook_schedule.get_job_history()",
        "from datarobot.models.notebooks.notebook import Notebook\n\nnotebook = Notebook.get(notebook_id='6556b00dcc4ea0bb7ea48121')\nmanual_run = notebook.run_as_job()\nrevision_id = manual_run.wait_for_completion()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html",
      "title": "Credentials\uf0c1",
      "description": "You can store credentials for use with databases and data connections.",
      "content": "Credentials\uf0c1\nYou can store credentials for use with databases and data connections.\nTo interact with credentials API, use the Credential class.\nList credentials\uf0c1\nTo retrieve the list of all credentials accessible to you, use\nCredential.list.\nimport datarobot as dr\ncredentials = dr.Credential.list()\nEach credential object contains the credential_id string field which\ncan be used in, for example, Batch predictions.\nBasic credentials\uf0c1\nUse the code below to store generic username and password credentials:\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_basic(\n...     name='my_db_cred',\n...     user='<user>',\n...     password='<password>',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e0f', 'my_db_cred', 'basic'),\n# Store cred.credential_id\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'5e429d6ecf8a5f36c5693e0f'\nStored credentials can be used in Batch predictions for JDBC intake or output.\nS3 credentials\uf0c1\nYou can store AWS credentials either using the following three parameters:\naws_access_key_id\naws_secret_access_key\naws_session_token\nor by using the ID of the saved shared secure configuration:\nconfig_id\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_s3(\n...     name='my_s3_cred',\n...     aws_access_key_id='<aws access key id>',\n...     aws_secret_access_key='<aws secret access key>',\n...     aws_session_token='<aws session token>',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),\n# Using config_id\n>>> cred = dr.Credential.dr.Credential.create_s3(\n...     name='my_s3_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('65ef55ef4cec97f0f733835c', 'my_s3_cred_with_config_id', 's3')\n# Store cred.credential_id\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'5e429d6ecf8a5f36c5693e03'\nStored credential can be used, for example, in Batch predictions for S3 intake or output.\nOAuth credentials\uf0c1\nYou can store OAuth credentials in the data store.\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_oauth(\n...     name='my_oauth_cred',\n...     token='<token>',\n...     refresh_token='<refresh_token>',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e0f', 'my_oauth_cred', 'oauth'),\n# Store cred.credential_id\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'5e429d6ecf8a5f36c5693e0f'\nSnowflake key pair credentials\uf0c1\nYou can store Snowflake key pair credentials in the store. It accepts either of the following parameters:\nprivate_key\npassphrase\nOr you can use the ID of the saved shared secure configuration.\nconfig_id\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_snowflake_key_pair(\n...     name='my_snowflake_key_pair_cred',\n...     user='<user>',\n...     private_key=\"\"\"<private_key>\"\"\",\n...     passphrase='<passphrase>',\n... )\n>>> cred\nCredential('65e9b55e4b0d925c678bb847', 'my_snowflake_key_pair_cred', 'snowflake_key_pair_user_account')\n>>> cred = dr.Credential.create_snowflake_key_pair(\n...     name='my_snowflake_key_pair_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('65e9b9494b0d925c678bb84d', 'my_snowflake_key_pair_cred_with_config_id', 'snowflake_key_pair_user_account')\nDatabricks access token credentials\uf0c1\nYou can store Databricks access token credentials in the data store.\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_access_token(\n...     name='my_databricks_access_token_cred',\n...     databricks_access_token='<databricks_access_token>',\n... )\n>>> cred\nCredential('65e9bace4b0d925c678bb850', 'my_databricks_access_token_cred', 'databricks_access_token_account')\nDatabricks service principal credentials\uf0c1\nYou can store Databricks service principal credentials in the store. It accepts either of the following parameters:\nclient_id\nclient_secret\nYou can also use the ID of the saved shared secure configuration.\nconfig_id\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_service_principal(\n...     name='my_databricks_service_principal_cred',\n...     client_id='<client_id>',\n...     client_secret='<client_secret>',\n... )\n>>> cred\nCredential('65e9bb864b0d925c678bb853', 'my_databricks_service_principal_cred', 'databricks_service_principal_account')\n>>> cred = dr.Credential.create_databricks_service_principal(\n...     name='my_databricks_service_principal_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('65e9bcc14b0d925c678bb85e', 'my_databricks_service_principal_cred_with_config_id', 'databricks_service_principal_account')\nAzure Service Principal credentials\uf0c1\nYou can store Azure Service Principal credentials using any of the three following parameters:\nclient_id\nclient_secret\nazure_tenant_id\nYou can also use the ID of the saved shared secure configuration.\nconfig_id\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_azure_service_principal(\n...     name='my_azure_service_principal_cred',\n...     client_id='<client id>',\n...     client_secret='<client secret>',\n...     azure_tenant_id='<azure tenant id>',\n... )\n>>> cred\nCredential('66c920fc4ef80072a8225e56', 'my_azure_service_principal_cred2', 'azure_service_principal')\n# Using config_id\n>>> cred = dr.Credential.dr.Credential.create_azure_service_principal(\n...     name='my_azure_service_principal_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('66c921aa0ff7aea1ce225e2d', 'my_azure_service_principal_cred_with_config_id', 'azure_service_principal')\n# Store cred.credential_id\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'66c921aa0ff7aea1ce225e2d'\nADLS OAuth credentials\uf0c1\nYou can store ADLS OAuth credentials using any of the three following parameters:\nclient_id\nclient_secret\noauth_scopes\nYou can also use the ID of the saved shared secure configuration.\nconfig_id\n>>> import datarobot as dr\n>>> cred = dr.Credential.create_adls_oauth(\n...     name='my_adls_oauth_cred',\n...     client_id='<client id>',\n...     client_secret='<client secret>',\n...     oauth_scopes=['<oauth scope>'],\n... )\n>>> cred\nCredential('66c9227e3b268d3278225e41', 'my_adls_oauth_cred', 'adls_gen2_oauth')\n# Using config_id\n>>> cred = dr.Credential.dr.Credential.create_adls_oauth(\n...     name='my_adls_oauth_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('66c922b3ae75806f1d126f06', 'my_adls_oauth_cred_with_config_id', 'adls_gen2_oauth')\n# Store cred.credential_id\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'66c922b3ae75806f1d126f06'\nCredential data\uf0c1\nFor methods that accept credential data instead of a username/password or credential ID:\n{\n\"credentialType\": \"basic\",\n\"user\": \"user123\",\n\"password\": \"pass123\",\n}\n{\n\"credentialType\": \"s3\",\n\"awsAccessKeyId\": \"key123\",\n\"awsSecretAccessKey\": \"secret123\",\n}\n{\n\"credentialType\": \"s3\",\n\"configId\": \"id123\",\n}\n{\n\"credentialType\": \"oauth\",\n\"oauthRefreshToken\": \"token123\",\n\"oauthClientId\": \"client123\",\n\"oauthClientSecret\": \"secret123\",\n}\n{\n\"credentialType\": \"snowflake_key_pair_user_account\",\n\"user\": \"user123\",\n\"privateKey\": \"privatekey123\",\n\"passphrase\": \"passphrase123\",\n}\n{\n\"credentialType\": \"snowflake_key_pair_user_account\",\n\"configId\": \"id123\",\n}\n{\n\"credentialType\": \"databricks_access_token_account\",\n\"databricksAccessToken\": \"token123\",\n}\n{\n\"credentialType\": \"databricks_service_principal_account\",\n\"clientId\": \"client123\",\n\"clientSecret\": \"secret123\",\n}\n{\n\"credentialType\": \"databricks_service_principal_account\",\n\"configId\": \"id123\",\n}\n{\n\"credentialType\": \"azure_service_principal\",\n\"clientId\": \"client123\",\n\"clientSecret\": \"secret123\",\n\"azureTenantId\": \"tenant123\"\n}\n{\n\"credentialType\": \"azure_service_principal\",\n\"configId\": \"id123\",\n}\n{\n\"credentialType\": \"adls_gen2_oauth\",\n\"clientId\": \"client123\",\n\"clientSecret\": \"secret123\",\n\"oauthScopes\": [\"scope123\"]\n}\n{\n\"credentialType\": \"adls_gen2_oauth\",\n\"configId\": \"id123\",\n}",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/credentials.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/batch_predictions.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\ncredentials = dr.Credential.list()",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_basic(\n...     name='my_db_cred',\n...     user='<user>',\n...     password='<password>',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e0f', 'my_db_cred', 'basic'),\n\n# Store cred.credential_id\n\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'5e429d6ecf8a5f36c5693e0f'",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_s3(\n...     name='my_s3_cred',\n...     aws_access_key_id='<aws access key id>',\n...     aws_secret_access_key='<aws secret access key>',\n...     aws_session_token='<aws session token>',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e03', 'my_s3_cred', 's3'),\n\n# Using config_id\n>>> cred = dr.Credential.dr.Credential.create_s3(\n...     name='my_s3_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('65ef55ef4cec97f0f733835c', 'my_s3_cred_with_config_id', 's3')\n\n# Store cred.credential_id\n\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'5e429d6ecf8a5f36c5693e03'",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_oauth(\n...     name='my_oauth_cred',\n...     token='<token>',\n...     refresh_token='<refresh_token>',\n... )\n>>> cred\nCredential('5e429d6ecf8a5f36c5693e0f', 'my_oauth_cred', 'oauth'),\n\n# Store cred.credential_id\n\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'5e429d6ecf8a5f36c5693e0f'",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_snowflake_key_pair(\n...     name='my_snowflake_key_pair_cred',\n...     user='<user>',\n...     private_key=\"\"\"<private_key>\"\"\",\n...     passphrase='<passphrase>',\n... )\n>>> cred\nCredential('65e9b55e4b0d925c678bb847', 'my_snowflake_key_pair_cred', 'snowflake_key_pair_user_account')\n>>> cred = dr.Credential.create_snowflake_key_pair(\n...     name='my_snowflake_key_pair_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('65e9b9494b0d925c678bb84d', 'my_snowflake_key_pair_cred_with_config_id', 'snowflake_key_pair_user_account')",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_access_token(\n...     name='my_databricks_access_token_cred',\n...     databricks_access_token='<databricks_access_token>',\n... )\n>>> cred\nCredential('65e9bace4b0d925c678bb850', 'my_databricks_access_token_cred', 'databricks_access_token_account')",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_databricks_service_principal(\n...     name='my_databricks_service_principal_cred',\n...     client_id='<client_id>',\n...     client_secret='<client_secret>',\n... )\n>>> cred\nCredential('65e9bb864b0d925c678bb853', 'my_databricks_service_principal_cred', 'databricks_service_principal_account')\n>>> cred = dr.Credential.create_databricks_service_principal(\n...     name='my_databricks_service_principal_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('65e9bcc14b0d925c678bb85e', 'my_databricks_service_principal_cred_with_config_id', 'databricks_service_principal_account')",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_azure_service_principal(\n...     name='my_azure_service_principal_cred',\n...     client_id='<client id>',\n...     client_secret='<client secret>',\n...     azure_tenant_id='<azure tenant id>',\n... )\n>>> cred\nCredential('66c920fc4ef80072a8225e56', 'my_azure_service_principal_cred2', 'azure_service_principal')\n\n# Using config_id\n>>> cred = dr.Credential.dr.Credential.create_azure_service_principal(\n...     name='my_azure_service_principal_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('66c921aa0ff7aea1ce225e2d', 'my_azure_service_principal_cred_with_config_id', 'azure_service_principal')\n\n# Store cred.credential_id\n\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'66c921aa0ff7aea1ce225e2d'",
        ">>> import datarobot as dr\n>>> cred = dr.Credential.create_adls_oauth(\n...     name='my_adls_oauth_cred',\n...     client_id='<client id>',\n...     client_secret='<client secret>',\n...     oauth_scopes=['<oauth scope>'],\n... )\n>>> cred\nCredential('66c9227e3b268d3278225e41', 'my_adls_oauth_cred', 'adls_gen2_oauth')\n\n# Using config_id\n>>> cred = dr.Credential.dr.Credential.create_adls_oauth(\n...     name='my_adls_oauth_cred_with_config_id',\n...     config_id='<id_of_shared_secure_configuration>',\n... )\n>>> cred\nCredential('66c922b3ae75806f1d126f06', 'my_adls_oauth_cred_with_config_id', 'adls_gen2_oauth')\n\n# Store cred.credential_id\n\n>>> cred = dr.Credential.get(credential_id)\n>>> cred.credential_id\n'66c922b3ae75806f1d126f06'"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/index.html",
      "title": "Administration\uf0c1",
      "description": "The administration section provides details for users and administrators about managing credentials and sharing permissions.",
      "content": "Administration\uf0c1\nThe administration section provides details for users and administrators about managing credentials and sharing permissions.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/sharing.html",
      "title": "Sharing\uf0c1",
      "description": "Once you have created entities in DataRobot, you may want to share them with collaborators.\nDataRobot provides an API for sharing the following entities:",
      "content": "Sharing\uf0c1\nOnce you have created entities in DataRobot, you may want to share them with collaborators.\nDataRobot provides an API for sharing the following entities:\nData sources and data stores ( see Database connectivity for more info on connecting to JDBC databases)\nDatasets\nProjects\nCalendar files\nModel deployments (see Deployment sharing for more information on sharing deployments)\nUse Cases (Sharing for Use Cases is slightly different than what\u2019s documented on this page. See Use Case sharing for more information and examples.)\nAccess levels\uf0c1\nEntities can be shared at varying access levels. For example, you can allow someone to\ncreate projects from a data source you have built without allowing them to delete it.\nEach entity type uses slightly different permission names intended to specifically convey what\nkind of actions are available. These roles fall into three categories. These generic role names\ncan be used in the sharing API for any entity.\nFor the complete set of actions granted by each role on a given entity, see the UI documentation for roles and permissions.\nOWNER\nUsed for all entities.\nAllows any action including deletion.\nREAD_WRITE\nKnown as as EDITOR on data sources and data stores.\nAllows modifications to the state, such as renaming and creating data sources from a data store, but not deleting the entity.\nREAD_ONLY\nKnown as CONSUMER on data sources and data stores.\nFor data sources, enables creating projects and predictions; for data stores, only allows you to view them.\nWhen a user\u2019s new role is specified as None, their access will be revoked.\nIn addition to the role, some entities (data sources and data stores) allow\nseparate control over whether a new user should be able to share that entity further. When granting access to a user,\nthe can_share parameter determines whether that user can, in turn, share this entity with another user.\nWhen this parameter is set as false, the user in question has all the access to the entity granted by their\nrole and can remove themselves if desired, but are unable to change the role of any other user.\nExamples\uf0c1\nTransfer access to the data source from mailto:old_user@datarobot.com to mailto:new_user@datarobot.com.\nimport datarobot as dr\nnew_access = dr.SharingAccess(\n\"[email\u00a0protected]\",\ndr.enums.SHARING_ROLE.OWNER,\ncan_share=True,\n)\naccess_list = [dr.SharingAccess(\"[email\u00a0protected]\", None), new_access]\ndr.DataSource.get('my-data-source-id').share(access_list)\nTo check access to a project:\nimport datarobot as dr\nproject = dr.Project.create('mydata.csv', project_name='My Data')\naccess_list = project.get_access_list()\naccess_list[0].username\nTo transfer ownership of all projects owned by your account to mailto:new_user@datarobot.com without sending notifications:\nimport datarobot as dr\n# Put path to YAML credentials below\ndr.Client(config_path= '.yaml')\n# Get all projects for your account and store the ids in a list\nprojects = dr.Project.list()\nproject_ids = [project.id for project in projects]\n# List of emails to share with\nshare_targets = ['[email\u00a0protected]']\n# Target role\ntarget_role = dr.enums.SHARING_ROLE.OWNER\nfor pid in project_ids:\nproject = dr.Project.get(project_id=pid)\nshares = []\nfor user in share_targets:\nshares.append(dr.SharingAccess(username=user, role=target_role))\nproject.share(shares, send_notification=False)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/database_connectivity.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/deployment.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/use_cases.html",
        "https://docs.datarobot.com/en/docs/get-started/acct-mgmt/data-sharing/roles-permissions.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\nnew_access = dr.SharingAccess(\n   \"[email\u00a0protected]\",\n   dr.enums.SHARING_ROLE.OWNER,\n   can_share=True,\n)\naccess_list = [dr.SharingAccess(\"[email\u00a0protected]\", None), new_access]\n\ndr.DataSource.get('my-data-source-id').share(access_list)",
        "import datarobot as dr\n\nproject = dr.Project.create('mydata.csv', project_name='My Data')\n\naccess_list = project.get_access_list()\n\naccess_list[0].username",
        "import datarobot as dr\n\n# Put path to YAML credentials below\ndr.Client(config_path= '.yaml')\n\n# Get all projects for your account and store the ids in a list\nprojects = dr.Project.list()\n\nproject_ids = [project.id for project in projects]\n\n# List of emails to share with\nshare_targets = ['[email\u00a0protected]']\n\n# Target role\ntarget_role = dr.enums.SHARING_ROLE.OWNER\n\nfor pid in project_ids:\n\n   project = dr.Project.get(project_id=pid)\n\n   shares = []\n\n   for user in share_targets:\n\n      shares.append(dr.SharingAccess(username=user, role=target_role))\n\n   project.share(shares, send_notification=False)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/database_connectivity.html",
      "title": "Database connectivity\uf0c1",
      "description": "Databases are a widely used tool for carrying valuable business data. To enable integration\nwith a variety of enterprise databases, DataRobot provides a \u201cself-service\u201d JDBC product\nfor database connectivity setup. Once configured, you can read data from production databases\nfor model building and predictions. This allows you to quickly train and retrain models\non that data, and avoids the unnecessary step of exporting data from your enterprise database\nto a CSV for ingest to DataRobot. With access to more diverse data, you can build more accurate models.",
      "content": "Database connectivity\uf0c1\nDatabases are a widely used tool for carrying valuable business data. To enable integration\nwith a variety of enterprise databases, DataRobot provides a \u201cself-service\u201d JDBC product\nfor database connectivity setup. Once configured, you can read data from production databases\nfor model building and predictions. This allows you to quickly train and retrain models\non that data, and avoids the unnecessary step of exporting data from your enterprise database\nto a CSV for ingest to DataRobot. With access to more diverse data, you can build more accurate models.\nDatabase connection configuration uses the following terminology:\nData store: A configured connection to a database. It has a name, a specified driver,\nand a JDBC URL. You can register data stores with DataRobot for ease of re-use.\nA data store has one connector but can have many data sources.\nData source: A configured connection to the backing data store (the location of data\nwithin a given endpoint). A data source specifies, via a SQL query or a selected table\nand schema data, which data to extract from the data store to use for modeling or predictions.\nA data source has one data store and one connector but can have many datasets.\nData driver: The software that allows the application to interact with a database;\neach data store is associated with either a driver or a connector (created by the administrator). The\ndriver configuration saves the storage location in the application of the JAR file and any additional\ndependency files associated with the driver.\nConnector: Similarly to data drivers, a connector allows the application to interact\nwith a database; each data store is associated with either a driver or a connector (created by the\nadministrator). The connector configuration saves the storage location in the application of the JAR file and\nany additional dependency files associated with the connector.\nDataset: Data, a file or the content of a data source, at a particular point in time.\nA data source can produce multiple datasets; a dataset has exactly one data source.\nReview the workflow to set up projects or prediction datasets below.\nThe administrator sets up a datarobot.DataDriver for accessing a particular database.\nFor any particular driver, this setup is performed once for the entire system and\nthe resulting driver is used by all users.\nUsers create a datarobot.DataStore which represents an interface\nto a particular database, using that driver.\nUsers create a datarobot.DataSource representing a particular set of data\nto be extracted from the data store.\nUsers create projects and prediction datasets from a data source.\nUsers can also manage their data stores and data sources and administrators can manage drivers by listing, retrieving, updating, and deleting existing instances.\nCreate drivers\uf0c1\nAdministrators should specify the class_name, the name of the Java class in the Java archive\nwhich implements the java.sql.Driver interface; canonical_name, a user-friendly name\nfor resulting driver to display in the API and the GUI; and files, a list of local files which\ncontain the driver.\n>>> import datarobot as dr\n>>> driver = dr.DataDriver.create(\n...     class_name='org.postgresql.Driver',\n...     canonical_name='PostgreSQL',\n...     files=['/tmp/postgresql-42.2.2.jar']\n... )\n>>> driver\nDataDriver('PostgreSQL')\nTo retrieve information about existing drivers, such as the driver ID for data store creation,\nyou can use dr.DataDriver.list().\nCreate data stores\uf0c1\nAfter an administrator has created drivers, any user can use them for DataStore creation.\nA data store represents a JDBC database. When creating them, you should specify the type,\nwhich must be jdbc; canonical_name, a user-friendly name to display\nin the API and GUI for the data store; driver_id, the ID of the driver to use to connect\nto the database; and jdbc_url, the full URL specifying the database connection settings\nsuch as the database type, server address, port, and database name.\nNote that you can only create data stores with drivers when using the Python client.\nDrivers and connectors are not interchangeable for this method. To create a data store with\na connector, instead use the REST API.\n>>> import datarobot as dr\n>>> data_store = dr.DataStore.create(\n...     data_store_type='jdbc',\n...     canonical_name='Demo DB',\n...     driver_id='5a6af02eb15372000117c040',\n...     jdbc_url='jdbc:postgresql://my.db.address.org:5432/perftest'\n... )\n>>> data_store\nDataStore('Demo DB')\n>>> data_store.test(username='username', password='password')\n{'message': 'Connection successful'}\nCreate data sources\uf0c1\nOnce you have a data store, you can can query datasets via the data source.\nWhen creating a data source, first create a\ndatarobot.DataSourceParameters object from a data store\u2019s ID and a query,\nand then create the data source with a type, currently always jdbc; a canonical_name,\nthe user-friendly name to display in the API and GUI, and params, the DataSourceParameters\nobject.\n>>> import datarobot as dr\n>>> params = dr.DataSourceParameters(\n...     data_store_id='5a8ac90b07a57a0001be501e',\n...     query='SELECT * FROM airlines10mb WHERE \"Year\" >= 1995;'\n... )\n>>> data_source = dr.DataSource.create(\n...     data_source_type='jdbc',\n...     canonical_name='airlines stats after 1995',\n...     params=params\n... )\n>>> data_source\nDataSource('airlines stats after 1995')\nCreate projects\uf0c1\nYou can create new projects from a data source, demonstrated below.\n>>> import datarobot as dr\n>>> project = dr.Project.create_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     username='username',\n...     password='password'\n... )\nAs of v3.0 of the Python API client, you can alternatively pass in the credential_id of an existing\nDataset.Credential object.\n>>> import datarobot as dr\n>>> project = dr.Project.create_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     credential_id='9963d544d5ce3se783r12190'\n... )\nOr, pass in credential_data which conforms to CredentialDataSchema.\n>>> import datarobot as dr\n>>> s3_credential_data = {\"credentialType\": \"s3\", \"awsAccessKeyId\": \"key123\", \"awsSecretAccessKey\": \"secret123\"}\n>>> project = dr.Project.create_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     credential_data=s3_credential_data\n... )\nCreate prediction datasets\uf0c1\nGiven a data source, new prediction datasets can be created for any project.\n>>> import datarobot as dr\n>>> project = dr.Project.get('5ae6f296962d740dd7b86887')\n>>> prediction_dataset = project.upload_dataset_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     username='username',\n...     password='password'\n... )",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-connectivity.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/credentials.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        ">>> import datarobot as dr\n>>> driver = dr.DataDriver.create(\n...     class_name='org.postgresql.Driver',\n...     canonical_name='PostgreSQL',\n...     files=['/tmp/postgresql-42.2.2.jar']\n... )\n>>> driver\nDataDriver('PostgreSQL')",
        ">>> import datarobot as dr\n>>> data_store = dr.DataStore.create(\n...     data_store_type='jdbc',\n...     canonical_name='Demo DB',\n...     driver_id='5a6af02eb15372000117c040',\n...     jdbc_url='jdbc:postgresql://my.db.address.org:5432/perftest'\n... )\n>>> data_store\nDataStore('Demo DB')\n>>> data_store.test(username='username', password='password')\n{'message': 'Connection successful'}",
        "datarobot.DataSourceParameters",
        ">>> import datarobot as dr\n>>> params = dr.DataSourceParameters(\n...     data_store_id='5a8ac90b07a57a0001be501e',\n...     query='SELECT * FROM airlines10mb WHERE \"Year\" >= 1995;'\n... )\n>>> data_source = dr.DataSource.create(\n...     data_source_type='jdbc',\n...     canonical_name='airlines stats after 1995',\n...     params=params\n... )\n>>> data_source\nDataSource('airlines stats after 1995')",
        ">>> import datarobot as dr\n>>> project = dr.Project.create_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     username='username',\n...     password='password'\n... )",
        ">>> import datarobot as dr\n>>> project = dr.Project.create_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     credential_id='9963d544d5ce3se783r12190'\n... )",
        ">>> import datarobot as dr\n>>> s3_credential_data = {\"credentialType\": \"s3\", \"awsAccessKeyId\": \"key123\", \"awsSecretAccessKey\": \"secret123\"}\n>>> project = dr.Project.create_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     credential_data=s3_credential_data\n... )",
        ">>> import datarobot as dr\n>>> project = dr.Project.get('5ae6f296962d740dd7b86887')\n>>> prediction_dataset = project.upload_dataset_from_data_source(\n...     data_source_id='5ae6eee9962d740dd7b86886',\n...     username='username',\n...     password='password'\n... )"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/dataset.html",
      "title": "Datasets\uf0c1",
      "description": "To create a project and begin modeling, you first need to upload your data and prepare a dataset.",
      "content": "Datasets\uf0c1\nTo create a project and begin modeling, you first need to upload your data and prepare a dataset.\nCreate a dataset\uf0c1\nThere are several ways to create a dataset.\nDataset.upload takes either a path to a\nlocal file, a streamable file object via external URL, or a pandas DataFrame.\n>>> import datarobot as dr\n>>> # Upload a local file\n>>> dataset_one = dr.Dataset.upload(\"./data/examples.csv\")\n>>> # Create a dataset with a URL\n>>> dataset_two = dr.Dataset.upload(\"https://raw.githubusercontent.com/curran/data/gh-pages/dbpedia/cities/data.csv\")\n>>> # Create a dataset using a pandas DataFrame\n>>> dataset_three = dr.Dataset.upload(my_df)\n>>> # Create a dataset using a local file\n>>> with open(\"./data/examples.csv\", \"rb\") as file_pointer:\n...     dataset_four = dr.Dataset.create_from_file(filelike=file_pointer)\nDataset.create_from_file can take either a path to a\nlocal file or any streamable file object.\n>>> import datarobot as dr\n>>> dataset = dr.Dataset.create_from_file(file_path='data_dir/my_data.csv')\n>>> with open('data_dir/my_data.csv', 'rb') as f:\n...     other_dataset = dr.Dataset.create_from_file(filelike=f)\nDataset.create_from_in_memory_data takes\neither a pandas.Dataframe or a list of dictionaries representing rows of data.  Note that the\ndictionaries representing the rows of data must contain the same keys.\n>>> import pandas as pd\n>>> data_frame = pd.read_csv('data_dir/my_data.csv')\n>>> pandas_dataset = dr.Dataset.create_from_in_memory_data(data_frame=data_frame)\n>>> in_memory_data = [{'key1': 'value', 'key2': 'other_value', ...},\n...                   {'key1': 'new_value', 'key2': 'other_new_value', ...}, ...]\n>>> in_memory_dataset = dr.Dataset.create_from_in_memory_data(records=other_data)\nDataset.create_from_url takes CSV data from a URL. If you\nhave set DISABLE_CREATE_SNAPSHOT_DATASOURCE, you must set do_snapshot=False.\n>>> url_dataset = dr.Dataset.create_from_url('https://s3.amazonaws.com/my_data/my_dataset.csv',\n...                                          do_snapshot=False)\nDataset.create_from_data_source takes data\nfrom a data source.\nIf you have set DISABLE_CREATE_SNAPSHOT_DATASOURCE, you must set do_snapshot=False.\n>>> data_source_dataset = dr.Dataset.create_from_data_source(data_source.id, do_snapshot=False)\nor\n>>> data_source_dataset = data_source.create_dataset(do_snapshot=False)\nUse datasets\uf0c1\nAfter creating a dataset, you can create Projects from it and begin training models. You can also combine project creation and a dataset upload in one method using Project.create.\nHowever, using this method means the data is only accessible to the project which created it.\n>>> project = dataset.create_project(project_name='New Project')\n>>> project.analyze_and_model('some target')\nProject(New Project)\nGet information from a dataset\uf0c1\nThe dataset object contains some basic information that you can query, as shown in the snippet below.\n>>> dataset.id\nu'5e31cdac39782d0f65842518'\n>>> dataset.name\nu'my_data.csv'\n>>> dataset.categories\n[\"TRAINING\", \"PREDICTION\"]\n>>> dataset.created_at\ndatetime.datetime(2020, 2, 7, 16, 51, 10, 311000, tzinfo=tzutc())\nThe snippet below outlines several methods available to retrieve details from a dataset.\n# Details\n>>> details = dataset.get_details()\n>>> details.last_modification_date\ndatetime.datetime(2020, 2, 7, 16, 51, 10, 311000, tzinfo=tzutc())\n>>> details.feature_count_by_type\n[FeatureTypeCount(count=1, feature_type=u'Text'),\nFeatureTypeCount(count=1, feature_type=u'Boolean'),\nFeatureTypeCount(count=16, feature_type=u'Numeric'),\nFeatureTypeCount(count=3, feature_type=u'Categorical')]\n>>> details.to_dataset().id == details.dataset_id\nTrue\n# Projects\n>>> dr.Project.create_from_dataset(dataset.id, project_name='Project One')\nProject(Project One)\n>>> dr.Project.create_from_dataset(dataset.id, project_name='Project Two')\nProject(Project Two)\n>>> dataset.get_projects()\n[ProjectLocation(url=u'https://app.datarobot.com/api/v2/projects/5e3c94aff86f2d10692497b5/', id=u'5e3c94aff86f2d10692497b5'),\nProjectLocation(url=u'https://app.datarobot.com/api/v2/projects/5e3c94eb9525d010a9918ec1/', id=u'5e3c94eb9525d010a9918ec1')]\n>>> first_id = dataset.get_projects()[0].id\n>>> dr.Project.get(first_id).project_name\n'Project One'\n# Features\n>>> all_features = dataset.get_all_features()\n>>> feature = next(dataset.iterate_all_features(offset=2, limit=1))\n>>> feature.name == all_features[2].name\nTrue\n>>> print(feature.name, feature.feature_type, feature.dataset_id)\n(u'Partition', u'Numeric', u'5e31cdac39782d0f65842518')\n>>> feature.get_histogram().plot\n[{'count': 3522, 'target': None, 'label': u'0.0'},\n{'count': 3521, 'target': None, 'label': u'1.0'}, ... ]\n# The raw data\n>>> with open('myfile.csv', 'wb') as f:\n...     dataset.get_file(filelike=f)\nRetrieve datasets\uf0c1\nYou can retrieve specific datasets, a list of all datasets, or an iterator that retrieves\nall or some datasets.\n>>> dataset_id = '5e387c501a438646ed7bf0f2'\n>>> dataset = dr.Dataset.get(dataset_id)\n>>> dataset.id == dataset_id\nTrue\n# A blocking call that returns all datasets\n>>> dr.Dataset.list()\n[Dataset(name=u'Untitled Dataset', id=u'5e3c51e0f86f2d1087249728'),\nDataset(name=u'my_data.csv', id=u'5e3c2028162e6a5fe9a0d678'), ...]\n# Avoid listing datasets that fail to properly upload\n>>> dr.Dataset.list(filter_failed=True)\n[Dataset(name=u'my_data.csv', id=u'5e3c2028162e6a5fe9a0d678'),\nDataset(name=u'my_other_data.csv', id=u'3efc2428g62eaa5f39a6dg7a'), ...]\n# An iterator that lazily retrieves from the server page-by-page\n>>> from itertools import islice\n>>> iterator = dr.Dataset.iterate(offset=2)\n>>> for element in islice(iterator, 3):\n...    print(element)\nDataset(name='some_data.csv', id='5e8df2f21a438656e7a23d12')\nDataset(name='other_data.csv', id='5e8df2e31a438656e7a23d0b')\nDataset(name='Untitled Dataset', id='5e6127681a438666cc73c2b0')\nManage datasets\uf0c1\nYou can modify, delete, and restore datasets.  Note that you need the dataset\u2019s ID in order to restore\nit from deletion. If you do not keep track of the ID, you will be unable to restore a dataset. If your deleted dataset was used to create a project, that project can still access it, but you will not be able to create new projects using that dataset.\n>>> dataset.modify(name='A Better Name')\n>>> dataset.name\n'A Better Name'\n>>> new_project = dr.Project.create_from_dataset(dataset.id)\n>>> stored_id = dataset.id\n>>> dr.Dataset.delete(dataset.id)\n# new_project is still ok\n>>> dr.Project.create_from_dataset(stored_id)\nTraceback (most recent call last):\n...\ndatarobot.errors.ClientError: 410 client error: {u'message': u'Requested Dataset 5e31cdac39782d0f65842518 was previously deleted.'}\n>>> dr.Dataset.un_delete(stored_id)\n>>> dr.Project.create_from_dataset(stored_id, project_name='Successful')\nProject(Successful)\nYou can share a dataset as demonstrated in the following code snippet.\n>>> from datarobot.enums import SHARING_ROLE\n>>> from datarobot.models.dataset import Dataset\n>>> from datarobot.models.sharing import SharingAccess\n>>>\n>>> new_access = SharingAccess(\n>>>     \"[email\u00a0protected]\",\n>>>     SHARING_ROLE.OWNER,\n>>>     can_share=True,\n>>> )\n>>> access_list = [\n>>>     SharingAccess(\"[email\u00a0protected]\", SHARING_ROLE.OWNER, can_share=True),\n>>>     new_access,\n>>> ]\n>>>\n>>> Dataset.get('my-dataset-id').share(access_list)\nManage dataset feature lists\uf0c1\nYou can create, modify, and delete custom feature lists on a given dataset. Some feature lists are\nautomatically created by DataRobot and cannot be modified or deleted. Note that you cannot\nrestore a deleted feature list.\n>>> dataset.get_featurelists()\n[DatasetFeaturelist(Raw Features),\nDatasetFeaturelist(universe),\nDatasetFeaturelist(Informative Features)]\n>>> dataset_features = [feature.name for feature in dataset.get_all_features()]\n>>> custom_featurelist = dataset.create_featurelist('Custom Features', dataset_features[:5])\n>>> custom_featurelist\nDatasetFeaturelist(Custom Features)\n>>> dataset.get_featurelists()\n[DatasetFeaturelist(Raw Features),\nDatasetFeaturelist(universe),\nDatasetFeaturelist(Informative Features),\nDatasetFeaturelist(Custom Features)]\n>>> custom_featurelist.update('New Name')\n>>> custom_featurelist.name\n'New Name'\n>>> custom_featurelist.delete()\n>>> dataset.get_featurelists()\n[DatasetFeaturelist(Raw Features),\nDatasetFeaturelist(universe),\nDatasetFeaturelist(Informative Features)]\nUse credential data\uf0c1\nFor methods that accept credential data instead of username and password or a credential ID, see the  Credential data section.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/project.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        ">>> import datarobot as dr\n>>> # Upload a local file\n>>> dataset_one = dr.Dataset.upload(\"./data/examples.csv\")\n\n>>> # Create a dataset with a URL\n>>> dataset_two = dr.Dataset.upload(\"https://raw.githubusercontent.com/curran/data/gh-pages/dbpedia/cities/data.csv\")\n\n>>> # Create a dataset using a pandas DataFrame\n>>> dataset_three = dr.Dataset.upload(my_df)\n\n>>> # Create a dataset using a local file\n>>> with open(\"./data/examples.csv\", \"rb\") as file_pointer:\n...     dataset_four = dr.Dataset.create_from_file(filelike=file_pointer)",
        ">>> import datarobot as dr\n>>> dataset = dr.Dataset.create_from_file(file_path='data_dir/my_data.csv')\n>>> with open('data_dir/my_data.csv', 'rb') as f:\n...     other_dataset = dr.Dataset.create_from_file(filelike=f)",
        ">>> import pandas as pd\n>>> data_frame = pd.read_csv('data_dir/my_data.csv')\n\n>>> pandas_dataset = dr.Dataset.create_from_in_memory_data(data_frame=data_frame)\n\n>>> in_memory_data = [{'key1': 'value', 'key2': 'other_value', ...},\n...                   {'key1': 'new_value', 'key2': 'other_new_value', ...}, ...]\n>>> in_memory_dataset = dr.Dataset.create_from_in_memory_data(records=other_data)",
        ">>> url_dataset = dr.Dataset.create_from_url('https://s3.amazonaws.com/my_data/my_dataset.csv',\n...                                          do_snapshot=False)",
        ">>> data_source_dataset = dr.Dataset.create_from_data_source(data_source.id, do_snapshot=False)",
        ">>> project = dataset.create_project(project_name='New Project')\n>>> project.analyze_and_model('some target')\nProject(New Project)",
        "# Details\n>>> details = dataset.get_details()\n>>> details.last_modification_date\ndatetime.datetime(2020, 2, 7, 16, 51, 10, 311000, tzinfo=tzutc())\n>>> details.feature_count_by_type\n[FeatureTypeCount(count=1, feature_type=u'Text'),\n FeatureTypeCount(count=1, feature_type=u'Boolean'),\n FeatureTypeCount(count=16, feature_type=u'Numeric'),\n FeatureTypeCount(count=3, feature_type=u'Categorical')]\n>>> details.to_dataset().id == details.dataset_id\nTrue\n\n# Projects\n>>> dr.Project.create_from_dataset(dataset.id, project_name='Project One')\nProject(Project One)\n>>> dr.Project.create_from_dataset(dataset.id, project_name='Project Two')\nProject(Project Two)\n>>> dataset.get_projects()\n[ProjectLocation(url=u'https://app.datarobot.com/api/v2/projects/5e3c94aff86f2d10692497b5/', id=u'5e3c94aff86f2d10692497b5'),\n ProjectLocation(url=u'https://app.datarobot.com/api/v2/projects/5e3c94eb9525d010a9918ec1/', id=u'5e3c94eb9525d010a9918ec1')]\n>>> first_id = dataset.get_projects()[0].id\n>>> dr.Project.get(first_id).project_name\n'Project One'\n\n# Features\n>>> all_features = dataset.get_all_features()\n>>> feature = next(dataset.iterate_all_features(offset=2, limit=1))\n>>> feature.name == all_features[2].name\nTrue\n>>> print(feature.name, feature.feature_type, feature.dataset_id)\n(u'Partition', u'Numeric', u'5e31cdac39782d0f65842518')\n>>> feature.get_histogram().plot\n[{'count': 3522, 'target': None, 'label': u'0.0'},\n {'count': 3521, 'target': None, 'label': u'1.0'}, ... ]\n\n# The raw data\n>>> with open('myfile.csv', 'wb') as f:\n...     dataset.get_file(filelike=f)",
        ">>> dataset_id = '5e387c501a438646ed7bf0f2'\n>>> dataset = dr.Dataset.get(dataset_id)\n>>> dataset.id == dataset_id\nTrue\n# A blocking call that returns all datasets\n>>> dr.Dataset.list()\n[Dataset(name=u'Untitled Dataset', id=u'5e3c51e0f86f2d1087249728'),\n Dataset(name=u'my_data.csv', id=u'5e3c2028162e6a5fe9a0d678'), ...]\n\n# Avoid listing datasets that fail to properly upload\n>>> dr.Dataset.list(filter_failed=True)\n[Dataset(name=u'my_data.csv', id=u'5e3c2028162e6a5fe9a0d678'),\n Dataset(name=u'my_other_data.csv', id=u'3efc2428g62eaa5f39a6dg7a'), ...]\n\n# An iterator that lazily retrieves from the server page-by-page\n>>> from itertools import islice\n>>> iterator = dr.Dataset.iterate(offset=2)\n>>> for element in islice(iterator, 3):\n...    print(element)\nDataset(name='some_data.csv', id='5e8df2f21a438656e7a23d12')\nDataset(name='other_data.csv', id='5e8df2e31a438656e7a23d0b')\nDataset(name='Untitled Dataset', id='5e6127681a438666cc73c2b0')",
        ">>> dataset.modify(name='A Better Name')\n>>> dataset.name\n'A Better Name'\n\n>>> new_project = dr.Project.create_from_dataset(dataset.id)\n>>> stored_id = dataset.id\n>>> dr.Dataset.delete(dataset.id)\n\n# new_project is still ok\n>>> dr.Project.create_from_dataset(stored_id)\nTraceback (most recent call last):\n ...\ndatarobot.errors.ClientError: 410 client error: {u'message': u'Requested Dataset 5e31cdac39782d0f65842518 was previously deleted.'}\n\n>>> dr.Dataset.un_delete(stored_id)\n>>> dr.Project.create_from_dataset(stored_id, project_name='Successful')\nProject(Successful)",
        ">>> from datarobot.enums import SHARING_ROLE\n>>> from datarobot.models.dataset import Dataset\n>>> from datarobot.models.sharing import SharingAccess\n>>>\n>>> new_access = SharingAccess(\n>>>     \"[email\u00a0protected]\",\n>>>     SHARING_ROLE.OWNER,\n>>>     can_share=True,\n>>> )\n>>> access_list = [\n>>>     SharingAccess(\"[email\u00a0protected]\", SHARING_ROLE.OWNER, can_share=True),\n>>>     new_access,\n>>> ]\n>>>\n>>> Dataset.get('my-dataset-id').share(access_list)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/index.html",
      "title": "Data\uf0c1",
      "description": "Data integrity and quality are cornerstones for creating highly accurate predictive models. These sections describe the tools and visualizations provided to ensure that your project doesn\u2019t suffer the \u201cgarbage in, garbage out\u201d outcome.",
      "content": "Data\uf0c1\nData integrity and quality are cornerstones for creating highly accurate predictive models. These sections describe the tools and visualizations provided to ensure that your project doesn\u2019t suffer the \u201cgarbage in, garbage out\u201d outcome.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/feature_discovery.html",
      "title": "Feature Discovery\uf0c1",
      "description": "Feature Discovery allows you to generate features automatically\nfrom secondary datasets connected to a primary dataset (training data).\nYou can create this type of connection using relationship configuration.",
      "content": "Feature Discovery\uf0c1\nFeature Discovery allows you to generate features automatically\nfrom secondary datasets connected to a primary dataset (training data).\nYou can create this type of connection using relationship configuration.\nRegister a primary dataset to create a project\uf0c1\nTo create a Feature Discovery project, upload the primary (training) dataset:\nProjects\nimport datarobot as dr\nprimary_dataset = dr.Dataset.create_from_file(file_path='your-training_file.csv')\nproject = dr.Project.create_from_dataset(primary_dataset.id, project_name='Lending Club')\nNext, register all the secondary datasets which you want to connect with the primary dataset.\nRegister secondary datasets\uf0c1\nYou can register the dataset using\nDataset.create_from_file, which can take either\na path to a local file or any streamable file object.\nprofile_dataset = dr.Dataset.create_from_file(file_path='your_profile_file.csv')\ntransaction_dataset = dr.Dataset.create_from_file(file_path='your_transaction_file.csv')\nCreate dataset definitions and relationships\uf0c1\nCreate the DatasetDefinition and Relationship for the profile and transaction datasets created above using helper functions.\nprofile_catalog_id = profile_dataset.id\nprofile_catalog_version_id = profile_dataset.version_id\ntransac_catalog_id = transaction_dataset.id\ntransac_catalog_version_id = transaction_dataset.version_id\nprofile_dataset_definition = dr.DatasetDefinition(\nidentifier='profile',\ncatalog_id=profile_catalog_id,\ncatalog_version_id=profile_catalog_version_id\n)\ntransaction_dataset_definition = dr.DatasetDefinition(\nidentifier='transaction',\ncatalog_id=transac_catalog_id,\ncatalog_version_id=transac_catalog_version_id,\nprimary_temporal_key='Date'\n)\nprofile_transaction_relationship = dr.Relationship(\ndataset1_identifier='profile',\ndataset2_identifier='transaction',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID']\n)\nprimary_profile_relationship = dr.Relationship(\ndataset2_identifier='profile',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID'],\nfeature_derivation_window_start=-14,\nfeature_derivation_window_end=-1,\nfeature_derivation_window_time_unit='DAY',\nprediction_point_rounding=1,\nprediction_point_rounding_time_unit='DAY'\n)\ndataset_definitions = [profile_dataset_definition, transaction_dataset_definition]\nrelationships = [primary_profile_relationship, profile_transaction_relationship]\nCreate a relationship configuration\uf0c1\nCreate a relationship configuration using the dataset definitions and relationships created above.\n# Create the relationships configuration to define connection between the datasets\nrelationship_config = dr.RelationshipsConfiguration.create(dataset_definitions=dataset_definitions, relationships=relationships)\nCreate a Feature Discovery project\uf0c1\nOnce you have configured relationships for your datasets, you can create a Feature Discovery project.\n# Set the datetime partitionining column (`date` in this example)\npartitioning_spec = dr.DatetimePartitioningSpecification('date')\n# As of v3.0, use ``Project.set_datetime_partitioning`` instead of passing the spec to ``Project.analyze_and_model`` via ``partitioning_method``.\nproject.set_datetime_partitioning(datetime_partition_spec=partitioning_spec)\n# Set the target for the project and start Feature discovery (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model(target='BadLoan', relationships_configuration_id=relationship_config.id, mode='manual', partitioning_method=partitioning_spec)\nProject(train.csv)\nTo start training a model, reference the ref:modeling <model> documentation.\nCreate secondary dataset configuration for predictions\uf0c1\nCreate configurations for your secondary datasets with Secondary Dataset:\nnew_secondary_dataset_config = dr.SecondaryDatasetConfigurations.create(\nproject_id=project.id,\nname='My config',\nsecondary_datasets=secondary_datasets\n)\nFor more details, reference the Secondary Dataset configuration documentation.\nMake predictions with a trained model\uf0c1\nTo make predictions with a trained model, reference the Predictions documentation.\ndataset_from_path = project.upload_dataset(\n'./data_to_predict.csv',\nsecondary_datasets_config_id=new_secondary_dataset_config.id\n)\npredict_job_1 = model.request_predictions(dataset_from_path.id)\nCommon errors\uf0c1\nDataset registration failed\uf0c1\ndatasetdr.Dataset.create_from_file(file_path='file.csv')\ndatarobot.errors.AsyncProcessUnsuccessfulError: The job did not complete successfully.\nSolutions:\nCheck the internet connectivity. Sometimes network flakiness can cause upload errors.\nCheck the dataset file size. If a file is too large, you should consider uploading the dataset via a URL rather than uploading the file directly.\nRelationship configuration errors\uf0c1\ndatarobot.errors.ClientError: 422 client error: {u'message': u'Invalid field data',\nu'errors': {u'datasetDefinitions': {u'1': {u'identifier': u'value cannot contain characters: $ - \" . { } / \\\\'},\nu'0': {u'identifier': u'value cannot contain characters: $ - \" . { } / \\\\'}}}}\nSolution:\nCheck the identifier name passed in datasets_definitions and relationships.\nTip: Do not use the name of the dataset if you did not specify it when registering the dataset to the AI Catalog.\ndatarobot.errors.ClientError: 422 client error: {u'message': u'Invalid field data',\nu'errors': {u'datasetDefinitions': {u'1': {u'primaryTemporalKey': u'date column doesnt exist'},\n}}}\nSolution:\nCheck if the name of the column passed as primaryTemporalKey is correct, as it is case-sensitive.\nConfigure relationships\uf0c1\nA relationship\u2019s configuration specifies additional datasets to be included to a project, how these datasets are related to each other, and the primary dataset.\nWhen a relationships configuration is specified for a project,\nFeature Discovery will create features automatically from these datasets.\nYou can create a relationship configuration from uploaded AI Catalog items.\nAfter uploading all the secondary datasets in the AI Catalog:\nCreate the dataset\u2019s definition to specify which datasets to be used as secondary datasets along with its details\nConfigure relationships among the above datasets.\nrelationship_config = dr.RelationshipsConfiguration.create(dataset_definitions=dataset_definitions, relationships=relationships)\n>>> relationship_config.id\nu'5506fcd38bd88f5953219da0'\nDataset definitions and relationships using helper functions\uf0c1\nCreate the DatasetDefinition and Relationship for the profile and transaction dataset using helper functions.\nprofile_catalog_id = '5ec4aec1f072bc028e3471ae'\nprofile_catalog_version_id = '5ec4aec2f072bc028e3471b1'\ntransac_catalog_id = '5ec4aec268f0f30289a03901'\ntransac_catalog_version_id = '5ec4aec268f0f30289a03900'\nprofile_dataset_definition = dr.DatasetDefinition(\nidentifier='profile',\ncatalog_id=profile_catalog_id,\ncatalog_version_id=profile_catalog_version_id\n)\ntransaction_dataset_definition = dr.DatasetDefinition(\nidentifier='transaction',\ncatalog_id=transac_catalog_id,\ncatalog_version_id=transac_catalog_version_id,\nprimary_temporal_key='Date'\n)\nprofile_transaction_relationship = dr.Relationship(\ndataset1_identifier='profile',\ndataset2_identifier='transaction',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID']\n)\nprimary_profile_relationship = dr.Relationship(\ndataset2_identifier='profile',\ndataset1_keys=['CustomerID'],\ndataset2_keys=['CustomerID'],\nfeature_derivation_window_start=-14,\nfeature_derivation_window_end=-1,\nfeature_derivation_window_time_unit='DAY',\nprediction_point_rounding=1,\nprediction_point_rounding_time_unit='DAY'\n)\ndataset_definitions = [profile_dataset_definition, transaction_dataset_definition]\nrelationships = [primary_profile_relationship, profile_transaction_relationship]\nDataset definition and relationship using a dictionary\uf0c1\nCreate the dataset definitions and relationships for the profile and transaction dataset using dict directly.\nprofile_catalog_id = profile_dataset.id\nprofile_catalog_version_id = profile_dataset.version_id\ntransac_catalog_id = transaction_dataset.id\ntransac_catalog_version_id = transaction_dataset.version_id\ndataset_definitions = [\n{\n'identifier': 'transaction',\n'catalogVersionId': transac_catalog_version_id,\n'catalogId': transac_catalog_id,\n'primaryTemporalKey': 'Date',\n'snapshotPolicy': 'latest',\n},\n{\n'identifier': 'profile',\n'catalogId': profile_catalog_id,\n'catalogVersionId': profile_catalog_version_id,\n'snapshotPolicy': 'latest',\n},\n]\nrelationships = [\n{\n'dataset2Identifier': 'profile',\n'dataset1Keys': ['CustomerID'],\n'dataset2Keys': ['CustomerID'],\n'featureDerivationWindowStart': -14,\n'featureDerivationWindowEnd': -1,\n'featureDerivationWindowTimeUnit': 'DAY',\n'predictionPointRounding': 1,\n'predictionPointRoundingTimeUnit': 'DAY',\n},\n{\n'dataset1Identifier': 'profile',\n'dataset2Identifier': 'transaction',\n'dataset1Keys': ['CustomerID'],\n'dataset2Keys': ['CustomerID'],\n},\n]\nRetrieving relationship configuration\uf0c1\nYou can retrieve a specific relationship\u2019s configuration using the ID of the relationship configuration.\nrelationship_config_id = '5506fcd38bd88f5953219da0'\nrelationship_config = dr.RelationshipsConfiguration(id=relationship_config_id).get()\n>>> relationship_config.id == relationship_config_id\nTrue\n# Get all the datasets used in this relationship's configuration\n>> len(relationship_config.dataset_definitions) == 2\nTrue\n>> relationship_config.dataset_definitions[0]\n{\n'feature_list_id': '5ec4af93603f596525d382d3',\n'snapshot_policy': 'latest',\n'catalog_id': '5ec4aec268f0f30289a03900',\n'catalog_version_id': '5ec4aec268f0f30289a03901',\n'primary_temporal_key': 'Date',\n'is_deleted': False,\n'identifier': 'transaction',\n'feature_lists':\n[\n{\n'name': 'Raw Features',\n'description': 'System created featurelist',\n'created_by': 'User1',\n'creation_date': datetime.datetime(2020, 5, 20, 4, 18, 27, 150000, tzinfo=tzutc()),\n'user_created': False,\n'dataset_id': '5ec4aec268f0f30289a03900',\n'id': '5ec4af93603f596525d382d1',\n'features': [u'CustomerID', u'AccountID', u'Date', u'Amount', u'Description']\n},\n{\n'name': 'universe',\n'description': 'System created featurelist',\n'created_by': 'User1',\n'creation_date': datetime.datetime(2020, 5, 20, 4, 18, 27, 172000, tzinfo=tzutc()),\n'user_created': False,\n'dataset_id': '5ec4aec268f0f30289a03900',\n'id': '5ec4af93603f596525d382d2',\n'features': [u'CustomerID', u'AccountID', u'Date', u'Amount', u'Description']\n},\n{\n'features': [u'CustomerID', u'AccountID', u'Date', u'Amount', u'Description'],\n'description': 'System created featurelist',\n'created_by': u'Garvit Bansal',\n'creation_date': datetime.datetime(2020, 5, 20, 4, 18, 27, 179000, tzinfo=tzutc()),\n'dataset_version_id': '5ec4aec268f0f30289a03901',\n'user_created': False,\n'dataset_id': '5ec4aec268f0f30289a03900',\n'id': u'5ec4af93603f596525d382d3',\n'name': 'Informative Features'\n}\n]\n}\n# Get information regarding how the datasets are connected among themselves as well as  theprimary dataset\n>> relationship_config.relationships\n[\n{\n'dataset2Identifier': 'profile',\n'dataset1Keys': ['CustomerID'],\n'dataset2Keys': ['CustomerID'],\n'featureDerivationWindowStart': -14,\n'featureDerivationWindowEnd': -1,\n'featureDerivationWindowTimeUnit': 'DAY',\n'predictionPointRounding': 1,\n'predictionPointRoundingTimeUnit': 'DAY',\n},\n{\n'dataset1Identifier': 'profile',\n'dataset2Identifier': 'transaction',\n'dataset1Keys': ['CustomerID'],\n'dataset2Keys': ['CustomerID'],\n},\n]\nUpdate details of a relationship configuration\uf0c1\nUse the snippet below as an example of how to update the details of the existing relationship configuration.\nrelationship_config_id = '5506fcd38bd88f5953219da0'\nrelationship_config = dr.RelationshipsConfiguration(id=relationship_config_id)\n# Remove obsolete dataset definitions and its relationships\nnew_datasets_definiton =\n[\n{\n'identifier': 'user',\n'catalogVersionId': '5c88a37770fc42a2fcc62759',\n'catalogId': '5c88a37770fc42a2fcc62759',\n'snapshotPolicy': 'latest',\n},\n]\n# Get information regarding how the datasets are connected among themselves as well as the primary dataset\nnew_relationships =\n[\n{\n'dataset2Identifier': 'user',\n'dataset1Keys': ['user_id', 'dept_id'],\n'dataset2Keys': ['user_id', 'dept_id'],\n},\n]\nnew_config = relationship_config.replace(new_datasets_definiton, new_relationships)\n>>> new_config.id == relationship_config_id\nTrue\n>>> new_config.datasets_definition\n[\n{\n'identifier': 'user',\n'catalogVersionId': '5c88a37770fc42a2fcc62759',\n'catalogId': '5c88a37770fc42a2fcc62759',\n'snapshotPolicy': 'latest',\n},\n]\n>>> new_config.relationships\n[\n{\n'dataset2Identifier': 'user',\n'dataset1Keys': ['user_id', 'dept_id'],\n'dataset2Keys': ['user_id', 'dept_id'],\n},\n]\nDelete relationships configuration\uf0c1\nYou can delete a relationship configuration that is not used by any project.\nrelationship_config_id = '5506fcd38bd88f5953219da0'\nrelationship_config = dr.RelationshipsConfiguration(id=relationship_config_id)\nresult = relationship_config.get()\n>>> result.id == relationship_config_id\nTrue\n# Delete the relationships configuration\n>>> relationship_config.delete()\n>>> relationship_config.get()\nClientError: Relationships Configuration 5506fcd38bd88f5953219da0 not found\n(secondary-dataset-configuration)=\nSecondary dataset configuration\uf0c1\nSecondary dataset configuration allows you to use the different secondary datasets\nfor a Feature Discovery project when making predictions.\nSecondary datasets using helper functions\uf0c1\nCreate the Secondary Dataset using helper functions.\n>>> profile_catalog_id = '5ec4aec1f072bc028e3471ae'\n>>> profile_catalog_version_id = '5ec4aec2f072bc028e3471b1'\n>>> transac_catalog_id = '5ec4aec268f0f30289a03901'\n>>> transac_catalog_version_id = '5ec4aec268f0f30289a03900'\nprofile_secondary_dataset = dr.SecondaryDataset(\nidentifier='profile',\ncatalog_id=profile_catalog_id,\ncatalog_version_id=profile_catalog_version_id,\nsnapshot_policy='latest'\n)\ntransaction_secondary_dataset = dr.SecondaryDataset(\nidentifier='transaction',\ncatalog_id=transac_catalog_id,\ncatalog_version_id=transac_catalog_version_id,\nsnapshot_policy='latest'\n)\nsecondary_datasets = [profile_secondary_dataset, transaction_secondary_dataset]\nCreate secondary datasets with dict\uf0c1\nYou can create secondary datasets using raw dict structure.\nsecondary_datasets = [\n{\n'snapshot_policy': u'latest',\n'identifier': u'profile',\n'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n'catalog_id': u'5fd06b4af24c641b68e4d88e'\n},\n{\n'snapshot_policy': u'dynamic',\n'identifier': u'transaction',\n'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n'catalog_id': u'5fd1e86c589238a4e635e98d'\n}\n]\nCreate a secondary dataset configuration\uf0c1\nCreate a secondary dataset configuration for a Feature Discovery Project which uses\ntwo secondary datasets: profile and transaction.\nimport datarobot as dr\nproject = dr.Project.get(project_id='54e639a18bd88f08078ca831')\nnew_secondary_dataset_config = dr.SecondaryDatasetConfigurations.create(\nproject_id=project.id,\nname='My config',\nsecondary_datasets=secondary_datasets\n)\n>>> new_secondary_dataset_config.id\n'5fd1e86c589238a4e635e93d'\nRetrieve a secondary dataset configuration\uf0c1\nYou can retrieve specific secondary dataset configurations using the configuration ID.\n>>> config_id = '5fd1e86c589238a4e635e93d'\nsecondary_dataset_config = dr.SecondaryDatasetConfigurations(id=config_id).get()\n>>> secondary_dataset_config.id == config_id\nTrue\n>>> secondary_dataset_config\n{\n'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n'creator_full_name': u'[email\u00a0protected]',\n'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n'credential_ids': None,\n'featurelist_id': None,\n'id': u'5fd1e86c589238a4e635e93d',\n'is_default': True,\n'name': u'My config',\n'project_id': u'5fd06afce2456ec1e9d20457',\n'project_version': None,\n'secondary_datasets': [\n{\n'snapshot_policy': u'latest',\n'identifier': u'profile',\n'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n'catalog_id': u'5fd06b4af24c641b68e4d88e'\n},\n{\n'snapshot_policy': u'dynamic',\n'identifier': u'transaction',\n'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n'catalog_id': u'5fd1e86c589238a4e635e98d'\n}\n]\n}\nList all secondary dataset configurations\uf0c1\nYou can list all secondary dataset configurations created in the project.\n>>> secondary_dataset_configs = dr.SecondaryDatasetConfigurations.list(project.id)\n>>> secondary_dataset_configs[0]\n{\n'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n'creator_full_name': u'[email\u00a0protected]',\n'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n'credential_ids': None,\n'featurelist_id': None,\n'id': u'5fd1e86c589238a4e635e93d',\n'is_default': True,\n'name': u'My config',\n'project_id': u'5fd06afce2456ec1e9d20457',\n'project_version': None,\n'secondary_datasets': [\n{\n'snapshot_policy': u'latest',\n'identifier': u'profile',\n'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n'catalog_id': u'5fd06b4af24c641b68e4d88e'\n},\n{\n'snapshot_policy': u'dynamic',\n'identifier': u'transaction',\n'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n'catalog_id': u'5fd1e86c589238a4e635e98d'\n}\n]\n}",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/project.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/features.html",
        "https://docs.datarobot.com/en/docs/predictions/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nprimary_dataset = dr.Dataset.create_from_file(file_path='your-training_file.csv')\nproject = dr.Project.create_from_dataset(primary_dataset.id, project_name='Lending Club')",
        "profile_dataset = dr.Dataset.create_from_file(file_path='your_profile_file.csv')\ntransaction_dataset = dr.Dataset.create_from_file(file_path='your_transaction_file.csv')",
        "profile_catalog_id = profile_dataset.id\nprofile_catalog_version_id = profile_dataset.version_id\n\ntransac_catalog_id = transaction_dataset.id\ntransac_catalog_version_id = transaction_dataset.version_id\n\nprofile_dataset_definition = dr.DatasetDefinition(\n    identifier='profile',\n    catalog_id=profile_catalog_id,\n    catalog_version_id=profile_catalog_version_id\n)\n\ntransaction_dataset_definition = dr.DatasetDefinition(\n    identifier='transaction',\n    catalog_id=transac_catalog_id,\n    catalog_version_id=transac_catalog_version_id,\n    primary_temporal_key='Date'\n)\n\nprofile_transaction_relationship = dr.Relationship(\n    dataset1_identifier='profile',\n    dataset2_identifier='transaction',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID']\n)\n\nprimary_profile_relationship = dr.Relationship(\n    dataset2_identifier='profile',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID'],\n    feature_derivation_window_start=-14,\n    feature_derivation_window_end=-1,\n    feature_derivation_window_time_unit='DAY',\n    prediction_point_rounding=1,\n    prediction_point_rounding_time_unit='DAY'\n)\n\ndataset_definitions = [profile_dataset_definition, transaction_dataset_definition]\nrelationships = [primary_profile_relationship, profile_transaction_relationship]",
        "# Create the relationships configuration to define connection between the datasets\nrelationship_config = dr.RelationshipsConfiguration.create(dataset_definitions=dataset_definitions, relationships=relationships)",
        "# Set the datetime partitionining column (`date` in this example)\npartitioning_spec = dr.DatetimePartitioningSpecification('date')\n\n# As of v3.0, use ``Project.set_datetime_partitioning`` instead of passing the spec to ``Project.analyze_and_model`` via ``partitioning_method``.\nproject.set_datetime_partitioning(datetime_partition_spec=partitioning_spec)\n\n# Set the target for the project and start Feature discovery (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model(target='BadLoan', relationships_configuration_id=relationship_config.id, mode='manual', partitioning_method=partitioning_spec)\nProject(train.csv)",
        "new_secondary_dataset_config = dr.SecondaryDatasetConfigurations.create(\n    project_id=project.id,\n    name='My config',\n    secondary_datasets=secondary_datasets\n)",
        "dataset_from_path = project.upload_dataset(\n    './data_to_predict.csv',\n    secondary_datasets_config_id=new_secondary_dataset_config.id\n)\n\npredict_job_1 = model.request_predictions(dataset_from_path.id)",
        "datasetdr.Dataset.create_from_file(file_path='file.csv')\ndatarobot.errors.AsyncProcessUnsuccessfulError: The job did not complete successfully.",
        "datarobot.errors.ClientError: 422 client error: {u'message': u'Invalid field data',\nu'errors': {u'datasetDefinitions': {u'1': {u'identifier': u'value cannot contain characters: $ - \" . { } / \\\\'},\nu'0': {u'identifier': u'value cannot contain characters: $ - \" . { } / \\\\'}}}}",
        "datarobot.errors.ClientError: 422 client error: {u'message': u'Invalid field data',\nu'errors': {u'datasetDefinitions': {u'1': {u'primaryTemporalKey': u'date column doesnt exist'},\n}}}",
        "relationship_config = dr.RelationshipsConfiguration.create(dataset_definitions=dataset_definitions, relationships=relationships)\n>>> relationship_config.id\nu'5506fcd38bd88f5953219da0'",
        "profile_catalog_id = '5ec4aec1f072bc028e3471ae'\nprofile_catalog_version_id = '5ec4aec2f072bc028e3471b1'\n\ntransac_catalog_id = '5ec4aec268f0f30289a03901'\ntransac_catalog_version_id = '5ec4aec268f0f30289a03900'\n\nprofile_dataset_definition = dr.DatasetDefinition(\n    identifier='profile',\n    catalog_id=profile_catalog_id,\n    catalog_version_id=profile_catalog_version_id\n)\n\ntransaction_dataset_definition = dr.DatasetDefinition(\n    identifier='transaction',\n    catalog_id=transac_catalog_id,\n    catalog_version_id=transac_catalog_version_id,\n    primary_temporal_key='Date'\n)\n\nprofile_transaction_relationship = dr.Relationship(\n    dataset1_identifier='profile',\n    dataset2_identifier='transaction',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID']\n)\n\nprimary_profile_relationship = dr.Relationship(\n    dataset2_identifier='profile',\n    dataset1_keys=['CustomerID'],\n    dataset2_keys=['CustomerID'],\n    feature_derivation_window_start=-14,\n    feature_derivation_window_end=-1,\n    feature_derivation_window_time_unit='DAY',\n    prediction_point_rounding=1,\n    prediction_point_rounding_time_unit='DAY'\n)\n\ndataset_definitions = [profile_dataset_definition, transaction_dataset_definition]\nrelationships = [primary_profile_relationship, profile_transaction_relationship]",
        "relationship_config_id = '5506fcd38bd88f5953219da0'\nrelationship_config = dr.RelationshipsConfiguration(id=relationship_config_id).get()\n>>> relationship_config.id == relationship_config_id\nTrue\n# Get all the datasets used in this relationship's configuration\n>> len(relationship_config.dataset_definitions) == 2\nTrue\n>> relationship_config.dataset_definitions[0]\n{\n    'feature_list_id': '5ec4af93603f596525d382d3',\n    'snapshot_policy': 'latest',\n    'catalog_id': '5ec4aec268f0f30289a03900',\n    'catalog_version_id': '5ec4aec268f0f30289a03901',\n    'primary_temporal_key': 'Date',\n    'is_deleted': False,\n    'identifier': 'transaction',\n    'feature_lists':\n        [\n            {\n                'name': 'Raw Features',\n                'description': 'System created featurelist',\n                'created_by': 'User1',\n                'creation_date': datetime.datetime(2020, 5, 20, 4, 18, 27, 150000, tzinfo=tzutc()),\n                'user_created': False,\n                'dataset_id': '5ec4aec268f0f30289a03900',\n                'id': '5ec4af93603f596525d382d1',\n                'features': [u'CustomerID', u'AccountID', u'Date', u'Amount', u'Description']\n            },\n            {\n                'name': 'universe',\n                'description': 'System created featurelist',\n                'created_by': 'User1',\n                'creation_date': datetime.datetime(2020, 5, 20, 4, 18, 27, 172000, tzinfo=tzutc()),\n                'user_created': False,\n                'dataset_id': '5ec4aec268f0f30289a03900',\n                'id': '5ec4af93603f596525d382d2',\n                'features': [u'CustomerID', u'AccountID', u'Date', u'Amount', u'Description']\n            },\n            {\n                'features': [u'CustomerID', u'AccountID', u'Date', u'Amount', u'Description'],\n                'description': 'System created featurelist',\n                'created_by': u'Garvit Bansal',\n                'creation_date': datetime.datetime(2020, 5, 20, 4, 18, 27, 179000, tzinfo=tzutc()),\n                'dataset_version_id': '5ec4aec268f0f30289a03901',\n                'user_created': False,\n                'dataset_id': '5ec4aec268f0f30289a03900',\n                'id': u'5ec4af93603f596525d382d3',\n                'name': 'Informative Features'\n            }\n        ]\n}\n# Get information regarding how the datasets are connected among themselves as well as  theprimary dataset\n>> relationship_config.relationships\n[\n    {\n        'dataset2Identifier': 'profile',\n        'dataset1Keys': ['CustomerID'],\n        'dataset2Keys': ['CustomerID'],\n        'featureDerivationWindowStart': -14,\n        'featureDerivationWindowEnd': -1,\n        'featureDerivationWindowTimeUnit': 'DAY',\n        'predictionPointRounding': 1,\n        'predictionPointRoundingTimeUnit': 'DAY',\n    },\n    {\n        'dataset1Identifier': 'profile',\n        'dataset2Identifier': 'transaction',\n        'dataset1Keys': ['CustomerID'],\n        'dataset2Keys': ['CustomerID'],\n    },\n]",
        "relationship_config_id = '5506fcd38bd88f5953219da0'\nrelationship_config = dr.RelationshipsConfiguration(id=relationship_config_id)\n# Remove obsolete dataset definitions and its relationships\nnew_datasets_definiton =\n[\n    {\n        'identifier': 'user',\n        'catalogVersionId': '5c88a37770fc42a2fcc62759',\n        'catalogId': '5c88a37770fc42a2fcc62759',\n        'snapshotPolicy': 'latest',\n    },\n]\n\n# Get information regarding how the datasets are connected among themselves as well as the primary dataset\nnew_relationships =\n[\n    {\n        'dataset2Identifier': 'user',\n        'dataset1Keys': ['user_id', 'dept_id'],\n        'dataset2Keys': ['user_id', 'dept_id'],\n    },\n]\nnew_config = relationship_config.replace(new_datasets_definiton, new_relationships)\n>>> new_config.id == relationship_config_id\nTrue\n>>> new_config.datasets_definition\n[\n    {\n        'identifier': 'user',\n        'catalogVersionId': '5c88a37770fc42a2fcc62759',\n        'catalogId': '5c88a37770fc42a2fcc62759',\n        'snapshotPolicy': 'latest',\n    },\n]\n>>> new_config.relationships\n[\n    {\n        'dataset2Identifier': 'user',\n        'dataset1Keys': ['user_id', 'dept_id'],\n        'dataset2Keys': ['user_id', 'dept_id'],\n    },\n]",
        "relationship_config_id = '5506fcd38bd88f5953219da0'\nrelationship_config = dr.RelationshipsConfiguration(id=relationship_config_id)\nresult = relationship_config.get()\n>>> result.id == relationship_config_id\nTrue\n# Delete the relationships configuration\n>>> relationship_config.delete()\n>>> relationship_config.get()\nClientError: Relationships Configuration 5506fcd38bd88f5953219da0 not found",
        ">>> profile_catalog_id = '5ec4aec1f072bc028e3471ae'\n>>> profile_catalog_version_id = '5ec4aec2f072bc028e3471b1'\n\n>>> transac_catalog_id = '5ec4aec268f0f30289a03901'\n>>> transac_catalog_version_id = '5ec4aec268f0f30289a03900'\n\nprofile_secondary_dataset = dr.SecondaryDataset(\n    identifier='profile',\n    catalog_id=profile_catalog_id,\n    catalog_version_id=profile_catalog_version_id,\n    snapshot_policy='latest'\n)\n\ntransaction_secondary_dataset = dr.SecondaryDataset(\n    identifier='transaction',\n    catalog_id=transac_catalog_id,\n    catalog_version_id=transac_catalog_version_id,\n    snapshot_policy='latest'\n)\n\nsecondary_datasets = [profile_secondary_dataset, transaction_secondary_dataset]",
        "import datarobot as dr\nproject = dr.Project.get(project_id='54e639a18bd88f08078ca831')\n\nnew_secondary_dataset_config = dr.SecondaryDatasetConfigurations.create(\n    project_id=project.id,\n    name='My config',\n    secondary_datasets=secondary_datasets\n)\n\n\n>>> new_secondary_dataset_config.id\n'5fd1e86c589238a4e635e93d'",
        ">>> config_id = '5fd1e86c589238a4e635e93d'\n\nsecondary_dataset_config = dr.SecondaryDatasetConfigurations(id=config_id).get()\n>>> secondary_dataset_config.id == config_id\nTrue\n>>> secondary_dataset_config\n    {\n         'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n         'creator_full_name': u'[email\u00a0protected]',\n         'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n         'credential_ids': None,\n         'featurelist_id': None,\n         'id': u'5fd1e86c589238a4e635e93d',\n         'is_default': True,\n         'name': u'My config',\n         'project_id': u'5fd06afce2456ec1e9d20457',\n         'project_version': None,\n         'secondary_datasets': [\n                {\n                    'snapshot_policy': u'latest',\n                    'identifier': u'profile',\n                    'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n                    'catalog_id': u'5fd06b4af24c641b68e4d88e'\n                },\n                {\n                    'snapshot_policy': u'dynamic',\n                    'identifier': u'transaction',\n                    'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n                    'catalog_id': u'5fd1e86c589238a4e635e98d'\n                }\n         ]\n    }",
        ">>> secondary_dataset_configs = dr.SecondaryDatasetConfigurations.list(project.id)\n>>> secondary_dataset_configs[0]\n    {\n         'created': datetime.datetime(2020, 12, 9, 6, 16, 22, tzinfo=tzutc()),\n         'creator_full_name': u'[email\u00a0protected]',\n         'creator_user_id': u'asdf4af1gf4bdsd2fba1de0a',\n         'credential_ids': None,\n         'featurelist_id': None,\n         'id': u'5fd1e86c589238a4e635e93d',\n         'is_default': True,\n         'name': u'My config',\n         'project_id': u'5fd06afce2456ec1e9d20457',\n         'project_version': None,\n         'secondary_datasets': [\n                {\n                    'snapshot_policy': u'latest',\n                    'identifier': u'profile',\n                    'catalog_version_id': u'5fd06b4af24c641b68e4d88f',\n                    'catalog_id': u'5fd06b4af24c641b68e4d88e'\n                },\n                {\n                    'snapshot_policy': u'dynamic',\n                    'identifier': u'transaction',\n                    'catalog_version_id': u'5fd1e86c589238a4e635e98e',\n                    'catalog_id': u'5fd1e86c589238a4e635e98d'\n                }\n         ]\n    }"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
      "title": "Projects\uf0c1",
      "description": "",
      "content": "Projects\uf0c1\nProject\uf0c1\nclass datarobot.models.Project\uf0c1\nA project built from a particular training dataset\nVariables:\nid (str) \u2013 the id of the project\nproject_name (str) \u2013 the name of the project\nproject_description (str) \u2013 an optional description for the project\nmode (int) \u2013 The current autopilot mode. 0: Full Autopilot. 2: Manual Mode.\n4: Comprehensive Autopilot. null: Mode not set.\ntarget (str) \u2013 the name of the selected target features\ntarget_type (str) \u2013 Indicating what kind of modeling is being done in this project Options are: \u2018Regression\u2019,\n\u2018Binary\u2019 (Binary classification), \u2018Multiclass\u2019 (Multiclass classification),\n\u2018Multilabel\u2019 (Multilabel classification)\nholdout_unlocked (bool) \u2013 whether the holdout has been unlocked\nmetric (str) \u2013 the selected project metric (e.g. LogLoss)\nstage (str) \u2013 the stage the project has reached - one of datarobot.enums.PROJECT_STAGE\npartition (dict) \u2013 information about the selected partitioning options\npositive_class (str) \u2013 for binary classification projects, the selected positive class; otherwise, None\ncreated (datetime.datetime) \u2013 the time the project was created\nadvanced_options (AdvancedOptions) \u2013 information on the advanced options that were selected for the project settings,\ne.g. a weights column or a cap of the runtime of models that can advance autopilot stages\nmax_train_pct (float) \u2013 The maximum percentage of the project dataset that can be used without going into the\nvalidation data or being too large to submit any blueprint for training\nmax_train_rows (int) \u2013 the maximum number of rows that can be trained on without going into the validation data\nor being too large to submit any blueprint for training\nfile_name (str) \u2013 The name of the file uploaded for the project dataset\ncredentials (Optional[List]) \u2013 A list of credentials for the datasets used in relationship configuration\n(previously graphs). For Feature Discovery projects, the list must be formatted\nin dictionary record format. Provide the catalogVersionId and credentialId\nfor each dataset that is to be used in the project that requires authentication.\nfeature_engineering_prediction_point (Optional[str]) \u2013 For time-aware Feature Engineering, this parameter specifies the column from the\nprimary dataset to use as the prediction point.\nunsupervised_mode (Optional[bool]) \u2013 (New in version v2.20) defaults to False, indicates whether this is an unsupervised project.\nrelationships_configuration_id (Optional[str]) \u2013 (New in version v2.21) id of the relationships configuration to use\nquery_generator_id (Optional[str]) \u2013 (New in version v2.27) id of the query generator applied for time series data prep\nsegmentation (dict, optional) \u2013 information on the segmentation options for segmented project\npartitioning_method (PartitioningMethod, optional) \u2013 (New in version v3.0) The partitioning class for this project. This attribute should only be used\nwith newly-created projects and before calling Project.analyze_and_model(). After the project has been\naimed, see Project.partition for actual partitioning options.\ncatalog_id (str) \u2013 (New in version v3.0) ID of the dataset used during creation of the project.\ncatalog_version_id (str) \u2013 (New in version v3.0) The object ID of the catalog_version which the project\u2019s dataset belongs to.\nuse_gpu (bool) \u2013 (New in version v3.2) Whether project allows usage of GPUs\nuse_case_id (Optional[str]) \u2013 (New in version v3.8) The object ID of the use case which the project belongs to.\nset_options(options=None, **kwargs)\uf0c1\nUpdate the advanced options of this project.\nEither accepts an AdvancedOptions object or individual keyword arguments.\nThis is an inplace update.\nRaises:\nValueError \u2013 Raised if an object passed to the options parameter is not an AdvancedOptions instance,\na valid keyword argument from the AdvancedOptions class, or a combination of an AdvancedOptions\ninstance AND keyword arguments.\nReturn type:\nNone\nget_options()\uf0c1\nReturn the stored advanced options for this project.\nReturn type:\nAdvancedOptions\nclassmethod get(project_id)\uf0c1\nGets information about a project.\nParameters:\nproject_id (str) \u2013 The identifier of the project you want to load.\nReturns:\nproject \u2013 The queried project\nReturn type:\nProject\nExamples\nimport datarobot as dr\np = dr.Project.get(project_id='54e639a18bd88f08078ca831')\np.id\n>>>'54e639a18bd88f08078ca831'\np.project_name\n>>>'Some project name'\nclassmethod create(cls, sourcedata, project_name='Untitled Project', max_wait=600, read_timeout=600, dataset_filename=None, *, use_case=None)\uf0c1\nCreates a project with provided data.\nProject creation is asynchronous process, which means that after\ninitial request we will keep polling status of async process\nthat is responsible for project creation until it\u2019s finished.\nFor SDK users this only means that this method might raise\nexceptions related to it\u2019s async nature.\nParameters:\nsourcedata (basestring, file, pathlib.Path or pandas.DataFrame) \u2013 Dataset to use for the project.\nIf string can be either a path to a local file, url to publicly\navailable file or raw file content. If using a file, the filename\nmust consist of ASCII characters only.\nproject_name (str, unicode, optional) \u2013 The name to assign to the empty project.\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered\nunsuccessful\nread_timeout (int) \u2013 The maximum number of seconds to wait for the server to respond indicating that the\ninitial upload is complete\ndataset_filename (string or None, optional) \u2013 (New in version v2.14) File name to use for dataset.\nIgnored for url and file path sources.\nuse_case (UseCase | string, optional) \u2013 A single UseCase object or ID to add this new Project to. Must be a kwarg.\nReturns:\nproject \u2013 Instance with initialized data.\nReturn type:\nProject\nRaises:\nInputNotUnderstoodError \u2013 Raised if sourcedata isn\u2019t one of supported types.\nAsyncFailureError \u2013 Polling for status of async process resulted in response\nwith unsupported status code. Beginning in version 2.1, this\nwill be ProjectAsyncFailureError, a subclass of AsyncFailureError\nAsyncProcessUnsuccessfulError \u2013 Raised if project creation was unsuccessful\nAsyncTimeoutError \u2013 Raised if project creation took more time, than specified\nby max_wait parameter\nExamples\np = Project.create('/home/datasets/somedataset.csv',\nproject_name=\"New API project\")\np.id\n>>> '5921731dkqshda8yd28h'\np.project_name\n>>> 'New API project'\nclassmethod encrypted_string(plaintext)\uf0c1\nSends a string to DataRobot to be encrypted\nThis is used for passwords that DataRobot uses to access external data sources\nParameters:\nplaintext (str) \u2013 The string to encrypt\nReturns:\nciphertext \u2013 The encrypted string\nReturn type:\nstr\nclassmethod create_from_hdfs(cls, url, port=None, project_name=None, max_wait=600)\uf0c1\nCreate a project from a datasource on a WebHDFS server.\nParameters:\nurl (str) \u2013 The location of the WebHDFS file, both server and full path. Per the DataRobot\nspecification, must begin with hdfs://, e.g. hdfs:///tmp/10kDiabetes.csv\nport (Optional[int]) \u2013 The port to use. If not specified, will default to the server default (50070)\nproject_name (Optional[str]) \u2013 A name to give to the project\nmax_wait (int) \u2013 The maximum number of seconds to wait before giving up.\nReturn type:\nProject\nExamples\np = Project.create_from_hdfs('hdfs:///tmp/somedataset.csv',\nproject_name=\"New API project\")\np.id\n>>> '5921731dkqshda8yd28h'\np.project_name\n>>> 'New API project'\nclassmethod create_from_data_source(cls, data_source_id, username=None, password=None, credential_id=None, use_kerberos=None, credential_data=None, project_name=None, max_wait=600, *, use_case=None)\uf0c1\nCreate a project from a data source. Either data_source or data_source_id\nshould be specified.\nParameters:\ndata_source_id (str) \u2013 the identifier of the data source.\nusername (Optional[str]) \u2013 The username for database authentication. If supplied password must also be supplied.\npassword (Optional[str]) \u2013 The password for database authentication. The password is encrypted\nat server side and never saved / stored. If supplied username must also be supplied.\ncredential_id (Optional[str]) \u2013 The ID of the set of credentials to\nuse instead of user and password. Note that with this change, username and password\nwill become optional.\nuse_kerberos (Optional[bool]) \u2013 Server default is False.\nIf true, use kerberos authentication for database authentication.\ncredential_data (dict, optional) \u2013 The credentials to authenticate with the database, to use instead of user/password or\ncredential ID.\nproject_name (Optional[str]) \u2013 optional, a name to give to the project.\nmax_wait (int) \u2013 optional, the maximum number of seconds to wait before giving up.\nuse_case (UseCase | string, optional) \u2013 A single UseCase object or ID to add this new Project to. Must be a kwarg.\nRaises:\nInvalidUsageError \u2013 Raised if either username or password is passed without the other.\nReturn type:\nProject\nclassmethod create_from_dataset(cls, dataset_id, dataset_version_id=None, project_name=None, user=None, password=None, credential_id=None, use_kerberos=None, use_sample_from_dataset=None, credential_data=None, max_wait=600, *, use_case=None)\uf0c1\nCreate a Project from a datarobot.models.Dataset\nParameters:\ndataset_id (string) \u2013 The ID of the dataset entry to user for the project\u2019s Dataset\ndataset_version_id (string, optional) \u2013 The ID of the dataset version to use for the project dataset. If not specified - uses\nlatest version associated with dataset_id\nproject_name (string, optional) \u2013 The name of the project to be created.\nIf not specified, will be \u201cUntitled Project\u201d for database connections, otherwise\nthe project name will be based on the file used.\nuser (string, optional) \u2013 The username for database authentication.\npassword (string, optional) \u2013 The password (in cleartext) for database authentication. The password\nwill be encrypted on the server side in scope of HTTP request and never saved or stored\ncredential_id (string, optional) \u2013 The ID of the set of credentials to use instead of user and password.\nuse_kerberos (Optional[bool]) \u2013 Server default is False.\nIf true, use kerberos authentication for database authentication.\nuse_sample_from_dataset (Optional[bool]) \u2013 Server default is False\nIf true, use the EDA sample for the project instead of the full data.\nIt is optional for datasets between 500 MB and 10 GB.\nFor datasets over 10 GB, this is always set to True on the server side.\ncredential_data (dict, optional) \u2013 The credentials to authenticate with the database, to use instead of user/password or\ncredential ID.\nmax_wait (int) \u2013 optional, the maximum number of seconds to wait before giving up.\nuse_case (UseCase | string, optional) \u2013 A single UseCase object or ID to add this new Project to. Must be a kwarg.\nReturn type:\nProject\nclassmethod create_from_recipe(cls, recipe_id, *, use_case=None)\uf0c1\nCreate a project from a recipe\nParameters:\nrecipe_id (string) \u2013 The ID of the recipe entry to use to create the project\u2019s dataset.\nReturn type:\nProject\nclassmethod create_segmented_project_from_clustering_model(cls, clustering_project_id, clustering_model_id, target, max_wait=600, *, use_case=None)\uf0c1\nCreate a new segmented project from a clustering model\nParameters:\nclustering_project_id (str) \u2013 The identifier of the clustering project you want to use as\nthe base.\nclustering_model_id (str) \u2013 The identifier of the clustering model you want to use as the\nsegmentation method.\ntarget (str) \u2013 The name of the target column that will be used from the\nclustering project.\nmax_wait (int) \u2013 optional, the maximum number of seconds to wait before giving up.\nuse_case (UseCase | string, optional) \u2013 A single UseCase object or ID to add this new Project to. Must be a kwarg.\nReturns:\nproject \u2013 The created project\nReturn type:\nProject\nclassmethod from_async(async_location, max_wait=600)\uf0c1\nGiven a temporary async status location poll for no more than max_wait seconds\nuntil the async process (project creation or setting the target, for example)\nfinishes successfully, then return the ready project\nParameters:\nasync_location (str) \u2013 The URL for the temporary async status resource. This is returned\nas a header in the response to a request that initiates an\nasync process\nmax_wait (int) \u2013 The maximum number of seconds to wait before giving up.\nReturns:\nproject \u2013 The project, now ready\nReturn type:\nProject\nRaises:\nProjectAsyncFailureError \u2013 If the server returned an unexpected response while polling for the\nasynchronous operation to resolve\nAsyncProcessUnsuccessfulError \u2013 If the final result of the asynchronous operation was a failure\nAsyncTimeoutError \u2013 If the asynchronous operation did not resolve within the time\nspecified\nclassmethod start(cls, sourcedata, target=None, project_name='Untitled Project', worker_count=None, metric=None, autopilot_on=True, blueprint_threshold=None, response_cap=None, partitioning_method=None, positive_class=None, target_type=None, unsupervised_mode=False, blend_best_models=None, prepare_model_for_deployment=None, consider_blenders_in_recommendation=None, scoring_code_only=None, min_secondary_validation_model_count=None, shap_only_mode=None, relationships_configuration_id=None, autopilot_with_feature_discovery=None, feature_discovery_supervised_feature_reduction=None, unsupervised_type=None, autopilot_cluster_list=None, bias_mitigation_feature_name=None, bias_mitigation_technique=None, include_bias_mitigation_feature_as_predictor_variable=None, incremental_learning_only_mode=None, incremental_learning_on_best_model=None, number_of_incremental_learning_iterations_before_best_model_selection=None, *, use_case=None)\uf0c1\nChain together project creation, file upload, and target selection.\nNotes\nWhile this function provides a simple means to get started, it does not expose\nall possible parameters. For advanced usage, using create, set_advanced_options\nand analyze_and_model directly is recommended.\nParameters:\nsourcedata (str or pandas.DataFrame) \u2013 The path to the file to upload. Can be either a path to a\nlocal file or a publicly accessible URL (starting with http://, https://,\nfile://, or s3://). If the source is a DataFrame, it will be serialized to a\ntemporary buffer.\nIf using a file, the filename must consist of ASCII\ncharacters only.\ntarget (Optional[str]) \u2013 The name of the target column in the uploaded file. Should not be provided if\nunsupervised_mode is True.\nproject_name (str) \u2013 The project name.\nworker_count (Optional[int]) \u2013 The number of workers that you want to allocate to this project.\nmetric (Optional[str]) \u2013 The name of metric to use.\nautopilot_on (boolean, default True) \u2013 Whether or not to begin modeling automatically.\nblueprint_threshold (Optional[int]) \u2013 Number of hours the model is permitted to run.\nMinimum 1\nresponse_cap (Optional[float]) \u2013 Quantile of the response distribution to use for response capping\nMust be in range 0.5 .. 1.0\npartitioning_method (PartitioningMethod object, optional) \u2013 Instance of one of the Partition Classes defined in\ndatarobot.helpers.partitioning_methods.  As an alternative, use\nProject.set_partitioning_method\nor Project.set_datetime_partitioning\nto set the partitioning for the project.\npositive_class (str, float, or int; optional) \u2013 Specifies a level of the target column that should be treated as the\npositive class for binary classification.  May only be specified\nfor binary classification targets.\ntarget_type (Optional[str]) \u2013 Override the automatically selected target_type. An example usage would be setting the\ntarget_type=\u2019Multiclass\u2019 when you want to preform a multiclass classification task on a\nnumeric column that has a low cardinality.\nYou can use TARGET_TYPE enum.\nunsupervised_mode (boolean, default False) \u2013 Specifies whether to create an unsupervised project.\nblend_best_models (Optional[bool]) \u2013 blend best models during Autopilot run\nscoring_code_only (Optional[bool]) \u2013 Keep only models that can be converted to scorable java code during Autopilot run.\nshap_only_mode (Optional[bool]) \u2013 Keep only models that support SHAP values during Autopilot run. Use SHAP-based insights\nwherever possible. Defaults to False.\nprepare_model_for_deployment (Optional[bool]) \u2013 Prepare model for deployment during Autopilot run.\nThe preparation includes creating reduced feature list models, retraining best model on\nhigher sample size, computing insights and assigning \u201cRECOMMENDED FOR DEPLOYMENT\u201d label.\nconsider_blenders_in_recommendation (Optional[bool]) \u2013 Include blenders when selecting a model to prepare for deployment in an Autopilot Run.\nDefaults to False.\nmin_secondary_validation_model_count (Optional[int]) \u2013 Compute \u201cAll backtest\u201d scores (datetime models) or cross validation scores\nfor the specified number of highest ranking models on the Leaderboard,\nif over the Autopilot default.\nrelationships_configuration_id (Optional[str]) \u2013 (New in version v2.23) id of the relationships configuration to use\nautopilot_with_feature_discovery (Optional[bool].) \u2013 (New in version v2.23) If true, autopilot will run on a feature list that includes\nfeatures found via search for interactions.\nfeature_discovery_supervised_feature_reduction (Optional[bool]) \u2013 (New in version v2.23) Run supervised feature reduction for feature discovery projects.\nunsupervised_type (UnsupervisedTypeEnum, optional) \u2013 (New in version v2.27) Specifies whether an unsupervised project is anomaly detection\nor clustering.\nautopilot_cluster_list (list(int), optional) \u2013 (New in version v2.27) Specifies the list of clusters to build for each model during\nAutopilot. Specifying multiple values in a list will build models with each number\nof clusters for the Leaderboard.\nbias_mitigation_feature_name (Optional[str]) \u2013 The feature from protected features that will be used in a bias mitigation task to\nmitigate bias\nbias_mitigation_technique (Optional[str]) \u2013 One of datarobot.enums.BiasMitigationTechnique\nOptions:\n- \u2018preprocessingReweighing\u2019\n- \u2018postProcessingRejectionOptionBasedClassification\u2019\nThe technique by which we\u2019ll mitigate bias, which will inform which bias mitigation task\nwe insert into blueprints\ninclude_bias_mitigation_feature_as_predictor_variable (Optional[bool]) \u2013 Whether we should also use the mitigation feature as in input to the modeler just like\nany other categorical used for training, i.e. do we want the model to \u201ctrain on\u201d this\nfeature in addition to using it for bias mitigation\nuse_case (UseCase | string, optional) \u2013 A single UseCase object or ID to add this new Project to. Must be a kwarg.\nReturns:\nproject \u2013 The newly created and initialized project.\nReturn type:\nProject\nRaises:\nAsyncFailureError \u2013 Polling for status of async process resulted in response\nwith unsupported status code\nAsyncProcessUnsuccessfulError \u2013 Raised if project creation or target setting was unsuccessful\nAsyncTimeoutError \u2013 Raised if project creation or target setting timed out\nExamples\nProject.start(\"./tests/fixtures/file.csv\",\n\"a_target\",\nproject_name=\"test_name\",\nworker_count=4,\nmetric=\"a_metric\")\nThis is an example of using a URL to specify the datasource:\nProject.start(\"https://example.com/data/file.csv\",\n\"a_target\",\nproject_name=\"test_name\",\nworker_count=4,\nmetric=\"a_metric\")\nclassmethod list(search_params=None, use_cases=None, offset=None, limit=None)\uf0c1\nReturns the projects associated with this account.\nParameters:\nsearch_params (dict, optional.) \u2013 If not None, the returned projects are filtered by lookup.\nCurrently you can query projects by:\nproject_name\nuse_cases (Union[UseCase, List[UseCase], str, List[str]], optional.) \u2013 If not None, the returned projects are filtered to those associated\nwith a specific Use Case or Use Cases. Accepts either the entity or the ID.\noffset (Optional[int]) \u2013 If provided, specifies the number of results to skip.\nlimit (Optional[int]) \u2013 If provided, specifies the maximum number of results to return. If not provided,\nreturns a maximum of 1000 results.\nReturns:\nprojects \u2013 Contains a list of projects associated with this user\naccount.\nReturn type:\nlist of Project instances\nRaises:\nTypeError \u2013 Raised if search_params parameter is provided,\nbut is not of supported type.\nExamples\nList all projects\np_list = Project.list()\np_list\n>>> [Project('Project One'), Project('Two')]\nSearch for projects by name\nProject.list(search_params={'project_name': 'red'})\n>>> [Project('Prediction Time'), Project('Fred Project')]\nList 2nd and 3rd projects\nProject.list(offset=1, limit=2)\n>>> [Project('Project 2'), Project('Project 3')]\nrefresh()\uf0c1\nFetches the latest state of the project, and updates this object\nwith that information. This is an in place update, not a new object.\nReturn type:\nNone\ndelete()\uf0c1\nRemoves this project from your account.\nReturn type:\nNone\nanalyze_and_model(target=None, mode='quick', metric=None, worker_count=None, positive_class=None, partitioning_method=None, featurelist_id=None, advanced_options=None, max_wait=600, target_type=None, credentials=None, feature_engineering_prediction_point=None, unsupervised_mode=False, relationships_configuration_id=None, class_mapping_aggregation_settings=None, segmentation_task_id=None, unsupervised_type=None, autopilot_cluster_list=None, use_gpu=None)\uf0c1\nSet target variable of an existing project and begin the autopilot process or send data to DataRobot\nfor feature analysis only if manual mode is specified.\nAny options saved using set_options will be used if nothing is passed to advanced_options.\nHowever, saved options will be ignored if advanced_options are passed.\nTarget setting is an asynchronous process, which means that after\ninitial request we will keep polling status of async process\nthat is responsible for target setting until it\u2019s finished.\nFor SDK users this only means that this method might raise\nexceptions related to it\u2019s async nature.\nWhen execution returns to the caller, the autopilot process will already have commenced\n(again, unless manual mode is specified).\nParameters:\ntarget (Optional[str]) \u2013 The name of the target column in the uploaded file. Should not be provided if\nunsupervised_mode is True.\nmode (Optional[str]) \u2013 You can use AUTOPILOT_MODE enum to choose between AUTOPILOT_MODE.FULL_AUTO,\nAUTOPILOT_MODE.MANUAL, AUTOPILOT_MODE.QUICK, and AUTOPILOT_MODE.COMPREHENSIVE.\nCOMPREHENSIVE` runs all blueprints in the repository (this may be extremely slow).\nIf unspecified, ``QUICK is used. If the MANUAL value is used, the model\ncreation process will need to be started by executing the start_autopilot\nfunction with the desired featurelist. It will start immediately otherwise.\nmetric (Optional[str]) \u2013 Name of the metric to use for evaluating models. You can query\nthe metrics available for the target by way of\nProject.get_metrics. If none is specified, then the default\nrecommended by DataRobot is used.\nworker_count (Optional[int]) \u2013 The number of concurrent workers to request for this project. If\nNone, then the default is used.\n(New in version v2.14) Setting this to -1 will request the maximum number\navailable to your account.\npartitioning_method (PartitioningMethod object, optional) \u2013 Instance of one of the Partition Classes defined in\ndatarobot.helpers.partitioning_methods.  As an alternative, use\nProject.set_partitioning_method\nor Project.set_datetime_partitioning\nto set the partitioning for the project.\npositive_class (str, float, or int; optional) \u2013 Specifies a level of the target column that should be treated as the\npositive class for binary classification.  May only be specified\nfor binary classification targets.\nfeaturelist_id (Optional[str]) \u2013 Specifies which feature list to use.\nadvanced_options (AdvancedOptions, optional) \u2013 Used to set advanced options of project creation. Will override any options saved using set_options.\nmax_wait (Optional[int]) \u2013 Time in seconds after which target setting is considered\nunsuccessful.\ntarget_type (Optional[str]) \u2013 Override the automatically selected target_type. An example usage would be setting the\ntarget_type=\u2019Multiclass\u2019 when you want to preform a multiclass classification task on a\nnumeric column that has a low cardinality. You can use TARGET_TYPE enum.\ncredentials (Optional[List]) \u2013 a list of credentials for the datasets used in relationship configuration\n(previously graphs).\nfeature_engineering_prediction_point (Optional[str]) \u2013 additional aim parameter.\nunsupervised_mode (boolean, default False) \u2013 (New in version v2.20) Specifies whether to create an unsupervised project. If True,\ntarget may not be provided.\nrelationships_configuration_id (Optional[str]) \u2013 (New in version v2.21) ID of the relationships configuration to use.\nsegmentation_task_id (str or SegmentationTask, optional) \u2013 (New in version v2.28) The segmentation task that should be used to split the project\nfor segmented modeling.\nunsupervised_type (UnsupervisedTypeEnum, optional) \u2013 (New in version v2.27) Specifies whether an unsupervised project is anomaly detection\nor clustering.\nautopilot_cluster_list (list(int), optional) \u2013 (New in version v2.27) Specifies the list of clusters to build for each model during\nAutopilot. Specifying multiple values in a list will build models with each number\nof clusters for the Leaderboard.\nuse_gpu (Optional[bool]) \u2013 (New in version v3.2) Specifies whether project should use GPUs\nReturns:\nproject \u2013 The instance with updated attributes.\nReturn type:\nProject\nRaises:\nAsyncFailureError \u2013 Polling for status of async process resulted in response\nwith unsupported status code\nAsyncProcessUnsuccessfulError \u2013 Raised if target setting was unsuccessful\nAsyncTimeoutError \u2013 Raised if target setting took more time, than specified\nby max_wait parameter\nTypeError \u2013 Raised if advanced_options, partitioning_method or target_type is\nprovided, but is not of supported type\nSee also\ndatarobot.models.Project.startcombines project creation, file upload, and target selection. Provides fewer options, but is useful for getting started quickly.\nset_target(target=None, mode='quick', metric=None, worker_count=None, positive_class=None, partitioning_method=None, featurelist_id=None, advanced_options=None, max_wait=600, target_type=None, credentials=None, feature_engineering_prediction_point=None, unsupervised_mode=False, relationships_configuration_id=None, class_mapping_aggregation_settings=None, segmentation_task_id=None, unsupervised_type=None, autopilot_cluster_list=None)\uf0c1\nSet target variable of an existing project and begin the Autopilot process (unless manual\nmode is specified).\nTarget setting is an asynchronous process, which means that after\ninitial request DataRobot keeps polling status of an async process\nthat is responsible for target setting until it\u2019s finished.\nFor SDK users, this method might raise\nexceptions related to its async nature.\nWhen execution returns to the caller, the Autopilot process will already have commenced\n(again, unless manual mode is specified).\nParameters:\ntarget (Optional[str]) \u2013 The name of the target column in the uploaded file. Should not be provided if\nunsupervised_mode is True.\nmode (Optional[str]) \u2013 You can use AUTOPILOT_MODE enum to choose between\nAUTOPILOT_MODE.FULL_AUTO\nAUTOPILOT_MODE.MANUAL\nAUTOPILOT_MODE.QUICK\nAUTOPILOT_MODE.COMPREHENSIVE: Runs all blueprints in the repository (warning:\nthis may be extremely slow).\nIf unspecified, QUICK mode is used. If the MANUAL value is used, the model\ncreation process needs to be started by executing the start_autopilot\nfunction with the desired feature list. It will start immediately otherwise.\nmetric (Optional[str]) \u2013 Name of the metric to use for evaluating models. You can query\nthe metrics available for the target by way of\nProject.get_metrics. If none is specified, then the default\nrecommended by DataRobot is used.\nworker_count (Optional[int]) \u2013 The number of concurrent workers to request for this project. If\nNone, then the default is used.\n(New in version v2.14) Setting this to -1 will request the maximum number\navailable to your account.\npositive_class (str, float, or int; optional) \u2013 Specifies a level of the target column that should be treated as the\npositive class for binary classification.  May only be specified\nfor binary classification targets.\npartitioning_method (PartitioningMethod object, optional) \u2013 Instance of one of the Partition Classes defined in\ndatarobot.helpers.partitioning_methods.  As an alternative, use\nProject.set_partitioning_method\nor Project.set_datetime_partitioning\nto set the partitioning for the project.\nfeaturelist_id (Optional[str]) \u2013 Specifies which feature list to use.\nadvanced_options (AdvancedOptions, optional) \u2013 Used to set advanced options of project creation.\nmax_wait (Optional[int]) \u2013 Time in seconds after which target setting is considered\nunsuccessful.\ntarget_type (Optional[str]) \u2013 Override the automatically selected target_type. An example usage would be setting the\ntarget_type=Multiclass\u2019 when you want to preform a multiclass classification task on a\nnumeric column that has a low cardinality. You can use ``TARGET_TYPE` enum.\ncredentials (Optional[List]) \u2013 A list of credentials for the datasets used in relationship configuration\n(previously graphs).\nfeature_engineering_prediction_point (Optional[str]) \u2013 For time-aware Feature Engineering, this parameter specifies the column from the\nprimary dataset to use as the prediction point.\nunsupervised_mode (boolean, default False) \u2013 (New in version v2.20) Specifies whether to create an unsupervised project. If True,\ntarget may not be provided.\nrelationships_configuration_id (Optional[str]) \u2013 (New in version v2.21) ID of the relationships configuration to use.\nclass_mapping_aggregation_settings (ClassMappingAggregationSettings, optional) \u2013 Instance of datarobot.helpers.ClassMappingAggregationSettings\nsegmentation_task_id (str or SegmentationTask, optional) \u2013 (New in version v2.28) The segmentation task that should be used to split the project\nfor segmented modeling.\nunsupervised_type (Optional[UnsupervisedTypeEnum]) \u2013 (New in version v2.27) Specifies whether an unsupervised project is anomaly detection\nor clustering.\nautopilot_cluster_list (Optional[List[int]]) \u2013 (New in version v2.27) Specifies the list of clusters to build for each model during\nAutopilot. Specifying multiple values in a list will build models with each number\nof clusters for the Leaderboard.\nReturns:\nproject \u2013 The instance with updated attributes.\nReturn type:\nProject\nRaises:\nAsyncFailureError \u2013 Polling for status of async process resulted in response\nwith unsupported status code.\nAsyncProcessUnsuccessfulError \u2013 Raised if target setting was unsuccessful.\nAsyncTimeoutError \u2013 Raised if target setting took more time, than specified\nby max_wait parameter.\nTypeError \u2013 Raised if advanced_options, partitioning_method or target_type is\nprovided, but is not of supported type.\nSee also\ndatarobot.models.Project.startCombines project creation, file upload, and target selection. Provides fewer options, but is useful for getting started quickly.\ndatarobot.models.Project.analyze_and_modelthe method replacing set_target after it is removed.\nget_model_records(sort_by_partition='validation', sort_by_metric=None, with_metric=None, search_term=None, featurelists=None, families=None, blueprints=None, labels=None, characteristics=None, training_filters=None, number_of_clusters=None, limit=100, offset=0)\uf0c1\nRetrieve paginated model records, sorted by scores, with optional filtering.\nParameters:\nsort_by_partition (str, one of validation, backtesting, crossValidation or holdout) \u2013 Set the partition to use for sorted (by score) list of models. validation is the default.\nsort_by_metric (str) \u2013\nSet the project metric to use for model sorting. DataRobot-selected project optimization metricis the default.\nwith_metric (str) \u2013 For a single-metric list of results, specify that project metric.\nsearch_term (str) \u2013 If specified, only models containing the term in their name or processes are returned.\nfeaturelists (List[str]) \u2013 If specified, only models trained on selected featurelists are returned.\nfamilies (List[str]) \u2013 If specified, only models belonging to selected families are returned.\nblueprints (List[str]) \u2013 If specified, only models trained on specified blueprint IDs are returned.\nlabels (List[str], starred or prepared for deployment) \u2013 If specified, only models tagged with all listed labels are returned.\ncharacteristics (List[str]) \u2013 If specified, only models matching all listed characteristics are returned. Possible values\n\u201cfrozen\u201d,\u201dtrained on gpu\u201d,\u201dwith exportable coefficients\u201d,\u201dwith mono constraints\u201d,\u201dwith rating table\u201d,\n\u201cwith scoring code\u201d,\u201dnew series optimized\u201d\ntraining_filters (List[str]) \u2013 If specified, only models matching at least one of the listed training conditions are returned.\nThe following formats are supported for autoML and datetime partitioned projects:\n- number of rows in training subset\nFor datetime partitioned projects:\n- <training duration>, example P6Y0M0D\n- <training_duration>-<time_window_sample_percent>-<sampling_method> Example: P6Y0M0D-78-Random,\n(returns models trained on 6 years of data, sampling rate 78%, random sampling).\n- Start/end date\n- Project settings\nnumber_of_clusters (list of int) \u2013 Filter models by number of clusters. Applicable only in unsupervised clustering projects.\nlimit (int)\noffset (int)\nReturns:\ngeneric_models\nReturn type:\nlist of GenericModel\nget_models(order_by=None, search_params=None, with_metric=None, use_new_models_retrieval=False)\uf0c1\nList all completed, successful models in the leaderboard for the given project.\nParameters:\norder_by (str or list of strings, optional) \u2013 If not None, the returned models are ordered by this\nattribute. If None, the default return is the order of\ndefault project metric.\nAllowed attributes to sort by are:\nmetric\nsample_pct\nIf the sort attribute is preceded by a hyphen, models will be sorted in descending\norder, otherwise in ascending order.\nMultiple sort attributes can be included as a comma-delimited string or in a list\ne.g. order_by=`sample_pct,-metric` or order_by=[sample_pct, -metric]\nUsing metric to sort by will result in models being sorted according to their\nvalidation score by how well they did according to the project metric.\nsearch_params (dict, optional.) \u2013 If not None, the returned models are filtered by lookup.\nCurrently you can query models by:\nname\nsample_pct\nis_starred\nwith_metric (Optional[str].) \u2013 If not None, the returned models will only have scores for this\nmetric. Otherwise all the metrics are returned.\nuse_new_models_retrieval (bool, False by default) \u2013 If true, new retrieval route is used, which supports filtering and returns fewer attributes per\nindividual model. Following attributes are absent and could be retrieved from the blueprint level:\nmonotonic_increasing_featurelist_id, monotonic_decreasing_featurelist_id, supports_composable_ml\nand supports_monotonic_constraints. Following attributes are absent and could be retrieved from\nthe individual model level: has_empty_clusters, is_n_clusters_dynamically_determined,\nprediction_threshold and prediction_threshold_read_only. Attribute n_clusters in Model is\nrenamed to number_of_clusters in GenericModel and is returned for unsupervised clustering models.\nReturns:\nmodels \u2013 All models trained in the project.\nReturn type:\na list of Model or a list of GenericModel if `use_new_models_retrieval is True.`\nRaises:\nTypeError \u2013 Raised if order_by or search_params parameter is provided,\nbut is not of supported type.\nExamples\nProject.get('pid').get_models(order_by=['-sample_pct',\n'metric'])\n# Getting models that contain \"Ridge\" in name\nProject.get('pid').get_models(\nsearch_params={\n'name': \"Ridge\"\n})\n# Filtering models based on 'starred' flag:\nProject.get('pid').get_models(search_params={'is_starred': True})\n# retrieve additional attributes for the model\nmodel_records = project.get_models(use_new_models_retrieval=True)\nmodel_record = model_records[0]\nblueprint_id = model_record.blueprint_id\nblueprint = dr.Blueprint.get(project.id, blueprint_id)\nmodel_record.number_of_clusters\nblueprint.supports_composable_ml\nblueprint.supports_monotonic_constraints\nblueprint.monotonic_decreasing_featurelist_id\nblueprint.monotonic_increasing_featurelist_id\nmodel = dr.Model.get(project.id, model_record.id)\nmodel.prediction_threshold\nmodel.prediction_threshold_read_only\nmodel.has_empty_clusters\nmodel.is_n_clusters_dynamically_determined\nrecommended_model()\uf0c1\nReturns the default recommended model, or None if there is no default recommended model.\nReturns:\nrecommended_model \u2013 The default recommended model.\nReturn type:\nModel or None\nget_top_model(metric=None)\uf0c1\nObtain the top ranked model for a given metric/\nIf no metric is passed in, it uses the project\u2019s default metric.\nModels that display score of N/A in the UI are not included in the ranking (see\nhttps://docs.datarobot.com/en/docs/modeling/reference/model-detail/leaderboard-ref.html#na-scores).\nParameters:\nmetric (Optional[str]) \u2013 Metric to sort models\nReturns:\nmodel \u2013 The top model\nReturn type:\nModel\nRaises:\nValueError \u2013 Raised if the project is unsupervised.\nRaised if the project has no target set.\nRaised if no metric was passed or the project has no metric.\nRaised if the metric passed is not used by the models on the leaderboard.\nExamples\nfrom datarobot.models.project import Project\nproject = Project.get(\"<MY_PROJECT_ID>\")\ntop_model = project.get_top_model()\nget_datetime_models()\uf0c1\nList all models in the project as DatetimeModels\nRequires the project to be datetime partitioned.  If it is not, a ClientError will occur.\nReturns:\nmodels \u2013 the datetime models\nReturn type:\nlist of DatetimeModel\nget_prime_models()\uf0c1\nList all DataRobot Prime models for the project\nPrime models were created to approximate a parent model, and have downloadable code.\nReturns:\nmodels\nReturn type:\nlist of PrimeModel\nget_prime_files(parent_model_id=None, model_id=None)\uf0c1\nList all downloadable code files from DataRobot Prime for the project\nParameters:\nparent_model_id (Optional[str]) \u2013 Filter for only those prime files approximating this parent model\nmodel_id (Optional[str]) \u2013 Filter for only those prime files with code for this prime model\nReturns:\nfiles\nReturn type:\nlist of PrimeFile\nget_dataset()\uf0c1\nRetrieve the dataset used to create a project.\nReturns:\nDataset used for creation of project or None if no catalog_id present.\nReturn type:\nDataset\nExamples\nfrom datarobot.models.project import Project\nproject = Project.get(\"<MY_PROJECT_ID>\")\ndataset = project.get_dataset()\nget_datasets()\uf0c1\nList all the datasets that have been uploaded for predictions\nReturns:\ndatasets\nReturn type:\nlist of PredictionDataset instances\nupload_dataset(sourcedata, max_wait=600, read_timeout=600, forecast_point=None, predictions_start_date=None, predictions_end_date=None, dataset_filename=None, relax_known_in_advance_features_check=None, credentials=None, actual_value_column=None, secondary_datasets_config_id=None)\uf0c1\nUpload a new dataset to make predictions against\nParameters:\nsourcedata (str, file or pandas.DataFrame) \u2013 Data to be used for predictions. If string, can be either a path to a local file,\na publicly accessible URL (starting with http://, https://, file://), or\nraw file content. If using a file on disk, the filename must consist of ASCII\ncharacters only.\nmax_wait (Optional[int]) \u2013 The maximum number of seconds to wait for the uploaded dataset to be processed before\nraising an error.\nread_timeout (Optional[int]) \u2013 The maximum number of seconds to wait for the server to respond indicating that the\ninitial upload is complete\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.8) May only be specified for time series projects, otherwise the\nupload will be rejected. The time in the dataset relative to which predictions should be\ngenerated in a time series project.  See the Time Series documentation for more information. If not provided, will default to using the\nlatest forecast point in the dataset.\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.11) May only be specified for time series projects. The start date\nfor bulk predictions. Note that this parameter is for generating historical predictions\nusing the training data. This parameter should be provided in conjunction with\npredictions_end_date. Cannot be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.11) May only be specified for time series projects. The end date\nfor bulk predictions, exclusive. Note that this parameter is for generating\nhistorical predictions using the training data. This parameter should be provided in\nconjunction with predictions_start_date.\nCannot be provided with the forecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) Actual value column name, valid for the prediction\nfiles if the project is unsupervised and the dataset is considered as bulk predictions\ndataset. Cannot be provided with the forecast_point parameter.\ndataset_filename (string or None, optional) \u2013 (New in version v2.14) File name to use for the dataset.\nIgnored for url and file path sources.\nrelax_known_in_advance_features_check (Optional[bool]) \u2013 (New in version v2.15) For time series projects only. If True, missing values in the\nknown in advance features are allowed in the forecast window at the prediction time.\nIf omitted or False, missing values are not allowed.\ncredentials (Optional[List] a list of credentials for the datasets used) \u2013 in Feature discovery project\nsecondary_datasets_config_id (string or None, optional) \u2013 (New in version v2.23) The Id of the alternative secondary dataset config\nto use during prediction for Feature discovery project.\nReturns:\ndataset \u2013 The newly uploaded dataset.\nReturn type:\nPredictionDataset\nRaises:\nInputNotUnderstoodError \u2013 Raised if sourcedata isn\u2019t one of supported types.\nAsyncFailureError \u2013 Raised if polling for the status of an async process resulted in a response with an\nunsupported status code.\nAsyncProcessUnsuccessfulError \u2013 Raised if project creation was unsuccessful (i.e. the server reported an error in\nuploading the dataset).\nAsyncTimeoutError \u2013 Raised if processing the uploaded dataset took more time than specified\nby the max_wait parameter.\nValueError \u2013 Raised if forecast_point or predictions_start_date and predictions_end_date\nare provided, but are not of the supported type.\nupload_dataset_from_data_source(data_source_id, username, password, max_wait=600, forecast_point=None, relax_known_in_advance_features_check=None, credentials=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, secondary_datasets_config_id=None)\uf0c1\nUpload a new dataset from a data source to make predictions against\nParameters:\ndata_source_id (str) \u2013 The identifier of the data source.\nusername (str) \u2013 The username for database authentication.\npassword (str) \u2013 The password for database authentication. The password is encrypted\nat server side and never saved / stored.\nmax_wait (Optional[int]) \u2013 Optional, the maximum number of seconds to wait before giving up.\nforecast_point (datetime.datetime or None, optional) \u2013 (New in version v2.8) For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\nrelax_known_in_advance_features_check (Optional[bool]) \u2013 (New in version v2.15) For time series projects only. If True, missing values in the\nknown in advance features are allowed in the forecast window at the prediction time.\nIf omitted or False, missing values are not allowed.\ncredentials (Optional[List] a list of credentials for the datasets used) \u2013 in Feature discovery project\npredictions_start_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 (New in version v2.20) For time series projects only. The end date for bulk predictions,\nexclusive. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_start_date. Can\u2019t be provided with the forecast_point parameter.\nactual_value_column (string, optional) \u2013 (New in version v2.21) Actual value column name, valid for the prediction\nfiles if the project is unsupervised and the dataset is considered as bulk predictions\ndataset. Cannot be provided with the forecast_point parameter.\nsecondary_datasets_config_id (string or None, optional) \u2013 (New in version v2.23) The Id of the alternative secondary dataset config\nto use during prediction for Feature discovery project.\nReturns:\ndataset \u2013 the newly uploaded dataset\nReturn type:\nPredictionDataset\nupload_dataset_from_catalog(dataset_id, credential_id=None, credential_data=None, dataset_version_id=None, max_wait=600, forecast_point=None, relax_known_in_advance_features_check=None, credentials=None, predictions_start_date=None, predictions_end_date=None, actual_value_column=None, secondary_datasets_config_id=None)\uf0c1\nUpload a new dataset from a catalog dataset to make predictions against\nParameters:\ndataset_id (str) \u2013 The identifier of the dataset.\ncredential_id (Optional[str]) \u2013 The credential ID of the AI Catalog dataset to upload.\ncredential_data (BasicCredentialsDataDict | S3CredentialsDataDict | OAuthCredentialsDataDict, optional) \u2013 Credential data of the catalog dataset to upload. credential_data can be in\none of the following forms:\nBasic Credentials:\ncredentialType (str)The credential type. For basic credentials, this value must be CredentialTypes.BASIC.\nuser (str)The username for database authentication.\npassword (str)The password for database authentication.\nThe password is encrypted at rest and never saved or stored.\nS3 Credentials\ncredentialType (str)The credential type. For S3 credentials, this value must be CredentialTypes.S3.\nawsAccessKeyId (Optional[str])The S3 AWS access key ID.\nawsSecretAccessKey (Optional[str])The S3 AWS secret access key.\nawsSessionToken (Optional[str])The S3 AWS session token.\nconfig_id (Optional[str])The ID of the saved shared secure configuration. If specified, cannot include awsAccessKeyId,\nawsSecretAccessKey or awsSessionToken.\nOAuth Credentials\ncredentialType (str)The credential type. For OAuth credentials, this value must be CredentialTypes.OAUTH.\noauthRefreshToken (str)The oauth refresh token.\noauthClientId (str)The oauth client ID.\noauthClientSecret (str)The oauth client secret.\noauthAccessToken (str)The oauth access token.\nSnowflake Key Pair Credentials\ncredentialType (str)The credential type. For Snowflake Key Pair, this value must be\nCredentialTypes.SNOWFLAKE_KEY_PAIR_AUTH.\nuser (Optional[str])The Snowflake login name.\nprivateKeyStr (Optional[str])The private key copied exactly from user private key file. Since it contains\nmultiple lines, when assign to a variable,\nput the key string inside triple-quotes\npassphrase (Optional[str])The string used to encrypt the private key.\nconfigId (Optional[str])The ID of the saved shared secure configuration. If specified, cannot include user,\nprivateKeyStr or passphrase.\nDatabricks Access Token Credentials\ncredentialType (str)The credential type. For a Databricks access token, this value must be\nCredentialTypes.DATABRICKS_ACCESS_TOKEN.\ndatabricksAccessToken (str)The Databricks personal access token.\nDatabricks Service Principal Credentials\ncredentialType (str)The credential type. For Databricks service principal, this value must be\nCredentialTypes.DATABRICKS_SERVICE_PRINCIPAL.\nclientId (Optional[str])The client ID for Databricks service principal.\nclientSecret (Optional[str])The client secret for Databricks service principal.\nconfigId (Optional[str])The ID of the saved shared secure configuration. If specified, cannot include clientId\nand clientSecret.\nAzure Service Principal Credentials\ncredentialType (str)The credential type. For Azure service principal, this value must be\nCredentialTypes.AZURE_SERVICE_PRINCIPAL.\nclientId (Optional[str])The client ID for Azure service principal.\nclientSecret (Optional[str])The client secret for Azure service principal.\nazureTenantId (Optional[str])The azure tenant ID for Azure service principal.\nconfigId (Optional[str])The ID of the saved shared secure configuration. If specified, cannot include clientId\nand clientSecret.\ndataset_version_id (Optional[str]) \u2013 The version id of the dataset to use.\nmax_wait (Optional[int]) \u2013 Optional, the maximum number of seconds to wait before giving up.\nforecast_point (datetime.datetime or None, optional) \u2013 For time series projects only. This is the default point relative\nto which predictions will be generated, based on the forecast window of the project. See\nthe time series prediction documentation for more\ninformation.\nrelax_known_in_advance_features_check (Optional[bool]) \u2013 For time series projects only. If True, missing values in the\nknown in advance features are allowed in the forecast window at the prediction time.\nIf omitted or False, missing values are not allowed.\ncredentials (list[BasicCredentialsDict | CredentialIdCredentialsDict], optional) \u2013 A list of credentials for the datasets used in Feature discovery project.\nItems in credentials can have the following forms:\nBasic Credentials\nuser (str)The username for database authentication.\npassword (str)The password (in cleartext) for database authentication. The password\nwill be encrypted on the server side in scope of HTTP request\nand never saved or stored.\nCredential ID\ncredentialId (str)The ID of the set of credentials to use instead of user and password.\nNote that with this change, username and password will become optional.\npredictions_start_date (datetime.datetime or None, optional) \u2013 For time series projects only. The start date for bulk\npredictions. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_end_date. Can\u2019t be provided with the forecast_point parameter.\npredictions_end_date (datetime.datetime or None, optional) \u2013 For time series projects only. The end date for bulk predictions,\nexclusive. Note that this parameter is for generating historical predictions using the\ntraining data. This parameter should be provided in conjunction with\npredictions_start_date. Can\u2019t be provided with the forecast_point parameter.\nactual_value_column (string, optional) \u2013 Actual value column name, valid for the prediction\nfiles if the project is unsupervised and the dataset is considered as bulk predictions\ndataset. Cannot be provided with the forecast_point parameter.\nsecondary_datasets_config_id (string or None, optional) \u2013 The Id of the alternative secondary dataset config\nto use during prediction for Feature discovery project.\nReturns:\ndataset \u2013 the newly uploaded dataset\nReturn type:\nPredictionDataset\nget_blueprints()\uf0c1\nList all blueprints recommended for a project.\nReturns:\nmenu \u2013 All blueprints in a project\u2019s repository.\nReturn type:\nlist of Blueprint instances\nget_features()\uf0c1\nList all features for this project\nReturns:\nall features for this project\nReturn type:\nlist of Feature\nget_modeling_features(batch_size=None)\uf0c1\nList all modeling features for this project\nOnly available once the target and partitioning settings have been set.  For more\ninformation on the distinction between input and modeling features, see the\ntime series documentation.\nParameters:\nbatch_size (Optional[int]) \u2013 The number of features to retrieve in a single API call.  If specified, the client may\nmake multiple calls to retrieve the full list of features.  If not specified, an\nappropriate default will be chosen by the server.\nReturns:\nAll modeling features in this project\nReturn type:\nlist of ModelingFeature\nget_featurelists()\uf0c1\nList all featurelists created for this project\nReturns:\nAll featurelists created for this project\nReturn type:\nlist of Featurelist\nget_associations(assoc_type, metric, featurelist_id=None)\uf0c1\nGet the association statistics and metadata for a project\u2019s\ninformative features\nAdded in version v2.17.\nParameters:\nassoc_type (string or None) \u2013 The type of association, must be either \u2018association\u2019 or \u2018correlation\u2019\nmetric (string or None) \u2013 The specified association metric, belongs under either association\nor correlation umbrella\nfeaturelist_id (string or None) \u2013 The desired featurelist for which to get association statistics\n(New in version v2.19)\nReturns:\nassociation_data \u2013 Pairwise metric strength data, feature clustering data,\nand ordering data for Feature Association Matrix visualization\nReturn type:\ndict\nget_association_featurelists()\uf0c1\nList featurelists and get feature association status for each\nAdded in version v2.19.\nReturns:\nfeature_lists \u2013 Dict with \u2018featurelists\u2019 as key, with list of featurelists as values\nReturn type:\ndict\nget_association_matrix_details(feature1, feature2)\uf0c1\nGet a sample of the actual values used to measure the association\nbetween a pair of features\nAdded in version v2.17.\nParameters:\nfeature1 (str) \u2013 Feature name for the first feature of interest\nfeature2 (str) \u2013 Feature name for the second feature of interest\nReturns:\ndict \u2013 This data has 3 keys: chart_type, features, values, and types\nchart_type (str) \u2013 Type of plotting the pair of features gets in the UI.\ne.g. \u2018HORIZONTAL_BOX\u2019, \u2018VERTICAL_BOX\u2019, \u2018SCATTER\u2019 or \u2018CONTINGENCY\u2019\nvalues (list) \u2013 A list of triplet lists e.g.\n{\u201cvalues\u201d: [[460.0, 428.5, 0.001], [1679.3, 259.0, 0.001], \u2026]\nThe first entry of each list is a value of feature1, the second entry of\neach list is a value of feature2, and the third is the relative frequency of\nthe pair of datapoints in the sample.\nfeatures (List[str]) \u2013 A list of the passed features, [feature1, feature2]\ntypes (List[str]) \u2013 A list of the passed features\u2019 types inferred by DataRobot.\ne.g. [\u2018NUMERIC\u2019, \u2018CATEGORICAL\u2019]\nget_modeling_featurelists(batch_size=None)\uf0c1\nList all modeling featurelists created for this project\nModeling featurelists can only be created after the target and partitioning options have\nbeen set for a project.  In time series projects, these are the featurelists that can be\nused for modeling; in other projects, they behave the same as regular featurelists.\nSee the time series documentation for more information.\nParameters:\nbatch_size (Optional[int]) \u2013 The number of featurelists to retrieve in a single API call.  If specified, the client\nmay make multiple calls to retrieve the full list of features.  If not specified, an\nappropriate default will be chosen by the server.\nReturns:\nall modeling featurelists in this project\nReturn type:\nlist of ModelingFeaturelist\nget_discarded_features()\uf0c1\nRetrieve discarded during feature generation features. Applicable for time\nseries projects. Can be called at the modeling stage.\nReturns:\ndiscarded_features_info\nReturn type:\nDiscardedFeaturesInfo\nrestore_discarded_features(features, max_wait=600)\uf0c1\nRestore discarded during feature generation features. Applicable for time\nseries projects. Can be called at the modeling stage.\nReturns:\nstatus \u2013 information about features requested to be restored.\nReturn type:\nFeatureRestorationStatus\ncreate_type_transform_feature(name, parent_name, variable_type, replacement=None, date_extraction=None, max_wait=600)\uf0c1\nCreate a new feature by transforming the type of an existing feature in the project\nNote that only the following transformations are supported:\nText to categorical or numeric\nCategorical to text or numeric\nNumeric to categorical\nDate to categorical or numeric\nNotes\nSpecial considerations when casting numeric to categorical\nThere are two parameters which can be used for variableType to convert numeric\ndata to categorical levels. These differ in the assumptions they make about the input\ndata, and are very important when considering the data that will be used to make\npredictions. The assumptions that each makes are:\ncategorical : The data in the column is all integral, and there are no missing\nvalues. If either of these conditions do not hold in the training set, the\ntransformation will be rejected. During predictions, if any of the values in the\nparent column are missing, the predictions will error.\ncategoricalInt : New in v2.6\nAll of the data in the column should be considered categorical in its string form when\ncast to an int by truncation. For example the value 3 will be cast as the string\n3 and the value 3.14 will also be cast as the string 3. Further, the\nvalue -3.6 will become the string -3.\nMissing values will still be recognized as missing.\nFor convenience these are represented in the enum VARIABLE_TYPE_TRANSFORM with the\nnames CATEGORICAL and CATEGORICAL_INT.\nParameters:\nname (str) \u2013 The name to give to the new feature\nparent_name (str) \u2013 The name of the feature to transform\nvariable_type (str) \u2013 The type the new column should have. See the values within\ndatarobot.enums.VARIABLE_TYPE_TRANSFORM.\nreplacement (str or Optional[float]) \u2013 The value that missing or unconvertable data should have\ndate_extraction (Optional[str]) \u2013 Must be specified when parent_name is a date column (and left None otherwise).\nSpecifies which value from a date should be extracted. See the list of values in\ndatarobot.enums.DATE_EXTRACTION\nmax_wait (Optional[int]) \u2013 The maximum amount of time to wait for DataRobot to finish processing the new column.\nThis process can take more time with more data to process. If this operation times\nout, an AsyncTimeoutError will occur. DataRobot continues the processing and the\nnew column may successfully be constructed.\nReturns:\nThe data of the new Feature\nReturn type:\nFeature\nRaises:\nAsyncFailureError \u2013 If any of the responses from the server are unexpected\nAsyncProcessUnsuccessfulError \u2013 If the job being waited for has failed or has been cancelled\nAsyncTimeoutError \u2013 If the resource did not resolve in time\nget_featurelist_by_name(name)\uf0c1\nCreates a new featurelist\nParameters:\nname (Optional[str]) \u2013 The name of the Project\u2019s featurelist to get.\nReturns:\nfeaturelist found by name, optional\nReturn type:\nFeaturelist\nExamples\nproject = Project.get('5223deadbeefdeadbeef0101')\nfeaturelist = project.get_featurelist_by_name(\"Raw Features\")\ncreate_featurelist(name=None, features=None, starting_featurelist=None, starting_featurelist_id=None, starting_featurelist_name=None, features_to_include=None, features_to_exclude=None)\uf0c1\nCreates a new featurelist\nParameters:\nname (Optional[str]) \u2013 The name to give to this new featurelist. Names must be unique, so\nan error will be returned from the server if this name has already\nbeen used in this project.  We dynamically create a name if none is\nprovided.\nfeatures (list of Optional[str]) \u2013 The names of the features. Each feature must exist in the project\nalready.\nstarting_featurelist (Featurelist, optional) \u2013 The featurelist to use as the basis when creating a new featurelist.\nstarting_featurelist.features will be read to get the list of features\nthat we will manipulate.\nstarting_featurelist_id (Optional[str]) \u2013 The featurelist ID used instead of passing an object instance.\nstarting_featurelist_name (Optional[str]) \u2013 The featurelist name like \u201cInformative Features\u201d to find a featurelist\nvia the API, and use to fetch features.\nfeatures_to_include (list of Optional[str]) \u2013 The list of the feature names to include in new featurelist. Throws an\nerror if an item in this list is not in the featurelist that was passed,\nor that was retrieved from the API. If nothing is passed, all features\nare included from the starting featurelist.\nfeatures_to_exclude (list of Optional[str]) \u2013 The list of the feature names to exclude in the new featurelist. Throws\nan error if an item in this list is not in the featurelist that was\npassed, also throws an error if a feature is in this list as well as\nfeatures_to_include. Method cannot use both at the same time.\nReturns:\nnewly created featurelist\nReturn type:\nFeaturelist\nRaises:\nDuplicateFeaturesError \u2013 Raised if features variable contains duplicate features\nInvalidUsageError \u2013 Raised method is called with incompatible arguments\nExamples\nproject = Project.get('5223deadbeefdeadbeef0101')\nflists = project.get_featurelists()\n# Create a new featurelist using a subset of features from an\n# existing featurelist\nflist = flists[0]\nfeatures = flist.features[::2]  # Half of the features\nnew_flist = project.create_featurelist(\nname='Feature Subset',\nfeatures=features,\n)\nproject = Project.get('5223deadbeefdeadbeef0101')\n# Create a new featurelist using a subset of features from an\n# existing featurelist by using features_to_exclude param\nnew_flist = project.create_featurelist(\nname='Feature Subset of Existing Featurelist',\nstarting_featurelist_name=\"Informative Features\",\nfeatures_to_exclude=[\"metformin\", \"weight\", \"age\"],\n)\ncreate_modeling_featurelist(name, features, skip_datetime_partition_column=False)\uf0c1\nCreate a new modeling featurelist\nModeling featurelists can only be created after the target and partitioning options have\nbeen set for a project.  In time series projects, these are the featurelists that can be\nused for modeling; in other projects, they behave the same as regular featurelists.\nSee the time series documentation for more information.\nParameters:\nname (str) \u2013 the name of the modeling featurelist to create.  Names must be unique within the\nproject, or the server will return an error.\nfeatures (List[str]) \u2013 the names of the features to include in the modeling featurelist.  Each feature must\nbe a modeling feature.\nskip_datetime_partition_column (boolean, optional) \u2013 False by default. If True, featurelist will not contain datetime partition column.\nUse to create monotonic feature lists in Time Series projects. Setting makes no difference for\nnot Time Series projects. Monotonic featurelists can not be used for modeling.\nReturns:\nfeaturelist \u2013 the newly created featurelist\nReturn type:\nModelingFeaturelist\nExamples\nproject = Project.get('1234deadbeeffeeddead4321')\nmodeling_features = project.get_modeling_features()\nselected_features = [feat.name for feat in modeling_features][:5]  # select first five\nnew_flist = project.create_modeling_featurelist('Model This', selected_features)\nget_metrics(feature_name)\uf0c1\nGet the metrics recommended for modeling on the given feature.\nParameters:\nfeature_name (str) \u2013 The name of the feature to query regarding which metrics are\nrecommended for modeling.\nReturns:\nfeature_name (str) \u2013 The name of the feature that was looked up\navailable_metrics (List[str]) \u2013 An array of strings representing the appropriate metrics.  If the feature\ncannot be selected as the target, then this array will be empty.\nmetric_details (list of dict) \u2013 The list of metricDetails objects\nmetric_name: strName of the metric\nsupports_timeseries: booleanThis metric is valid for timeseries\nsupports_multiclass: booleanThis metric is valid for multiclass classification\nsupports_binary: booleanThis metric is valid for binary classification\nsupports_regression: booleanThis metric is valid for regression\nascending: booleanShould the metric be sorted in ascending order\nget_status()\uf0c1\nQuery the server for project status.\nReturns:\nstatus \u2013 Contains:\nautopilot_done : a boolean.\nstage : a short string indicating which stage the project\nis in.\nstage_description : a description of what stage means.\nReturn type:\ndict\nExamples\n{\"autopilot_done\": False,\n\"stage\": \"modeling\",\n\"stage_description\": \"Ready for modeling\"}\npause_autopilot()\uf0c1\nPause autopilot, which stops processing the next jobs in the queue.\nReturns:\npaused \u2013 Whether the command was acknowledged\nReturn type:\nboolean\nunpause_autopilot()\uf0c1\nUnpause autopilot, which restarts processing the next jobs in the queue.\nReturns:\nunpaused \u2013 Whether the command was acknowledged.\nReturn type:\nboolean\nstart_autopilot(featurelist_id, mode='quick', blend_best_models=False, scoring_code_only=False, prepare_model_for_deployment=True, consider_blenders_in_recommendation=False, run_leakage_removed_feature_list=True, autopilot_cluster_list=None)\uf0c1\nStart Autopilot on provided featurelist with the specified Autopilot settings,\nhalting the current Autopilot run.\nOnly one autopilot can be running at the time.\nThat\u2019s why any ongoing autopilot on a different featurelist will\nbe halted - modeling jobs in queue would not\nbe affected but new jobs would not be added to queue by\nthe halted autopilot.\nParameters:\nfeaturelist_id (str) \u2013 Identifier of featurelist that should be used for autopilot\nmode (Optional[str]) \u2013 The Autopilot mode to run. You can use AUTOPILOT_MODE enum to choose between\nAUTOPILOT_MODE.FULL_AUTO\nAUTOPILOT_MODE.QUICK\nAUTOPILOT_MODE.COMPREHENSIVE\nIf unspecified, AUTOPILOT_MODE.QUICK is used.\nblend_best_models (Optional[bool]) \u2013 Blend best models during Autopilot run. This option is not supported in SHAP-only \u2018\n\u2018mode.\nscoring_code_only (Optional[bool]) \u2013 Keep only models that can be converted to scorable java code during Autopilot run.\nprepare_model_for_deployment (Optional[bool]) \u2013 Prepare model for deployment during Autopilot run. The preparation includes creating\nreduced feature list models, retraining best model on higher sample size,\ncomputing insights and assigning \u201cRECOMMENDED FOR DEPLOYMENT\u201d label.\nconsider_blenders_in_recommendation (Optional[bool]) \u2013 Include blenders when selecting a model to prepare for deployment in an Autopilot Run.\nThis option is not supported in SHAP-only mode or for multilabel projects.\nrun_leakage_removed_feature_list (Optional[bool]) \u2013 Run Autopilot on Leakage Removed feature list (if exists).\nautopilot_cluster_list (list of Optional[int]) \u2013 (New in v2.27) A list of integers, where each value will be used as the number of\nclusters in Autopilot model(s) for unsupervised clustering projects. Cannot be specified\nunless project unsupervisedMode is true and unsupervisedType is set to \u2018clustering\u2019.\nRaises:\nAppPlatformError \u2013 Raised project\u2019s target was not selected or the settings for Autopilot are invalid\nfor the project project.\nReturn type:\nNone\ntrain(trainable, sample_pct=None, featurelist_id=None, source_project_id=None, scoring_type=None, training_row_count=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, n_clusters=None)\uf0c1\nSubmit a job to the queue to train a model.\nEither sample_pct or training_row_count can be used to specify the amount of data to\nuse, but not both.  If neither are specified, a default of the maximum amount of data that\ncan safely be used to train any blueprint without going into the validation data will be\nselected.\nIn smart-sampled projects, sample_pct and training_row_count are assumed to be in terms\nof rows of the minority class.\nNotes\nIf the project uses datetime partitioning, use\nProject.train_datetime instead.\nParameters:\ntrainable (str or Blueprint) \u2013 For str, this is assumed to be a blueprint_id. If no\nsource_project_id is provided, the project_id will be assumed\nto be the project that this instance represents.\nOtherwise, for a Blueprint, it contains the\nblueprint_id and source_project_id that we want\nto use. featurelist_id will assume the default for this project\nif not provided, and sample_pct will default to using the maximum\ntraining value allowed for this project\u2019s partition setup.\nsource_project_id will be ignored if a\nBlueprint instance is used for this parameter\nsample_pct (Optional[float]) \u2013 The amount of data to use for training, as a percentage of the project dataset from 0\nto 100.\nfeaturelist_id (Optional[str]) \u2013 The identifier of the featurelist to use. If not defined, the\ndefault for this project is used.\nsource_project_id (Optional[str]) \u2013 Which project created this blueprint_id. If None, it defaults\nto looking in this project. Note that you must have read\npermissions in this project.\nscoring_type (Optional[str]) \u2013 Either validation or crossValidation (also dr.SCORING_TYPE.validation\nor dr.SCORING_TYPE.cross_validation). validation is available for every\npartitioning type, and indicates that the default model validation should be\nused for the project.\nIf the project uses a form of cross-validation partitioning,\ncrossValidation can also be used to indicate\nthat all of the available training/validation combinations\nshould be used to evaluate the model.\ntraining_row_count (Optional[int]) \u2013 The number of rows to use to train the requested model.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (new in version 2.11) the id of the featurelist that defines the set of features with\na monotonically increasing relationship to the target. Passing None disables\nincreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (new in version 2.11) the id of the featurelist that defines the set of features with\na monotonically decreasing relationship to the target. Passing None disables\ndecreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nn_clusters (Optional[int]) \u2013 (new in version 2.27) Number of clusters to use in an unsupervised clustering model.\nThis parameter is used only for unsupervised clustering models that don\u2019t automatically\ndetermine the number of clusters.\nReturns:\nmodel_job_id \u2013 id of created job, can be used as parameter to ModelJob.get\nmethod or wait_for_async_model_creation function\nReturn type:\nstr\nExamples\nUse a Blueprint instance:\nblueprint = project.get_blueprints()[0]\nmodel_job_id = project.train(blueprint, training_row_count=project.max_train_rows)\nUse a blueprint_id, which is a string. In the first case, it is\nassumed that the blueprint was created by this project. If you are\nusing a blueprint used by another project, you will need to pass the\nid of that other project as well.\nblueprint_id = 'e1c7fc29ba2e612a72272324b8a842af'\nproject.train(blueprint, training_row_count=project.max_train_rows)\nanother_project.train(blueprint, source_project_id=project.id)\nYou can also easily use this interface to train a new model using the data from\nan existing model:\nmodel = project.get_models()[0]\nmodel_job_id = project.train(model.blueprint.id,\nsample_pct=100)\ntrain_datetime(blueprint_id, featurelist_id=None, training_row_count=None, training_duration=None, source_project_id=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, use_project_settings=False, sampling_method=None, n_clusters=None)\uf0c1\nCreate a new model in a datetime partitioned project\nIf the project is not datetime partitioned, an error will occur.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nParameters:\nblueprint_id (str) \u2013 the blueprint to use to train the model\nfeaturelist_id (Optional[str]) \u2013 the featurelist to use to train the model.  If not specified, the project default will\nbe used.\ntraining_row_count (Optional[int]) \u2013 the number of rows of data that should be used to train the model.  If specified,\nneither training_duration nor use_project_settings may be specified.\ntraining_duration (Optional[str]) \u2013 a duration string specifying what time range the data used to train the model should\nspan.  If specified, neither training_row_count nor use_project_settings may be\nspecified.\nsampling_method (Optional[str]) \u2013 (New in version v2.23) defines the way training data is selected. Can be either\nrandom or latest.  In combination with training_row_count defines how rows\nare selected from backtest (latest by default).  When training data is defined using\ntime range (training_duration or use_project_settings) this setting changes the\nway time_window_sample_pct is applied (random by default).  Applicable to OTV\nprojects only.\nuse_project_settings (Optional[bool]) \u2013 (New in version v2.20) defaults to False. If True, indicates that the custom\nbacktest partitioning settings specified by the user will be used to train the model and\nevaluate backtest scores. If specified, neither training_row_count nor\ntraining_duration may be specified.\nsource_project_id (Optional[str]) \u2013 the id of the project this blueprint comes from, if not this project.  If left\nunspecified, the blueprint must belong to this project.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically increasing relationship to the target.\nPassing None disables increasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (New in version v2.18) optional, the id of the featurelist that defines\nthe set of features with a monotonically decreasing relationship to the target.\nPassing None disables decreasing monotonicity constraint. Default\n(dr.enums.MONOTONICITY_FEATURELIST_DEFAULT) is the one specified by the blueprint.\nn_clusters (Optional[int]) \u2013 The number of clusters to use in the specified unsupervised clustering model.\nONLY VALID IN UNSUPERVISED CLUSTERING PROJECTS\nReturns:\njob \u2013 the created job to build the model\nReturn type:\nModelJob\nblend(model_ids, blender_method)\uf0c1\nSubmit a job for creating blender model. Upon success, the new job will\nbe added to the end of the queue.\nParameters:\nmodel_ids (List[str]) \u2013 List of model ids that will be used to create blender. These models should have\ncompleted validation stage without errors, and can\u2019t be blenders or DataRobot Prime\nblender_method (str) \u2013 Chosen blend method, one from datarobot.enums.BLENDER_METHOD. If this is a time\nseries project, only methods in datarobot.enums.TS_BLENDER_METHOD are allowed.\nReturns:\nmodel_job \u2013 New ModelJob instance for the blender creation job in queue.\nReturn type:\nModelJob\nSee also\ndatarobot.models.Project.check_blendableto confirm if models can be blended\ncheck_blendable(model_ids, blender_method)\uf0c1\nCheck if the specified models can be successfully blended\nParameters:\nmodel_ids (List[str]) \u2013 List of model ids that will be used to create blender. These models should have\ncompleted validation stage without errors, and can\u2019t be blenders or DataRobot Prime\nblender_method (str) \u2013 Chosen blend method, one from datarobot.enums.BLENDER_METHOD. If this is a time\nseries project, only methods in datarobot.enums.TS_BLENDER_METHOD are allowed.\nReturn type:\nEligibilityResult\nstart_prepare_model_for_deployment(model_id)\uf0c1\nPrepare a specific model for deployment.\nThe requested model will be trained on the maximum autopilot size then go through the\nrecommendation stages. For datetime partitioned projects, this includes the feature impact\nstage, retraining on a reduced feature list, and retraining the best of the reduced\nfeature list model and the max autopilot original model on recent data. For non-datetime\npartitioned projects, this includes the feature impact stage, retraining on a reduced\nfeature list, retraining the best of the reduced feature list model and the max autopilot\noriginal model up to the holdout size, then retraining the up-to-the holdout model on the\nfull dataset.\nParameters:\nmodel_id (str) \u2013 The model to prepare for deployment.\nReturn type:\nNone\nget_all_jobs(status=None)\uf0c1\nGet a list of jobs\nThis will give Jobs representing any type of job, including modeling or predict jobs.\nParameters:\nstatus (QUEUE_STATUS enum, optional) \u2013 If called with QUEUE_STATUS.INPROGRESS, will return the jobs\nthat are currently running.\nIf called with QUEUE_STATUS.QUEUE, will return the jobs that\nare waiting to be run.\nIf called with QUEUE_STATUS.ERROR, will return the jobs that\nhave errored.\nIf no value is provided, will return all jobs currently running\nor waiting to be run.\nReturns:\njobs \u2013 Each is an instance of Job\nReturn type:\nlist\nget_blenders()\uf0c1\nGet a list of blender models.\nReturns:\nlist of all blender models in project.\nReturn type:\nlist of BlenderModel\nget_frozen_models()\uf0c1\nGet a list of frozen models\nReturns:\nlist of all frozen models in project.\nReturn type:\nlist of FrozenModel\nget_combined_models()\uf0c1\nGet a list of models in segmented project.\nReturns:\nlist of all combined models in segmented project.\nReturn type:\nlist of CombinedModel\nget_active_combined_model()\uf0c1\nRetrieve currently active combined model in segmented project.\nReturns:\ncurrently active combined model in segmented project.\nReturn type:\nCombinedModel\nget_segments_models(combined_model_id=None)\uf0c1\nRetrieve a list of all models belonging to the segments/child projects\nof the segmented project.\nParameters:\ncombined_model_id (Optional[str]) \u2013 Id of the combined model to get segments for. If there is only a single\ncombined model it can be retrieved automatically, but this must be\nspecified when there are > 1 combined models.\nReturns:\nsegments_models \u2013 A list of dictionaries containing all of the segments/child projects,\neach with a list of their models ordered by metric from best to worst.\nReturn type:\nlist(dict)\nget_model_jobs(status=None)\uf0c1\nGet a list of modeling jobs\nParameters:\nstatus (QUEUE_STATUS enum, optional) \u2013 If called with QUEUE_STATUS.INPROGRESS, will return the modeling jobs\nthat are currently running.\nIf called with QUEUE_STATUS.QUEUE, will return the modeling jobs that\nare waiting to be run.\nIf called with QUEUE_STATUS.ERROR, will return the modeling jobs that\nhave errored.\nIf no value is provided, will return all modeling jobs currently running\nor waiting to be run.\nReturns:\njobs \u2013 Each is an instance of ModelJob\nReturn type:\nlist\nget_predict_jobs(status=None)\uf0c1\nGet a list of prediction jobs\nParameters:\nstatus (QUEUE_STATUS enum, optional) \u2013 If called with QUEUE_STATUS.INPROGRESS, will return the prediction jobs\nthat are currently running.\nIf called with QUEUE_STATUS.QUEUE, will return the prediction jobs that\nare waiting to be run.\nIf called with QUEUE_STATUS.ERROR, will return the prediction jobs that\nhave errored.\nIf called without a status, will return all prediction jobs currently running\nor waiting to be run.\nReturns:\njobs \u2013 Each is an instance of PredictJob\nReturn type:\nlist\nwait_for_autopilot(check_interval=20.0, timeout=86400, verbosity=1)\uf0c1\nBlocks until autopilot is finished. This will raise an exception if the autopilot\nmode is changed from AUTOPILOT_MODE.FULL_AUTO.\nIt makes API calls to sync the project state with the server and to look at\nwhich jobs are enqueued.\nParameters:\ncheck_interval (float or int) \u2013 The maximum time (in seconds) to wait between checks for whether autopilot is finished\ntimeout (float or int or None) \u2013 After this long (in seconds), we give up. If None, never timeout.\nverbosity (Union[int, Enum]) \u2013 This should be VERBOSITY_LEVEL.SILENT or VERBOSITY_LEVEL.VERBOSE.\nFor VERBOSITY_LEVEL.SILENT, nothing will be displayed about progress.\nFor VERBOSITY_LEVEL.VERBOSE, the number of jobs in progress or queued is shown.\nNote that new jobs are added to the queue along the way.\nRaises:\nAsyncTimeoutError \u2013 If autopilot does not finished in the amount of time specified\nRuntimeError \u2013 If a condition is detected that indicates that autopilot will not complete\non its own\nReturn type:\nNone\nrename(project_name)\uf0c1\nUpdate the name of the project.\nParameters:\nproject_name (str) \u2013 The new name\nReturn type:\nNone\nset_project_description(project_description)\uf0c1\nSet or Update the project description.\nParameters:\nproject_description (str) \u2013 The new description for this project.\nReturn type:\nNone\nunlock_holdout()\uf0c1\nUnlock the holdout for this project.\nThis will cause subsequent queries of the models of this project to\ncontain the metric values for the holdout set, if it exists.\nTake care, as this cannot be undone. Remember that best practice is to\nselect a model before analyzing the model performance on the holdout set\nReturn type:\nNone\nset_worker_count(worker_count)\uf0c1\nSets the number of workers allocated to this project.\nNote that this value is limited to the number allowed by your account.\nLowering the number will not stop currently running jobs, but will\ncause the queue to wait for the appropriate number of jobs to finish\nbefore attempting to run more jobs.\nParameters:\nworker_count (int) \u2013 The number of concurrent workers to request from the pool of workers.\n(New in version v2.14) Setting this to -1 will update the number of workers to the\nmaximum available to your account.\nReturn type:\nNone\nset_advanced_options(advanced_options=None, **kwargs)\uf0c1\nUpdate the advanced options of this project.\nNotes\nProject options will not be stored at the database level, so the options\nset via this method will only be attached to a project instance for the lifetime of a\nclient session (if you quit your session and reopen a new one before running autopilot,\nthe advanced options will be lost).\nEither accepts an AdvancedOptions object to replace all advanced options or individual keyword\narguments. This is an inplace update, not a new object. The options set will only remain for the\nlife of this project instance within a given session.\nParameters:\nadvanced_options (AdvancedOptions, optional) \u2013 AdvancedOptions instance as an alternative to passing individual parameters.\nweights (string, optional) \u2013 The name of a column indicating the weight of each row\nresponse_cap (float in [0.5, 1), optional) \u2013 Quantile of the response distribution to use for response capping.\nblueprint_threshold (Optional[int]) \u2013 Number of hours models are permitted to run before being excluded from later autopilot\nstages\nMinimum 1\nseed (Optional[int]) \u2013 a seed to use for randomization\nsmart_downsampled (Optional[bool]) \u2013 whether to use smart downsampling to throw away excess rows of the majority class.  Only\napplicable to classification and zero-boosted regression projects.\nmajority_downsampling_rate (Optional[float]) \u2013 The percentage between 0 and 100 of the majority rows that should be kept.  Specify only if\nusing smart downsampling.  May not cause the majority class to become smaller than the\nminority class.\noffset (list of Optional[str]) \u2013 (New in version v2.6) the list of the names of the columns containing the offset\nof each row\nexposure (string, optional) \u2013 (New in version v2.6) the name of a column containing the exposure of each row\naccuracy_optimized_mb (Optional[bool]) \u2013 (New in version v2.6) Include additional, longer-running models that will be run by the\nautopilot and available to run manually.\nevents_count (string, optional) \u2013 (New in version v2.8) the name of a column specifying events count.\nmonotonic_increasing_featurelist_id (string, optional) \u2013 (new in version 2.11) the id of the featurelist that defines the set of features\nwith a monotonically increasing relationship to the target. If None,\nno such constraints are enforced. When specified, this will set a default for the project\nthat can be overridden at model submission time if desired.\nmonotonic_decreasing_featurelist_id (string, optional) \u2013 (new in version 2.11) the id of the featurelist that defines the set of features\nwith a monotonically decreasing relationship to the target. If None,\nno such constraints are enforced. When specified, this will set a default for the project\nthat can be overridden at model submission time if desired.\nonly_include_monotonic_blueprints (Optional[bool]) \u2013 (new in version 2.11) when true, only blueprints that support enforcing\nmonotonic constraints will be available in the project or selected for the autopilot.\nallowed_pairwise_interaction_groups (list of tuple, optional) \u2013 (New in version v2.19) For GA2M models - specify groups of columns for which pairwise\ninteractions will be allowed. E.g. if set to [(A, B, C), (C, D)] then GA2M models will\nallow interactions between columns A x B, B x C, A x C, C x D. All others (A x D, B x D) will\nnot be considered.\nblend_best_models (Optional[bool]) \u2013 (New in version v2.19) blend best models during Autopilot run\nscoring_code_only (Optional[bool]) \u2013 (New in version v2.19) Keep only models that can be converted to scorable java code\nduring Autopilot run\nshap_only_mode (Optional[bool]) \u2013 (New in version v2.21) Keep only models that support SHAP values during Autopilot run. Use\nSHAP-based insights wherever possible. Defaults to False.\nprepare_model_for_deployment (Optional[bool]) \u2013 (New in version v2.19) Prepare model for deployment during Autopilot run.\nThe preparation includes creating reduced feature list models, retraining best model\non higher sample size, computing insights and assigning \u201cRECOMMENDED FOR DEPLOYMENT\u201d label.\nconsider_blenders_in_recommendation (Optional[bool]) \u2013 (New in version 2.22.0) Include blenders when selecting a model to prepare for\ndeployment in an Autopilot Run. Defaults to False.\nmin_secondary_validation_model_count (Optional[int]) \u2013 (New in version v2.19) Compute \u201cAll backtest\u201d scores (datetime models) or cross validation\nscores for the specified number of highest ranking models on the Leaderboard,\nif over the Autopilot default.\nautopilot_data_sampling_method (Optional[str]) \u2013 (New in version v2.23) one of datarobot.enums.DATETIME_AUTOPILOT_DATA_SAMPLING_METHOD.\nApplicable for OTV projects only, defines if autopilot uses \u201crandom\u201d or \u201clatest\u201d sampling\nwhen iteratively building models on various training samples. Defaults to \u201crandom\u201d for\nduration-based projects and to \u201clatest\u201d for row-based projects.\nrun_leakage_removed_feature_list (Optional[bool]) \u2013 (New in version v2.23) Run Autopilot on Leakage Removed feature list (if exists).\nautopilot_with_feature_discovery (Optional[bool].) \u2013 (New in version v2.23) If true, autopilot will run on a feature list that includes features\nfound via search for interactions.\nfeature_discovery_supervised_feature_reduction (Optional[bool]) \u2013 (New in version v2.23) Run supervised feature reduction for feature discovery projects.\nexponentially_weighted_moving_alpha (Optional[float]) \u2013 (New in version v2.26) defaults to None, value between 0 and 1 (inclusive), indicates\nalpha parameter used in exponentially weighted moving average within feature derivation\nwindow.\nexternal_time_series_baseline_dataset_id (Optional[str].) \u2013 (New in version v2.26) If provided, will generate metrics scaled by external model\npredictions metric for time series projects. The external predictions catalog\nmust be validated before autopilot starts, see\nProject.validate_external_time_series_baseline and\nexternal baseline predictions documentation\nfor further explanation.\nuse_supervised_feature_reduction (bool, default True optional) \u2013 Time Series only. When true, during feature generation DataRobot runs a supervised\nalgorithm to retain only qualifying features. Setting to false can\nseverely impact autopilot duration, especially for datasets with many features.\nprimary_location_column (Optional[str].) \u2013 The name of primary location column.\nprotected_features (list of Optional[str].) \u2013 (New in version v2.24) A list of project features to mark as protected for\nBias and Fairness testing calculations. Max number of protected features allowed is 10.\npreferable_target_value (Optional[str].) \u2013 (New in version v2.24) A target value that should be treated as a favorable outcome\nfor the prediction. For example, if we want to check gender discrimination for\ngiving a loan and our target is named is_bad, then the positive outcome for\nthe prediction would be No, which means that the loan is good and that\u2019s\nwhat we treat as a favorable result for the loaner.\nfairness_metrics_set (Optional[str].) \u2013 (New in version v2.24) Metric to use for calculating fairness.\nCan be one of proportionalParity, equalParity, predictionBalance,\ntrueFavorableAndUnfavorableRateParity or\nfavorableAndUnfavorablePredictiveValueParity.\nUsed and required only if Bias & Fairness in AutoML feature is enabled.\nfairness_threshold (Optional[str].) \u2013 (New in version v2.24) Threshold value for the fairness metric.\nCan be in a range of [0.0, 1.0]. If the relative (i.e. normalized) fairness\nscore is below the threshold, then the user will see a visual indication on the\nbias_mitigation_feature_name (Optional[str]) \u2013 The feature from protected features that will be used in a bias mitigation task to\nmitigate bias\nbias_mitigation_technique (Optional[str]) \u2013 One of datarobot.enums.BiasMitigationTechnique\nOptions:\n- \u2018preprocessingReweighing\u2019\n- \u2018postProcessingRejectionOptionBasedClassification\u2019\nThe technique by which we\u2019ll mitigate bias, which will inform which bias mitigation task\nwe insert into blueprints\ninclude_bias_mitigation_feature_as_predictor_variable (Optional[bool]) \u2013 Whether we should also use the mitigation feature as in input to the modeler just like\nany other categorical used for training, i.e. do we want the model to \u201ctrain on\u201d this\nfeature in addition to using it for bias mitigation\nseries_id (string, optional) \u2013 (New in version v3.6) The name of a column containing the series ID for each row.\nforecast_distance (string, optional) \u2013 (New in version v3.6) The name of a column containing the forecast distance for each row.\nforecast_offsets (list of Optional[str]) \u2013 (New in version v3.6) The list of the names of the columns containing the forecast offsets\nfor each row.\nincremental_learning_only_mode (Optional[bool]) \u2013 (New in version v3.4) Keep only models that support incremental learning during Autopilot run.\nincremental_learning_on_best_model (Optional[bool]) \u2013 (New in version v3.4) Run incremental learning on the best model during Autopilot run.\nchunk_definition_id (string, optional) \u2013 (New in version v3.4) Unique definition for chunks needed to run automated incremental learning.\nincremental_learning_early_stopping_rounds (Optional[int]) \u2013 (New in version v3.4) Early stopping rounds used in the automated incremental learning service.\nnumber_of_incremental_learning_iterations_before_best_model_selection (Optional[int] = None) \u2013 (New in version v3.6) Number of iterations top 5 models complete prior to best model selection.\nThe minimum is 1, which means no additional iterations after the first iteration (initial model)\nwill be run. The maximum is 10.\nReturn type:\nNone\nlist_advanced_options()\uf0c1\nView the advanced options that have been set on a project instance.\nIncludes those that haven\u2019t been set (with value of None).\nReturn type:\ndict of advanced options and their values\nset_partitioning_method(cv_method=None, validation_type=None, seed=0, reps=None, user_partition_col=None, training_level=None, validation_level=None, holdout_level=None, cv_holdout_level=None, validation_pct=None, holdout_pct=None, partition_key_cols=None, partitioning_method=None)\uf0c1\nConfigures the partitioning method for this project.\nIf this project does not already have a partitioning method set, creates\na new configuration based on provided args.\nIf the partitioning_method arg is set, that configuration will instead be used.\nNotes\nThis is an inplace update, not a new object. The options set will only remain for the\nlife of this project instance within a given session. You must still call set_target\nto make this change permanent for the project. Calling refresh without first calling\nset_target will invalidate this configuration. Similarly, calling get to retrieve a\nsecond copy of the project will not include this configuration.\nAdded in version v3.0.\nParameters:\ncv_method (str) \u2013 The partitioning method used. Supported values can be found in datarobot.enums.CV_METHOD.\nvalidation_type (str) \u2013 May be \u201cCV\u201d (K-fold cross-validation) or \u201cTVH\u201d (Training, validation, and holdout).\nseed (int) \u2013 A seed to use for randomization.\nreps (int) \u2013 Number of cross validation folds to use.\nuser_partition_col (str) \u2013 The name of the column containing the partition assignments.\ntraining_level (Union[str,int]) \u2013 The value of the partition column indicating a row is part of the training set.\nvalidation_level (Union[str,int]) \u2013 The value of the partition column indicating a row is part of the validation set.\nholdout_level (Union[str,int]) \u2013 The value of the partition column indicating a row is part of the holdout set (use\nNone if you want no holdout set).\ncv_holdout_level (Union[str,int]) \u2013 The value of the partition column indicating a row is part of the holdout set.\nvalidation_pct (int) \u2013 The desired percentage of dataset to assign to validation set.\nholdout_pct (int) \u2013 The desired percentage of dataset to assign to holdout set.\npartition_key_cols (list) \u2013 A list containing a single string, where the string is the name of the column whose\nvalues should remain together in partitioning.\npartitioning_method (PartitioningMethod, optional) \u2013 An instance of datarobot.helpers.partitioning_methods.PartitioningMethod that will\nbe used instead of creating a new instance from the other args.\nRaises:\nTypeError \u2013 If cv_method or validation_type are not set and partitioning_method is not set.\nInvalidUsageError \u2013 If invoked after project.set_target or project.start, or\nif invoked with the wrong combination of args for a given partitioning method.\nReturns:\nproject \u2013 The instance with updated attributes.\nReturn type:\nProject\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to a project leaderboard.\nReturn type:\nstr\nget_rating_table_models()\uf0c1\nGet a list of models with a rating table\nReturns:\nlist of all models with a rating table in project.\nReturn type:\nlist of RatingTableModel\nget_rating_tables()\uf0c1\nGet a list of rating tables\nReturns:\nlist of rating tables in project.\nReturn type:\nlist of RatingTable\nget_access_list()\uf0c1\nRetrieve users who have access to this project and their access levels\nAdded in version v2.15.\nReturn type:\nlist of SharingAccess\nshare(access_list, send_notification=None, include_feature_discovery_entities=None)\uf0c1\nModify the ability of users to access this project\nAdded in version v2.15.\nParameters:\naccess_list (list of SharingAccess) \u2013 the modifications to make.\nsend_notification (boolean, default None) \u2013 (New in version v2.21) optional, whether or not an email notification should be sent,\ndefault to None\ninclude_feature_discovery_entities (boolean, default None) \u2013 (New in version v2.21) optional (default: None), whether or not to share all the\nrelated entities i.e., datasets for a project with Feature Discovery enabled\nReturn type:\nNone\nRaises:\ndatarobot.ClientError : \u2013 if you do not have permission to share this project, if the user you\u2019re sharing with\ndoesn\u2019t exist, if the same user appears multiple times in the access_list, or if these\nchanges would leave the project without an owner\nExamples\nTransfer access to the project from old_user@datarobot.com to new_user@datarobot.com\nimport datarobot as dr\nnew_access = dr.SharingAccess(new_user@datarobot.com,\ndr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\ndr.Project.get('my-project-id').share(access_list)\nbatch_features_type_transform(parent_names, variable_type, prefix=None, suffix=None, max_wait=600)\uf0c1\nCreate new features by transforming the type of existing ones.\nAdded in version v2.17.\nNotes\nThe following transformations are only supported in batch mode:\nText to categorical or numeric\nCategorical to text or numeric\nNumeric to categorical\nSee {ref}`here <type-transform-considerations>` for special considerations when casting\nnumeric to categorical.\nDate to categorical or numeric transformations are not currently supported for batch\nmode but can be performed individually using create_type_transform_feature.\nParameters:\nparent_names (list[str]) \u2013 The list of variable names to be transformed.\nvariable_type (str) \u2013 The type new columns should have. Can be one of \u2018categorical\u2019, \u2018categoricalInt\u2019,\n\u2018numeric\u2019, and \u2018text\u2019 - supported values can be found in\ndatarobot.enums.VARIABLE_TYPE_TRANSFORM.\nprefix (Optional[str]) \u2013\nNotes\nEither prefix, suffix, or both must be provided.\nThe string that will preface all feature names. At least one of prefix and\nsuffix must be specified.\nsuffix (Optional[str]) \u2013\nNotes\nEither prefix, suffix, or both must be provided.\nThe string that will be appended at the end to all feature names. At least one of\nprefix and suffix must be specified.\nmax_wait (Optional[int]) \u2013 The maximum amount of time to wait for DataRobot to finish processing the new column.\nThis process can take more time with more data to process. If this operation times\nout, an AsyncTimeoutError will occur. DataRobot continues the processing and the\nnew column may successfully be constructed.\nReturns:\nall features for this project after transformation.\nReturn type:\nlist of Features\nRaises:\nTypeError: \u2013 If parent_names is not a list.\nValueError \u2013 If value of variable_type is not from datarobot.enums.VARIABLE_TYPE_TRANSFORM.\nAsyncFailureError \u2013 If any of the responses from the server are unexpected.\nAsyncProcessUnsuccessfulError \u2013 If the job being waited for has failed or has been cancelled.\nAsyncTimeoutError \u2013 If the resource did not resolve in time.\nclone_project(new_project_name=None, max_wait=600)\uf0c1\nCreate a fresh (post-EDA1) copy of this project that is ready for setting\ntargets and modeling options.\nParameters:\nnew_project_name (Optional[str]) \u2013 The desired name of the new project. If omitted, the API will default to\n\u2018Copy of <original project>\u2019\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered\nunsuccessful\nReturn type:\ndatarobot.models.Project\ncreate_interaction_feature(name, features, separator, max_wait=600)\uf0c1\nCreate a new interaction feature by combining two categorical ones.\nAdded in version v2.21.\nParameters:\nname (str) \u2013 The name of final Interaction Feature\nfeatures (list(str)) \u2013 List of two categorical feature names\nseparator (str) \u2013 The character used to join the two data values, one of these ` + - / | & . _ , `\nmax_wait (Optional[int]) \u2013 Time in seconds after which project creation is considered unsuccessful.\nReturns:\nThe data of the new Interaction feature\nReturn type:\ndatarobot.models.InteractionFeature\nRaises:\nClientError \u2013 If requested Interaction feature can not be created. Possible reasons for example are:\n* one of features either does not exist or is of unsupported type\n* feature with requested name already exists\n* invalid separator character submitted.\nAsyncFailureError \u2013 If any of the responses from the server are unexpected\nAsyncProcessUnsuccessfulError \u2013 If the job being waited for has failed or has been cancelled\nAsyncTimeoutError \u2013 If the resource did not resolve in time\nget_relationships_configuration()\uf0c1\nGet the relationships configuration for a given project\nAdded in version v2.21.\nReturns:\nrelationships_configuration \u2013 relationships configuration applied to project\nReturn type:\nRelationshipsConfiguration\ndownload_feature_discovery_dataset(file_name, pred_dataset_id=None)\uf0c1\nDownload Feature discovery training or prediction dataset\nParameters:\nfile_name (str) \u2013 File path where dataset will be saved.\npred_dataset_id (Optional[str]) \u2013 ID of the prediction dataset\nReturn type:\nNone\ndownload_feature_discovery_recipe_sqls(file_name, model_id=None, max_wait=600)\uf0c1\nExport and download Feature discovery recipe SQL statements\n.. versionadded:: v2.25\nParameters:\nfile_name (str) \u2013 File path where dataset will be saved.\nmodel_id (Optional[str]) \u2013 ID of the model to export SQL for.\nIf specified, QL to generate only features used by the model will be exported.\nIf not specified, SQL to generate all features will be exported.\nmax_wait (Optional[int]) \u2013 Time in seconds after which export is considered unsuccessful.\nRaises:\nClientError \u2013 If requested SQL cannot be exported. Possible reason is the feature is not\navailable to user.\nAsyncFailureError \u2013 If any of the responses from the server are unexpected.\nAsyncProcessUnsuccessfulError \u2013 If the job being waited for has failed or has been cancelled.\nAsyncTimeoutError \u2013 If the resource did not resolve in time.\nReturn type:\nNone\nvalidate_external_time_series_baseline(catalog_version_id, target, datetime_partitioning, max_wait=600)\uf0c1\nValidate external baseline prediction catalog.\nThe forecast windows settings, validation and holdout duration specified in the\ndatetime specification must be consistent with project settings as these parameters\nare used to check whether the specified catalog version id has been validated or not.\nSee external baseline predictions documentation\nfor example usage.\nParameters:\ncatalog_version_id (str) \u2013 Id of the catalog version for validating external baseline predictions.\ntarget (str) \u2013 The name of the target column.\ndatetime_partitioning (DatetimePartitioning object) \u2013 Instance of the DatetimePartitioning defined in\ndatarobot.helpers.partitioning_methods.\nAttributes of the object used to check the validation are:\ndatetime_partition_column\nforecast_window_start\nforecast_window_end\nholdout_start_date\nholdout_end_date\nbacktests\nmultiseries_id_columns\nIf the above attributes are different from the project settings, the catalog version\nwill not pass the validation check in the autopilot.\nmax_wait (Optional[int]) \u2013 The maximum number of seconds to wait for the catalog version to be validated before\nraising an error.\nReturns:\nexternal_baseline_validation_info \u2013 Validation result of the specified catalog version.\nReturn type:\nExternalBaselineValidationInfo\nRaises:\nAsyncTimeoutError \u2013 Raised if the catalog version validation took more time than specified\nby the max_wait parameter.\ndownload_multicategorical_data_format_errors(file_name)\uf0c1\nDownload multicategorical data format errors to the CSV file. If any format errors\nwhere detected in potentially multicategorical features the resulting file will contain\nat max 10 entries. CSV file content contains feature name, dataset index in which the\nerror was detected, row value and type of error detected. In case that there were no\nerrors or none of the features where potentially multicategorical the CSV file will be\nempty containing only the header.\nParameters:\nfile_name (str) \u2013 File path where CSV file will be saved.\nReturn type:\nNone\nget_multiseries_names()\uf0c1\nFor a multiseries timeseries project it returns all distinct entries in the\nmultiseries column. For a non timeseries project it will just return an empty list.\nReturns:\nmultiseries_names \u2013 List of all distinct entries in the multiseries column\nReturn type:\nList[str]\nrestart_segment(segment)\uf0c1\nRestart single segment in a segmented project.\nAdded in version v2.28.\nSegment restart is allowed only for segments that haven\u2019t reached modeling phase.\nRestart will permanently remove previous project and trigger set up of a new one\nfor particular segment.\nParameters:\nsegment (str) \u2013 Segment to restart\nget_bias_mitigated_models(parent_model_id=None, offset=0, limit=100)\uf0c1\nList the child models with bias mitigation applied\nAdded in version v2.29.\nParameters:\nparent_model_id (Optional[str]) \u2013 Filter by parent models\noffset (Optional[int]) \u2013 Number of items to skip.\nlimit (Optional[int]) \u2013 Number of items to return.\nReturns:\nmodels\nReturn type:\nlist of dict\napply_bias_mitigation(bias_mitigation_parent_leaderboard_id, bias_mitigation_feature_name, bias_mitigation_technique, include_bias_mitigation_feature_as_predictor_variable)\uf0c1\nApply bias mitigation to an existing model by training a version of that model but with\nbias mitigation applied.\nAn error will be returned if the model does not support bias mitigation with the technique\nrequested.\nAdded in version v2.29.\nParameters:\nbias_mitigation_parent_leaderboard_id (str) \u2013 The leaderboard id of the model to apply bias mitigation to\nbias_mitigation_feature_name (str) \u2013 The feature name of the protected features that will be used in a bias mitigation task to\nattempt to mitigate bias\nbias_mitigation_technique (Optional[str]) \u2013 One of datarobot.enums.BiasMitigationTechnique\nOptions:\n- \u2018preprocessingReweighing\u2019\n- \u2018postProcessingRejectionOptionBasedClassification\u2019\nThe technique by which we\u2019ll mitigate bias, which will inform which bias mitigation task\nwe insert into blueprints\ninclude_bias_mitigation_feature_as_predictor_variable (bool) \u2013 Whether we should also use the mitigation feature as in input to the modeler just like\nany other categorical used for training, i.e. do we want the model to \u201ctrain on\u201d this\nfeature in addition to using it for bias mitigation\nReturns:\nthe job of the model with bias mitigation applied that was just submitted for training\nReturn type:\nModelJob\nrequest_bias_mitigation_feature_info(bias_mitigation_feature_name)\uf0c1\nRequest a compute job for bias mitigation feature info for a given feature, which will\ninclude\n- if there are any rare classes\n- if there are any combinations of the target values and the feature values that never occur\nin the same row\n- if the feature has a high number of missing values.\nNote that this feature check is dependent on the current target selected for the project.\nAdded in version v2.29.\nParameters:\nbias_mitigation_feature_name (str) \u2013 The feature name of the protected features that will be used in a bias mitigation task to\nattempt to mitigate bias\nReturns:\nBias mitigation feature info model for the requested feature\nReturn type:\nBiasMitigationFeatureInfo\nget_bias_mitigation_feature_info(bias_mitigation_feature_name)\uf0c1\nGet the computed bias mitigation feature info for a given feature, which will include\n- if there are any rare classes\n- if there are any combinations of the target values and the feature values that never occur\nin the same row\n- if the feature has a high number of missing values.\nNote that this feature check is dependent on the current target selected for the project.\nIf this info has not already been computed, this will raise a 404 error.\nAdded in version v2.29.\nParameters:\nbias_mitigation_feature_name (str) \u2013 The feature name of the protected features that will be used in a bias mitigation task to\nattempt to mitigate bias\nReturns:\nBias mitigation feature info model for the requested feature\nReturn type:\nBiasMitigationFeatureInfo\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nset_datetime_partitioning(datetime_partition_spec=None, **kwargs)\uf0c1\nSet the datetime partitioning method for a time series project by either passing in\na DatetimePartitioningSpecification instance or any individual attributes of that class.\nUpdates self.partitioning_method if already set previously (does not replace it).\nThis is an alternative to passing a specification to\nProject.analyze_and_model via the\npartitioning_method parameter. To see the\nfull partitioning based on the project dataset, use\nDatetimePartitioning.generate.\nAdded in version v3.0.\nParameters:\ndatetime_partition_spec (DatetimePartitioningSpecification) \u2013 DatetimePartitioningSpecification,\noptional\nThe customizable aspects of datetime partitioning for a time series project. An alternative\nto passing individual settings (attributes of the DatetimePartitioningSpecification class).\nReturns:\nFull partitioning including user-specified attributes as well as those determined by DR\nbased on the dataset.\nReturn type:\nDatetimePartitioning\nlist_datetime_partition_spec()\uf0c1\nList datetime partitioning settings.\nThis method makes an API call to retrieve settings from the DB if project is in the modeling\nstage, i.e. if analyze_and_model (autopilot) has already been called.\nIf analyze_and_model has not yet been called, this method will instead simply print\nsettings from project.partitioning_method.\nAdded in version v3.0.\nReturn type:\nDatetimePartitioningSpecification or None\nclass datarobot.helpers.eligibility_result.EligibilityResult\uf0c1\nRepresents whether a particular operation is supported\nFor instance, a function to check whether a set of models can be blended can return an\nEligibilityResult specifying whether or not blending is supported and why it may not be\nsupported.\nVariables:\nsupported (bool) \u2013 whether the operation this result represents is supported\nreason (str) \u2013 why the operation is or is not supported\ncontext (str) \u2013 what operation isn\u2019t supported\nAdvanced options\uf0c1\nclass datarobot.helpers.AdvancedOptions\uf0c1\nUsed when setting the target of a project to set advanced options of modeling process.\nParameters:\nweights (Optional[str]) \u2013 The name of a column indicating the weight of each row\nresponse_cap (Optional[bool] or Optional[float in [0.5, 1)]) \u2013 Defaults to none here, but server defaults to False.\nIf specified, it is the quantile of the response distribution to use for response capping.\nblueprint_threshold (Optional[int]) \u2013 Number of hours models are permitted to run before being excluded from later autopilot\nstages\nMinimum 1\nseed (Optional[int]) \u2013 a seed to use for randomization\nsmart_downsampled (Optional[bool]) \u2013 whether to use smart downsampling to throw away excess rows of the majority class.  Only\napplicable to classification and zero-boosted regression projects.\nmajority_downsampling_rate (Optional[float]) \u2013 the percentage between 0 and 100 of the majority rows that should be kept.  Specify only if\nusing smart downsampling.  May not cause the majority class to become smaller than the\nminority class.\noffset (list of Optional[str]) \u2013 (New in version v2.6) the list of the names of the columns containing the offset\nof each row\nexposure (Optional[str]) \u2013 (New in version v2.6) the name of a column containing the exposure of each row\naccuracy_optimized_mb (Optional[bool]) \u2013 (New in version v2.6) Include additional, longer-running models that will be run by the\nautopilot and available to run manually.\nscaleout_modeling_mode (Optional[str]) \u2013 (Deprecated in 2.28. Will be removed in 2.30) DataRobot no longer supports scaleout models.\nPlease remove any usage of this parameter as it will be removed from the API soon.\nevents_count (Optional[str]) \u2013 (New in version v2.8) the name of a column specifying events count.\nmonotonic_increasing_featurelist_id (Optional[str]) \u2013 (new in version 2.11) the id of the featurelist that defines the set of features\nwith a monotonically increasing relationship to the target. If None,\nno such constraints are enforced. When specified, this will set a default for the project\nthat can be overridden at model submission time if desired.\nmonotonic_decreasing_featurelist_id (Optional[str]) \u2013 (new in version 2.11) the id of the featurelist that defines the set of features\nwith a monotonically decreasing relationship to the target. If None,\nno such constraints are enforced. When specified, this will set a default for the project\nthat can be overridden at model submission time if desired.\nonly_include_monotonic_blueprints (Optional[bool]) \u2013 (new in version 2.11) when true, only blueprints that support enforcing\nmonotonic constraints will be available in the project or selected for the autopilot.\nallowed_pairwise_interaction_groups (Optional[List[Tuple[str, ]]]) \u2013 (New in version v2.19) For GA2M models - specify groups of columns for which pairwise\ninteractions will be allowed. E.g. if set to [(A, B, C), (C, D)] then GA2M models will\nallow interactions between columns A x B, B x C, A x C, C x D. All others (A x D, B x D) will\nnot be considered.\nblend_best_models (Optional[bool]) \u2013 (New in version v2.19) blend best models during Autopilot run.\nscoring_code_only (Optional[bool]) \u2013 (New in version v2.19) Keep only models that can be converted to scorable java code\nduring Autopilot run\nshap_only_mode (Optional[bool]) \u2013 (New in version v2.21) Keep only models that support SHAP values during Autopilot run. Use\nSHAP-based insights wherever possible. Defaults to False.\nprepare_model_for_deployment (Optional[bool]) \u2013 (New in version v2.19) Prepare model for deployment during Autopilot run.\nThe preparation includes creating reduced feature list models, retraining best model\non higher sample size, computing insights and assigning \u201cRECOMMENDED FOR DEPLOYMENT\u201d label.\nconsider_blenders_in_recommendation (Optional[bool]) \u2013 (New in version 2.22.0) Include blenders when selecting a model to prepare for\ndeployment in an Autopilot Run. Defaults to False.\nmin_secondary_validation_model_count (Optional[int]) \u2013 (New in version v2.19) Compute \u201cAll backtest\u201d scores (datetime models) or cross validation\nscores for the specified number of the highest ranking models on the Leaderboard,\nif over the Autopilot default.\nautopilot_data_sampling_method (Optional[str]) \u2013 (New in version v2.23) one of datarobot.enums.DATETIME_AUTOPILOT_DATA_SAMPLING_METHOD.\nApplicable for OTV projects only, defines if autopilot uses \u201crandom\u201d or \u201clatest\u201d sampling\nwhen iteratively building models on various training samples. Defaults to \u201crandom\u201d for\nduration-based projects and to \u201clatest\u201d for row-based projects.\nrun_leakage_removed_feature_list (Optional[bool]) \u2013 (New in version v2.23) Run Autopilot on Leakage Removed feature list (if exists).\nautopilot_with_feature_discovery (Optional[bool]) \u2013 default = False\n(New in version v2.23) If true, autopilot will run on a feature list that includes features\nfound via search for interactions.\nfeature_discovery_supervised_feature_reduction (Optional[bool]) \u2013 (New in version v2.23) Run supervised feature reduction for feature discovery projects.\nexponentially_weighted_moving_alpha (Optional[float]) \u2013 (New in version v2.26) defaults to None, value between 0 and 1 (inclusive), indicates\nalpha parameter used in exponentially weighted moving average within feature derivation\nwindow.\nexternal_time_series_baseline_dataset_id (Optional[str]) \u2013 (New in version v2.26) If provided, will generate metrics scaled by external model\npredictions metric for time series projects. The external predictions catalog\nmust be validated before autopilot starts, see\nProject.validate_external_time_series_baseline and\nexternal baseline predictions documentation\nfor further explanation.\nuse_supervised_feature_reduction (Optional[bool]) \u2013 defaults to True,\nTime Series only. When true, during feature generation DataRobot runs a supervised\nalgorithm to retain only qualifying features. Setting to false can\nseverely impact autopilot duration, especially for datasets with many features.\nprimary_location_column (Optional[str].) \u2013 The name of primary location column.\nprotected_features (list of Optional[str].) \u2013 (New in version v2.24) A list of project features to mark as protected for\nBias and Fairness testing calculations. Max number of protected features allowed is 10.\npreferable_target_value (Optional[str].) \u2013 (New in version v2.24) A target value that should be treated as a favorable outcome\nfor the prediction. For example, if we want to check gender discrimination for\ngiving a loan and our target is named is_bad, then the positive outcome for\nthe prediction would be No, which means that the loan is good and that\u2019s\nwhat we treat as a favorable result for the loaner.\nfairness_metrics_set (Optional[str].) \u2013 (New in version v2.24) Metric to use for calculating fairness.\nCan be one of proportionalParity, equalParity, predictionBalance,\ntrueFavorableAndUnfavorableRateParity or\nfavorableAndUnfavorablePredictiveValueParity.\nUsed and required only if Bias & Fairness in AutoML feature is enabled.\nfairness_threshold (Optional[str].) \u2013 (New in version v2.24) Threshold value for the fairness metric.\nCan be in a range of [0.0, 1.0]. If the relative (i.e. normalized) fairness\nscore is below the threshold, then the user will see a visual indication on the\nbias_mitigation_feature_name (Optional[str]) \u2013 The feature from protected features that will be used in a bias mitigation task to\nmitigate bias\nbias_mitigation_technique (Optional[str]) \u2013 One of datarobot.enums.BiasMitigationTechnique\nOptions:\n- \u2018preprocessingReweighing\u2019\n- \u2018postProcessingRejectionOptionBasedClassification\u2019\nThe technique by which we\u2019ll mitigate bias, which will inform which bias mitigation task\nwe insert into blueprints\ninclude_bias_mitigation_feature_as_predictor_variable (Optional[bool]) \u2013 Whether we should also use the mitigation feature as in input to the modeler just like\nany other categorical used for training, i.e. do we want the model to \u201ctrain on\u201d this\nfeature in addition to using it for bias mitigation\ndefault_monotonic_increasing_featurelist_id (Optional[str]) \u2013 Returned from server on Project GET request - not able to be updated by user\ndefault_monotonic_decreasing_featurelist_id (Optional[str]) \u2013 Returned from server on Project GET request - not able to be updated by user\nmodel_group_id (Optional[str] = None) \u2013 (New in version v3.3) The name of a column containing the model group id for each row.\nmodel_regime_id (Optional[str] = None) \u2013 (New in version v3.3) The name of a column containing the model regime id for each row.\nmodel_baselines (Optional[List[str]] = None) \u2013 (New in version v3.3) The list of the names of the columns containing the model baselines\nseries_id (Optional[str] = None) \u2013 (New in version v3.6) The name of a column containing the series id for each row.\nforecast_distance (Optional[str] = None) \u2013 (New in version v3.6) The name of a column containing the forecast distance for each row.\nforecast_offsets (Optional[List[str]] = None) \u2013 (New in version v3.6) The list of the names of the columns containing the forecast offsets\nfor each row.\nincremental_learning_only_mode (Optional[bool] = None) \u2013 (New in version v3.4) Keep only models that support incremental learning during Autopilot run.\nincremental_learning_on_best_model (Optional[bool] = None) \u2013 (New in version v3.4) Run incremental learning on the best model during Autopilot run.\nchunk_definition_id (Optional[str]) \u2013 (New in version v3.4) Unique definition for chunks needed to run automated incremental learning.\nincremental_learning_early_stopping_rounds (Optional[int] = None) \u2013 (New in version v3.4) Early stopping rounds used in the automated incremental learning service.\nnumber_of_incremental_learning_iterations_before_best_model_selection (Optional[int] = None) \u2013 (New in version v3.6) Number of iterations top 5 models complete prior to best model selection.\nThe minimum is 1, which means no additional iterations after the first iteration (initial model) will be run.\nThe maximum is 10.\nfeature_engineering_prediction_point (Optional[str] = None) \u2013 (New in version v3.7) The date column to be used as the prediction point for time-based feature engineering.\nExamples\nimport datarobot as dr\nadvanced_options = dr.AdvancedOptions(\nweights='weights_column',\noffset=['offset_column'],\nexposure='exposure_column',\nresponse_cap=0.7,\nblueprint_threshold=2,\nsmart_downsampled=True, majority_downsampling_rate=75.0)\nget(_AdvancedOptions__key, _AdvancedOptions__default=None)\uf0c1\nReturn the value for key if key is in the dictionary, else default.\nReturn type:\nOptional[Any]\npop(_AdvancedOptions__key)\uf0c1\nIf the key is not found, return the default if given; otherwise,\nraise a KeyError.\nReturn type:\nOptional[Any]\nupdate_individual_options(**kwargs)\uf0c1\nUpdate individual attributes of an instance of\nAdvancedOptions.\nReturn type:\nNone\nPartitioning\uf0c1\nclass datarobot.RandomCV\uf0c1\nA partition in which observations are randomly assigned to cross-validation groups\nand the holdout set.\nParameters:\nholdout_pct (int) \u2013 the desired percentage of dataset to assign to holdout set\nreps (int) \u2013 number of cross validation folds to use\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.StratifiedCV\uf0c1\nA partition in which observations are randomly assigned to cross-validation groups\nand the holdout set, preserving in each group the same ratio of positive to negative cases as in\nthe original data.\nParameters:\nholdout_pct (int) \u2013 the desired percentage of dataset to assign to holdout set\nreps (int) \u2013 number of cross validation folds to use\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.GroupCV\uf0c1\nA partition in which one column is specified, and rows sharing a common value\nfor that column are guaranteed to stay together in the partitioning into cross-validation\ngroups and the holdout set.\nParameters:\nholdout_pct (int) \u2013 the desired percentage of dataset to assign to holdout set\nreps (int) \u2013 number of cross validation folds to use\npartition_key_cols (list) \u2013 a list containing a single string, where the string is the name of the column whose\nvalues should remain together in partitioning\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.UserCV\uf0c1\nA partition where the cross-validation folds and the holdout set are specified by\nthe user.\nParameters:\nuser_partition_col (string) \u2013 the name of the column containing the partition assignments\ncv_holdout_level \u2013 the value of the partition column indicating a row is part of the holdout set\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.RandomTVH\uf0c1\nSpecifies a partitioning method in which rows are randomly assigned to training, validation,\nand holdout.\nParameters:\nholdout_pct (int) \u2013 the desired percentage of dataset to assign to holdout set\nvalidation_pct (int) \u2013 the desired percentage of dataset to assign to validation set\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.UserTVH\uf0c1\nSpecifies a partitioning method in which rows are assigned by the user to training,\nvalidation, and holdout sets.\nParameters:\nuser_partition_col (string) \u2013 the name of the column containing the partition assignments\ntraining_level \u2013 the value of the partition column indicating a row is part of the training set\nvalidation_level \u2013 the value of the partition column indicating a row is part of the validation set\nholdout_level \u2013 the value of the partition column indicating a row is part of the holdout set (use\nNone if you want no holdout set)\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.StratifiedTVH\uf0c1\nA partition in which observations are randomly assigned to train, validation, and\nholdout sets, preserving in each group the same ratio of positive to negative cases as in the\noriginal data.\nParameters:\nholdout_pct (int) \u2013 the desired percentage of dataset to assign to holdout set\nvalidation_pct (int) \u2013 the desired percentage of dataset to assign to validation set\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.GroupTVH\uf0c1\nA partition in which one column is specified, and rows sharing a common value\nfor that column are guaranteed to stay together in the partitioning into the training,\nvalidation, and holdout sets.\nParameters:\nholdout_pct (int) \u2013 the desired percentage of dataset to assign to holdout set\nvalidation_pct (int) \u2013 the desired percentage of dataset to assign to validation set\npartition_key_cols (list) \u2013 a list containing a single string, where the string is the name of the column whose\nvalues should remain together in partitioning\nseed (int) \u2013 a seed to use for randomization\nclass datarobot.DatetimePartitioningSpecification\uf0c1\nUniquely defines a DatetimePartitioning for some project\nIncludes only the attributes of DatetimePartitioning that are directly controllable by users,\nnot those determined by the DataRobot application based on the project dataset and the\nuser-controlled settings.\nThis is the specification that should be passed to Project.analyze_and_model via the partitioning_method parameter. To see the\nfull partitioning based on the project dataset, use DatetimePartitioning.generate.\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nNote that either (holdout_start_date, holdout_duration) or (holdout_start_date,\nholdout_end_date) can be used to specify holdout partitioning settings.\nVariables:\ndatetime_partition_column (str) \u2013 the name of the column whose values as dates are used to assign a row\nto a particular partition\nautopilot_data_selection_method (str) \u2013 one of datarobot.enums.DATETIME_AUTOPILOT_DATA_SELECTION_METHOD.  Whether models created\nby the autopilot should use \u201crowCount\u201d or \u201cduration\u201d as their data_selection_method.\nvalidation_duration (str or None) \u2013 the default validation_duration for the backtests\nholdout_start_date (datetime.datetime or None) \u2013 The start date of holdout scoring data.  If holdout_start_date is specified,\neither holdout_duration or holdout_end_date must also be specified. If\ndisable_holdout is set to True, holdout_start_date, holdout_duration, and\nholdout_end_date may not be specified.\nholdout_duration (str or None) \u2013 The duration of the holdout scoring data.  If holdout_duration is specified,\nholdout_start_date must also be specified.  If disable_holdout is set to True,\nholdout_duration, holdout_start_date, and holdout_end_date may not be specified.\nholdout_end_date (datetime.datetime or None) \u2013 The end date of holdout scoring data.  If holdout_end_date is specified,\nholdout_start_date must also be specified.  If disable_holdout is set to True,\nholdout_end_date, holdout_start_date, and holdout_duration may not be specified.\ndisable_holdout (bool or None) \u2013 (New in version v2.8) Whether to suppress allocating a holdout fold.\nIf set to True, holdout_start_date, holdout_duration, and holdout_end_date\nmay not be specified.\ngap_duration (str or None) \u2013 The duration of the gap between training and holdout scoring data\nnumber_of_backtests (int or None) \u2013 the number of backtests to  use\nbacktests (list of BacktestSpecification) \u2013 the exact specification of backtests to use.  The indices of the specified backtests should\nrange from 0 to number_of_backtests - 1.  If any backtest is left unspecified, a default\nconfiguration will be chosen.\nuse_time_series (bool) \u2013 (New in version v2.8) Whether to create a time series project (if True) or an OTV\nproject which uses datetime partitioning (if False).  The default behavior is to create\nan OTV project.\ndefault_to_known_in_advance (bool) \u2013 (New in version v2.11) Optional, default False. Used for time series projects only. Sets\nwhether all features default to being treated as known in advance. Known in advance features\nare expected to be known for dates in the future when making predictions, e.g., \u201cis this a\nholiday?\u201d. Individual features can be set to a value different than the default using the\nfeature_settings parameter.\ndefault_to_do_not_derive (bool) \u2013 (New in v2.17) Optional, default False. Used for time series projects only. Sets whether\nall features default to being treated as do-not-derive features, excluding them from feature\nderivation. Individual features can be set to a value different than the default by using\nthe feature_settings parameter.\nfeature_derivation_window_start (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the past to define how\nfar back relative to the forecast point the feature derivation window should start.\nExpressed in terms of the windows_basis_unit and should be negative value or zero.\nfeature_derivation_window_end (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the past to define how\nfar back relative to the forecast point the feature derivation window should end.  Expressed\nin terms of the windows_basis_unit and should be a negative value or zero.\nfeature_settings (list of FeatureSettings) \u2013 (New in version v2.9) Optional, a list specifying per feature settings, can be\nleft unspecified.\nforecast_window_start (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the future to define\nhow far forward relative to the forecast point the forecast window should start.  Expressed\nin terms of the windows_basis_unit.\nforecast_window_end (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the future to define\nhow far forward relative to the forecast point the forecast window should end.  Expressed\nin terms of the windows_basis_unit.\nwindows_basis_unit (string, optional) \u2013 (New in version v2.14) Only used for time series projects. Indicates which unit is\na basis for feature derivation window and forecast window. Valid options are detected time\nunit (one of the datarobot.enums.TIME_UNITS) or \u201cROW\u201d.\nIf omitted, the default value is the detected time unit.\ntreat_as_exponential (string, optional) \u2013 (New in version v2.9) defaults to \u201cauto\u201d. Used to specify whether to treat data\nas exponential trend and apply transformations like log-transform. Use values from the\ndatarobot.enums.TREAT_AS_EXPONENTIAL enum.\ndifferencing_method (string, optional) \u2013 (New in version v2.9) defaults to \u201cauto\u201d. Used to specify which differencing method to\napply of case if data is stationary. Use values from\ndatarobot.enums.DIFFERENCING_METHOD enum.\nperiodicities (list of Periodicity, optional) \u2013 (New in version v2.9) a list of datarobot.Periodicity. Periodicities units\nshould be \u201cROW\u201d, if the windows_basis_unit is \u201cROW\u201d.\nmultiseries_id_columns (List[str] or null) \u2013 (New in version v2.11) a list of the names of multiseries id columns to define series\nwithin the training data.  Currently only one multiseries id column is supported.\nuse_cross_series_features (bool) \u2013 (New in version v2.14) Whether to use cross series features.\naggregation_type (Optional[str]) \u2013 (New in version v2.14) The aggregation type to apply when creating\ncross series features. Optional, must be one of \u201ctotal\u201d or \u201caverage\u201d.\ncross_series_group_by_columns (list of Optional[str]) \u2013 (New in version v2.15) List of columns (currently of length 1).\nOptional setting that indicates how to further split series into\nrelated groups. For example, if every series is sales of an individual product, the series\ngroup-by could be the product category with values like \u201cmen\u2019s clothing\u201d,\n\u201csports equipment\u201d, etc.. Can only be used in a multiseries project with\nuse_cross_series_features set to True.\ncalendar_id (Optional[str]) \u2013 (New in version v2.15) The id of the CalendarFile to\nuse with this project.\nunsupervised_mode (Optional[bool]) \u2013 (New in version v2.20) defaults to False, indicates whether partitioning should be\nconstructed for the unsupervised project.\nmodel_splits (Optional[int]) \u2013 (New in version v2.21) Sets the cap on the number of jobs per model used when\nbuilding models to control number of jobs in the queue. Higher number of model splits\nwill allow for less downsampling leading to the use of more post-processed data.\nallow_partial_history_time_series_predictions (Optional[bool]) \u2013 (New in version v2.24) Whether to allow time series models to make predictions using\npartial historical data.\nunsupervised_type (Optional[str]) \u2013 (New in version v3.2) The unsupervised project type, only valid if unsupervised_mode is\nTrue. Use values from datarobot.enums.UnsupervisedTypeEnum enum.\nIf not specified then the project defaults to \u2018anomaly\u2019 when unsupervised_mode is True.\ncollect_payload()\uf0c1\nSet up the dict that should be sent to the server when setting the target\nReturns:\npartitioning_spec\nReturn type:\ndict\nprep_payload(project_id, max_wait=600)\uf0c1\nRun any necessary validation and prep of the payload, including async operations\nMainly used for the datetime partitioning spec but implemented in general for consistency\nReturn type:\nNone\nupdate(**kwargs)\uf0c1\nUpdate this instance, matching attributes to kwargs\nMainly used for the datetime partitioning spec but implemented in general for consistency\nReturn type:\nNone\nclass datarobot.BacktestSpecification\uf0c1\nUniquely defines a Backtest used in a DatetimePartitioning\nIncludes only the attributes of a backtest directly controllable by users.  The other attributes\nare assigned by the DataRobot application based on the project dataset and the user-controlled\nsettings.\nThere are two ways to specify an individual backtest:\nOption 1: Use index, gap_duration, validation_start_date, and\nvalidation_duration. All durations should be specified with a duration string such as those\nreturned by the partitioning_methods.construct_duration_string helper method.\nimport datarobot as dr\npartitioning_spec = dr.DatetimePartitioningSpecification(\nbacktests=[\n# modify the first backtest using option 1\ndr.BacktestSpecification(\nindex=0,\ngap_duration=dr.partitioning_methods.construct_duration_string(),\nvalidation_start_date=datetime(year=2010, month=1, day=1),\nvalidation_duration=dr.partitioning_methods.construct_duration_string(years=1),\n)\n],\n# other partitioning settings...\n)\nOption 2 (New in version v2.20): Use index, primary_training_start_date,\nprimary_training_end_date, validation_start_date, and validation_end_date. In this\ncase, note that setting primary_training_end_date and validation_start_date to the same\ntimestamp will result with no gap being created.\nimport datarobot as dr\npartitioning_spec = dr.DatetimePartitioningSpecification(\nbacktests=[\n# modify the first backtest using option 2\ndr.BacktestSpecification(\nindex=0,\nprimary_training_start_date=datetime(year=2005, month=1, day=1),\nprimary_training_end_date=datetime(year=2010, month=1, day=1),\nvalidation_start_date=datetime(year=2010, month=1, day=1),\nvalidation_end_date=datetime(year=2011, month=1, day=1),\n)\n],\n# other partitioning settings...\n)\nAll durations should be specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nindex (int) \u2013 the index of the backtest to update\ngap_duration (str) \u2013 a duration string specifying the desired duration of the gap between\ntraining and validation scoring data for the backtest\nvalidation_start_date (datetime.datetime) \u2013 the desired start date of the validation scoring data for this backtest\nvalidation_duration (str) \u2013 a duration string specifying the desired duration of the validation\nscoring data for this backtest\nvalidation_end_date (datetime.datetime) \u2013 the desired end date of the validation scoring data for this backtest\nprimary_training_start_date (datetime.datetime) \u2013 the desired start date of the training partition for this backtest\nprimary_training_end_date (datetime.datetime) \u2013 the desired end date of the training partition for this backtest\nclass datarobot.FeatureSettings\uf0c1\nPer feature settings\nVariables:\nfeature_name (string) \u2013 name of the feature\nknown_in_advance (bool) \u2013 (New in version v2.11) Optional, for time series projects\nonly. Sets whether the feature is known in advance, i.e., values for future dates are known\nat prediction time. If not specified, the feature uses the value from the\ndefault_to_known_in_advance flag.\ndo_not_derive (bool) \u2013 (New in v2.17) Optional, for time series projects only.\nSets whether the feature is excluded from feature derivation. If not\nspecified, the feature uses the value from the default_to_do_not_derive flag.\ncollect_payload(use_a_priori=False)\uf0c1\nParameters:\nuse_a_priori (bool) \u2013 Switch to using the older a_priori key name instead of known_in_advance.\nDefault False\nReturn type:\nBacktestSpecification dictionary representation\nclass datarobot.Periodicity\uf0c1\nPeriodicity configuration\nParameters:\ntime_steps (int) \u2013 Time step value\ntime_unit (string) \u2013 Time step unit, valid options are values from datarobot.enums.TIME_UNITS\nExamples\nfrom datarobot as dr\nperiodicities = [\ndr.Periodicity(time_steps=10, time_unit=dr.enums.TIME_UNITS.HOUR),\ndr.Periodicity(time_steps=600, time_unit=dr.enums.TIME_UNITS.MINUTE)]\nspec = dr.DatetimePartitioningSpecification(\n# ...\nperiodicities=periodicities\n)\nclass datarobot.DatetimePartitioning\uf0c1\nFull partitioning of a project for datetime partitioning.\nTo instantiate, use\nDatetimePartitioning.get(project_id).\nIncludes both the attributes specified by the user, as well as those determined by the DataRobot\napplication based on the project dataset.  In order to use a partitioning to set the target,\ncall to_specification and pass the\nresulting\nDatetimePartitioningSpecification to\nProject.analyze_and_model via the partitioning_method\nparameter.\nThe available training data corresponds to all the data available for training, while the\nprimary training data corresponds to the data that can be used to train while ensuring that all\nbacktests are available.  If a model is trained with more data than is available in the primary\ntraining data, then all backtests may not have scores available.\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nproject_id (str) \u2013 the id of the project this partitioning applies to\ndatetime_partitioning_id (str or None) \u2013 the id of the datetime partitioning it is an optimized partitioning\ndatetime_partition_column (str) \u2013 the name of the column whose values as dates are used to assign a row\nto a particular partition\ndate_format (str) \u2013 the format (e.g. \u201c%Y-%m-%d %H:%M:%S\u201d) by which the partition column was interpreted\n(compatible with strftime)\nautopilot_data_selection_method (str) \u2013 one of datarobot.enums.DATETIME_AUTOPILOT_DATA_SELECTION_METHOD.  Whether models created\nby the autopilot use \u201crowCount\u201d or \u201cduration\u201d as their data_selection_method.\nvalidation_duration (str or None) \u2013 the validation duration specified when initializing the partitioning - not directly\nsignificant if the backtests have been modified, but used as the default validation_duration\nfor the backtests. Can be absent if this is a time series project with an irregular primary\ndate/time feature.\navailable_training_start_date (datetime.datetime) \u2013 The start date of the available training data for scoring the holdout\navailable_training_duration (str) \u2013 The duration of the available training data for scoring the holdout\navailable_training_row_count (int or None) \u2013 The number of rows in the available training data for scoring the holdout.  Only available\nwhen retrieving the partitioning after setting the target.\navailable_training_end_date (datetime.datetime) \u2013 The end date of the available training data for scoring the holdout\nprimary_training_start_date (datetime.datetime or None) \u2013 The start date of primary training data for scoring the holdout.\nUnavailable when the holdout fold is disabled.\nprimary_training_duration (str) \u2013 The duration of the primary training data for scoring the holdout\nprimary_training_row_count (int or None) \u2013 The number of rows in the primary training data for scoring the holdout.  Only available\nwhen retrieving the partitioning after setting the target.\nprimary_training_end_date (datetime.datetime or None) \u2013 The end date of the primary training data for scoring the holdout.\nUnavailable when the holdout fold is disabled.\ngap_start_date (datetime.datetime or None) \u2013 The start date of the gap between training and holdout scoring data.\nUnavailable when the holdout fold is disabled.\ngap_duration (str) \u2013 The duration of the gap between training and holdout scoring data\ngap_row_count (int or None) \u2013 The number of rows in the gap between training and holdout scoring data.  Only available\nwhen retrieving the partitioning after setting the target.\ngap_end_date (datetime.datetime or None) \u2013 The end date of the gap between training and holdout scoring data.\nUnavailable when the holdout fold is disabled.\ndisable_holdout (bool or None) \u2013 Whether to suppress allocating a holdout fold.\nIf set to True, holdout_start_date, holdout_duration, and holdout_end_date\nmay not be specified.\nholdout_start_date (datetime.datetime or None) \u2013 The start date of holdout scoring data.\nUnavailable when the holdout fold is disabled.\nholdout_duration (str) \u2013 The duration of the holdout scoring data\nholdout_row_count (int or None) \u2013 The number of rows in the holdout scoring data.  Only available when retrieving the\npartitioning after setting the target.\nholdout_end_date (datetime.datetime or None) \u2013 The end date of the holdout scoring data. Unavailable when the holdout fold is disabled.\nnumber_of_backtests (int) \u2013 the number of backtests used.\nbacktests (list of Backtest) \u2013 the configured backtests.\ntotal_row_count (int) \u2013 the number of rows in the project dataset.  Only available when retrieving the partitioning\nafter setting the target.\nuse_time_series (bool) \u2013 (New in version v2.8) Whether to create a time series project (if True) or an OTV\nproject which uses datetime partitioning (if False).  The default behavior is to create\nan OTV project.\ndefault_to_known_in_advance (bool) \u2013 (New in version v2.11) Optional, default False. Used for time series projects only. Sets\nwhether all features default to being treated as known in advance. Known in advance features\nare expected to be known for dates in the future when making predictions, e.g., \u201cis this a\nholiday?\u201d. Individual features can be set to a value different from the default using the\nfeature_settings parameter.\ndefault_to_do_not_derive (bool) \u2013 (New in v2.17) Optional, default False. Used for time series projects only. Sets whether\nall features default to being treated as do-not-derive features, excluding them from feature\nderivation. Individual features can be set to a value different from the default by using\nthe feature_settings parameter.\nfeature_derivation_window_start (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the past to define\nhow far back relative to the forecast point the feature derivation window should start.\nExpressed in terms of the windows_basis_unit.\nfeature_derivation_window_end (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the past to define how\nfar back relative to the forecast point the feature derivation window should end. Expressed\nin terms of the windows_basis_unit.\nfeature_settings (list of FeatureSettings) \u2013 (New in version v2.9) Optional, a list specifying per feature settings, can be\nleft unspecified.\nforecast_window_start (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the future to define\nhow far forward relative to the forecast point the forecast window should start. Expressed\nin terms of the windows_basis_unit.\nforecast_window_end (int or None) \u2013 (New in version v2.8) Only used for time series projects. Offset into the future to define\nhow far forward relative to the forecast point the forecast window should end. Expressed in\nterms of the windows_basis_unit.\nwindows_basis_unit (string, optional) \u2013 (New in version v2.14) Only used for time series projects. Indicates which unit is\na basis for feature derivation window and forecast window. Valid options are detected time\nunit (one of the datarobot.enums.TIME_UNITS) or \u201cROW\u201d.\nIf omitted, the default value is detected time unit.\ntreat_as_exponential (string, optional) \u2013 (New in version v2.9) defaults to \u201cauto\u201d. Used to specify whether to treat data\nas exponential trend and apply transformations like log-transform. Use values from the\ndatarobot.enums.TREAT_AS_EXPONENTIAL enum.\ndifferencing_method (string, optional) \u2013 (New in version v2.9) defaults to \u201cauto\u201d. Used to specify which differencing method to\napply of case if data is stationary. Use values from the\ndatarobot.enums.DIFFERENCING_METHOD enum.\nperiodicities (list of Periodicity, optional) \u2013 (New in version v2.9) a list of datarobot.Periodicity. Periodicities units\nshould be \u201cROW\u201d, if the windows_basis_unit is \u201cROW\u201d.\nmultiseries_id_columns (List[str] or null) \u2013 (New in version v2.11) a list of the names of multiseries id columns to define series\nwithin the training data.  Currently only one multiseries id column is supported.\nnumber_of_known_in_advance_features (int) \u2013 (New in version v2.14) Number of features that are marked as known in advance.\nnumber_of_do_not_derive_features (int) \u2013 (New in v2.17) Number of features that are excluded from derivation.\nuse_cross_series_features (bool) \u2013 (New in version v2.14) Whether to use cross series features.\naggregation_type (Optional[str]) \u2013 (New in version v2.14) The aggregation type to apply when creating cross series\nfeatures. Optional, must be one of \u201ctotal\u201d or \u201caverage\u201d.\ncross_series_group_by_columns (list of Optional[str]) \u2013 (New in version v2.15) List of columns (currently of length 1).\nOptional setting that indicates how to further split series into\nrelated groups. For example, if every series is sales of an individual product, the series\ngroup-by could be the product category with values like \u201cmen\u2019s clothing\u201d,\n\u201csports equipment\u201d, etc.. Can only be used in a multiseries project with\nuse_cross_series_features set to True.\ncalendar_id (Optional[str]) \u2013 (New in version v2.15) Only available for time series projects. The id of the\nCalendarFile to use with this project.\ncalendar_name (Optional[str]) \u2013 (New in version v2.17) Only available for time series projects. The name of the\nCalendarFile used with this project.\nmodel_splits (Optional[int]) \u2013 (New in version v2.21) Sets the cap on the number of jobs per model used when\nbuilding models to control number of jobs in the queue. Higher number of model splits\nwill allow for less downsampling leading to the use of more post-processed data.\nallow_partial_history_time_series_predictions (Optional[bool]) \u2013 (New in version v2.24) Whether to allow time series models to make predictions using\npartial historical data.\nunsupervised_mode (Optional[bool]) \u2013 (New in version v3.1) Whether the date/time partitioning is for an unsupervised project\nunsupervised_type (Optional[str]) \u2013 (New in version v3.2) The unsupervised project type, only valid if unsupervised_mode is\nTrue. Use values from datarobot.enums.UnsupervisedTypeEnum enum.\nIf not specified then the project defaults to \u2018anomaly\u2019 when unsupervised_mode is True.\nclassmethod generate(project_id, spec, max_wait=600, target=None)\uf0c1\nPreview the full partitioning determined by a DatetimePartitioningSpecification\nBased on the project dataset and the partitioning specification, inspect the full\npartitioning that would be used if the same specification were passed into\nProject.analyze_and_model.\nParameters:\nproject_id (str) \u2013 the id of the project\nspec (DatetimePartitioningSpec) \u2013 the desired partitioning\nmax_wait (Optional[int]) \u2013 For some settings (e.g. generating a partitioning preview for a multiseries project for\nthe first time), an asynchronous task must be run to analyze the dataset.  max_wait\ngoverns the maximum time (in seconds) to wait before giving up.  In all non-multiseries\nprojects, this is unused.\ntarget (Optional[str]) \u2013 the name of the target column. For unsupervised projects target may be None. Providing\na target will ensure that partitions are correctly optimized for your dataset.\nReturns:\nthe full generated partitioning\nReturn type:\nDatetimePartitioning\nclassmethod get(project_id)\uf0c1\nRetrieve the DatetimePartitioning from a project\nOnly available if the project has already set the target as a datetime project.\nParameters:\nproject_id (str) \u2013 the id of the project to retrieve partitioning for\nReturns:\nDatetimePartitioning\nReturn type:\nthe full partitioning for the project\nclassmethod generate_optimized(project_id, spec, target, max_wait=600)\uf0c1\nPreview the full partitioning determined by a DatetimePartitioningSpecification\nBased on the project dataset and the partitioning specification, inspect the full\npartitioning that would be used if the same specification were passed into\nProject.analyze_and_model.\nParameters:\nproject_id (str) \u2013 the id of the project\nspec (DatetimePartitioningSpecification) \u2013 the desired partitioning\ntarget (str) \u2013 the name of the target column. For unsupervised projects target may be None.\nmax_wait (Optional[int]) \u2013 Governs the maximum time (in seconds) to wait before giving up.\nReturns:\nthe full generated partitioning\nReturn type:\nDatetimePartitioning\nclassmethod get_optimized(project_id, datetime_partitioning_id)\uf0c1\nRetrieve an Optimized DatetimePartitioning from a project for the specified\ndatetime_partitioning_id. A datetime_partitioning_id is created by using the\ngenerate_optimized function.\nParameters:\nproject_id (str) \u2013 the id of the project to retrieve partitioning for\ndatetime_partitioning_id (ObjectId) \u2013 the ObjectId associated with the project to retrieve from Mongo\nReturns:\nDatetimePartitioning\nReturn type:\nthe full partitioning for the project\nclassmethod feature_log_list(project_id, offset=None, limit=None)\uf0c1\nRetrieve the feature derivation log content and log length for a time series project.\nThe Time Series Feature Log provides details about the feature generation process for a\ntime series project. It includes information about which features are generated and their\npriority, as well as the detected properties of the time series data such as whether the\nseries is stationary, and periodicities detected.\nThis route is only supported for time series projects that have finished partitioning.\nThe feature derivation log will include information about:\nDetected stationarity of the series:\ne.g. \u2018Series detected as non-stationary\u2019\nDetected presence of multiplicative trend in the series:\ne.g. \u2018Multiplicative trend detected\u2019\nDetected presence of multiplicative trend in the series:\ne.g.  \u2018Detected periodicities: 7 day\u2019\nMaximum number of feature to be generated:\ne.g. \u2018Maximum number of feature to be generated is 1440\u2019\nWindow sizes used in rolling statistics / lag extractors\ne.g. \u2018The window sizes chosen to be: 2 months\n(because the time step is 1 month and Feature Derivation Window is 2 months)\u2019\nFeatures that are specified as known-in-advance\ne.g. \u2018Variables treated as apriori: holiday\u2019\nDetails about why certain variables are transformed in the input data\ne.g. \u2018Generating variable \u201cy (log)\u201d from \u201cy\u201d because multiplicative trend\nis detected\u2019\nDetails about features generated as timeseries features, and their priority\ne.g. \u2018Generating feature \u201cdate (actual)\u201d from \u201cdate\u201d (priority: 1)\u2019\nParameters:\nproject_id (str) \u2013 project id to retrieve a feature derivation log for.\noffset (int) \u2013 optional, defaults is 0, this many results will be skipped.\nlimit (int) \u2013 optional, defaults to 100, at most this many results are returned. To specify\nno limit, use 0. The default may change without notice.\nclassmethod feature_log_retrieve(project_id)\uf0c1\nRetrieve the feature derivation log content and log length for a time series project.\nThe Time Series Feature Log provides details about the feature generation process for a\ntime series project. It includes information about which features are generated and their\npriority, as well as the detected properties of the time series data such as whether the\nseries is stationary, and periodicities detected.\nThis route is only supported for time series projects that have finished partitioning.\nThe feature derivation log will include information about:\nDetected stationarity of the series:\ne.g. \u2018Series detected as non-stationary\u2019\nDetected presence of multiplicative trend in the series:\ne.g. \u2018Multiplicative trend detected\u2019\nDetected presence of multiplicative trend in the series:\ne.g.  \u2018Detected periodicities: 7 day\u2019\nMaximum number of feature to be generated:\ne.g. \u2018Maximum number of feature to be generated is 1440\u2019\nWindow sizes used in rolling statistics / lag extractors\ne.g. \u2018The window sizes chosen to be: 2 months\n(because the time step is 1 month and Feature Derivation Window is 2 months)\u2019\nFeatures that are specified as known-in-advance\ne.g. \u2018Variables treated as apriori: holiday\u2019\nDetails about why certain variables are transformed in the input data\ne.g. \u2018Generating variable \u201cy (log)\u201d from \u201cy\u201d because multiplicative trend\nis detected\u2019\nDetails about features generated as timeseries features, and their priority\ne.g. \u2018Generating feature \u201cdate (actual)\u201d from \u201cdate\u201d (priority: 1)\u2019\nParameters:\nproject_id (str) \u2013 project id to retrieve a feature derivation log for.\nReturn type:\nstr\nto_specification(use_holdout_start_end_format=False, use_backtest_start_end_format=False)\uf0c1\nRender the DatetimePartitioning as a DatetimePartitioningSpecification\nThe resulting specification can be used when setting the target, and contains only the\nattributes directly controllable by users.\nParameters:\nuse_holdout_start_end_format (Optional[bool]) \u2013 Defaults to False. If True, will use holdout_end_date when configuring the\nholdout partition. If False, will use holdout_duration instead.\nuse_backtest_start_end_format (Optional[bool]) \u2013 Defaults to False. If False, will use a duration-based approach for specifying\nbacktests (gap_duration, validation_start_date, and validation_duration).\nIf True, will use a start/end date approach for specifying\nbacktests (primary_training_start_date, primary_training_end_date,\nvalidation_start_date, validation_end_date).\nIn contrast, projects created in the Web UI will use the start/end date approach for specifying\nbacktests. Set this parameter to True to mirror the behavior in the Web UI.\nReturns:\nthe specification for this partitioning\nReturn type:\nDatetimePartitioningSpecification\nto_dataframe()\uf0c1\nRender the partitioning settings as a dataframe for convenience of display\nExcludes project_id, datetime_partition_column, date_format,\nautopilot_data_selection_method, validation_duration,\nand number_of_backtests, as well as the row count information, if present.\nAlso excludes the time series specific parameters for use_time_series,\ndefault_to_known_in_advance, default_to_do_not_derive, and defining the feature\nderivation and forecast windows.\nReturn type:\nDataFrame\nclassmethod datetime_partitioning_log_retrieve(project_id, datetime_partitioning_id)\uf0c1\nRetrieve the datetime partitioning log content for an optimized datetime partitioning.\nThe datetime partitioning log provides details about the partitioning process for an OTV\nor time series project.\nParameters:\nproject_id (str) \u2013 The project ID of the project associated with the datetime partitioning.\ndatetime_partitioning_id (str) \u2013 id of the optimized datetime partitioning\nReturn type:\nAny\nclassmethod datetime_partitioning_log_list(project_id, datetime_partitioning_id, offset=None, limit=None)\uf0c1\nRetrieve the datetime partitioning log content and log length for an optimized\ndatetime partitioning.\nThe Datetime Partitioning Log provides details about the partitioning process for an OTV\nor Time Series project.\nParameters:\nproject_id (str) \u2013 project id of the project associated with the datetime partitioning.\ndatetime_partitioning_id (str) \u2013 id of the optimized datetime partitioning\noffset (int or None) \u2013 optional, defaults is 0, this many results will be skipped.\nlimit (int or None) \u2013 optional, defaults to 100, at most this many results are returned. To specify\nno limit, use 0. The default may change without notice.\nReturn type:\nAny\nclassmethod get_input_data(project_id, datetime_partitioning_id)\uf0c1\nRetrieve the input used to create an optimized DatetimePartitioning from a project for\nthe specified datetime_partitioning_id. A datetime_partitioning_id is created by using the\ngenerate_optimized function.\nParameters:\nproject_id (str) \u2013 The ID of the project to retrieve partitioning for.\ndatetime_partitioning_id (ObjectId) \u2013 The ObjectId associated with the project to retrieve from Mongo.\nReturns:\nDatetimePartitioningInput\nReturn type:\nThe input to optimized datetime partitioning.\nclass datarobot.helpers.partitioning_methods.DatetimePartitioningId\uf0c1\nDefines a DatetimePartitioningId used for datetime partitioning.\nThis class only includes the datetime_partitioning_id that identifies a previously\noptimized datetime partitioning and the project_id for the associated project.\nThis is the specification that should be passed to Project.analyze_and_model via the partitioning_method parameter. To see\nthe full partitioning use DatetimePartitioning.get_optimized.\nVariables:\ndatetime_partitioning_id (str) \u2013 The ID of the datetime partitioning to use.\nproject_id (str) \u2013 The ID of the project that the datetime partitioning is associated with.\ncollect_payload()\uf0c1\nSet up the dict that should be sent to the server when setting the target\nReturns:\npartitioning_spec\nReturn type:\ndict\nprep_payload(project_id, max_wait=600)\uf0c1\nRun any necessary validation and prep of the payload, including async operations\nMainly used for the datetime partitioning spec but implemented in general for consistency\nReturn type:\nNone\nupdate(**kwargs)\uf0c1\nUpdate this instance, matching attributes to kwargs\nMainly used for the datetime partitioning spec but implemented in general for consistency\nReturn type:\nNoReturn\nclass datarobot.helpers.partitioning_methods.Backtest\uf0c1\nA backtest used to evaluate models trained in a datetime partitioned project\nWhen setting up a datetime partitioning project, backtests are specified by a\nBacktestSpecification.\nThe available training data corresponds to all the data available for training, while the\nprimary training data corresponds to the data that can be used to train while ensuring that all\nbacktests are available.  If a model is trained with more data than is available in the primary\ntraining data, then all backtests may not have scores available.\nAll durations are specified with a duration string such as those returned\nby the partitioning_methods.construct_duration_string helper method.\nPlease see datetime partitioned project documentation\nfor more information on duration strings.\nVariables:\nindex (int) \u2013 the index of the backtest\navailable_training_start_date (datetime.datetime) \u2013 the start date of the available training data for this backtest\navailable_training_duration (str) \u2013 the duration of available training data for this backtest\navailable_training_row_count (int or None) \u2013 the number of rows of available training data for this backtest.  Only available when\nretrieving from a project where the target is set.\navailable_training_end_date (datetime.datetime) \u2013 the end date of the available training data for this backtest\nprimary_training_start_date (datetime.datetime) \u2013 the start date of the primary training data for this backtest\nprimary_training_duration (str) \u2013 the duration of the primary training data for this backtest\nprimary_training_row_count (int or None) \u2013 the number of rows of primary training data for this backtest.  Only available when\nretrieving from a project where the target is set.\nprimary_training_end_date (datetime.datetime) \u2013 the end date of the primary training data for this backtest\ngap_start_date (datetime.datetime) \u2013 the start date of the gap between training and validation scoring data for this backtest\ngap_duration (str) \u2013 the duration of the gap between training and validation scoring data for this backtest\ngap_row_count (int or None) \u2013 the number of rows in the gap between training and validation scoring data for this\nbacktest.  Only available when retrieving from a project where the target is set.\ngap_end_date (datetime.datetime) \u2013 the end date of the gap between training and validation scoring data for this backtest\nvalidation_start_date (datetime.datetime) \u2013 the start date of the validation scoring data for this backtest\nvalidation_duration (str) \u2013 the duration of the validation scoring data for this backtest\nvalidation_row_count (int or None) \u2013 the number of rows of validation scoring data for this backtest.  Only available when\nretrieving from a project where the target is set.\nvalidation_end_date (datetime.datetime) \u2013 the end date of the validation scoring data for this backtest\ntotal_row_count (int or None) \u2013 the number of rows in this backtest.  Only available when retrieving from a project where\nthe target is set.\nto_specification(use_start_end_format=False)\uf0c1\nRender this backtest as a\nBacktestSpecification.\nThe resulting specification includes only the attributes users can directly control, not\nthose indirectly determined by the project dataset.\nParameters:\nuse_start_end_format (bool) \u2013 Default False. If False, will use a duration-based approach for specifying\nbacktests (gap_duration, validation_start_date, and validation_duration).\nIf True, will use a start/end date approach for specifying\nbacktests (primary_training_start_date, primary_training_end_date,\nvalidation_start_date, validation_end_date).\nIn contrast, projects created in the Web UI will use the start/end date approach for specifying\nbacktests. Set this parameter to True to mirror the behavior in the Web UI.\nReturns:\nthe specification for this backtest\nReturn type:\nBacktestSpecification\nto_dataframe()\uf0c1\nRender this backtest as a dataframe for convenience of display\nReturns:\nbacktest_partitioning \u2013 the backtest attributes, formatted into a dataframe\nReturn type:\npandas.Dataframe\nclass datarobot.helpers.partitioning_methods.FeatureSettingsPayload\uf0c1\ndatarobot.helpers.partitioning_methods.construct_duration_string(years=0, months=0, days=0, hours=0, minutes=0, seconds=0)\uf0c1\nConstruct a valid string representing a duration in accordance with ISO8601\nA duration of six months, 3 days, and 12 hours could be represented as P6M3DT12H.\nParameters:\nyears (int) \u2013 the number of years in the duration\nmonths (int) \u2013 the number of months in the duration\ndays (int) \u2013 the number of days in the duration\nhours (int) \u2013 the number of hours in the duration\nminutes (int) \u2013 the number of minutes in the duration\nseconds (int) \u2013 the number of seconds in the duration\nReturns:\nduration_string \u2013 The duration string, specified compatibly with ISO8601\nReturn type:\nstr\nStatus check job\uf0c1\nclass datarobot.models.StatusCheckJob\uf0c1\nTracks asynchronous task status\nVariables:\njob_id (str) \u2013 The ID of the status the job belongs to.\nwait_for_completion(max_wait=600)\uf0c1\nWaits for job to complete.\nParameters:\nmax_wait (Optional[int]) \u2013 How long to wait for the job to finish. If the time expires, DataRobot returns the current status.\nReturns:\nstatus \u2013 Returns the current status of the job.\nReturn type:\nJobStatusResult\nget_status()\uf0c1\nRetrieve JobStatusResult object with the latest job status data from the server.\nReturn type:\nJobStatusResult\nget_result_when_complete(max_wait=600)\uf0c1\nWait for the job to complete, then attempt to convert the resulting json into an object of type\nself.resource_type\n:rtype: A newly created resource of type self.resource_type\nclass datarobot.models.JobStatusResult\uf0c1\nJobStatusResult(status, status_id, completed_resource_url, message)\nstatus: Optional[str]\uf0c1\nAlias for field number 0\nstatus_id: Optional[str]\uf0c1\nAlias for field number 1\ncompleted_resource_url: Optional[str]\uf0c1\nAlias for field number 2\nmessage: Optional[str]\uf0c1\nAlias for field number 3\nSegmented modeling\uf0c1\nAPI Reference for entities used in Segmented Modeling. See dedicated User Guide for examples.\nclass datarobot.CombinedModel\uf0c1\nA model from a segmented project. Combination of ordinary models in child segments projects.\nVariables:\nid (str) \u2013 the id of the model\nproject_id (str) \u2013 the id of the project the model belongs to\nsegmentation_task_id (str) \u2013 the id of a segmentation task used in this model\nis_active_combined_model (bool) \u2013 flag indicating if this is the active combined model in segmented project\nclassmethod get(project_id, combined_model_id)\uf0c1\nRetrieve combined model\nParameters:\nproject_id (str) \u2013 The project\u2019s id.\ncombined_model_id (str) \u2013 Id of the combined model.\nReturns:\nThe queried combined model.\nReturn type:\nCombinedModel\nclassmethod set_segment_champion(project_id, model_id, clone=False)\uf0c1\nUpdate a segment champion in a combined model by setting the model_id\nthat belongs to the child project_id as the champion.\nParameters:\nproject_id (str) \u2013 The project id for the child model that contains the model id.\nmodel_id (str) \u2013 Id of the model to mark as the champion\nclone (bool) \u2013 (New in version v2.29) optional, defaults to False.\nDefines if combined model has to be cloned prior to setting champion\n(champion will be set for new combined model if yes).\nReturns:\ncombined_model_id \u2013 Id of the combined model that was updated\nReturn type:\nstr\nget_segments_info()\uf0c1\nRetrieve Combined Model segments info\nReturns:\nList of segments\nReturn type:\nlist[SegmentInfo]\nget_segments_as_dataframe(encoding='utf-8')\uf0c1\nRetrieve Combine Models segments as a DataFrame.\nParameters:\nencoding (Optional[str]) \u2013 A string representing the encoding to use in the output csv file.\nDefaults to \u2018utf-8\u2019.\nReturns:\nCombined model segments\nReturn type:\nDataFrame\nget_segments_as_csv(filename, encoding='utf-8')\uf0c1\nSave the Combine Models segments to a csv.\nParameters:\nfilename (str or file object) \u2013 The path or file object to save the data to.\nencoding (Optional[str]) \u2013 A string representing the encoding to use in the output csv file.\nDefaults to \u2018utf-8\u2019.\nReturn type:\nNone\ntrain(sample_pct=None, featurelist_id=None, scoring_type=None, training_row_count=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>)\uf0c1\nInherited from Model - CombinedModels cannot be retrained directly\nReturn type:\nNoReturn\ntrain_datetime(featurelist_id=None, training_row_count=None, training_duration=None, time_window_sample_pct=None, monotonic_increasing_featurelist_id=<object object>, monotonic_decreasing_featurelist_id=<object object>, use_project_settings=False, sampling_method=None, n_clusters=None)\uf0c1\nInherited from Model - CombinedModels cannot be retrained directly\nReturn type:\nNoReturn\nretrain(sample_pct=None, featurelist_id=None, training_row_count=None, n_clusters=None)\uf0c1\nInherited from Model - CombinedModels cannot be retrained directly\nReturn type:\nNoReturn\nrequest_frozen_model(sample_pct=None, training_row_count=None)\uf0c1\nInherited from Model - CombinedModels cannot be retrained as frozen\nReturn type:\nNoReturn\nrequest_frozen_datetime_model(training_row_count=None, training_duration=None, training_start_date=None, training_end_date=None, time_window_sample_pct=None, sampling_method=None)\uf0c1\nInherited from Model - CombinedModels cannot be retrained as frozen\nReturn type:\nNoReturn\ncross_validate()\uf0c1\nInherited from Model - CombinedModels cannot request cross validation\nReturn type:\nNoReturn\nclass datarobot.SegmentationTask\uf0c1\nA Segmentation Task is used for segmenting an existing project into multiple child\nprojects. Each child project (or segment) will be a separate autopilot run. Currently\nonly user defined segmentation is supported.\nExample for creating a new SegmentationTask for Time Series segmentation with a\nuser defined id column:\nfrom datarobot import SegmentationTask\n# Create the SegmentationTask\nsegmentation_task_results = SegmentationTask.create(\nproject_id=project.id,\ntarget=target,\nuse_time_series=True,\ndatetime_partition_column=datetime_partition_column,\nmultiseries_id_columns=[multiseries_id_column],\nuser_defined_segment_id_columns=[user_defined_segment_id_column]\n)\n# Retrieve the completed SegmentationTask object from the job results\nsegmentation_task = segmentation_task_results['completedJobs'][0]\nVariables:\nid (bson.ObjectId) \u2013 The id of the segmentation task.\nproject_id (bson.ObjectId) \u2013 The associated id of the parent project.\ntype (str) \u2013 What type of job the segmentation task is associated with, e.g. auto_ml or auto_ts.\ncreated (datetime.datetime) \u2013 The date this segmentation task was created.\nsegments_count (int) \u2013 The number of segments the segmentation task generated.\nsegments (list[str]) \u2013 The segment names that the segmentation task generated.\nmetadata (dict) \u2013 List of features that help to identify the parameters used by the segmentation task.\ndata (dict) \u2013 Optional parameters that are associated with enabled metadata for the segmentation task.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nSegmentationTask\ncollect_payload()\uf0c1\nConvert the record to a dictionary\nReturn type:\nDict[str, str]\nclassmethod create(project_id, target, use_time_series=False, datetime_partition_column=None, multiseries_id_columns=None, user_defined_segment_id_columns=None, max_wait=600, model_package_id=None)\uf0c1\nCreates segmentation tasks for the project based on the defined parameters.\nParameters:\nproject_id (str) \u2013 The associated id of the parent project.\ntarget (str) \u2013 The column that represents the target in the dataset.\nuse_time_series (bool) \u2013 Whether AutoTS or AutoML segmentations should be generated.\ndatetime_partition_column (str or null) \u2013 Required for Time Series.\nThe name of the column whose values as dates are used to assign a row\nto a particular partition.\nmultiseries_id_columns (List[str] or null) \u2013 Required for Time Series.\nA list of the names of multiseries id columns to define series within the training\ndata. Currently only one multiseries id column is supported.\nuser_defined_segment_id_columns (List[str] or null) \u2013 Required when using a column for segmentation.\nA list of the segment id columns to use to define what columns are used to manually\nsegment data. Currently only one user defined segment id column is supported.\nmodel_package_id (str) \u2013 Required when using automated segmentation.\nThe associated id of the model in the DataRobot Model Registry that will be used to\nperform automated segmentation on a dataset.\nmax_wait (integer) \u2013 The number of seconds to wait\nReturns:\nsegmentation_tasks \u2013 Dictionary containing the numberOfJobs, completedJobs, and failedJobs. completedJobs\nis a list of SegmentationTask objects, while failed jobs is a list of dictionaries\nindicating problems with submitted tasks.\nReturn type:\ndict\nclassmethod list(project_id)\uf0c1\nList all of the segmentation tasks that have been created for a specific project_id.\nParameters:\nproject_id (str) \u2013 The id of the parent project\nReturns:\nsegmentation_tasks \u2013 List of instances with initialized data.\nReturn type:\nlist of SegmentationTask\nclassmethod get(project_id, segmentation_task_id)\uf0c1\nRetrieve information for a single segmentation task associated with a project_id.\nParameters:\nproject_id (str) \u2013 The id of the parent project\nsegmentation_task_id (str) \u2013 The id of the segmentation task\nReturns:\nsegmentation_task \u2013 Instance with initialized data.\nReturn type:\nSegmentationTask\nclass datarobot.SegmentInfo\uf0c1\nA SegmentInfo is an object containing information about the combined model segments\nVariables:\nproject_id (str) \u2013 The associated id of the child project.\nsegment (str) \u2013 the name of the segment\nproject_stage (str) \u2013 A description of the current stage of the project\nproject_status_error (str) \u2013 Project status error message.\nautopilot_done (bool) \u2013 Is autopilot done for the project.\nmodel_count (int) \u2013 Count of trained models in project.\nmodel_id (str) \u2013 ID of segment champion model.\nclassmethod list(project_id, model_id)\uf0c1\nList all of the segments that have been created for a specific project_id.\nParameters:\nproject_id (str) \u2013 The id of the parent project\nReturns:\nsegments \u2013 List of instances with initialized data.\nReturn type:\nlist of datarobot.models.segmentation.SegmentInfo\nclass datarobot.models.segmentation.SegmentationTask\uf0c1\nA Segmentation Task is used for segmenting an existing project into multiple child\nprojects. Each child project (or segment) will be a separate autopilot run. Currently\nonly user defined segmentation is supported.\nExample for creating a new SegmentationTask for Time Series segmentation with a\nuser defined id column:\nfrom datarobot import SegmentationTask\n# Create the SegmentationTask\nsegmentation_task_results = SegmentationTask.create(\nproject_id=project.id,\ntarget=target,\nuse_time_series=True,\ndatetime_partition_column=datetime_partition_column,\nmultiseries_id_columns=[multiseries_id_column],\nuser_defined_segment_id_columns=[user_defined_segment_id_column]\n)\n# Retrieve the completed SegmentationTask object from the job results\nsegmentation_task = segmentation_task_results['completedJobs'][0]\nVariables:\nid (bson.ObjectId) \u2013 The id of the segmentation task.\nproject_id (bson.ObjectId) \u2013 The associated id of the parent project.\ntype (str) \u2013 What type of job the segmentation task is associated with, e.g. auto_ml or auto_ts.\ncreated (datetime.datetime) \u2013 The date this segmentation task was created.\nsegments_count (int) \u2013 The number of segments the segmentation task generated.\nsegments (list[str]) \u2013 The segment names that the segmentation task generated.\nmetadata (dict) \u2013 List of features that help to identify the parameters used by the segmentation task.\ndata (dict) \u2013 Optional parameters that are associated with enabled metadata for the segmentation task.\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nSegmentationTask\ncollect_payload()\uf0c1\nConvert the record to a dictionary\nReturn type:\nDict[str, str]\nclassmethod create(project_id, target, use_time_series=False, datetime_partition_column=None, multiseries_id_columns=None, user_defined_segment_id_columns=None, max_wait=600, model_package_id=None)\uf0c1\nCreates segmentation tasks for the project based on the defined parameters.\nParameters:\nproject_id (str) \u2013 The associated id of the parent project.\ntarget (str) \u2013 The column that represents the target in the dataset.\nuse_time_series (bool) \u2013 Whether AutoTS or AutoML segmentations should be generated.\ndatetime_partition_column (str or null) \u2013 Required for Time Series.\nThe name of the column whose values as dates are used to assign a row\nto a particular partition.\nmultiseries_id_columns (List[str] or null) \u2013 Required for Time Series.\nA list of the names of multiseries id columns to define series within the training\ndata. Currently only one multiseries id column is supported.\nuser_defined_segment_id_columns (List[str] or null) \u2013 Required when using a column for segmentation.\nA list of the segment id columns to use to define what columns are used to manually\nsegment data. Currently only one user defined segment id column is supported.\nmodel_package_id (str) \u2013 Required when using automated segmentation.\nThe associated id of the model in the DataRobot Model Registry that will be used to\nperform automated segmentation on a dataset.\nmax_wait (integer) \u2013 The number of seconds to wait\nReturns:\nsegmentation_tasks \u2013 Dictionary containing the numberOfJobs, completedJobs, and failedJobs. completedJobs\nis a list of SegmentationTask objects, while failed jobs is a list of dictionaries\nindicating problems with submitted tasks.\nReturn type:\ndict\nclassmethod list(project_id)\uf0c1\nList all of the segmentation tasks that have been created for a specific project_id.\nParameters:\nproject_id (str) \u2013 The id of the parent project\nReturns:\nsegmentation_tasks \u2013 List of instances with initialized data.\nReturn type:\nlist of SegmentationTask\nclassmethod get(project_id, segmentation_task_id)\uf0c1\nRetrieve information for a single segmentation task associated with a project_id.\nParameters:\nproject_id (str) \u2013 The id of the parent project\nsegmentation_task_id (str) \u2013 The id of the segmentation task\nReturns:\nsegmentation_task \u2013 Instance with initialized data.\nReturn type:\nSegmentationTask\nclass datarobot.models.segmentation.SegmentationTaskCreatedResponse\uf0c1\nExternal baseline validation\uf0c1\nclass datarobot.models.external_baseline_validation.ExternalBaselineValidationInfo\uf0c1\nAn object containing information about external time series baseline predictions\nvalidation results.\nVariables:\nbaseline_validation_job_id (str) \u2013 the identifier of the baseline validation job\nproject_id (str) \u2013 the identifier of the project\ncatalog_version_id (str) \u2013 the identifier of the catalog version used in the validation job\ntarget (str) \u2013 the name of the target feature\ndatetime_partition_column (str) \u2013 the name of the column whose values as dates are used to assign a row\nto a particular partition\nis_external_baseline_dataset_valid (bool) \u2013 whether the external baseline dataset passes the validation check\nmultiseries_id_columns (List[str] or null) \u2013 a list of the names of multiseries id columns to define series\nwithin the training data.  Currently only one multiseries id column is supported.\nholdout_start_date (str or None) \u2013 the start date of holdout scoring data\nholdout_end_date (str or None) \u2013 the end date of holdout scoring data\nbacktests (list of dicts containing validation_start_date and validation_end_date or None) \u2013 the configured backtests of the time series project\nforecast_window_start (int) \u2013 offset into the future to define how far forward relative to the forecast point the\nforecast window should start.\nforecast_window_end (int) \u2013 offset into the future to define how far forward relative to the forecast point the\nforecast window should end.\nmessage (str or None) \u2013 the description of the issue with external baseline validation job\nclassmethod get(project_id, validation_job_id)\uf0c1\nGet information about external baseline validation job\nParameters:\nproject_id (string) \u2013 the identifier of the project\nvalidation_job_id (string) \u2013 the identifier of the external baseline validation job\nReturns:\ninfo \u2013 information about external baseline validation job\nReturn type:\nExternalBaselineValidationInfo\nCalendar file\uf0c1\nclass datarobot.CalendarFile\uf0c1\nRepresents the data for a calendar file.\nFor more information about calendar files, see the\ncalendar documentation.\nVariables:\nid (str) \u2013 The id of the calendar file.\ncalendar_start_date (str) \u2013 The earliest date in the calendar.\ncalendar_end_date (str) \u2013 The last date in the calendar.\ncreated (str) \u2013 The date this calendar was created, i.e. uploaded to DR.\nname (str) \u2013 The name of the calendar.\nnum_event_types (int) \u2013 The number of different event types.\nnum_events (int) \u2013 The number of events this calendar has.\nproject_ids (list of strings) \u2013 A list containing the projectIds of the projects using this calendar.\nmultiseries_id_columns (List[str] or None) \u2013 A list of columns in calendar which uniquely identify events for different series.\nCurrently, only one column is supported.\nIf multiseries id columns are not provided, calendar is considered to be single series.\nrole (str) \u2013 The access role the user has for this calendar.\nclassmethod create(file_path, calendar_name=None, multiseries_id_columns=None)\uf0c1\nCreates a calendar using the given file. For information about calendar files, see the\ncalendar documentation\nThe provided file must be a CSV in the format:\nDate,   Event,          Series ID,    Event Duration\n<date>, <event_type>,   <series id>,  <event duration>\n<date>, <event_type>,              ,  <event duration>\nA header row is required, and the \u201cSeries ID\u201d and \u201cEvent Duration\u201d columns are optional.\nOnce the CalendarFile has been created, pass its ID with\nthe DatetimePartitioningSpecification\nwhen setting the target for a time series project in order to use it.\nParameters:\nfile_path (string) \u2013 A string representing a path to a local csv file.\ncalendar_name (string, optional) \u2013 A name to assign to the calendar. Defaults to the name of the file if not provided.\nmultiseries_id_columns (List[str] or None) \u2013 A list of the names of multiseries id columns to define which series an event\nbelongs to. Currently only one multiseries id column is supported.\nReturns:\ncalendar_file \u2013 Instance with initialized data.\nReturn type:\nCalendarFile\nRaises:\nAsyncProcessUnsuccessfulError \u2013 Raised if there was an error processing the provided calendar file.\nExamples\n# Creating a calendar with a specified name\ncal = dr.CalendarFile.create('/home/calendars/somecalendar.csv',\ncalendar_name='Some Calendar Name')\ncal.id\n>>> 5c1d4904211c0a061bc93013\ncal.name\n>>> Some Calendar Name\n# Creating a calendar without specifying a name\ncal = dr.CalendarFile.create('/home/calendars/somecalendar.csv')\ncal.id\n>>> 5c1d4904211c0a061bc93012\ncal.name\n>>> somecalendar.csv\n# Creating a calendar with multiseries id columns\ncal = dr.CalendarFile.create('/home/calendars/somemultiseriescalendar.csv',\ncalendar_name='Some Multiseries Calendar Name',\nmultiseries_id_columns=['series_id'])\ncal.id\n>>> 5da9bb21962d746f97e4daee\ncal.name\n>>> Some Multiseries Calendar Name\ncal.multiseries_id_columns\n>>> ['series_id']\nclassmethod create_calendar_from_dataset(dataset_id, dataset_version_id=None, calendar_name=None, multiseries_id_columns=None, delete_on_error=False)\uf0c1\nCreates a calendar using the given dataset. For information about calendar files, see the\ncalendar documentation\nThe provided dataset have the following format:\nDate,   Event,          Series ID,    Event Duration\n<date>, <event_type>,   <series id>,  <event duration>\n<date>, <event_type>,              ,  <event duration>\nThe \u201cSeries ID\u201d and \u201cEvent Duration\u201d columns are optional.\nOnce the CalendarFile has been created, pass its ID with\nthe DatetimePartitioningSpecification\nwhen setting the target for a time series project in order to use it.\nParameters:\ndataset_id (string) \u2013 The identifier of the dataset from which to create the calendar.\ndataset_version_id (string, optional) \u2013 The identifier of the dataset version from which to create the calendar.\ncalendar_name (string, optional) \u2013 A name to assign to the calendar. Defaults to the name of the dataset if not provided.\nmultiseries_id_columns (list of Optional[str]) \u2013 A list of the names of multiseries id columns to define which series an event\nbelongs to. Currently only one multiseries id column is supported.\ndelete_on_error (boolean, optional) \u2013 Whether delete calendar file from Catalog if it\u2019s not valid.\nReturns:\ncalendar_file \u2013 Instance with initialized data.\nReturn type:\nCalendarFile\nRaises:\nAsyncProcessUnsuccessfulError \u2013 Raised if there was an error processing the provided calendar file.\nExamples\n# Creating a calendar from a dataset\ndataset = dr.Dataset.create_from_file('/home/calendars/somecalendar.csv')\ncal = dr.CalendarFile.create_calendar_from_dataset(\ndataset.id, calendar_name='Some Calendar Name'\n)\ncal.id\n>>> 5c1d4904211c0a061bc93013\ncal.name\n>>> Some Calendar Name\n# Creating a calendar from a new dataset version\nnew_dataset_version = dr.Dataset.create_version_from_file(\ndataset.id, '/home/calendars/anothercalendar.csv'\n)\ncal = dr.CalendarFile.create(\nnew_dataset_version.id, dataset_version_id=new_dataset_version.version_id\n)\ncal.id\n>>> 5c1d4904211c0a061bc93012\ncal.name\n>>> anothercalendar.csv\nclassmethod create_calendar_from_country_code(country_code, start_date, end_date)\uf0c1\nGenerates a calendar based on the provided country code and dataset start date and end\ndates. The provided country code should be uppercase and 2-3 characters long. See\nCalendarFile.get_allowed_country_codes for a list of allowed country codes.\nParameters:\ncountry_code (string) \u2013 The country code for the country to use for generating the calendar.\nstart_date (datetime.datetime) \u2013 The earliest date to include in the generated calendar.\nend_date (datetime.datetime) \u2013 The latest date to include in the generated calendar.\nReturns:\ncalendar_file \u2013 Instance with initialized data.\nReturn type:\nCalendarFile\nclassmethod get_allowed_country_codes(offset=None, limit=None)\uf0c1\nRetrieves the list of allowed country codes that can be used for generating the preloaded\ncalendars.\nParameters:\noffset (int) \u2013 Optional, defaults to 0. This many results will be skipped.\nlimit (int) \u2013 Optional, defaults to 100, maximum 1000. At most this many results are returned.\nReturns:\nA list dicts, each of which represents an allowed country codes. Each item has the\nfollowing structure:\nname : (str) The name of the country.\ncode : (str) The code for this country. This is the value that should be supplied\nto CalendarFile.create_calendar_from_country_code.\nReturn type:\nlist\nclassmethod get(calendar_id)\uf0c1\nGets the details of a calendar, given the id.\nParameters:\ncalendar_id (str) \u2013 The identifier of the calendar.\nReturns:\ncalendar_file \u2013 The requested calendar.\nReturn type:\nCalendarFile\nRaises:\nDataError \u2013 Raised if the calendar_id is invalid, i.e. the specified CalendarFile does not exist.\nExamples\ncal = dr.CalendarFile.get(some_calendar_id)\ncal.id\n>>> some_calendar_id\nclassmethod list(project_id=None, batch_size=None)\uf0c1\nGets the details of all calendars this user has view access for.\nParameters:\nproject_id (Optional[str]) \u2013 If provided, will filter for calendars associated only with the specified project.\nbatch_size (Optional[int]) \u2013 The number of calendars to retrieve in a single API call. If specified, the client may\nmake multiple calls to retrieve the full list of calendars. If not specified, an\nappropriate default will be chosen by the server.\nReturns:\ncalendar_list \u2013 A list of CalendarFile objects.\nReturn type:\nlist of CalendarFile\nExamples\ncalendars = dr.CalendarFile.list()\nlen(calendars)\n>>> 10\nclassmethod delete(calendar_id)\uf0c1\nDeletes the calendar specified by calendar_id.\nParameters:\ncalendar_id (str) \u2013 The id of the calendar to delete.\nThe requester must have OWNER access for this calendar.\nRaises:\nClientError \u2013 Raised if an invalid calendar_id is provided.\nReturn type:\nNone\nExamples\n# Deleting with a valid calendar_id\nstatus_code = dr.CalendarFile.delete(some_calendar_id)\nstatus_code\n>>> 204\ndr.CalendarFile.get(some_calendar_id)\n>>> ClientError: Item not found\nclassmethod update_name(calendar_id, new_calendar_name)\uf0c1\nChanges the name of the specified calendar to the specified name.\nThe requester must have at least READ_WRITE permissions on the calendar.\nParameters:\ncalendar_id (str) \u2013 The id of the calendar to update.\nnew_calendar_name (str) \u2013 The new name to set for the specified calendar.\nReturns:\nstatus_code \u2013 200 for success\nReturn type:\nint\nRaises:\nClientError \u2013 Raised if an invalid calendar_id is provided.\nExamples\nresponse = dr.CalendarFile.update_name(some_calendar_id, some_new_name)\nresponse\n>>> 200\ncal = dr.CalendarFile.get(some_calendar_id)\ncal.name\n>>> some_new_name\nclassmethod share(calendar_id, access_list)\uf0c1\nShares the calendar with the specified users, assigning the specified roles.\nParameters:\ncalendar_id (str) \u2013 The id of the calendar to update\naccess_list (List[SharingAccess]) \u2013 A list of dr.SharingAccess objects. Specify None for the role to delete a user\u2019s\naccess from the specified CalendarFile. For more information on specific access levels,\nsee the sharing documentation.\nReturns:\nstatus_code \u2013 200 for success\nReturn type:\nint\nRaises:\nClientError \u2013 Raised if unable to update permissions for a user.\nAssertionError \u2013 Raised if access_list is invalid.\nExamples\n# assuming some_user is a valid user, share this calendar with some_user\nsharing_list = [dr.SharingAccess(some_user_username,\ndr.enums.SHARING_ROLE.READ_WRITE)]\nresponse = dr.CalendarFile.share(some_calendar_id, sharing_list)\nresponse.status_code\n>>> 200\n# delete some_user from this calendar, assuming they have access of some kind already\ndelete_sharing_list = [dr.SharingAccess(some_user_username,\nNone)]\nresponse = dr.CalendarFile.share(some_calendar_id, delete_sharing_list)\nresponse.status_code\n>>> 200\n# Attempt to add an invalid user to a calendar\ninvalid_sharing_list = [dr.SharingAccess(invalid_username,\ndr.enums.SHARING_ROLE.READ_WRITE)]\ndr.CalendarFile.share(some_calendar_id, invalid_sharing_list)\n>>> ClientError: Unable to update access for this calendar\nclassmethod get_access_list(calendar_id, batch_size=None)\uf0c1\nRetrieve a list of users that have access to this calendar.\nParameters:\ncalendar_id (str) \u2013 The id of the calendar to retrieve the access list for.\nbatch_size (Optional[int]) \u2013 The number of access records to retrieve in a single API call. If specified, the client\nmay make multiple calls to retrieve the full list of calendars. If not specified, an\nappropriate default will be chosen by the server.\nReturns:\naccess_control_list \u2013 A list of SharingAccess objects.\nReturn type:\nlist of SharingAccess\nRaises:\nClientError \u2013 Raised if user does not have access to calendar or calendar does not exist.\nclass datarobot.models.calendar_file.CountryCode\uf0c1",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://docs.datarobot.com/en/docs/modeling/reference/model-detail/leaderboard-ref.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/features.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/blueprints.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/datetime_partition.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/insights.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/segmented_modeling.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/sharing.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.PROJECT_STAGE",
        "import datarobot as dr\np = dr.Project.get(project_id='54e639a18bd88f08078ca831')\np.id\n>>>'54e639a18bd88f08078ca831'\np.project_name\n>>>'Some project name'",
        "p = Project.create('/home/datasets/somedataset.csv',\n                   project_name=\"New API project\")\np.id\n>>> '5921731dkqshda8yd28h'\np.project_name\n>>> 'New API project'",
        "p = Project.create_from_hdfs('hdfs:///tmp/somedataset.csv',\n                             project_name=\"New API project\")\np.id\n>>> '5921731dkqshda8yd28h'\np.project_name\n>>> 'New API project'",
        "datarobot.models.Dataset",
        "datarobot.helpers.partitioning_methods",
        "Project.set_partitioning_method",
        "Project.set_datetime_partitioning",
        "Project.start(\"./tests/fixtures/file.csv\",\n              \"a_target\",\n              project_name=\"test_name\",\n              worker_count=4,\n              metric=\"a_metric\")",
        "Project.start(\"https://example.com/data/file.csv\",\n              \"a_target\",\n              project_name=\"test_name\",\n              worker_count=4,\n              metric=\"a_metric\")",
        "p_list = Project.list()\np_list\n>>> [Project('Project One'), Project('Two')]",
        "Project.list(search_params={'project_name': 'red'})\n>>> [Project('Prediction Time'), Project('Fred Project')]",
        "Project.list(offset=1, limit=2)\n>>> [Project('Project 2'), Project('Project 3')]",
        "datarobot.helpers.partitioning_methods",
        "Project.set_partitioning_method",
        "Project.set_datetime_partitioning",
        "datarobot.models.Project.start",
        "datarobot.helpers.partitioning_methods",
        "Project.set_partitioning_method",
        "Project.set_datetime_partitioning",
        "datarobot.helpers.ClassMappingAggregationSettings",
        "datarobot.models.Project.start",
        "datarobot.models.Project.analyze_and_model",
        "GenericModel if `use_new_models_retrieval",
        "Project.get('pid').get_models(order_by=['-sample_pct',\n                              'metric'])\n\n# Getting models that contain \"Ridge\" in name\nProject.get('pid').get_models(\n    search_params={\n        'name': \"Ridge\"\n    })\n\n# Filtering models based on 'starred' flag:\nProject.get('pid').get_models(search_params={'is_starred': True})",
        "# retrieve additional attributes for the model\nmodel_records = project.get_models(use_new_models_retrieval=True)\nmodel_record = model_records[0]\nblueprint_id = model_record.blueprint_id\nblueprint = dr.Blueprint.get(project.id, blueprint_id)\nmodel_record.number_of_clusters\nblueprint.supports_composable_ml\nblueprint.supports_monotonic_constraints\nblueprint.monotonic_decreasing_featurelist_id\nblueprint.monotonic_increasing_featurelist_id\nmodel = dr.Model.get(project.id, model_record.id)\nmodel.prediction_threshold\nmodel.prediction_threshold_read_only\nmodel.has_empty_clusters\nmodel.is_n_clusters_dynamically_determined",
        "from datarobot.models.project import Project\n\nproject = Project.get(\"<MY_PROJECT_ID>\")\ntop_model = project.get_top_model()",
        "from datarobot.models.project import Project\n\nproject = Project.get(\"<MY_PROJECT_ID>\")\ndataset = project.get_dataset()",
        "datarobot.enums.VARIABLE_TYPE_TRANSFORM",
        "datarobot.enums.DATE_EXTRACTION",
        "project = Project.get('5223deadbeefdeadbeef0101')\nfeaturelist = project.get_featurelist_by_name(\"Raw Features\")",
        "project = Project.get('5223deadbeefdeadbeef0101')\nflists = project.get_featurelists()\n\n# Create a new featurelist using a subset of features from an\n# existing featurelist\nflist = flists[0]\nfeatures = flist.features[::2]  # Half of the features\n\nnew_flist = project.create_featurelist(\n    name='Feature Subset',\n    features=features,\n)",
        "project = Project.get('5223deadbeefdeadbeef0101')\n\n# Create a new featurelist using a subset of features from an\n# existing featurelist by using features_to_exclude param\n\nnew_flist = project.create_featurelist(\n    name='Feature Subset of Existing Featurelist',\n    starting_featurelist_name=\"Informative Features\",\n    features_to_exclude=[\"metformin\", \"weight\", \"age\"],\n)",
        "project = Project.get('1234deadbeeffeeddead4321')\nmodeling_features = project.get_modeling_features()\nselected_features = [feat.name for feat in modeling_features][:5]  # select first five\nnew_flist = project.create_modeling_featurelist('Model This', selected_features)",
        "{\"autopilot_done\": False,\n \"stage\": \"modeling\",\n \"stage_description\": \"Ready for modeling\"}",
        "Project.train_datetime",
        "dr.SCORING_TYPE.validation",
        "dr.SCORING_TYPE.cross_validation",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "wait_for_async_model_creation",
        "blueprint = project.get_blueprints()[0]\nmodel_job_id = project.train(blueprint, training_row_count=project.max_train_rows)",
        "blueprint_id = 'e1c7fc29ba2e612a72272324b8a842af'\nproject.train(blueprint, training_row_count=project.max_train_rows)\n\nanother_project.train(blueprint, source_project_id=project.id)",
        "model = project.get_models()[0]\nmodel_job_id = project.train(model.blueprint.id,\n                             sample_pct=100)",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "dr.enums.MONOTONICITY_FEATURELIST_DEFAULT",
        "datarobot.enums.BLENDER_METHOD",
        "datarobot.enums.TS_BLENDER_METHOD",
        "datarobot.models.Project.check_blendable",
        "datarobot.enums.BLENDER_METHOD",
        "datarobot.enums.TS_BLENDER_METHOD",
        "datarobot.enums.DATETIME_AUTOPILOT_DATA_SAMPLING_METHOD",
        "Project.validate_external_time_series_baseline",
        "datarobot.enums.CV_METHOD",
        "datarobot.helpers.partitioning_methods.PartitioningMethod",
        "import datarobot as dr\n\nnew_access = dr.SharingAccess(new_user@datarobot.com,\n                              dr.enums.SHARING_ROLE.OWNER, can_share=True)\naccess_list = [dr.SharingAccess(old_user@datarobot.com, None), new_access]\n\ndr.Project.get('my-project-id').share(access_list)",
        "datarobot.enums.VARIABLE_TYPE_TRANSFORM",
        "datarobot.enums.VARIABLE_TYPE_TRANSFORM",
        "datarobot.models.Project",
        "datarobot.models.InteractionFeature",
        "datarobot.helpers.partitioning_methods",
        "Project.analyze_and_model",
        "datarobot.enums.DATETIME_AUTOPILOT_DATA_SAMPLING_METHOD",
        "Project.validate_external_time_series_baseline",
        "import datarobot as dr\nadvanced_options = dr.AdvancedOptions(\n    weights='weights_column',\n    offset=['offset_column'],\n    exposure='exposure_column',\n    response_cap=0.7,\n    blueprint_threshold=2,\n    smart_downsampled=True, majority_downsampling_rate=75.0)",
        "Project.analyze_and_model",
        "datarobot.enums.DATETIME_AUTOPILOT_DATA_SELECTION_METHOD",
        "datarobot.enums.TIME_UNITS",
        "datarobot.enums.TREAT_AS_EXPONENTIAL",
        "datarobot.enums.DIFFERENCING_METHOD",
        "datarobot.Periodicity",
        "datarobot.enums.UnsupervisedTypeEnum",
        "import datarobot as dr\n\npartitioning_spec = dr.DatetimePartitioningSpecification(\n    backtests=[\n        # modify the first backtest using option 1\n        dr.BacktestSpecification(\n            index=0,\n            gap_duration=dr.partitioning_methods.construct_duration_string(),\n            validation_start_date=datetime(year=2010, month=1, day=1),\n            validation_duration=dr.partitioning_methods.construct_duration_string(years=1),\n        )\n    ],\n    # other partitioning settings...\n)",
        "import datarobot as dr\n\npartitioning_spec = dr.DatetimePartitioningSpecification(\n    backtests=[\n        # modify the first backtest using option 2\n        dr.BacktestSpecification(\n            index=0,\n            primary_training_start_date=datetime(year=2005, month=1, day=1),\n            primary_training_end_date=datetime(year=2010, month=1, day=1),\n            validation_start_date=datetime(year=2010, month=1, day=1),\n            validation_end_date=datetime(year=2011, month=1, day=1),\n        )\n    ],\n    # other partitioning settings...\n)",
        "from datarobot as dr\nperiodicities = [\n    dr.Periodicity(time_steps=10, time_unit=dr.enums.TIME_UNITS.HOUR),\n    dr.Periodicity(time_steps=600, time_unit=dr.enums.TIME_UNITS.MINUTE)]\nspec = dr.DatetimePartitioningSpecification(\n    # ...\n    periodicities=periodicities\n)",
        "DatetimePartitioning.get(project_id)",
        "Project.analyze_and_model",
        "datarobot.enums.DATETIME_AUTOPILOT_DATA_SELECTION_METHOD",
        "datarobot.enums.TIME_UNITS",
        "datarobot.enums.TREAT_AS_EXPONENTIAL",
        "datarobot.enums.DIFFERENCING_METHOD",
        "datarobot.Periodicity",
        "datarobot.enums.UnsupervisedTypeEnum",
        "Project.analyze_and_model",
        "the full partitioning for the project",
        "the full partitioning for the project",
        "Project.analyze_and_model",
        "from datarobot import SegmentationTask\n\n# Create the SegmentationTask\nsegmentation_task_results = SegmentationTask.create(\n    project_id=project.id,\n    target=target,\n    use_time_series=True,\n    datetime_partition_column=datetime_partition_column,\n    multiseries_id_columns=[multiseries_id_column],\n    user_defined_segment_id_columns=[user_defined_segment_id_column]\n)\n\n# Retrieve the completed SegmentationTask object from the job results\nsegmentation_task = segmentation_task_results['completedJobs'][0]",
        "datarobot.models.segmentation.SegmentInfo",
        "from datarobot import SegmentationTask\n\n# Create the SegmentationTask\nsegmentation_task_results = SegmentationTask.create(\n    project_id=project.id,\n    target=target,\n    use_time_series=True,\n    datetime_partition_column=datetime_partition_column,\n    multiseries_id_columns=[multiseries_id_column],\n    user_defined_segment_id_columns=[user_defined_segment_id_column]\n)\n\n# Retrieve the completed SegmentationTask object from the job results\nsegmentation_task = segmentation_task_results['completedJobs'][0]",
        "# Creating a calendar with a specified name\ncal = dr.CalendarFile.create('/home/calendars/somecalendar.csv',\n                                         calendar_name='Some Calendar Name')\ncal.id\n>>> 5c1d4904211c0a061bc93013\ncal.name\n>>> Some Calendar Name\n\n# Creating a calendar without specifying a name\ncal = dr.CalendarFile.create('/home/calendars/somecalendar.csv')\ncal.id\n>>> 5c1d4904211c0a061bc93012\ncal.name\n>>> somecalendar.csv\n\n# Creating a calendar with multiseries id columns\ncal = dr.CalendarFile.create('/home/calendars/somemultiseriescalendar.csv',\n                             calendar_name='Some Multiseries Calendar Name',\n                             multiseries_id_columns=['series_id'])\ncal.id\n>>> 5da9bb21962d746f97e4daee\ncal.name\n>>> Some Multiseries Calendar Name\ncal.multiseries_id_columns\n>>> ['series_id']",
        "# Creating a calendar from a dataset\ndataset = dr.Dataset.create_from_file('/home/calendars/somecalendar.csv')\ncal = dr.CalendarFile.create_calendar_from_dataset(\n    dataset.id, calendar_name='Some Calendar Name'\n)\ncal.id\n>>> 5c1d4904211c0a061bc93013\ncal.name\n>>> Some Calendar Name\n\n# Creating a calendar from a new dataset version\nnew_dataset_version = dr.Dataset.create_version_from_file(\n    dataset.id, '/home/calendars/anothercalendar.csv'\n)\ncal = dr.CalendarFile.create(\n    new_dataset_version.id, dataset_version_id=new_dataset_version.version_id\n)\ncal.id\n>>> 5c1d4904211c0a061bc93012\ncal.name\n>>> anothercalendar.csv",
        "cal = dr.CalendarFile.get(some_calendar_id)\ncal.id\n>>> some_calendar_id",
        "calendars = dr.CalendarFile.list()\nlen(calendars)\n>>> 10",
        "# Deleting with a valid calendar_id\nstatus_code = dr.CalendarFile.delete(some_calendar_id)\nstatus_code\n>>> 204\ndr.CalendarFile.get(some_calendar_id)\n>>> ClientError: Item not found",
        "response = dr.CalendarFile.update_name(some_calendar_id, some_new_name)\nresponse\n>>> 200\ncal = dr.CalendarFile.get(some_calendar_id)\ncal.name\n>>> some_new_name",
        "# assuming some_user is a valid user, share this calendar with some_user\nsharing_list = [dr.SharingAccess(some_user_username,\n                                 dr.enums.SHARING_ROLE.READ_WRITE)]\nresponse = dr.CalendarFile.share(some_calendar_id, sharing_list)\nresponse.status_code\n>>> 200\n\n# delete some_user from this calendar, assuming they have access of some kind already\ndelete_sharing_list = [dr.SharingAccess(some_user_username,\n                                        None)]\nresponse = dr.CalendarFile.share(some_calendar_id, delete_sharing_list)\nresponse.status_code\n>>> 200\n\n# Attempt to add an invalid user to a calendar\ninvalid_sharing_list = [dr.SharingAccess(invalid_username,\n                                         dr.enums.SHARING_ROLE.READ_WRITE)]\ndr.CalendarFile.share(some_calendar_id, invalid_sharing_list)\n>>> ClientError: Unable to update access for this calendar"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/index.html",
      "title": "Python API client user guide\uf0c1",
      "description": "",
      "content": "Python API client user guide\uf0c1\nTopic\nDescription\nAdministration\nHow to manage DataRobot Self-Managed AI Platform deployments.\nData\nHow to manage data for machine learning, including importing and transforming data, and connecting to data sources.\nMLOps\nHow to deploy, monitor, manage, and govern your models in production.\nModeling\nHow to set modeling parameters before building, use the modeling workflow, and manage models and projects.\nPredictions\nHow to get predictions (\u201cscoring\u201d) on new data from a model.\nUse Cases\nHow to use Use Cases to group everything related to solving a specific business problem.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/data_exports.html",
      "title": "Data exports\uf0c1",
      "description": "Use deployment data export to retrieve the data sent for predictions along with the associated predictions.",
      "content": "Data exports\uf0c1\nUse deployment data export to retrieve the data sent for predictions along with the associated predictions.\nPrediction data export\uf0c1\nUse the following commands to manage prediction data exports:\nCreate a prediction data export\uf0c1\nTo create a prediction data export, use PredictionDataExport.create, defining the time window to include in the export\nusing the start and end parameters, as shown in the following example:\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\nnow=datetime.now()\nprediction_data_export = PredictionDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now)\nSpecify the model ID for export, otherwise the champion model ID is used by default:\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\nnow=datetime.now()\nprediction_data_export = PredictionDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0',\nmodel_id='6444482e5583f6ee2e572265',\nstart=now - timedelta(days=7),\nend=now\n)\nFor deployments in batch mode, provide batch IDs to export prediction data for those batches:\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\nnow=datetime.now()\nprediction_data_export = PredictionDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0',\nmodel_id='6444482e5583f6ee2e572265',\nstart=now - timedelta(days=7),\nend=now,\nbatch_ids=['6572db2c9f9d4ad3b9de33d0', '6572db2c9f9d4ad3b9de33d0']\n)\nThe start and end of the export can be defined as a datetime or string type.\nList prediction data exports\uf0c1\nTo list prediction data exports, use PredictionDataExport.list, as in the following example:\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_exports = PredictionDataExport.list(deployment_id='5c939e08962d741e34f609f0', limit=0)\nprediction_data_exports\n>>> [PredictionDataExport('65fbe59aaa3f847bd5acc75b'),\nPredictionDataExport('65fbe59aaa3f847bd5acc75c'),\nPredictionDataExport('65fbe59aaa3f847bd5acc75a')]\nTo list all prediction data exports, set the limit to 0.\nAdjust additional parameters to filter the data as needed:\nfrom datarobot.enums import ExportStatus\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_exports = PredictionDataExport.list(deployment_id='5c939e08962d741e34f609f0', limit=100, offset=100)\n# use additional filters\nprediction_data_exports = PredictionDataExport.list(\ndeployment_id='5c939e08962d741e34f609f0',\nmodel_id=\"6444482e5583f6ee2e572265\",\nbatch=False,\nstatus=ExportStatus.FAILED\n)\nRetrieve a prediction data export\uf0c1\nTo get a prediction data export by identifier, use PredictionDataExport.get, as in the following example:\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_export = PredictionDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n)\nprediction_data_exports\n>>> PredictionDataExport('65fbe59aaa3f847bd5acc75b')\nFetch prediction export datasets\uf0c1\nTo return data from a prediction export as dr.Dataset, use fetch_data method, as in the following example:\nfrom datarobot.models.deployment import PredictionDataExport\nprediction_data_export = PredictionDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n)\nprediction_datasets = prediction_data_export.fetch_data()\nprediction_datasets\n>>> [Dataset(name='Deployment prediction data', id='65f240b0e37a9f1a104bf450')]\nprediction_dataset = prediction_datasets[0]\ndf = prediction_dataset.get_as_dataframe()\ndf.head(2)\n>>>    DR_RESERVED_PREDICTION_TIMESTAMP  ...    upstream_x_datarobot_version\n0  2024-03-13 23:00:38.998000+00:00  ...               predictionapi/X/X\n1  2024-03-13 23:00:38.998000+00:00  ...               predictionapi/X/X\nThis method can return a list of datasets; however, usually it returns one dataset . There are cases, like time series,\nwhen more than one element is returned. The obtained dataset (or datasets) can be transformed into, for example, a pandas DataFrame.\nActuals data export\uf0c1\nUse the following commands to manage actuals data exports:\nCreate actuals data export\uf0c1\nTo create actuals data export, use ActualsDataExport.create, defining the time window to include in the export\nusing the start and end parameters, as shown in the following example:\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now\n)\nSpecify the model ID for export, otherwise the champion model ID is used by default:\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0',\nmodel_id=\"6444482e5583f6ee2e572265\",\nstart=now - timedelta(days=7),\nend=now,\n)\nTo export only actuals that are matched to predictions, set only_matched_predictions to True;\nby default all available actuals are exported.\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0',\nonly_matched_predictions=True,\nstart=now - timedelta(days=7),\nend=now,\n)\nThe start and end of the export can be defined as a datetime or string type.\nList actuals data exports\uf0c1\nTo list actuals data exports, use ActualsDataExport.list, as in the following example:\nfrom datarobot.models.deployment import ActualsDataExport\nactuals_data_exports = ActualsDataExport.list(deployment_id='5c939e08962d741e34f609f0', limit=0)\nactuals_data_exports\n>>> [ActualsDataExport('660456a332d0081029ee5031'),\nActualsDataExport('660456a332d0081029ee5032'),\nActualsDataExport('660456a332d0081029ee5033')]\nTo list all actuals data exports, set the limit to 0.\nAdjust additional parameters to filter the data as needed:\nfrom datarobot.enums import ExportStatus\nfrom datarobot.models.deployment import ActualsDataExport\n# use additional filters\nactuals_data_exports = ActualsDataExport.list(\ndeployment_id='5c939e08962d741e34f609f0',\noffset=500,\nlimit=50,\nstatus=ExportStatus.SUCCEEDED\n)\nRetrieve actuals data export\uf0c1\nTo get actuals data export by identifier, use ActualsDataExport.get, as in the following example:\nfrom datarobot.models.deployment import ActualsDataExport\nactuals_data_export = ActualsDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='660456a332d0081029ee4031'\n)\nactuals_data_export\n>>> ActualsDataExport('660456a332d0081029ee4031')\nFetch actuals export datasets\uf0c1\nTo return data from actuals export as dr.Dataset, use fetch_data method, as in the following example:\nfrom datarobot.models.deployment import ActualsDataExport\nactuals_data_export = ActualsDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='660456a332d0081029ee4031'\n)\nactuals_datasets = actuals_data_export.fetch_data()\nactuals_datasets\n>>> [Dataset(name='Deployment prediction data', id='65f240b0e37a9f1a104bf450')]\nactuals_dataset = actuals_datasets[0]\ndf = actuals_dataset.get_as_dataframe()\ndf.head(2)\n>>>    association_id                  timestamp  actuals  predictions\n0               1  2024-03-20 15:00:00+00:00     21.0    18.125388\n1              10  2024-03-20 15:00:00+00:00     12.0    22.805252\nThis method may return a list of datasets; however, it usually returns one dataset.\nThe obtained dataset (or datasets) can be transformed into, for example, a pandas DataFrame.\nTraining data export\uf0c1\nUse the following commands to manage training data exports:\nCreate training data export\uf0c1\nTo create training data export, use TrainingDataExport.create and define the deployment ID, as shown in the following example:\nfrom datarobot.models.deployment import TrainingDataExport\ndataset_id = TrainingDataExport.create(deployment_id='5c939e08962d741e34f609f0')\nSpecify the model ID for export, otherwise the champion model ID is used by default:\nfrom datarobot.models.deployment import TrainingDataExport\ndataset_id = TrainingDataExport.create(\ndeployment_id='5c939e08962d741e34f609f0', model_id='6444482e5583f6ee2e572265')\ndataset_id\n>>> 65fb0c25019ca3333bbb4c10\nThis method returns the ID of the dataset that contains the training data. This dataset is saved in the AI Catalog.\nList training data exports\uf0c1\nTo list training data exports, use TrainingDataExport.list, as in the following example:\nfrom datarobot.models.deployment import TrainingDataExport\ntraining_data_exports = TrainingDataExport.list(deployment_id='5c939e08962d741e34f609f0')\ntraining_data_exports\n>>> [TrainingDataExport('6565fbf2356124f1daa3acc522')]\nRetrieve training data export\uf0c1\nTo get training data export by identifier, use TrainingDataExport.get, as in the following example:\nfrom datarobot.models.deployment import ActualsDataExport\ntraining_data_export = TrainingDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='65fbf2356124f1daa3acc522'\n)\ntraining_data_export\n>>> TrainingDataExport('6565fbf2356124f1daa3acc522')\nFetch training export dataset\uf0c1\nTo return data from the training export as dr.Dataset, use fetch_data, as in the following example:\nfrom datarobot.models.deployment import TrainingDataExport\ntraining_data_export = TrainingDataExport.get(\ndeployment_id='5c939e08962d741e34f609f0', export_id='660456a332d0081029ee4031'\n)\ntraining_dataset = training_data_export.fetch_data()\ntraining_dataset\n>>> [Dataset(name='training-data-10k_diabetes.csv', id='65fb0c25019ca3333bbb4c10')]\ndf = training_dataset.get_as_dataframe()\ndf.head(2)\n>>> acetohexamide  time_in_hospital  ... number_outpatient payer_code\n0            No                 1  ...                 0         YY\n1            No                 2  ...                 0         XX\nThis method returns a single training dataset. The obtained dataset can be transformed into, for example, a pandas DataFrame.\nData quality export\uf0c1\nThe data-quality exports provide feedback on LLM deployments. It is intended to be used in conjunction with custom-metrics for prompt monitoring.\nUse the following commands to manage data-quality exports:\nData quality export list\uf0c1\nTo list data quality exports, use DataQualityExport.list, as in the following example:\nfrom datetime import datetime, timedelta\nfrom datarobot.models.deployment import DataQualityExport\nnow=datetime.now()\ndata_quality_exports = DataQualityExport.list(\ndeployment_id='66903c40f18e6ec90fd7c8c7',\nstart=now - timedelta(days=1),\nend=now,\n)\ndata_quality_exports\n>>> [DataQualityExport(6447ca39c6a04df6b5b0ed19c6101e3c),\n...\nDataQualityExport(0ff46fd3636545a9ac3e15ee1dbd8638)]\ndata_quality_deports[0].metrics\n>>> [{'id': '669688f90a23524131e2d301', 'name': 'metric 3', 'value': None},\n{'id': '669688e633ae1ffce40eb2f8', 'name': 'metric 2', 'value': 45.0},\n{'id': '669688d282c9384ab8068a6c', 'name': 'metric 1', 'value': 178.0}]\nThe start and end of the export can be defined as a datetime or string type. And, there are many options for filtering and ordering the data.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\n\nnow=datetime.now()\n\nprediction_data_export = PredictionDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now)",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\n\nnow=datetime.now()\n\nprediction_data_export = PredictionDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0',\n    model_id='6444482e5583f6ee2e572265',\n    start=now - timedelta(days=7),\n    end=now\n)",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import PredictionDataExport\n\nnow=datetime.now()\n\nprediction_data_export = PredictionDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0',\n    model_id='6444482e5583f6ee2e572265',\n    start=now - timedelta(days=7),\n    end=now,\n    batch_ids=['6572db2c9f9d4ad3b9de33d0', '6572db2c9f9d4ad3b9de33d0']\n)",
        "from datarobot.models.deployment import PredictionDataExport\n\nprediction_data_exports = PredictionDataExport.list(deployment_id='5c939e08962d741e34f609f0', limit=0)\n\nprediction_data_exports\n>>> [PredictionDataExport('65fbe59aaa3f847bd5acc75b'),\n     PredictionDataExport('65fbe59aaa3f847bd5acc75c'),\n     PredictionDataExport('65fbe59aaa3f847bd5acc75a')]",
        "from datarobot.enums import ExportStatus\nfrom datarobot.models.deployment import PredictionDataExport\n\nprediction_data_exports = PredictionDataExport.list(deployment_id='5c939e08962d741e34f609f0', limit=100, offset=100)\n\n# use additional filters\nprediction_data_exports = PredictionDataExport.list(\n    deployment_id='5c939e08962d741e34f609f0',\n    model_id=\"6444482e5583f6ee2e572265\",\n    batch=False,\n    status=ExportStatus.FAILED\n)",
        "from datarobot.models.deployment import PredictionDataExport\n\nprediction_data_export = PredictionDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n    )\n\nprediction_data_exports\n>>> PredictionDataExport('65fbe59aaa3f847bd5acc75b')",
        "from datarobot.models.deployment import PredictionDataExport\n\nprediction_data_export = PredictionDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbe59aaa3f847bd5acc75b'\n    )\nprediction_datasets = prediction_data_export.fetch_data()\n\nprediction_datasets\n>>> [Dataset(name='Deployment prediction data', id='65f240b0e37a9f1a104bf450')]\n\nprediction_dataset = prediction_datasets[0]\n\ndf = prediction_dataset.get_as_dataframe()\ndf.head(2)\n>>>    DR_RESERVED_PREDICTION_TIMESTAMP  ...    upstream_x_datarobot_version\n    0  2024-03-13 23:00:38.998000+00:00  ...               predictionapi/X/X\n    1  2024-03-13 23:00:38.998000+00:00  ...               predictionapi/X/X",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\n\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0', start=now - timedelta(days=7), end=now\n    )",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\n\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0',\n    model_id=\"6444482e5583f6ee2e572265\",\n    start=now - timedelta(days=7),\n    end=now,\n    )",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import ActualsDataExport\n\nnow=datetime.now()\nactuals_data_export = ActualsDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0',\n    only_matched_predictions=True,\n    start=now - timedelta(days=7),\n    end=now,\n    )",
        "from datarobot.models.deployment import ActualsDataExport\n\nactuals_data_exports = ActualsDataExport.list(deployment_id='5c939e08962d741e34f609f0', limit=0)\n\nactuals_data_exports\n>>> [ActualsDataExport('660456a332d0081029ee5031'),\n     ActualsDataExport('660456a332d0081029ee5032'),\n     ActualsDataExport('660456a332d0081029ee5033')]",
        "from datarobot.enums import ExportStatus\nfrom datarobot.models.deployment import ActualsDataExport\n\n# use additional filters\nactuals_data_exports = ActualsDataExport.list(\n    deployment_id='5c939e08962d741e34f609f0',\n    offset=500,\n    limit=50,\n    status=ExportStatus.SUCCEEDED\n)",
        "from datarobot.models.deployment import ActualsDataExport\n\nactuals_data_export = ActualsDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='660456a332d0081029ee4031'\n    )\n\nactuals_data_export\n>>> ActualsDataExport('660456a332d0081029ee4031')",
        "from datarobot.models.deployment import ActualsDataExport\n\nactuals_data_export = ActualsDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='660456a332d0081029ee4031'\n    )\nactuals_datasets = actuals_data_export.fetch_data()\n\nactuals_datasets\n>>> [Dataset(name='Deployment prediction data', id='65f240b0e37a9f1a104bf450')]\n\nactuals_dataset = actuals_datasets[0]\n\ndf = actuals_dataset.get_as_dataframe()\ndf.head(2)\n>>>    association_id                  timestamp  actuals  predictions\n    0               1  2024-03-20 15:00:00+00:00     21.0    18.125388\n    1              10  2024-03-20 15:00:00+00:00     12.0    22.805252",
        "from datarobot.models.deployment import TrainingDataExport\n\ndataset_id = TrainingDataExport.create(deployment_id='5c939e08962d741e34f609f0')",
        "from datarobot.models.deployment import TrainingDataExport\n\ndataset_id = TrainingDataExport.create(\n    deployment_id='5c939e08962d741e34f609f0', model_id='6444482e5583f6ee2e572265')\n\ndataset_id\n>>> 65fb0c25019ca3333bbb4c10",
        "from datarobot.models.deployment import TrainingDataExport\n\ntraining_data_exports = TrainingDataExport.list(deployment_id='5c939e08962d741e34f609f0')\n\ntraining_data_exports\n>>> [TrainingDataExport('6565fbf2356124f1daa3acc522')]",
        "from datarobot.models.deployment import ActualsDataExport\n\ntraining_data_export = TrainingDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='65fbf2356124f1daa3acc522'\n    )\n\ntraining_data_export\n>>> TrainingDataExport('6565fbf2356124f1daa3acc522')",
        "from datarobot.models.deployment import TrainingDataExport\n\ntraining_data_export = TrainingDataExport.get(\n    deployment_id='5c939e08962d741e34f609f0', export_id='660456a332d0081029ee4031'\n    )\ntraining_dataset = training_data_export.fetch_data()\n\ntraining_dataset\n>>> [Dataset(name='training-data-10k_diabetes.csv', id='65fb0c25019ca3333bbb4c10')]\n\ndf = training_dataset.get_as_dataframe()\ndf.head(2)\n>>> acetohexamide  time_in_hospital  ... number_outpatient payer_code\n  0            No                 1  ...                 0         YY\n  1            No                 2  ...                 0         XX",
        "from datetime import datetime, timedelta\nfrom datarobot.models.deployment import DataQualityExport\n\nnow=datetime.now()\n\ndata_quality_exports = DataQualityExport.list(\n    deployment_id='66903c40f18e6ec90fd7c8c7',\n    start=now - timedelta(days=1),\n    end=now,\n)\n\ndata_quality_exports\n>>> [DataQualityExport(6447ca39c6a04df6b5b0ed19c6101e3c),\n ...\n DataQualityExport(0ff46fd3636545a9ac3e15ee1dbd8638)]\n\ndata_quality_deports[0].metrics\n>>> [{'id': '669688f90a23524131e2d301', 'name': 'metric 3', 'value': None},\n {'id': '669688e633ae1ffce40eb2f8', 'name': 'metric 2', 'value': 45.0},\n {'id': '669688d282c9384ab8068a6c', 'name': 'metric 1', 'value': 178.0}]"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/custom_metrics.html",
      "title": "Custom Metrics\uf0c1",
      "description": "Custom metrics are used to compute and monitor user-defined metrics.",
      "content": "Custom Metrics\uf0c1\nCustom metrics are used to compute and monitor user-defined metrics.\nManage custom metrics\uf0c1\nUse the following commands to manage custom metrics:\nCreate custom metric\uf0c1\nTo create a custom metric, use CustomMetric.create, as shown in the following example:\nFill in all metric required custom metric fields:\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.create(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"My custom metric\",\nunits=\"x\",\nis_model_specific=True,\naggregation_type=CustomMetricAggregationType.AVERAGE,\ndirectionality=CustomMetricDirectionality.HIGHER_IS_BETTER,\n)\nSet the baseline value during metric creation:\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import (\nCustomMetricAggregationType,\nCustomMetricDirectionality,\nCustomMetricBucketTimeStep,\n)\ncustom_metric = CustomMetric.create(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"My custom metric 2\",\nunits=\"y\",\nbaseline_value=12,\nis_model_specific=True,\naggregation_type=CustomMetricAggregationType.AVERAGE,\ndirectionality=CustomMetricDirectionality.HIGHER_IS_BETTER,\ntime_step=CustomMetricBucketTimeStep.HOUR,\n)\nDefine the names of the columns that will be used when submitting values from a dataset:\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.create(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"My custom metric 3\",\nunits=\"z\",\nbaseline_value=1000,\nis_model_specific=False,\naggregation_type=CustomMetricAggregationType.SUM,\ndirectionality=CustomMetricDirectionality.LOWER_IS_BETTER,\ntimestamp_column_name=\"My Timestamp column\",\ntimestamp_format=\"%d/%m/%y\",\nvalue_column_name=\"My Value column\",\nsample_count_column_name=\"My Sample Count column\",\n)\nFor batches:\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.create(\ndeployment_id=\"5c939e08962d741e34f609f0\",\nname=\"My custom metric 4\",\nunits=\"z\",\nbaseline_value=1000,\nis_model_specific=False,\naggregation_type=CustomMetricAggregationType.SUM,\ndirectionality=CustomMetricDirectionality.LOWER_IS_BETTER,\nbatch_column_name=\"My Batch column\",\n)\nList custom metrics\uf0c1\nTo list all custom metrics available for a given deployment, use CustomMetric.list, as in the following example:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metrics = CustomMetric.list(deployment_id=\"5c939e08962d741e34f609f0\")\ncustom_metrics\n>>> [CustomMetric('66015bdda7ba87e66baa09ee' | 'My custom metric 2'),\nCustomMetric('66015bdc5f850c5df3aa09f0' | 'My custom metric')]\nRetrieve custom metrics\uf0c1\nTo get a custom metric by unique identifier, use CustomMetric.get, as in the following example:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\ncustom_metric\n>>> CustomMetric('66015bdc5f850c5df3aa09f0' | 'My custom metric')\nUpdate custom metrics\uf0c1\nTo get a custom metric by unique identifier and update it, use CustomMetric.get() and then update(), as in the following example:\nfrom datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\ncustom_metric.update(\nname=\"Updated custom metric\",\nunits=\"foo\",\nbaseline_value=-12,\naggregation_type=CustomMetricAggregationType.SUM,\ndirectionality=CustomMetricDirectionality.LOWER_IS_BETTER,\n)\nUnset custom metric baseline\uf0c1\nTo reset the current metric baseline, use a separate method unset_baseline(), as in the following example:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\ncustom_metric.baseline_values\n>>> [{'value': -12.0}]\ncustom_metric.unset_baseline()\ncustom_metric.baseline_values\n>>> []\nDelete custom metrics\uf0c1\nTo delete a custom metric by unique identifier, use CustomMetric.delete, as in the following example:\nfrom datarobot.models.deployment import CustomMetric\nCustomMetric.delete(deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\nSubmit custom metric values\uf0c1\nUse the following commands to submit custom metric values:\nSubmit values from JSON\uf0c1\nTo submit aggregated custom metric values from JSON, use submit_values method, as shown in the following example:\nSubmit data in the form of a list of dictionaries:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\ndata = [{'value': 12, 'sample_size': 3, 'timestamp': '2024-03-15T18:00:00'},\n{'value': 11, 'sample_size': 5, 'timestamp': '2024-03-15T17:00:00'},\n{'value': 14, 'sample_size': 3, 'timestamp': '2024-03-15T16:00:00'}]\ncustom_metric.submit_values(data=data)\n# data witch association IDs\ndata = [{'value': 15, 'sample_size': 2, 'timestamp': '2024-03-15T21:00:00', 'association_id': '65f44d04dbe192b552e752aa'},\n{'value': 13, 'sample_size': 6, 'timestamp': '2024-03-15T20:00:00', 'association_id': '65f44d04dbe192b552e753bb'},\n{'value': 17, 'sample_size': 2, 'timestamp': '2024-03-15T19:00:00', 'association_id': '65f44d04dbe192b552e754cc'}]\ncustom_metric.submit_values(data=data)\nSubmit data in the form of pandas DataFrame:\nfrom datetime import datetime\nimport pandas as pd\nfrom datarobot.models.deployment import CustomMetric\ndf = pd.DataFrame(\ndata={\n\"timestamp\": [\ndatetime(year=2024, month=3, day=10),\ndatetime(year=2024, month=3, day=11),\ndatetime(year=2024, month=3, day=12),\ndatetime(year=2024, month=3, day=13),\ndatetime(year=2024, month=3, day=14),\ndatetime(year=2024, month=3, day=15),\n],\n\"value\": [28, 34, 29, 1, 2, 13],\n\"sample_size\": [1, 2, 3, 4, 1, 2],\n}\n)\ncustom_metric.submit_values(data=df)\nFor deployment-specific metrics, do not provide model information.\nFor model specific metrics set model_package_id or model_id:\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\")\ncustom_metric.submit_values(data=data, model_id=\"6444482e5583f6ee2e572265\")\nUse a dry run for test uploads (without saving metric data on the DR side), this option is disabled by default:\ncustom_metric.submit_values(data=data, dry_run=True)\nTo send data for a given segment, it must be specified as follow, more than one segment can be specified:\nsegments = [{\"name\": \"custom_seg\", \"value\": \"baz\"}]\ncustom_metric.submit_values(data=data, segments=segments)\nBatch mode  requires specifying batch IDs, for batches always specify a model by model_package_id or model_id:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f600e1\", custom_metric_id=\"65f17bdcd2d66683cdfc2224\")\ndata = [{'value': 12, 'sample_size': 3, 'batch': '65f44c93fedc5de16b673aaa'},\n{'value': 11, 'sample_size': 5, 'batch': '65f44c93fedc5de16b673bbb'},\n{'value': 14, 'sample_size': 3, 'batch': '65f44c93fedc5de16b673ccc'}]\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\")\nSubmit a single value\uf0c1\nTo report a single metric value at the current moment, use submit_single_value method, as in the following example:\nFor deployment-specific metrics:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\ncustom_metric.submit_single_value(value=16)\nFor model specific metrics set model_package_id or model_id:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\ncustom_metric.submit_single_value(value=16, model_package_id=\"6421df32525c58cc6f991f25\")\ncustom_metric.submit_single_value(value=16, model_id=\"6444482e5583f6ee2e572265\")\nDry run and segments work analogously to reporting aggregated metric values:\ncustom_metric.submit_single_value(value=16, dry_run=True)\nsegments = [{\"name\": \"custom_seg\", \"value\": \"boo\"}]\ncustom_metric.submit_single_value(value=16, segments=segments)\nThe sent value timestamp indicates the time the request was sent, the number of samples values is always 1.\nThis method does not support batch submissions.\nSubmit values from a dataset\uf0c1\nTo report aggregated custom metrics values from dataset (AI catalog), use submit_values_from_catalog method, as in the following example:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n# for deployment specific metrics\ncustom_metric.submit_values_from_catalog(dataset_id=\"61093144cabd630828bca321\")\n# for model specific metrics set model_package_id or model_id\ncustom_metric.submit_values_from_catalog(\ndataset_id=\"61093144cabd630828bca321\",\nmodel_package_id=\"6421df32525c58cc6f991f25\"\n)\nFor segmented analysis define the name of the column in the dataset and the segment it corresponds to:\nsegments = [{\"name\": \"custom_seg\", \"column\": \"column_with_segment_values\"}]\ncustom_metric.submit_values_from_catalog(\ndataset_id=\"61093144cabd630828bca321\",\nmodel_package_id=\"6421df32525c58cc6f991f25\",\nsegments=segments\n)\nFor batches, specify batch IDs in the dataset or send the entire dataset for a single batch ID:\ncustom_metric.submit_values_from_catalog(\ndataset_id=\"61093144cabd630828bca432\",\nmodel_package_id=\"6421df32525c58cc6f991f25\",\nbatch_id=\"65f7f71198c2f234b4cb2f7d\"\n)\nThe names of the columns in the dataset should correspond to the names of the columns that were defined in\nthe custom metric. In addition, the format of the timestamps should also be the same as defined in the metric.\nIf the sample size is not specified, it is treated as a 1 sample by default.\nThe following is an example of the shape of a dataset saved in the AI catalog:\ntimestamp\nsample_size\nvalue\n12/12/22\n1\n22\n13/12/22\n2\n23\n14/12/22\n3\n24\n15/12/22\n4\n25\nSample dataset for batches:\nbatch\nsample_size\nvalue\n6572db2c9f9d4ad3b9de33d0\n1\n22\n6572db2c9f9d4ad3b9de33d0\n2\n23\n6572db319f9d4ad3b9de33d9\n3\n24\n6572db319f9d4ad3b9de33d9\n4\n25\nRetrieve custom metric values over time\uf0c1\nUse the following commands to retrieve custom metric values:\nRetrieve values over a time period\uf0c1\nTo retrieve values of a custom metric over a time period, use get_values_over_time, as in the following example:\nfrom datetime import datetime, timedelta\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\nnow = datetime.now()\n# specify the time window and bucket size by which results are grouped, the default bucket is 7 days\nvalues_over_time = custom_metric.get_values_over_time(\nstart=now - timedelta(days=2), end=now, bucket_size=BUCKET_SIZE.P1D)\nvalues_over_time\n>>> CustomMetricValuesOverTime('2024-03-21 20:15:00+00:00'- '2024-03-23 20:15:00+00:00')\"\nvalues_over_time.bucket_values\n>>>{datetime.datetime(2024, 3, 22, 10, 0, tzinfo=tzutc()): 1.0,\n>>> datetime.datetime(2024, 3, 22, 11, 0, tzinfo=tzutc()): 123.0}}\nvalues_over_time.bucket_sample_sizes\n>>>{datetime.datetime(2024, 3, 22, 10, 0, tzinfo=tzutc()): 1,\n>>> datetime.datetime(2024, 3, 22, 11, 0, tzinfo=tzutc()): 1}}\nvalues_over_time.get_buckets_as_dataframe()\n>>>                        start                       end  value  sample_size\n>>> 0  2024-03-21 00:00:00+00:00 2024-03-22 00:00:00+00:00    1.0            1\n>>> 1  2024-03-22 00:00:00+00:00 2024-03-23 00:00:00+00:00  123.0            1\nFor model specific metrics set model_package_id or model_id:\nvalues_over_time = custom_metric.get_values_over_time(\nstart=now - timedelta(days=1), end=now, model_package_id=\"6421df32525c58cc6f991f25\")\nvalues_over_time = custom_metric.get_values_over_time(\nstart=now - timedelta(days=1), end=now, model_id=\"6444482e5583f6ee2e572265\")\nTo retrieve values for a specific segment, specify the segment name and its value:\nvalues_over_time = custom_metric.get_values_over_time(\nstart=now - timedelta(days=1), end=now, segment_attribute=\"custom_seg\", segment_value=\"val_1\")\nRetrieve a summary over a time period\uf0c1\nTo retrieve summary of a custom metric over a time period, use get_summary method, as in the following example:\nfrom datetime import datetime, timedelta\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\nnow = datetime.now()\n# specify the time window\nsummary = custom_metric.get_summary(start=now - timedelta(days=7), end=now)\nprint(summary)\n>> \"CustomMetricSummary(2024-03-15 15:52:13.392178+00:00 - 2024-03-22 15:52:13.392168+00:00:\n{'id': '65fd9b1c0c1a840bc6751ce0', 'name': 'My custom metric', 'value': 215.0, 'sample_count': 13,\n'baseline_value': 12.0, 'percent_change': 24.02})\"\nFor model specific metrics set model_package_id or model_id:\nsummary = custom_metric.get_summary(\nstart=now - timedelta(days=7), end=now, model_package_id=\"6421df32525c58cc6f991f25\")\nsummary = custom_metric.get_summary(\nstart=now - timedelta(days=7), end=now, model_id=\"6444482e5583f6ee2e572265\")\nTo retrieve summary for a specific segment, specify the segment name and its value:\nsummary = custom_metric.get_summary(\nstart=now - timedelta(days=7), end=now, segment_attribute=\"custom_seg\", segment_value=\"val_1\")\nRetrieve values over batch\uf0c1\nTo retrieve values of a custom metric over batch, use get_values_over_batch, as in the following example:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nvalues_over_batch = custom_metric.get_values_over_batch(model_package_id='6421df32525c58cc6f991f25')\nvalues_over_batch.bucket_values\n>>> {'6572db2c9f9d4ad3b9de33d0': 35.0, '6572db2c9f9d4ad3b9de44e1': 105.0}\nvalues_over_batch.bucket_sample_sizes\n>>> {'6572db2c9f9d4ad3b9de33d0': 6, '6572db2c9f9d4ad3b9de44e1': 8}\nvalues_over_batch.get_buckets_as_dataframe()\n>>>                    batch_id                     batch_name  value  sample_size\n>>> 0  6572db2c9f9d4ad3b9de33d0  Batch 1 - 03/26/2024 13:04:46   35.0            6\n>>> 1  6572db2c9f9d4ad3b9de44e1  Batch 2 - 03/26/2024 13:06:04  105.0            8\nFor specific batches, set batch_ids:\nvalues_over_batch = custom_metric.get_values_over_batch(\nmodel_package_id='6421df32525c58cc6f991f25', batch_ids=[\"65f44c93fedc5de16b673aaa\", \"65f44c93fedc5de16b673bbb\"])\nTo retrieve values for a specific segment, specify the segment name and its value:\nvalues_over_batch = custom_metric.get_values_over_batch(\nmodel_package_id='6421df32525c58cc6f991f25', segment_attribute=\"custom_seg\", segment_value=\"val_1\")\nRetrieve a summary over batch\uf0c1\nTo retrieve summary of a custom metric over batch, use get_summary, as in the following example:\nfrom datarobot.models.deployment import CustomMetric\ncustom_metric = CustomMetric.get(\ndeployment_id=\"5c939e08962d741e34f609f0\",\ncustom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nbatch_summary = custom_metric.get_batch_summary(model_package_id='6421df32525c58cc6f991f25')\nprint(batch_summary)\n>> CustomMetricBatchSummary({'id': '6605396413434b3a7b74342c', 'name': 'batch metric', 'value': 41.25,\n'sample_count': 28, 'baseline_value': 123.0, 'percent_change': -66.46})\nFor specific batches, set batch_ids:\nbatch_summary = custom_metric.get_batch_summary(\nmodel_package_id='6421df32525c58cc6f991f25', batch_ids=[\"65f44c93fedc5de16b673aaa\", \"65f44c93fedc5de16b673bbb\"])\nTo retrieve values for a specific segment, specify the segment name and its value:\nbatch_summary = custom_metric.get_batch_summary(\nmodel_package_id='6421df32525c58cc6f991f25', segment_attribute=\"custom_seg\", segment_value=\"val_1\")",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.create(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"My custom metric\",\n    units=\"x\",\n    is_model_specific=True,\n    aggregation_type=CustomMetricAggregationType.AVERAGE,\n    directionality=CustomMetricDirectionality.HIGHER_IS_BETTER,\n)",
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import (\n    CustomMetricAggregationType,\n    CustomMetricDirectionality,\n    CustomMetricBucketTimeStep,\n)\n\ncustom_metric = CustomMetric.create(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"My custom metric 2\",\n    units=\"y\",\n    baseline_value=12,\n    is_model_specific=True,\n    aggregation_type=CustomMetricAggregationType.AVERAGE,\n    directionality=CustomMetricDirectionality.HIGHER_IS_BETTER,\n    time_step=CustomMetricBucketTimeStep.HOUR,\n)",
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.create(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"My custom metric 3\",\n    units=\"z\",\n    baseline_value=1000,\n    is_model_specific=False,\n    aggregation_type=CustomMetricAggregationType.SUM,\n    directionality=CustomMetricDirectionality.LOWER_IS_BETTER,\n    timestamp_column_name=\"My Timestamp column\",\n    timestamp_format=\"%d/%m/%y\",\n    value_column_name=\"My Value column\",\n    sample_count_column_name=\"My Sample Count column\",\n)",
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.create(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    name=\"My custom metric 4\",\n    units=\"z\",\n    baseline_value=1000,\n    is_model_specific=False,\n    aggregation_type=CustomMetricAggregationType.SUM,\n    directionality=CustomMetricDirectionality.LOWER_IS_BETTER,\n    batch_column_name=\"My Batch column\",\n)",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metrics = CustomMetric.list(deployment_id=\"5c939e08962d741e34f609f0\")\n\ncustom_metrics\n>>> [CustomMetric('66015bdda7ba87e66baa09ee' | 'My custom metric 2'),\n     CustomMetric('66015bdc5f850c5df3aa09f0' | 'My custom metric')]",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\ncustom_metric\n>>> CustomMetric('66015bdc5f850c5df3aa09f0' | 'My custom metric')",
        "from datarobot.models.deployment import CustomMetric\nfrom datarobot.enums import CustomMetricAggregationType, CustomMetricDirectionality\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\ncustom_metric.update(\n    name=\"Updated custom metric\",\n    units=\"foo\",\n    baseline_value=-12,\n    aggregation_type=CustomMetricAggregationType.SUM,\n    directionality=CustomMetricDirectionality.LOWER_IS_BETTER,\n)",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\ncustom_metric.baseline_values\n>>> [{'value': -12.0}]\n\ncustom_metric.unset_baseline()\ncustom_metric.baseline_values\n>>> []",
        "from datarobot.models.deployment import CustomMetric\n\nCustomMetric.delete(deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\ndata = [{'value': 12, 'sample_size': 3, 'timestamp': '2024-03-15T18:00:00'},\n        {'value': 11, 'sample_size': 5, 'timestamp': '2024-03-15T17:00:00'},\n        {'value': 14, 'sample_size': 3, 'timestamp': '2024-03-15T16:00:00'}]\n\ncustom_metric.submit_values(data=data)\n\n# data witch association IDs\ndata = [{'value': 15, 'sample_size': 2, 'timestamp': '2024-03-15T21:00:00', 'association_id': '65f44d04dbe192b552e752aa'},\n        {'value': 13, 'sample_size': 6, 'timestamp': '2024-03-15T20:00:00', 'association_id': '65f44d04dbe192b552e753bb'},\n        {'value': 17, 'sample_size': 2, 'timestamp': '2024-03-15T19:00:00', 'association_id': '65f44d04dbe192b552e754cc'}]\n\ncustom_metric.submit_values(data=data)",
        "from datetime import datetime\nimport pandas as pd\nfrom datarobot.models.deployment import CustomMetric\n\ndf = pd.DataFrame(\n    data={\n        \"timestamp\": [\n            datetime(year=2024, month=3, day=10),\n            datetime(year=2024, month=3, day=11),\n            datetime(year=2024, month=3, day=12),\n            datetime(year=2024, month=3, day=13),\n            datetime(year=2024, month=3, day=14),\n            datetime(year=2024, month=3, day=15),\n        ],\n        \"value\": [28, 34, 29, 1, 2, 13],\n        \"sample_size\": [1, 2, 3, 4, 1, 2],\n    }\n)\ncustom_metric.submit_values(data=df)",
        "custom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\")\n\ncustom_metric.submit_values(data=data, model_id=\"6444482e5583f6ee2e572265\")",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f600e1\", custom_metric_id=\"65f17bdcd2d66683cdfc2224\")\n\ndata = [{'value': 12, 'sample_size': 3, 'batch': '65f44c93fedc5de16b673aaa'},\n        {'value': 11, 'sample_size': 5, 'batch': '65f44c93fedc5de16b673bbb'},\n        {'value': 14, 'sample_size': 3, 'batch': '65f44c93fedc5de16b673ccc'}]\n\ncustom_metric.submit_values(data=data, model_package_id=\"6421df32525c58cc6f991f25\")",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\ncustom_metric.submit_single_value(value=16)",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\ncustom_metric.submit_single_value(value=16, model_package_id=\"6421df32525c58cc6f991f25\")\n\ncustom_metric.submit_single_value(value=16, model_id=\"6444482e5583f6ee2e572265\")",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\n# for deployment specific metrics\ncustom_metric.submit_values_from_catalog(dataset_id=\"61093144cabd630828bca321\")\n\n# for model specific metrics set model_package_id or model_id\ncustom_metric.submit_values_from_catalog(\n    dataset_id=\"61093144cabd630828bca321\",\n    model_package_id=\"6421df32525c58cc6f991f25\"\n)",
        "segments = [{\"name\": \"custom_seg\", \"column\": \"column_with_segment_values\"}]\ncustom_metric.submit_values_from_catalog(\n    dataset_id=\"61093144cabd630828bca321\",\n    model_package_id=\"6421df32525c58cc6f991f25\",\n    segments=segments\n)",
        "custom_metric.submit_values_from_catalog(\n    dataset_id=\"61093144cabd630828bca432\",\n    model_package_id=\"6421df32525c58cc6f991f25\",\n    batch_id=\"65f7f71198c2f234b4cb2f7d\"\n)",
        "from datetime import datetime, timedelta\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\nnow = datetime.now()\n# specify the time window and bucket size by which results are grouped, the default bucket is 7 days\nvalues_over_time = custom_metric.get_values_over_time(\n    start=now - timedelta(days=2), end=now, bucket_size=BUCKET_SIZE.P1D)\n\nvalues_over_time\n>>> CustomMetricValuesOverTime('2024-03-21 20:15:00+00:00'- '2024-03-23 20:15:00+00:00')\"\n\nvalues_over_time.bucket_values\n>>>{datetime.datetime(2024, 3, 22, 10, 0, tzinfo=tzutc()): 1.0,\n>>> datetime.datetime(2024, 3, 22, 11, 0, tzinfo=tzutc()): 123.0}}\n\nvalues_over_time.bucket_sample_sizes\n>>>{datetime.datetime(2024, 3, 22, 10, 0, tzinfo=tzutc()): 1,\n>>> datetime.datetime(2024, 3, 22, 11, 0, tzinfo=tzutc()): 1}}\n\nvalues_over_time.get_buckets_as_dataframe()\n>>>                        start                       end  value  sample_size\n>>> 0  2024-03-21 00:00:00+00:00 2024-03-22 00:00:00+00:00    1.0            1\n>>> 1  2024-03-22 00:00:00+00:00 2024-03-23 00:00:00+00:00  123.0            1",
        "values_over_time = custom_metric.get_values_over_time(\n    start=now - timedelta(days=1), end=now, model_package_id=\"6421df32525c58cc6f991f25\")\n\nvalues_over_time = custom_metric.get_values_over_time(\n    start=now - timedelta(days=1), end=now, model_id=\"6444482e5583f6ee2e572265\")",
        "from datetime import datetime, timedelta\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\", custom_metric_id=\"65f17bdcd2d66683cdfc1113\")\n\nnow = datetime.now()\n# specify the time window\nsummary = custom_metric.get_summary(start=now - timedelta(days=7), end=now)\n\nprint(summary)\n>> \"CustomMetricSummary(2024-03-15 15:52:13.392178+00:00 - 2024-03-22 15:52:13.392168+00:00:\n{'id': '65fd9b1c0c1a840bc6751ce0', 'name': 'My custom metric', 'value': 215.0, 'sample_count': 13,\n'baseline_value': 12.0, 'percent_change': 24.02})\"",
        "summary = custom_metric.get_summary(\n    start=now - timedelta(days=7), end=now, model_package_id=\"6421df32525c58cc6f991f25\")\n\nsummary = custom_metric.get_summary(\n    start=now - timedelta(days=7), end=now, model_id=\"6444482e5583f6ee2e572265\")",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nvalues_over_batch = custom_metric.get_values_over_batch(model_package_id='6421df32525c58cc6f991f25')\n\nvalues_over_batch.bucket_values\n>>> {'6572db2c9f9d4ad3b9de33d0': 35.0, '6572db2c9f9d4ad3b9de44e1': 105.0}\n\nvalues_over_batch.bucket_sample_sizes\n>>> {'6572db2c9f9d4ad3b9de33d0': 6, '6572db2c9f9d4ad3b9de44e1': 8}\n\nvalues_over_batch.get_buckets_as_dataframe()\n>>>                    batch_id                     batch_name  value  sample_size\n>>> 0  6572db2c9f9d4ad3b9de33d0  Batch 1 - 03/26/2024 13:04:46   35.0            6\n>>> 1  6572db2c9f9d4ad3b9de44e1  Batch 2 - 03/26/2024 13:06:04  105.0            8",
        "values_over_batch = custom_metric.get_values_over_batch(\n    model_package_id='6421df32525c58cc6f991f25', batch_ids=[\"65f44c93fedc5de16b673aaa\", \"65f44c93fedc5de16b673bbb\"])",
        "values_over_batch = custom_metric.get_values_over_batch(\n    model_package_id='6421df32525c58cc6f991f25', segment_attribute=\"custom_seg\", segment_value=\"val_1\")",
        "from datarobot.models.deployment import CustomMetric\n\ncustom_metric = CustomMetric.get(\n    deployment_id=\"5c939e08962d741e34f609f0\",\n    custom_metric_id=\"65f17bdcd2d66683cdfc1113\"\n)\n# all batch metrics all model specific\nbatch_summary = custom_metric.get_batch_summary(model_package_id='6421df32525c58cc6f991f25')\n\nprint(batch_summary)\n>> CustomMetricBatchSummary({'id': '6605396413434b3a7b74342c', 'name': 'batch metric', 'value': 41.25,\n'sample_count': 28, 'baseline_value': 123.0, 'percent_change': -66.46})",
        "batch_summary = custom_metric.get_batch_summary(\n    model_package_id='6421df32525c58cc6f991f25', batch_ids=[\"65f44c93fedc5de16b673aaa\", \"65f44c93fedc5de16b673bbb\"])",
        "batch_summary = custom_metric.get_batch_summary(\n    model_package_id='6421df32525c58cc6f991f25', segment_attribute=\"custom_seg\", segment_value=\"val_1\")"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/custom_model.html",
      "title": "Custom Models\uf0c1",
      "description": "Custom models provide users the ability to run arbitrary modeling code in an environment defined by the user.",
      "content": "Custom Models\uf0c1\nCustom models provide users the ability to run arbitrary modeling code in an environment defined by the user.\nManage Execution Environments\uf0c1\nExecution Environment defines the runtime environment for custom models.\nExecution Environment Version is a revision of Execution Environment with an actual runtime definition.\nPlease refer to DataRobot User Models (https://github.com/datarobot/datarobot-user-models) for sample\nenvironments.\nCreate Execution Environment\uf0c1\nTo create an Execution Environment run:\nimport datarobot as dr\nexecution_environment = dr.ExecutionEnvironment.create(\nname=\"Python3 PyTorch Environment\",\ndescription=\"This environment contains Python3 pytorch library.\",\n)\nexecution_environment.id\n>>> '5b6b2315ca36c0108fc5d41b'\nCreate an execution environment version from Docker Context or Docker URI\uf0c1\nYou can create an Execution Environment Version using either a Docker image URI, a Docker context, or both.\nIf you provide both, the environment version is built from the image URI,\nwhile the context is uploaded for informational purposes and can be later downloaded.\nThe execution environment versions offer two creation modes: synchronous and asynchronous.\nSynchronous way means that program execution will be blocked until an Execution Environment Version\ncreation process is finished with either success or failure:\nimport datarobot as dr\n# use execution_environment created earlier\nenvironment_version = dr.ExecutionEnvironmentVersion.create(\nexecution_environment.id,\ndocker_context_path=\"datarobot-user-models/public_dropin_environments/python3_pytorch\",\nmax_wait=3600,  # 1 hour timeout\n)\nenvironment_version.id\n>>> '5eb538959bc057003b487b2d'\nenvironment_version.build_status\n>>> 'success'\nAsynchronous way means that program execution will be not blocked, but an Execution Environment Version\ncreated will not be ready to be used for some time, until its creation process is finished.\nIn such case, it will be required to manually call refresh()\nfor the Execution Environment Version and check if its build_status is \u201csuccess\u201d.\nTo create an Execution Environment Version without blocking a program, set max_wait to None:\nimport datarobot as dr\n# use execution_environment created earlier\n# create environment version from docker context\nenvironment_version = dr.ExecutionEnvironmentVersion.create(\nexecution_environment.id,\ndocker_context_path=\"datarobot-user-models/public_dropin_environments/python3_pytorch\",\nmax_wait=None,  # set None to not block execution on this method\n)\nenvironment_version.id\n>>> '5eb538959bc057003b487b2d'\nenvironment_version.build_status\n>>> 'processing'\n# after some time\nenvironment_version.refresh()\nenvironment_version.build_status\n>>> 'success'\n# now create anoter environment version from docker image URI\nenvironment_version = dr.ExecutionEnvironmentVersion.create(\nexecution_environment.id,\ndocker_image_uri=\"test_org/test_repo:test_tag\",\nmax_wait=None,  # set None to not block execution on this method\n)\nenvironment_version.id\n>>> '5eb538959bc057003b4943d2'\nenvironment_version.build_status\n>>> 'success'\nenvironment_version.docker_image_uri\n'test_org/test_repo:test_tag'\nIf your environment requires additional metadata to be supplied for models using it, you can create an\nenvironment with additional metadata keys. Custom model versions that use this environment must specify\nvalues for these keys before they can be used to run tests or make deployments.  The values will be baked in\nas environment variables with field_name as the environment variable name.\nimport datarobot as dr\nfrom datarobot.models.execution_environment import RequiredMetadataKey\nexecution_environment = dr.ExecutionEnvironment.create(\nname=\"Python3 PyTorch Environment\",\ndescription=\"This environment contains Python3 pytorch library.\",\nrequired_metadata_keys=[\nRequiredMetadataKey(field_name=\"MY_VAR\", display_name=\"A value needed by hte environment\")\n],\n)\nmodel_version = dr.CustomModelVersion.create_clean(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nfolder_path=custom_model_folder,\nrequired_metadata={\"MY_VAR\": \"a value\"}\n)\nList Execution Environments\uf0c1\nUse the following command to list execution environments available to the user.\nimport datarobot as dr\nexecution_environments = dr.ExecutionEnvironment.list()\nexecution_environments\n>>> [ExecutionEnvironment('[DataRobot] Python 3 PyTorch Drop-In'), ExecutionEnvironment('[DataRobot] Java Drop-In')]\nenvironment_versions = dr.ExecutionEnvironmentVersion.list(execution_environment.id)\nenvironment_versions\n>>> [ExecutionEnvironmentVersion('v1')]\nRefer to ExecutionEnvironment for properties of the execution environment object and\nExecutionEnvironmentVersion for properties of the execution environment object version.\nYou can also filter the execution environments that are returned by passing a string as search_for parameter -\nonly the execution environments that contain the passed string in name or description will be returned.\nimport datarobot as dr\nexecution_environments = dr.ExecutionEnvironment.list(search_for='java')\nexecution_environments\n>>> [ExecutionEnvironment('[DataRobot] Java Drop-In')]\nExecution environment versions can be filtered by build status.\nimport datarobot as dr\nenvironment_versions = dr.ExecutionEnvironmentVersion.list(\nexecution_environment.id, dr.EXECUTION_ENVIRONMENT_VERSION_BUILD_STATUS.PROCESSING\n)\nenvironment_versions\n>>> [ExecutionEnvironmentVersion('v1')]\nRetrieve Execution Environment\uf0c1\nTo retrieve an execution environment and an execution environment version by identifier,\nrather than list all available ones, do the following:\nimport datarobot as dr\nexecution_environment = dr.ExecutionEnvironment.get(execution_environment_id='5506fcd38bd88f5953219da0')\nexecution_environment\n>>> ExecutionEnvironment('[DataRobot] Python 3 PyTorch Drop-In')\nenvironment_version = dr.ExecutionEnvironmentVersion.get(\nexecution_environment_id=execution_environment.id, version_id='5eb538959bc057003b487b2d')\nenvironment_version\n>>> ExecutionEnvironmentVersion('v1')\nUpdate Execution Environment\uf0c1\nTo update name and/or description of the execution environment run:\nimport datarobot as dr\nexecution_environment = dr.ExecutionEnvironment.get(execution_environment_id='5506fcd38bd88f5953219da0')\nexecution_environment.update(name='new name', description='new description')\nDelete Execution Environment\uf0c1\nTo delete the execution environment and execution environment version, use the following commands.\nimport datarobot as dr\nexecution_environment = dr.ExecutionEnvironment.get(execution_environment_id='5506fcd38bd88f5953219da0')\nexecution_environment.delete()\nGet Execution Environment build log\uf0c1\nTo get execution environment version build log run:\nimport datarobot as dr\nenvironment_version = dr.ExecutionEnvironmentVersion.get(\nexecution_environment_id='5506fcd38bd88f5953219da0', version_id='5eb538959bc057003b487b2d')\nlog, error = environment_version.get_build_log()\nManage Custom Models\uf0c1\nCustom Inference Model is user-defined modeling code that supports making predictions against it.\nCustom Inference Model supports regression and binary classification target types.\nTo upload actual modeling code Custom Model Version must be created for a custom model.\nPlease see Custom Model Version documentation.\nCreate Custom Inference Model\uf0c1\nTo create a regression Custom Inference Model run:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 PyTorch Custom Model',\ntarget_type=dr.TARGET_TYPE.REGRESSION,\ntarget_name='MEDV',\ndescription='This is a Python3-based custom model. It has a simple PyTorch model built on boston housing',\nlanguage='python'\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nWhen creating a binary classification Custom Inference Model,\npositive_class_label and negative_class_label must be set:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 PyTorch Custom Model',\ntarget_type=dr.TARGET_TYPE.BINARY,\ntarget_name='readmitted',\npositive_class_label='False',\nnegative_class_label='True',\ndescription='This is a Python3-based custom model. It has a simple PyTorch model built on 10k_diabetes dataset',\nlanguage='Python 3'\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nWhen creating a multiclass classification Custom Inference Model,\nclass_labels must be provided:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 PyTorch Custom Model',\ntarget_type=dr.TARGET_TYPE.MULTICLASS,\ntarget_name='readmitted',\nclass_labels=['hot dog', 'burrito', 'hoagie', 'reuben'],\ndescription='This is a Python3-based custom model. It has a simple PyTorch model built on sandwich dataset',\nlanguage='Python 3'\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nFor convenience when there are many class labels, multiclass labels can also be provided as a file.\nThe file should have all the class labels separated by newline:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 PyTorch Custom Model',\ntarget_type=dr.TARGET_TYPE.MULTICLASS,\ntarget_name='readmitted',\nclass_labels_file='/path/to/classlabels.txt',\ndescription='This is a Python3-based custom model. It has a simple PyTorch model built on sandwich dataset',\nlanguage='Python 3'\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nFor unstructured model target_name parameter is optional and is ignored if provided.\nTo create an unstructured Custom Inference Model run:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 Unstructured Custom Model',\ntarget_type=dr.TARGET_TYPE.UNSTRUCTURED,\ndescription='This is a Python3-based unstructured model',\nlanguage='python'\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nFor anomaly detection models, the target_name parameter is also optional and is ignored if provided.\nTo create an anomaly Custom Inference Model run:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 Unstructured Custom Model',\ntarget_type=dr.TARGET_TYPE.ANOMALY,\ndescription='This is a Python3-based anomaly detection model',\nlanguage='python'\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nTo create a Custom Inference Model with specific k8s resources:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 PyTorch Custom Model',\ntarget_type=dr.TARGET_TYPE.BINARY,\ntarget_name='readmitted',\npositive_class_label='False',\nnegative_class_label='True',\ndescription='This is a Python3-based custom model. It has a simple PyTorch model built on 10k_diabetes dataset',\nlanguage='Python 3',\nmaximum_memory=512*1024*1024,\n)\nCustom Inference Model k8s resources are optional and unless specifically provided, the configured defaults\nwill be used.\nTo create a Custom Inference Model enabling training data assignment on the model version level,\nprovide the is_training_data_for_versions_permanently_enabled=True parameter.\nFor more information, refer to the Custom model version creation with training data documentation.\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.create(\nname='Python 3 PyTorch Custom Model',\ntarget_type=dr.TARGET_TYPE.REGRESSION,\ntarget_name='MEDV',\ndescription='This is a Python3-based custom model. It has a simple PyTorch model built on boston housing',\nlanguage='python',\nis_training_data_for_versions_permanently_enabled=True\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\nList Custom Inference Models\uf0c1\nUse the following command to list Custom Inference Models available to the user:\nimport datarobot as dr\ndr.CustomInferenceModel.list()\n>>> [CustomInferenceModel('my model 2'), CustomInferenceModel('my model 1')]\n# use these parameters to filter results:\ndr.CustomInferenceModel.list(\nis_deployed=True,  # set to return only deployed models\norder_by='-updated',  # set to define order of returned results\nsearch_for='model 1',  # return only models containing 'model 1' in name or description\n)\n>>> CustomInferenceModel('my model 1')\nPlease refer to list() for detailed parameter description.\nRetrieve Custom Inference Model\uf0c1\nTo retrieve a specific Custom Inference Model, run:\nimport datarobot as dr\ndr.CustomInferenceModel.get('5ebe95044024035cc6a65602')\n>>> CustomInferenceModel('my model 1')\nUpdate Custom Model\uf0c1\nTo update Custom Inference Model properties execute the following:\nimport datarobot as dr\ncustom_model = dr.CustomInferenceModel.get('5ebe95044024035cc6a65602')\ncustom_model.update(\nname='new name',\ndescription='new description',\n)\nPlease, refer to update() for the full list of properties that can be updated.\nDownload latest revision of Custom Inference Model\uf0c1\nTo download content of the latest Custom Model Version of CustomInferenceModel as a ZIP archive:\nimport datarobot as dr\npath_to_download = '/home/user/Documents/myModel.zip'\ncustom_model = dr.CustomInferenceModel.get('5ebe96b84024035cc6a6560b')\ncustom_model.download_latest_version(path_to_download)\nAssign training data to a custom inference model\uf0c1\nThis example assigns training data on the model level. To assign training data on the model version level, see the Custom model version creation with training data documentation.\nTo assign training data to custom inference model, run:\nimport datarobot as dr\npath_to_dataset = '/home/user/Documents/trainingDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\ncustom_model = dr.CustomInferenceModel.get('5ebe96b84024035cc6a6560b')\ncustom_model.assign_training_data(dataset.id)\nTo assign training data without blocking a program, set max_wait to None:\nimport datarobot as dr\npath_to_dataset = '/home/user/Documents/trainingDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\ncustom_model = dr.CustomInferenceModel.get('5ebe96b84024035cc6a6560b')\ncustom_model.assign_training_data(\ndataset.id,\nmax_wait=None\n)\ncustom_model.training_data_assignment_in_progress\n>>> True\n# after some time\ncustom_model.refresh()\ncustom_model.training_data_assignment_in_progress\n>>> False\nNote: training data must be assigned to retrieve feature impact from a custom model version.\nSee the Custom Model Version documentation.\nManage Custom Model Versions\uf0c1\nModeling code for Custom Inference Models can be uploaded by creating a Custom Model Version.\nWhen creating a Custom Model Version, the version must be associated with a base execution\nenvironment.  If the base environment supports additional model dependencies\n(R or Python environments) and the Custom Model Version\ncontains a valid requirements.txt file, the model version will run in an environment based on\nthe base environment with the additional dependencies installed.\nCreate Custom Model Version\uf0c1\nUpload actual custom model content by creating a clean Custom Model Version:\nimport os\nimport datarobot as dr\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\n# add files from the folder to the custom model\nmodel_version = dr.CustomModelVersion.create_clean(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nfolder_path=custom_model_folder,\n)\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\n# or add a list of files to the custom model\nmodel_version_2 = dr.CustomModelVersion.create_clean(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nfiles=[(os.path.join(custom_model_folder, 'custom.py'), 'custom.py')],\n)\n# and/or set k8s resources to the custom model\nmodel_version_3 = dr.CustomModelVersion.create_clean(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nfiles=[(os.path.join(custom_model_folder, 'custom.py'), 'custom.py')],\nnetwork_egress_policy=dr.NETWORK_EGRESS_POLICY.PUBLIC,\nmaximum_memory=512*1024*1024,\nreplicas=1,\n)\nTo create a new Custom Model Version from a previous one, with just some files added or removed, do the following:\nimport os\nimport datarobot as dr\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\nfile_to_delete = model_version_2.items[0].id\nmodel_version_3 = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nfiles=[(os.path.join(custom_model_folder, 'custom.py'), 'custom.py')],\nfiles_to_delete=[file_to_delete],\n)\nPlease refer to CustomModelFileItem for description of custom model file properties.\nSpecify a custom environment version when creating a custom model version.\nBy default a version of the same environment does not change between consecutive model versions.\nThis behavior can be overridden:\nimport os\nimport datarobot as dr\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\n# create a clean version and specify an explicit environment version.\nmodel_version = dr.CustomModelVersion.create_clean(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nbase_environment_version_id=\"642209acc5638929a9b8dc3d\",\nfolder_path=custom_model_folder,\n)\n# create a version from a previous one, specify an explicit environment version.\nmodel_version_2 = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nbase_environment_version_id=\"660186775d016eabb290aee9\",\n)\nTo create a new Custom Model Version from a previous one, with just new k8s resources values, do the following:\nimport os\nimport datarobot as dr\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\nfile_to_delete = model_version_2.items[0].id\nmodel_version_3 = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\nmaximum_memory=1024*1024*1024,\n)\nCreate a custom model version with training data\uf0c1\nModel version creation allows to provide training (and holdout) data information.\nEvery custom model has to be explicitly switched to allow training data assignment for model versions.\nNote that the training data assignment differs for structured and unstructured models, and should be handled differently.\nEnable training data assignment for custom model versions\uf0c1\nBy default, custom model training data is assigned on the model level; for more information, see the Custom model training data assignment documentation.\nWhen training data is assigned to a model, the same training data is used for every model version. This method of training data assignment is deprecated and scheduled for removal; however, to avoid introducing issues for existing models, you must individually convert existing models to perform training data assignment by model version. This change is permanent and can not be undone.\nBecause the conversion process is irreversible, it is highly recommended that you do not convert critical models to the new training data assignment method. Instead, you should duplicate the existing model and test the new method.\nTo permanently enable a training data assignment on the model version level for the specified model, do the following:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ncustom_model = dr.CustomInferenceModel.get(custom_model_id)\ncustom_model.update(is_training_data_for_versions_permanently_enabled=True)\ncustom_model.is_training_data_for_versions_permanently_enabled  # True\nAssign training data for structured models\uf0c1\nAssign training data for structured models, you can provide the parameters training_dataset_id and partition_column.\nTraining data assignment is performed asynchronously,\nso you can create a version in a blocking or non-blocking way (see examples).\nCreate a structured model version with blocking (default max_wait=600) and wait for the training data assignment result.\nIf the training data assignment fails:\na datarobot.errors.TrainingDataAssignmentError exception is raised. The exception contains the custom model ID, the custom model version ID, the failure message.\na new custom model version is still created and can be fetched for further processing, but it\u2019s not possible to create a model package from it or deploy it.\nimport datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\ndr.Client(token=my_token, endpoint=endpoint)\ntry:\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n)\nexcept TrainingDataAssignmentError as e:\nprint(e)\nFetching model version in the case of the assignment error, example 1:\nimport datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\ndr.Client(token=my_token, endpoint=endpoint)\ntry:\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n)\nexcept TrainingDataAssignmentError as e:\nversion = CustomModelVersion.get(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\ncustom_model_version_id=e.custom_model_version_id,\n)\nprint(version.training_data.dataset_id)\nprint(version.training_data.dataset_version_id)\nprint(version.training_data.dataset_name)\nprint(version.training_data.assignment_error)\nFetching model version in the case of the assignment error, example 2:\nimport datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\ndr.Client(token=my_token, endpoint=endpoint)\ncustom_model = dr.CustomInferenceModel.get(\"6444482e5583f6ee2e572265\")\ntry:\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n)\nexcept TrainingDataAssignmentError as e:\npass\ncustom_model.refresh()\nversion = custom_model.latest_version\nprint(version.training_data.dataset_id)\nprint(version.training_data.dataset_version_id)\nprint(version.training_data.dataset_name)\nprint(version.training_data.assignment_error)\nCreate a structured model version with a non-blocking (set max_wat=None) training data assignment.\nIn this case, it is the user\u2019s responsibility to poll for version.training_data.assignment_in_progress.\nOnce the assignment is finished, check for errors if version.training_data.assignment_in_progress==False. If\nversion.training_data.assignment_error is None, then there is no error.\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\nmax_wait=None,\n)\nwhile version.training_data.assignment_in_progress:\ntime.sleep(10)\nversion.refresh()\nif version.training_data.assignment_error:\nprint(version.training_data.assignment_error[\"message\"])\nAssign training data for unstructured models\uf0c1\nFor unstructured models: you can provide the parameters training_dataset_id and holdout_dataset_id.\nThe training data assignment is performed synchronously and the max_wait parameter is ignored.\nThe example below shows how to create an unstructured model version with training and holdout data.\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\ntraining_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\nholdout_dataset_id=\"6421f2149a4f9b1bec6ad6ef\",\n)\nif version.training_data.assignment_error:\nprint(version.training_data.assignment_error[\"message\"])\nRemove training data\uf0c1\nBy default, training and holdout data are copied to a new model version from the previous model version.\nIf you don\u2019t want to keep training and holdout data for the new version, set keep_training_holdout_data to False.\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\nversion = dr.CustomModelVersion.create_from_previous(\ncustom_model_id=\"6444482e5583f6ee2e572265\",\nbase_environment_id=\"642209acc563893014a41e24\",\nkeep_training_holdout_data=False,\n)\nList Custom Model Versions\uf0c1\nUse the following command to list Custom Model Versions available to the user:\nimport datarobot as dr\ndr.CustomModelVersion.list(custom_model.id)\n>>> [CustomModelVersion('v2.0'), CustomModelVersion('v1.0')]\nRetrieve Custom Model Version\uf0c1\nTo retrieve a specific Custom Model Version, run:\nimport datarobot as dr\ndr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\n>>> CustomModelVersion('v2.0')\nUpdate Custom Model Version\uf0c1\nTo update Custom Model Version description execute the following:\nimport datarobot as dr\ncustom_model_version = dr.CustomModelVersion.get(\ncustom_model.id,\ncustom_model_version_id='5ebe96b84024035cc6a6560b',\n)\ncustom_model_version.update(description='new description')\ncustom_model_version.description\n>>> 'new description'\nDownload Custom Model Version\uf0c1\nDownload content of the Custom Model Version as a ZIP archive:\nimport datarobot as dr\npath_to_download = '/home/user/Documents/myModel.zip'\ncustom_model_version = dr.CustomModelVersion.get(\ncustom_model.id,\ncustom_model_version_id='5ebe96b84024035cc6a6560b',\n)\ncustom_model_version.download(path_to_download)\nStart Custom Model Inference Legacy Conversion\uf0c1\nCustom model version may include SAS files, with a main program entrypoint. In order to be able\nto use this model it is required to run a conversion. The conversion can later be fetched and\nexamined by reading the conversion print-outs.\nBy default, a conversion is initiated in a non-blocking mode. If a max_wait parameter\nis provided, than the call is blocked until the conversion is completed. The results can\nthan be read by fetching the conversion entity.\nimport datarobot as dr\n# Read a custom model version\ncustom_model_version = dr.CustomModelVersion.get(model_id, model_version_id)\n# Find the main program item ID\nmain_program_item_id = None\nfor item in cm_ver.items:\nif item.file_name.lower().endswith('.sas'):\nmain_program_item_id = item.id\n# Execute the conversion\nif async:\n# This is a non-blocking call\nconversion_id = dr.models.CustomModelVersionConversion.run_conversion(\ncustom_model_version.custom_model_id,\ncustom_model_version.id,\nmain_program_item_id,\n)\nelse:\n# This call is blocked until a completion or a timeout\nconversion_id = dr.models.CustomModelVersionConversion.run_conversion(\ncustom_model_version.custom_model_id,\ncustom_model_version.id,\nmain_program_item_id,\nmax_wait=60,\n)\nMonitor Custom Model Inference Legacy Conversion Process\uf0c1\nIf a custom model version conversion was initiated in a non-blocking mode, it is possible\nto monitor the progress as follows:\nimport datarobot as dr\nwhile True:\nconversion = dr.models.CustomModelVersionConversion.get(\ncustom_model_id, custom_model_version_id, conversion_id,\n)\nif conversion.conversion_in_progress:\nlogging.info('Conversion is in progress...')\ntime.sleep(1)\nelse:\nif conversion.conversion_succeeded:\nlogging.info('Conversion succeeded')\nelse:\nlogging.error(f'Conversion failed!\\n{conversion.log_message}')\nbreak\nStop a Custom Model Inference Legacy Conversion\uf0c1\nIt is possible to stop a custom model version conversion that is in progress. The call is\nnon-blocking and you may keep monitoring the conversion progress (see above) until is it completed.\nimport datarobot as dr\ndr.models.CustomModelVersionConversion.stop_conversion(\ncustom_model_id, custom_model_version_id, conversion_id,\n)\nCalculate Custom ModelVersion feature impact\uf0c1\nTo trigger calculation of custom model version Feature Impact, training data must be assigned to a custom inference model.\nPlease refer to the custom inference model documentation.\nIf training data is assigned, run the following to trigger the calculation of the feature impact:\nimport datarobot as dr\nversion = dr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\nversion.calculate_feature_impact()\nTo trigger calculating feature impact without blocking a program, set max_wait to None:\nimport datarobot as dr\nversion = dr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\nversion.calculate_feature_impact(max_wait=None)\nRetrieve Custom Inference Image feature impact\uf0c1\nTo retrieve Custom Model Version feature impact, it must be calculated beforehand.\nPlease refer to Custom Inference Image feature impact documentation.\nRun the following to get feature impact:\nimport datarobot as dr\nversion = dr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\nversion.get_feature_impact()\n>>> [{'featureName': 'B', 'impactNormalized': 1.0, 'impactUnnormalized': 1.1085356209402688, 'redundantWith': 'B'}...]\nPreparing a Custom Model Version for Use\uf0c1\nIf your custom model version has dependencies, a dependency build must be completed before the model\ncan be used.  The dependency build installs your model\u2019s dependencies into the base environment\nassociated with the model version.\nStarting the Dependency Build\uf0c1\nTo start the Custom Model Version Dependency Build, run:\nimport datarobot as dr\nbuild_info = dr.CustomModelVersionDependencyBuild.start_build(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\nmax_wait=3600,  # 1 hour timeout\n)\nbuild_info.build_status\n>>> 'success'\nTo start Custom Model Version Dependency Build without blocking a program until the test finishes,\nset max_wait to None:\nimport datarobot as dr\nbuild_info = dr.CustomModelVersionDependencyBuild.start_build(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\nmax_wait=None,\n)\nbuild_info.build_status\n>>> 'submitted'\n# after some time\nbuild_info.refresh()\nbuild_info.build_status\n>>> 'success'\nIn case the build fails, or you are just curious, do the following to retrieve the build log once complete:\nprint(build_info.get_log())\nTo cancel a Custom Model Version Dependency Build, simply run:\nbuild_info.cancel()\nManage Custom Model Tests\uf0c1\nA Custom Model Test represents testing performed on custom models.\nCreate Custom Model Test\uf0c1\nTo create Custom Model Test, run:\nimport datarobot as dr\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\ncustom_model_test = dr.CustomModelTest.create(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\ndataset_id=dataset.id,\nmax_wait=3600,  # 1 hour timeout\n)\ncustom_model_test.overall_status\n>>> 'succeeded'\nor, with k8s resources:\nimport datarobot as dr\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\ncustom_model_test = dr.CustomModelTest.create(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\ndataset_id=dataset.id,\nmax_wait=3600,  # 1 hour timeout\nmaximum_memory=1024*1024*1024,\n)\ncustom_model_test.overall_status\n>>> 'succeeded'\nTo start Custom Model Test without blocking a program until the test finishes, set max_wait to None:\nimport datarobot as dr\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\ncustom_model_test = dr.CustomModelTest.create(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\ndataset_id=dataset.id,\nmax_wait=None,\n)\ncustom_model_test.overall_status\n>>> 'in_progress'\n# after some time\ncustom_model_test.refresh()\ncustom_model_test.overall_status\n>>> 'succeeded'\nRunning a Custom Model Test uses the Custom Model Version\u2019s base image with its dependencies installed as an execution\nenvironment. To start Custom Model Test using an execution environment \u201cas-is\u201d, without the model\u2019s\ndependencies installed, supply an environment ID and (optionally) and environment version ID:\nimport datarobot as dr\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\ncustom_model_test = dr.CustomModelTest.create(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\ndataset_id=dataset.id,\nmax_wait=3600,  # 1 hour timeout\n)\ncustom_model_test.overall_status\n>>> 'succeeded'\nIn case a test fails, do the following to examine details of the failure:\nfor name, test in custom_model_test.detailed_status.items():\nprint('Test: {}'.format(name))\nprint('Status: {}'.format(test['status']))\nprint('Message: {}'.format(test['message']))\nprint(custom_model_test.get_log())\nTo cancel a Custom Model Test, simply run:\ncustom_model_test.cancel()\nTo start Custom Model Test for an unstructured custom model, dataset details should not be provided:\nimport datarobot as dr\ncustom_model_test = dr.CustomModelTest.create(\ncustom_model_id=custom_model.id,\ncustom_model_version_id=model_version.id,\n)\nList Custom Model Tests\uf0c1\nUse the following command to list Custom Model Tests available to the user:\nimport datarobot as dr\ndr.CustomModelTest.list(custom_model_id=custom_model.id)\n>>> [CustomModelTest('5ec262604024031bed5aaa16')]\nRetrieve Custom Model Test\uf0c1\nTo retrieve a specific Custom Model Test, run:\nimport datarobot as dr\ndr.CustomModelTest.get(custom_model_test_id='5ec262604024031bed5aaa16')\n>>> CustomModelTest('5ec262604024031bed5aaa16')",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/custom-models.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\nexecution_environment = dr.ExecutionEnvironment.create(\n    name=\"Python3 PyTorch Environment\",\n    description=\"This environment contains Python3 pytorch library.\",\n)\n\nexecution_environment.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\n# use execution_environment created earlier\n\nenvironment_version = dr.ExecutionEnvironmentVersion.create(\n    execution_environment.id,\n    docker_context_path=\"datarobot-user-models/public_dropin_environments/python3_pytorch\",\n    max_wait=3600,  # 1 hour timeout\n)\n\nenvironment_version.id\n>>> '5eb538959bc057003b487b2d'\nenvironment_version.build_status\n>>> 'success'",
        "import datarobot as dr\n\n# use execution_environment created earlier\n\n# create environment version from docker context\nenvironment_version = dr.ExecutionEnvironmentVersion.create(\n    execution_environment.id,\n    docker_context_path=\"datarobot-user-models/public_dropin_environments/python3_pytorch\",\n    max_wait=None,  # set None to not block execution on this method\n)\n\nenvironment_version.id\n>>> '5eb538959bc057003b487b2d'\nenvironment_version.build_status\n>>> 'processing'\n\n# after some time\nenvironment_version.refresh()\nenvironment_version.build_status\n>>> 'success'\n\n# now create anoter environment version from docker image URI\nenvironment_version = dr.ExecutionEnvironmentVersion.create(\n    execution_environment.id,\n    docker_image_uri=\"test_org/test_repo:test_tag\",\n    max_wait=None,  # set None to not block execution on this method\n)\n\nenvironment_version.id\n>>> '5eb538959bc057003b4943d2'\nenvironment_version.build_status\n>>> 'success'\nenvironment_version.docker_image_uri\n'test_org/test_repo:test_tag'",
        "import datarobot as dr\nfrom datarobot.models.execution_environment import RequiredMetadataKey\n\nexecution_environment = dr.ExecutionEnvironment.create(\n    name=\"Python3 PyTorch Environment\",\n    description=\"This environment contains Python3 pytorch library.\",\n    required_metadata_keys=[\n        RequiredMetadataKey(field_name=\"MY_VAR\", display_name=\"A value needed by hte environment\")\n    ],\n)\n\nmodel_version = dr.CustomModelVersion.create_clean(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    folder_path=custom_model_folder,\n    required_metadata={\"MY_VAR\": \"a value\"}\n)",
        "import datarobot as dr\n\nexecution_environments = dr.ExecutionEnvironment.list()\nexecution_environments\n>>> [ExecutionEnvironment('[DataRobot] Python 3 PyTorch Drop-In'), ExecutionEnvironment('[DataRobot] Java Drop-In')]\n\nenvironment_versions = dr.ExecutionEnvironmentVersion.list(execution_environment.id)\nenvironment_versions\n>>> [ExecutionEnvironmentVersion('v1')]",
        "import datarobot as dr\n\nexecution_environments = dr.ExecutionEnvironment.list(search_for='java')\nexecution_environments\n>>> [ExecutionEnvironment('[DataRobot] Java Drop-In')]",
        "import datarobot as dr\n\nenvironment_versions = dr.ExecutionEnvironmentVersion.list(\n    execution_environment.id, dr.EXECUTION_ENVIRONMENT_VERSION_BUILD_STATUS.PROCESSING\n)\nenvironment_versions\n>>> [ExecutionEnvironmentVersion('v1')]",
        "import datarobot as dr\n\nexecution_environment = dr.ExecutionEnvironment.get(execution_environment_id='5506fcd38bd88f5953219da0')\nexecution_environment\n>>> ExecutionEnvironment('[DataRobot] Python 3 PyTorch Drop-In')\n\nenvironment_version = dr.ExecutionEnvironmentVersion.get(\n    execution_environment_id=execution_environment.id, version_id='5eb538959bc057003b487b2d')\nenvironment_version\n>>> ExecutionEnvironmentVersion('v1')",
        "import datarobot as dr\n\nexecution_environment = dr.ExecutionEnvironment.get(execution_environment_id='5506fcd38bd88f5953219da0')\nexecution_environment.update(name='new name', description='new description')",
        "import datarobot as dr\n\nexecution_environment = dr.ExecutionEnvironment.get(execution_environment_id='5506fcd38bd88f5953219da0')\nexecution_environment.delete()",
        "import datarobot as dr\n\nenvironment_version = dr.ExecutionEnvironmentVersion.get(\n    execution_environment_id='5506fcd38bd88f5953219da0', version_id='5eb538959bc057003b487b2d')\nlog, error = environment_version.get_build_log()",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 PyTorch Custom Model',\n    target_type=dr.TARGET_TYPE.REGRESSION,\n    target_name='MEDV',\n    description='This is a Python3-based custom model. It has a simple PyTorch model built on boston housing',\n    language='python'\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 PyTorch Custom Model',\n    target_type=dr.TARGET_TYPE.BINARY,\n    target_name='readmitted',\n    positive_class_label='False',\n    negative_class_label='True',\n    description='This is a Python3-based custom model. It has a simple PyTorch model built on 10k_diabetes dataset',\n    language='Python 3'\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 PyTorch Custom Model',\n    target_type=dr.TARGET_TYPE.MULTICLASS,\n    target_name='readmitted',\n    class_labels=['hot dog', 'burrito', 'hoagie', 'reuben'],\n    description='This is a Python3-based custom model. It has a simple PyTorch model built on sandwich dataset',\n    language='Python 3'\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 PyTorch Custom Model',\n    target_type=dr.TARGET_TYPE.MULTICLASS,\n    target_name='readmitted',\n    class_labels_file='/path/to/classlabels.txt',\n    description='This is a Python3-based custom model. It has a simple PyTorch model built on sandwich dataset',\n    language='Python 3'\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 Unstructured Custom Model',\n    target_type=dr.TARGET_TYPE.UNSTRUCTURED,\n    description='This is a Python3-based unstructured model',\n    language='python'\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 Unstructured Custom Model',\n    target_type=dr.TARGET_TYPE.ANOMALY,\n    description='This is a Python3-based anomaly detection model',\n    language='python'\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 PyTorch Custom Model',\n    target_type=dr.TARGET_TYPE.BINARY,\n    target_name='readmitted',\n    positive_class_label='False',\n    negative_class_label='True',\n    description='This is a Python3-based custom model. It has a simple PyTorch model built on 10k_diabetes dataset',\n    language='Python 3',\n    maximum_memory=512*1024*1024,\n)",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.create(\n    name='Python 3 PyTorch Custom Model',\n    target_type=dr.TARGET_TYPE.REGRESSION,\n    target_name='MEDV',\n    description='This is a Python3-based custom model. It has a simple PyTorch model built on boston housing',\n    language='python',\n    is_training_data_for_versions_permanently_enabled=True\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'",
        "import datarobot as dr\n\ndr.CustomInferenceModel.list()\n>>> [CustomInferenceModel('my model 2'), CustomInferenceModel('my model 1')]\n\n# use these parameters to filter results:\ndr.CustomInferenceModel.list(\n    is_deployed=True,  # set to return only deployed models\n    order_by='-updated',  # set to define order of returned results\n    search_for='model 1',  # return only models containing 'model 1' in name or description\n)\n>>> CustomInferenceModel('my model 1')",
        "import datarobot as dr\n\ndr.CustomInferenceModel.get('5ebe95044024035cc6a65602')\n>>> CustomInferenceModel('my model 1')",
        "import datarobot as dr\n\ncustom_model = dr.CustomInferenceModel.get('5ebe95044024035cc6a65602')\n\ncustom_model.update(\n    name='new name',\n    description='new description',\n)",
        "import datarobot as dr\n\npath_to_download = '/home/user/Documents/myModel.zip'\n\ncustom_model = dr.CustomInferenceModel.get('5ebe96b84024035cc6a6560b')\n\ncustom_model.download_latest_version(path_to_download)",
        "import datarobot as dr\n\npath_to_dataset = '/home/user/Documents/trainingDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\n\ncustom_model = dr.CustomInferenceModel.get('5ebe96b84024035cc6a6560b')\n\ncustom_model.assign_training_data(dataset.id)",
        "import datarobot as dr\n\npath_to_dataset = '/home/user/Documents/trainingDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\n\ncustom_model = dr.CustomInferenceModel.get('5ebe96b84024035cc6a6560b')\n\ncustom_model.assign_training_data(\n    dataset.id,\n    max_wait=None\n)\n\ncustom_model.training_data_assignment_in_progress\n>>> True\n\n# after some time\ncustom_model.refresh()\ncustom_model.training_data_assignment_in_progress\n>>> False",
        "import os\nimport datarobot as dr\n\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\n\n# add files from the folder to the custom model\nmodel_version = dr.CustomModelVersion.create_clean(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    folder_path=custom_model_folder,\n)\n\ncustom_model.id\n>>> '5b6b2315ca36c0108fc5d41b'\n\n# or add a list of files to the custom model\nmodel_version_2 = dr.CustomModelVersion.create_clean(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    files=[(os.path.join(custom_model_folder, 'custom.py'), 'custom.py')],\n)\n\n# and/or set k8s resources to the custom model\nmodel_version_3 = dr.CustomModelVersion.create_clean(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    files=[(os.path.join(custom_model_folder, 'custom.py'), 'custom.py')],\n    network_egress_policy=dr.NETWORK_EGRESS_POLICY.PUBLIC,\n    maximum_memory=512*1024*1024,\n    replicas=1,\n)",
        "import os\nimport datarobot as dr\n\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\n\nfile_to_delete = model_version_2.items[0].id\n\nmodel_version_3 = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    files=[(os.path.join(custom_model_folder, 'custom.py'), 'custom.py')],\n    files_to_delete=[file_to_delete],\n)",
        "import os\nimport datarobot as dr\n\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\n\n# create a clean version and specify an explicit environment version.\nmodel_version = dr.CustomModelVersion.create_clean(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    base_environment_version_id=\"642209acc5638929a9b8dc3d\",\n    folder_path=custom_model_folder,\n)\n\n# create a version from a previous one, specify an explicit environment version.\nmodel_version_2 = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    base_environment_version_id=\"660186775d016eabb290aee9\",\n)",
        "import os\nimport datarobot as dr\n\ncustom_model_folder = \"datarobot-user-models/model_templates/python3_pytorch\"\n\nfile_to_delete = model_version_2.items[0].id\n\nmodel_version_3 = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    maximum_memory=1024*1024*1024,\n)",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ncustom_model = dr.CustomInferenceModel.get(custom_model_id)\ncustom_model.update(is_training_data_for_versions_permanently_enabled=True)\ncustom_model.is_training_data_for_versions_permanently_enabled  # True",
        "datarobot.errors.TrainingDataAssignmentError",
        "import datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ntry:\n    version = dr.CustomModelVersion.create_from_previous(\n        custom_model_id=\"6444482e5583f6ee2e572265\",\n        base_environment_id=\"642209acc563893014a41e24\",\n        training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    )\nexcept TrainingDataAssignmentError as e:\n    print(e)",
        "import datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ntry:\n    version = dr.CustomModelVersion.create_from_previous(\n        custom_model_id=\"6444482e5583f6ee2e572265\",\n        base_environment_id=\"642209acc563893014a41e24\",\n        training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    )\nexcept TrainingDataAssignmentError as e:\n    version = CustomModelVersion.get(\n        custom_model_id=\"6444482e5583f6ee2e572265\",\n        custom_model_version_id=e.custom_model_version_id,\n    )\n    print(version.training_data.dataset_id)\n    print(version.training_data.dataset_version_id)\n    print(version.training_data.dataset_name)\n    print(version.training_data.assignment_error)",
        "import datarobot as dr\nfrom datarobot.errors import TrainingDataAssignmentError\n\ndr.Client(token=my_token, endpoint=endpoint)\ncustom_model = dr.CustomInferenceModel.get(\"6444482e5583f6ee2e572265\")\n\ntry:\n    version = dr.CustomModelVersion.create_from_previous(\n        custom_model_id=\"6444482e5583f6ee2e572265\",\n        base_environment_id=\"642209acc563893014a41e24\",\n        training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    )\nexcept TrainingDataAssignmentError as e:\n    pass\n\ncustom_model.refresh()\nversion = custom_model.latest_version\nprint(version.training_data.dataset_id)\nprint(version.training_data.dataset_version_id)\nprint(version.training_data.dataset_name)\nprint(version.training_data.assignment_error)",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nversion = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=\"6444482e5583f6ee2e572265\",\n    base_environment_id=\"642209acc563893014a41e24\",\n    training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    max_wait=None,\n)\n\nwhile version.training_data.assignment_in_progress:\n    time.sleep(10)\n    version.refresh()\nif version.training_data.assignment_error:\n    print(version.training_data.assignment_error[\"message\"])",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nversion = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=\"6444482e5583f6ee2e572265\",\n    base_environment_id=\"642209acc563893014a41e24\",\n    training_dataset_id=\"6421f2149a4f9b1bec6ad6dd\",\n    holdout_dataset_id=\"6421f2149a4f9b1bec6ad6ef\",\n)\nif version.training_data.assignment_error:\n    print(version.training_data.assignment_error[\"message\"])",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\nversion = dr.CustomModelVersion.create_from_previous(\n    custom_model_id=\"6444482e5583f6ee2e572265\",\n    base_environment_id=\"642209acc563893014a41e24\",\n    keep_training_holdout_data=False,\n)",
        "import datarobot as dr\n\ndr.CustomModelVersion.list(custom_model.id)\n\n>>> [CustomModelVersion('v2.0'), CustomModelVersion('v1.0')]",
        "import datarobot as dr\n\ndr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\n\n>>> CustomModelVersion('v2.0')",
        "import datarobot as dr\n\ncustom_model_version = dr.CustomModelVersion.get(\n    custom_model.id,\n    custom_model_version_id='5ebe96b84024035cc6a6560b',\n)\n\ncustom_model_version.update(description='new description')\n\ncustom_model_version.description\n>>> 'new description'",
        "import datarobot as dr\n\npath_to_download = '/home/user/Documents/myModel.zip'\n\ncustom_model_version = dr.CustomModelVersion.get(\n    custom_model.id,\n    custom_model_version_id='5ebe96b84024035cc6a6560b',\n)\n\ncustom_model_version.download(path_to_download)",
        "import datarobot as dr\n\n    # Read a custom model version\n    custom_model_version = dr.CustomModelVersion.get(model_id, model_version_id)\n\n    # Find the main program item ID\n    main_program_item_id = None\n    for item in cm_ver.items:\n            if item.file_name.lower().endswith('.sas'):\n                    main_program_item_id = item.id\n\n    # Execute the conversion\n    if async:\n            # This is a non-blocking call\n            conversion_id = dr.models.CustomModelVersionConversion.run_conversion(\n                    custom_model_version.custom_model_id,\n                    custom_model_version.id,\n                    main_program_item_id,\n            )\n    else:\n            # This call is blocked until a completion or a timeout\n            conversion_id = dr.models.CustomModelVersionConversion.run_conversion(\n                    custom_model_version.custom_model_id,\n                    custom_model_version.id,\n                    main_program_item_id,\n                    max_wait=60,\n            )",
        "import datarobot as dr\n\n    while True:\n            conversion = dr.models.CustomModelVersionConversion.get(\n                    custom_model_id, custom_model_version_id, conversion_id,\n            )\n            if conversion.conversion_in_progress:\n                    logging.info('Conversion is in progress...')\n                    time.sleep(1)\n            else:\n                    if conversion.conversion_succeeded:\n                            logging.info('Conversion succeeded')\n                    else:\n                            logging.error(f'Conversion failed!\\n{conversion.log_message}')\n                    break",
        "import datarobot as dr\n\n    dr.models.CustomModelVersionConversion.stop_conversion(\n            custom_model_id, custom_model_version_id, conversion_id,\n    )",
        "import datarobot as dr\n\nversion = dr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\n\nversion.calculate_feature_impact()",
        "import datarobot as dr\n\nversion = dr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\n\nversion.calculate_feature_impact(max_wait=None)",
        "import datarobot as dr\n\nversion = dr.CustomModelVersion.get(custom_model.id, custom_model_version_id='5ebe96b84024035cc6a6560b')\n\nversion.get_feature_impact()\n>>> [{'featureName': 'B', 'impactNormalized': 1.0, 'impactUnnormalized': 1.1085356209402688, 'redundantWith': 'B'}...]",
        "import datarobot as dr\n\nbuild_info = dr.CustomModelVersionDependencyBuild.start_build(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n    max_wait=3600,  # 1 hour timeout\n)\n\nbuild_info.build_status\n>>> 'success'",
        "import datarobot as dr\n\nbuild_info = dr.CustomModelVersionDependencyBuild.start_build(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n    max_wait=None,\n)\n\nbuild_info.build_status\n>>> 'submitted'\n\n# after some time\nbuild_info.refresh()\nbuild_info.build_status\n>>> 'success'",
        "import datarobot as dr\n\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\n\ncustom_model_test = dr.CustomModelTest.create(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n    dataset_id=dataset.id,\n    max_wait=3600,  # 1 hour timeout\n)\n\ncustom_model_test.overall_status\n>>> 'succeeded'",
        "import datarobot as dr\n\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\n\ncustom_model_test = dr.CustomModelTest.create(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n    dataset_id=dataset.id,\n    max_wait=3600,  # 1 hour timeout\n    maximum_memory=1024*1024*1024,\n)\n\ncustom_model_test.overall_status\n>>> 'succeeded'",
        "import datarobot as dr\n\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\n\ncustom_model_test = dr.CustomModelTest.create(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n    dataset_id=dataset.id,\n    max_wait=None,\n)\n\ncustom_model_test.overall_status\n>>> 'in_progress'\n\n# after some time\ncustom_model_test.refresh()\ncustom_model_test.overall_status\n>>> 'succeeded'",
        "import datarobot as dr\n\npath_to_dataset = '/home/user/Documents/testDataset.csv'\ndataset = dr.Dataset.create_from_file(file_path=path_to_dataset)\n\ncustom_model_test = dr.CustomModelTest.create(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n    dataset_id=dataset.id,\n    max_wait=3600,  # 1 hour timeout\n)\n\ncustom_model_test.overall_status\n>>> 'succeeded'",
        "for name, test in custom_model_test.detailed_status.items():\n    print('Test: {}'.format(name))\n    print('Status: {}'.format(test['status']))\n    print('Message: {}'.format(test['message']))\n\nprint(custom_model_test.get_log())",
        "custom_model_test.cancel()",
        "import datarobot as dr\n\ncustom_model_test = dr.CustomModelTest.create(\n    custom_model_id=custom_model.id,\n    custom_model_version_id=model_version.id,\n)",
        "import datarobot as dr\n\ndr.CustomModelTest.list(custom_model_id=custom_model.id)\n>>> [CustomModelTest('5ec262604024031bed5aaa16')]",
        "import datarobot as dr\n\ndr.CustomModelTest.get(custom_model_test_id='5ec262604024031bed5aaa16')\n>>> CustomModelTest('5ec262604024031bed5aaa16')"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/hosted_custom_metrics.html",
      "title": "Custom Metrics\uf0c1",
      "description": "Hosted custom metrics run user-provided code on DataRobot infrastructure to calculate\nyour organization\u2019s customized metrics.\nDataRobot provides a variety of templates for common metrics. These metrics can be used as is,\nor as a starting point for user-provided metrics.\nIn this tutorial, you create a hosted custom metric using the Python SDK.",
      "content": "Custom Metrics\uf0c1\nHosted custom metrics run user-provided code on DataRobot infrastructure to calculate\nyour organization\u2019s customized metrics.\nDataRobot provides a variety of templates for common metrics. These metrics can be used as is,\nor as a starting point for user-provided metrics.\nIn this tutorial, you create a hosted custom metric using the Python SDK.\nPrerequisites\uf0c1\nBefore you start, import all objects used in this tutorial and initialize the DataRobot client:\nimport datarobot as dr\nfrom datarobot.enums import HostedCustomMetricsTemplateMetricTypeQueryParams\nfrom datarobot.models.deployment.custom_metrics import HostedCustomMetricTemplate, HostedCustomMetric, \\\nHostedCustomMetricBlueprint, CustomMetric, MetricTimestampSpoofing, ValueField, SampleCountField, BatchField\nfrom datarobot.models.registry import JobRun\nfrom datarobot.models.registry.job import Job\nfrom datarobot import Deployment\nfrom datarobot.models.runtime_parameters import RuntimeParameterValue\nfrom datarobot.models.types import Schedule\ndr.Client(token=\"<DataRobot API Token>\", endpoint=\"<DataRobot URL>\")\ngen_ai_deployment_1 = Deployment.get('<Deployment Id>')\nList hosted custom metrics templates\uf0c1\nBefore creating a hosted custom metric from a template,\nretrieve the LLM metric template to use as the basis of the new metric.\nTo do this, specify the metric_type and,\nbecause the deployments are LLM models handling Japanese text,\nsearch for the specific metric by name, limiting the search to 1 result.\nStore the result in templates for the next step.\ntemplates = HostedCustomMetricTemplate.list(\nsearch=\"[JP] Character Count\",\nmetric_type=HostedCustomMetricsTemplateMetricTypeQueryParams.LLM,\nlimit=1,\noffset=0,\n)\nCreate hosted custom metric in single step\uf0c1\nAfter locating the custom metric template, create the hosted custom metric from that template.\nThis method is a shortcut, combining two steps to create the new custom metric from the retrieved template:\n1. Create a custom job for a hosted custom metric from the template retrieved in the previous step (stored in templates).\n2. Connect the hosted custom metric job to the deployment defined during the prerequisites step (stored in  gen_ai_deployment_1).\nBecause we are creating 2 objects, specify both the job name and custom metric name\nin addition to the template and deployment IDs. Additionally, define the job schedule\nand the runtime parameter overrides for the deployment.\nhosted_custom_metric = HostedCustomMetric.create_from_template(\ntemplate_id=templates[0].id,\ndeployment_id=gen_ai_deployment_1.id,\njob_name=\"Hosted Custom Metric Character Count\",\ncustom_metric_name=\"Character Count\",\njob_description=\"Hosted Custom Metric\",\ncustom_metric_description=\"LLM Character Count\",\nbaseline_value=10,\ntimestamp=MetricTimestampSpoofing(\ncolumn_name=\"timestamp\",\ntime_format=\"%Y-%m-%d %H:%M:%S\",\n),\nvalue = ValueField(column_name=\"value\"),\nsample_count=SampleCountField(column_name='Sample Count'),\nbatch=BatchField(column_name='Batch'),\nschedule=Schedule(\nday_of_week=[0],\nhour=['*'],\nminute=['*'],\nday_of_month=[12],\nmonth=[1],\n),\nparameter_overrides=[RuntimeParameterValue(field_name='DRY_RUN', value=\"0\", type=\"string\")]\n)\nOnce we have created the hosted custom metric, you can initiate the manual run.\njob_run = JobRun.create(\njob_id=hosted_custom_metric.custom_job_id\nruntime_parameter_values=[\nRuntimeParameterValue(field_name='DRY_RUN', value=\"1\", type=\"string\"),\nRuntimeParameterValue(field_name='DEPLOYMENT_ID', value=gen_ai_deployment_1.id, type=\"deployment\"),\nRuntimeParameterValue(field_name='CUSTOM_METRIC_ID', value=hosted_custom_metric.id, type=\"customMetric\"),\n]\n)\nprint(job_run.status)\nCreate hosted custom metric in two steps\uf0c1\nYou can also perform these steps manually, in sequence. This is useful if you want\nto edit the custom metric blueprint before attaching the custom job to the deployment.\nWhen you attach the job to the deployment, most settings are\ncopied from blueprint (unless you provide an override) .\nTo create the hosted custom metric manually, first,\ncreate a custom job from the template retrieved earlier (stored in templates).\njob = Job.create_from_custom_metric_gallery_template(\ntemplate_id=templates[0].id,\nname=\"Job created from template\",\ndescription=\"Job created from template\"\n)\nNext, retrieve the default blueprint, provided by the template, and edit it.\nblueprint = HostedCustomMetricBlueprint.get(job.id)\nprint(f\"Original directionality: {blueprint.directionality}\")\nThen, update the parameters of the custom metric in the blueprint.\nupdated_blueprint = blueprint.update(\ndirectionality='lowerIsBetter',\nunits='characters',\ntype='gauge',\ntime_step='hour',\nis_model_specific=False\n)\nprint(f\"Updated directionality: {updated_blueprint.directionality}\")\nNow create the hosted custom metric. As in the shortcut method, you can provide the job schedule,\nruntime parameter overrides, and custom metric parameters specific to this deployment.\nanother_hosted_custom_metric = HostedCustomMetric.create_from_custom_job(\ncustom_job_id=job.id,\ndeployment_id=gen_ai_deployment_1.id,\nname=\"Custom metric created in 2 steps\",\n)\nAfter creating and configuring the metric, verify that the changes to the blueprint are reflected in the custom metric.\nanother_custom_metric = CustomMetric.get(custom_metric_id=another_hosted_custom_metric.id, deployment_id=gen_ai_deployment_1.id)\nprint(f\"Directionality of another custom metric: {another_custom_metric.directionality}\")\nFinally, create a manual job run for the custom metric job.\njob_run = JobRun.create(\njob_id=job.id,\nruntime_parameter_values=[\nRuntimeParameterValue(field_name='DRY_RUN', value=\"1\", type=\"string\"),\nRuntimeParameterValue(field_name='DEPLOYMENT_ID', value=gen_ai_deployment_1.id, type=\"deployment\"),\nRuntimeParameterValue(field_name='CUSTOM_METRIC_ID', value=another_hosted_custom_metric.id, type=\"customMetric\"),\n]\n)\nprint(job_run.status)\nList Hosted Custom Metrics\uf0c1\nTo list all hosted custom metrics associated with a custom job, use the following code:\nhosted_custom_metrics = HostedCustomMetric.list(deployment_id=hosted_custom_metric.custom_job_id)\nfor metric in hosted_custom_metrics:\nprint(metric.name)\nDelete Hosted Custom Metrics\uf0c1\nIn addition, you can delete the hosted custom metric, removing the custom metric from deployment\nbut keeping the job, allowing you to create the metric for another deployment.\nhosted_custom_metric.delete()\nanother_hosted_custom_metric.delete()\nIf necessary, you can delete the entire custom job. If there are any custom metrics associated with that job,\nthey are also deleted.\njob.delete()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nfrom datarobot.enums import HostedCustomMetricsTemplateMetricTypeQueryParams\nfrom datarobot.models.deployment.custom_metrics import HostedCustomMetricTemplate, HostedCustomMetric, \\\n    HostedCustomMetricBlueprint, CustomMetric, MetricTimestampSpoofing, ValueField, SampleCountField, BatchField\nfrom datarobot.models.registry import JobRun\nfrom datarobot.models.registry.job import Job\nfrom datarobot import Deployment\nfrom datarobot.models.runtime_parameters import RuntimeParameterValue\nfrom datarobot.models.types import Schedule\n\ndr.Client(token=\"<DataRobot API Token>\", endpoint=\"<DataRobot URL>\")\ngen_ai_deployment_1 = Deployment.get('<Deployment Id>')",
        "updated_blueprint = blueprint.update(\n    directionality='lowerIsBetter',\n    units='characters',\n    type='gauge',\n    time_step='hour',\n    is_model_specific=False\n)\nprint(f\"Updated directionality: {updated_blueprint.directionality}\")"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/deployment.html",
      "title": "Deployments\uf0c1",
      "description": "Deployment is the central hub for users to deploy, manage and monitor their models.",
      "content": "Deployments\uf0c1\nDeployment is the central hub for users to deploy, manage and monitor their models.\nManage Deployments\uf0c1\nThe following commands can be used to manage deployments.\nCreate a Deployment\uf0c1\nA new deployment can be created from:\nDataRobot model - use create_from_registered_model_version(). Please refer to the Model Registry documentation that describes how to create a registered model version.\nWhen creating a new deployment, a DataRobot registered_model_version_id (also known as model_package_id) and label must be provided.\nA description can be optionally provided to document the purpose of the deployment.\nThe default prediction server is used when making predictions against the deployment,\nand is a requirement for creating a deployment on DataRobot cloud.\nFor on-prem installations, a user must not provide a default prediction server\nand a pre-configured prediction server will be used instead.\nRefer to datarobot.PredictionServer.list for more information on retrieving available prediction servers.\nimport datarobot as dr\nproject = dr.Project.get('6527eb38b9e5dead5fc12491')\nmodel = project.get_models()[0]\nprediction_server = dr.PredictionServer.list()[0]\nregistered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\nmodel_id=model.id,\nname=\"Name of the version(aka model package)\",\nregistered_model_name='Name of the registered model unique across the org '\n)\ndeployment = dr.Deployment.create_from_registered_model_version(\nregistered_model_version.id, label='New Deployment', description='A new deployment',\ndefault_prediction_server_id=prediction_server.id)\n>>> Deployment('New Deployment')\nList Deployments\uf0c1\nUse the following command to list deployments a user can view.\nimport datarobot as dr\ndeployments = dr.Deployment.list()\ndeployments\n>>> [Deployment('New Deployment'), Deployment('Previous Deployment')]\nRefer to Deployment for properties of the deployment object.\nYou can also filter the deployments that are returned by passing an instance of the\nDeploymentListFilters class to the filters keyword argument.\nimport datarobot as dr\nfilters = dr.models.deployment.DeploymentListFilters(\nrole='OWNER',\naccuracy_health=dr.enums.DEPLOYMENT_ACCURACY_HEALTH_STATUS.FAILING\n)\ndeployments = dr.Deployment.list(filters=filters)\ndeployments\n>>> [Deployment('Deployment Owned by Me w/ Failing Accuracy 1'), Deployment('Deployment Owned by Me w/ Failing Accuracy 2')]\nRetrieve a Deployment\uf0c1\nIt is possible to retrieve a single deployment with its identifier,\nrather than list all deployments.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.id\n>>> '5c939e08962d741e34f609f0'\ndeployment.label\n>>> 'New Deployment'\nRefer to Deployment for properties of the deployment object.\nUpdate a Deployment\uf0c1\nDeployment\u2019s label and description can be updated.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update(label='new label')\nDelete a Deployment\uf0c1\nTo mark a deployment as deleted, use the following command.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.delete()\nActivate or deactivate a Deployment\uf0c1\nTo activate a deployment, use the following command.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.activate()\ndeployment.status\n>>> 'active'\nTo deactivate a deployment, use the following command.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.deactivate()\ndeployment.status\n>>> 'inactive'\nMake batch predictions with a deployment\uf0c1\nDataRobot provides a small utility function to make batch predictions using a deployment: Deployment.predict_batch.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n# To note: `source` can be a file path, a file, or a pandas DataFrame\nprediction_results_as_dataframe = deployment.predict_batch(\nsource=\"./my_local_file.csv\",\n)\nModel Replacement\uf0c1\nA deployment\u2019s model can be replaced effortlessly with zero interruption of\npredictions.\nModel replacement is an asynchronous process, which means some\npreparatory work may be performed after the initial request is completed.\nPredictions made against this deployment will start\nusing the new model as soon as the request is completed.\nThere will be no interruption for predictions throughout the process.\nThe replace_model() function won\u2019t return until the\nasynchronous process is fully finished.\nAlongside the identifier of the new model, a reason is also required.\nThe reason is stored in model history of the deployment for bookkeeping purpose.\nAn enum MODEL_REPLACEMENT_REASON is provided for convenience, all possible values are documented below:\nMODEL_REPLACEMENT_REASON.ACCURACY\nMODEL_REPLACEMENT_REASON.DATA_DRIFT\nMODEL_REPLACEMENT_REASON.ERRORS\nMODEL_REPLACEMENT_REASON.SCHEDULED_REFRESH\nMODEL_REPLACEMENT_REASON.SCORING_SPEED\nMODEL_REPLACEMENT_REASON.OTHER\nHere is an example of model replacement:\nimport datarobot as dr\nfrom datarobot.enums import MODEL_REPLACEMENT_REASON\nproject = dr.Project.get('5cc899abc191a20104ff446a')\nmodel = project.get_models()[0]\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.model['id'], deployment.model['type']\n>>> ('5c0a979859b00004ba52e431', 'Decision Tree Classifier (Gini)')\ndeployment.replace_model('5c0a969859b00004ba52e41b', MODEL_REPLACEMENT_REASON.ACCURACY)\ndeployment.model['id'], deployment.model['type']\n>>> ('5c0a969859b00004ba52e41b', 'Support Vector Classifier (Linear Kernel)')\nValidation\uf0c1\nBefore initiating the model replacement request, it is usually a good idea to use\nthe validate_replacement_model() function to validate if the new model can be used as a replacement.\nThe validate_replacement_model() function returns the validation status, a message and a checks dictionary.\nIf the status is \u2018passing\u2019 or \u2018warning\u2019, use replace_model() to perform model the replacement.\nIf status is \u2018failing\u2019, refer to the checks dict for more details on why the new model cannot be used as a replacement.\nimport datarobot as dr\nproject = dr.Project.get('5cc899abc191a20104ff446a')\nmodel = project.get_models()[0]\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nstatus, message, checks = deployment.validate_replacement_model(new_model_id=model.id)\nstatus\n>>> 'passing'\n# `checks` can be inspected for detail, showing two examples here:\nchecks['target']\n>>> {'status': 'passing', 'message': 'Target is compatible.'}\nchecks['permission']\n>>> {'status': 'passing', 'message': 'User has permission to replace model.'}\nMonitoring\uf0c1\nDeployment monitoring can be categorized into several area of concerns:\nService Stats & Service Stats Over Time\nAccuracy & Accuracy Over Time\nWith a Deployment object, get functions are provided to allow querying of the monitoring data.\nAlternatively, it is also possible to retrieve monitoring data directly using a deployment ID. For example:\nfrom datarobot.models import Deployment, ServiceStats\ndeployment_id = '5c939e08962d741e34f609f0'\n# call `get` functions on a `Deployment` object\ndeployment = Deployment.get(deployment_id)\nservice_stats = deployment.get_service_stats()\n# directly fetch without a `Deployment` object\nservice_stats = ServiceStats.get(deployment_id)\nWhen querying monitoring data, a start and end time can be optionally provided, will accept either a datetime object or a string.\nNote that only top of the hour datetimes are accepted, for example: 2019-08-01T00:00:00Z.\nBy default, the end time of the query will be the next top of the hour, the start time will be 7 days before the end time.\nIn the over time variants, an optional bucket_size can be provided to specify the resolution of time buckets.\nFor example, if start time is 2019-08-01T00:00:00Z, end time is 2019-08-02T00:00:00Z and bucket_size is T1H,\nthen 24 time buckets will be generated, each providing data calculated over one hour.\nUse construct_duration_string() to help construct a bucket size string.\nNote\nThe minimum bucket size is one hour.\nService Stats\uf0c1\nService stats are metrics tracking deployment utilization and how well deployments respond to prediction requests.\nUse SERVICE_STAT_METRIC.ALL to retrieve a list of supported metrics.\nServiceStats retrieves values for all service stats metrics;\nServiceStatsOverTime can be used to fetch how one single metric changes over time.\nfrom datetime import datetime\nfrom datarobot.enums import SERVICE_STAT_METRIC\nfrom datarobot.helpers.partitioning_methods import construct_duration_string\nfrom datarobot.models import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nservice_stats = deployment.get_service_stats(\nstart_time=datetime(2019, 8, 1, hour=15),\nend_time=datetime(2019, 8, 8, hour=15)\n)\nservice_stats[SERVICE_STAT_METRIC.TOTAL_PREDICTIONS]\n>>> 12597\ntotal_predictions = deployment.get_service_stats_over_time(\nstart_time=datetime(2019, 8, 1, hour=15),\nend_time=datetime(2019, 8, 8, hour=15),\nbucket_size=construct_duration_string(days=1),\nmetric=SERVICE_STAT_METRIC.TOTAL_PREDICTIONS\n)\ntotal_predictions.bucket_values\n>>> OrderedDict([(datetime.datetime(2019, 8, 1, 15, 0, tzinfo=tzutc()), 1610),\n(datetime.datetime(2019, 8, 2, 15, 0, tzinfo=tzutc()), 2249),\n(datetime.datetime(2019, 8, 3, 15, 0, tzinfo=tzutc()), 254),\n(datetime.datetime(2019, 8, 4, 15, 0, tzinfo=tzutc()), 943),\n(datetime.datetime(2019, 8, 5, 15, 0, tzinfo=tzutc()), 1967),\n(datetime.datetime(2019, 8, 6, 15, 0, tzinfo=tzutc()), 2810),\n(datetime.datetime(2019, 8, 7, 15, 0, tzinfo=tzutc()), 2775)])\nData Drift\uf0c1\nData drift describe how much the distribution of target or a feature has changed comparing to the training data.\nDeployment\u2019s target drift and feature drift can be retrieved separately using datarobot.models.deployment.TargetDrift and datarobot.models.deployment.FeatureDrift.\nUse DATA_DRIFT_METRIC.ALL to retrieve a list of supported metrics.\nfrom datetime import datetime\nfrom datarobot.enums import DATA_DRIFT_METRIC\nfrom datarobot.models import Deployment, FeatureDrift\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ntarget_drift = deployment.get_target_drift(\nstart_time=datetime(2019, 8, 1, hour=15),\nend_time=datetime(2019, 8, 8, hour=15)\n)\ntarget_drift.drift_score\n>>> 0.00408514\nfeature_drift_data = FeatureDrift.list(\ndeployment_id='5c939e08962d741e34f609f0',\nstart_time=datetime(2019, 8, 1, hour=15),\nend_time=datetime(2019, 8, 8, hour=15),\nmetric=DATA_DRIFT_METRIC.HELLINGER\n)\nfeature_drift = feature_drift_data[0]\nfeature_drift.name\n>>> 'age'\nfeature_drift.drift_score\n>>> 4.16981594\nPredictions Over Time\uf0c1\nPredictions over time gives insight on how deployment\u2019s prediction response has changed over time.\nDifferent data can be retrieved in each bucket, depending on deployment\u2019s target type:\nrow_count: number of rows in the bucket, available for all target types\nmean_predicted_value: mean of predicted value for all rows in the bucket, available for regression target type\nmean_probabilities: mean of predicted probability for each class, available for binary or multiclass classification target types\nclass_distribution: count and percent of predicted class labels, available for binary or multiclass classification target types\npercentiles: 10th and 90th percentile of predicted value or positive class probability, available for regression and binary target type\nfrom datetime import datetime\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models import Deployment\n# deployment with regression target type\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_over_time(\nstart_time=datetime(2023, 4, 1),\nend_time=datetime(2023, 4, 30),\nbucket_size=BUCKET_SIZE.P1D,\n)\npredicted = [bucket['mean_predicted_value'] for bucket in predictions_over_time.buckets]\npredicted\n>>> [0.3772, 0.6642, ...., 0.7937]\n# deployment with binary target type\ndeployment = Deployment.get(deployment_id='62fff28a0f5fee488587ce92')\npredictions_over_time = deployment.get_predictions_over_time(\nstart_time=datetime(2023, 4, 1),\nend_time=datetime(2023, 4, 22),\nbucket_size=BUCKET_SIZE.P7D,\n)\npredicted = [\n{item['class_name']: item['value'] for item in bucket['mean_probabilities']}.get('True')\nfor bucket in predictions_over_time.buckets\n]\npredicted\n>>> [0.3955, 0.4274, None]\nAccuracy\uf0c1\nA collection of metrics are provided to measure the accuracy of a deployment\u2019s predictions.\nFor deployments with classification model, use ACCURACY_METRIC.ALL_CLASSIFICATION for all supported metrics;\nin the case of deployment with regression model, use ACCURACY_METRIC.ALL_REGRESSION instead.\nSimilarly with Service Stats, Accuracy and AccuracyOverTime\nare provided to retrieve all default accuracy metrics and how one single metric change over time.\nfrom datetime import datetime\nfrom datarobot.enums import ACCURACY_METRIC\nfrom datarobot.helpers.partitioning_methods import construct_duration_string\nfrom datarobot.models import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy = deployment.get_accuracy(\nstart_time=datetime(2019, 8, 1, hour=15),\nend_time=datetime(2019, 8, 1, 15, 0)\n)\naccuracy[ACCURACY_METRIC.RMSE]\n>>> 943.225\nrmse = deployment.get_accuracy_over_time(\nstart_time=datetime(2019, 8, 1),\nend_time=datetime(2019, 8, 3),\nbucket_size=construct_duration_string(days=1),\nmetric=ACCURACY_METRIC.RMSE\n)\nrmse.bucket_values\n>>> OrderedDict([(datetime.datetime(2019, 8, 1, 15, 0, tzinfo=tzutc()), 1777.190657),\n(datetime.datetime(2019, 8, 2, 15, 0, tzinfo=tzutc()), 1613.140772)])\nIt is also possible to retrieve how multiple metrics changes over the same period of time,\nenabling easier side by side comparison across different metrics.\nfrom datarobot.enums import ACCURACY_METRIC\nfrom datarobot.models import Deployment\naccuracy_over_time = AccuracyOverTime.get_as_dataframe(\nram_app.id, [ACCURACY_METRIC.RMSE, ACCURACY_METRIC.GAMMA_DEVIANCE, ACCURACY_METRIC.MAD])\nPredictions vs Actuals Over Time\uf0c1\nPredictions vs actuals over time can be used to analyze how deployment\u2019s predictions compare against actuals.\nDifferent data can be retrieved in each bucket, depending on deployment\u2019s target type:\nrow_count_total: The number of rows with or without actual in the bucket, available for all target types.\nrow_count_with_actual: The number of rows with actuals in the bucket, available for all target types.\nmean_predicted_value: The mean of the predicted value for all rows match with an actual in the bucket, available for the regression target type.\nmean_actual_value: The mean of the actual value for all rows in the bucket. Available for the regression target type.\npredicted_class_distribution: The count and percent of predicted class labels. Available for binary and multiclass classification target types.\nactual_class_distribution: The count and percent of actual class labels. Available for binary or multiclass classification target types.\nfrom datetime import datetime\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models import Deployment\n# deployment with regression target type\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_vs_actuals_over_time(\nstart_time=datetime(2023, 4, 1),\nend_time=datetime(2023, 4, 30),\nbucket_size=BUCKET_SIZE.P1D,\n)\npredicted = [bucket['mean_actual_value'] for bucket in predictions_over_time.buckets]\npredicted\n>>> [0.2806, 0.9170, ...., 0.0314]\n# deployment with binary target type\ndeployment = Deployment.get(deployment_id='62fff28a0f5fee488587ce92')\npredictions_over_time = deployment.get_predictions_vs_actuals_over_time(\nstart_time=datetime(2023, 4, 1),\nend_time=datetime(2023, 4, 22),\nbucket_size=BUCKET_SIZE.P7D,\n)\npredicted = [\n{item['class_name']: item['value'] for item in bucket['mean_predicted_value']}.get('True')\nfor bucket in predictions_over_time.buckets\n]\npredicted\n>>> [0.5822, 0.6305, None]\nDelete Data\uf0c1\nMonitoring data accumulated on a deployment can be deleted using delete_monitoring_data().\nA start and end timestamp could be provided to limit data deletion to certain time period.\nWarning\nMonitoring data is not recoverable once deleted.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.delete_monitoring_data(model_id=deployment.model['id'])\nList deployment prediction data exports\uf0c1\nPrediction data exports for a deployment can be retrieved using list_prediction_data_exports().\nfrom datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nprediction_data_exports = deployment.list_prediction_data_exports(limit=0)\nprediction_data_exports\n>>> [PredictionDataExport('65fbe59aaa3f847bd5acc75b'),\nPredictionDataExport('65fbe59aaa3f847bd5acc75c'),\nPredictionDataExport('65fbe59aaa3f847bd5acc75a')]\nTo list all prediction data exports, set the limit to 0.\nAdjust additional parameters to filter the data as needed:\nfrom datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nprediction_data_exports = deployment.list_prediction_data_exports(\nmodel_id=\"6444482e5583f6ee2e572265\",\nbatch=False,\nstatus=ExportStatus.SUCCEEDED,\nlimit=100,\noffset=50,\n)\nList deployment actuals data exports\uf0c1\nActuals data exports for a deployment can be retrieved using list_actuals_data_exports().\nfrom datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nactuals_data_exports = deployment.list_actuals_data_exports(limit=0)\nactuals_data_exports\n>>> [ActualsDataExport('660456a332d0081029ee5031'),\nActualsDataExport('660456a332d0081029ee5032'),\nActualsDataExport('660456a332d0081029ee5033')]\nTo list all actuals data exports, set the limit to 0.\nAdjust additional parameters to filter the data as needed:\nfrom datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nactuals_data_exports = deployment.list_actuals_data_exports(\ndeployment_id='5c939e08962d741e34f609f0',\noffset=500,\nlimit=50,\nstatus=ExportStatus.SUCCEEDED\n)\nList deployment training data exports\uf0c1\nTo retrieve successful training data exports for a deployment, use list_training_data_exports().\nfrom datarobot.models.deployment import TrainingDataExport\ntraining_data_exports = TrainingDataExport.list(deployment_id='5c939e08962d741e34f609f0')\ntraining_data_exports\n>>> [TrainingDataExport('6565fbf2356124f1daa3acc522')]\nList deployment data quality exports\uf0c1\nTo retrieve successful data quality exports for a deployment, use list_data_quality_exports().\nfrom datarobot.models import Deployment\ndeployment = Deployment.get('66903c40f18e6ec90fd7c8c7')\ndata_quality_exports = deployment.list_data_quality_exports(start='2024-07-01', end='2024-08-01')\ndata_quality_exports\n>>> [DataQualityExport(6447ca39c6a04df6b5b0ed19c6101e3c),\n...\nDataQualityExport(0ff46fd3636545a9ac3e15ee1dbd8638)]\nThere are many filtering and sorting options available.\nSegment Analysis\uf0c1\nSegment analysis is a deployment utility that filters service stats, data drift, and accuracy statistics into unique segment attributes and values.\nUse get_segment_attributes() to retrieve segment analysis data.\nUse get_segment_values() to retrieve segment value data.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsegment_attributes_service_health = deployment.get_segment_attributes(DEPLOYMENT_MONITORING_TYPE.SERVICE_HEALTH)\n>>>['DataRobot-Consumer', 'DataRobot-Host-IP', 'DataRobot-Remote-IP']\nsegment_attributes_data_drift = deployment.get_segment_attributes(DEPLOYMENT_MONITORING_TYPE.DATA_DRIFT)\n>>>['DataRobot-Consumer', 'attribute_1', 'attribute_2']\nsegment_values = deployment.get_segment_values(segmentAttribute=ReservedSegmentAttributes.CONSUMER)\n>>>['DataRobot-Consumer', '[email\u00a0protected]']\nChallengers\uf0c1\nChallenger models can be used to compare the currently deployed model (the \u201cchampion\u201d model) to another model.\nThe following functions can be used to manage deployment\u2019s challenger models:\nList: list_challengers() or list().\nCreate: create().\nGet: get().\nUpdate: update().\nDelete: delete().\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nchallenger = deployment.list_challengers()[-1]\nchallenger.update(name='New Challenger Name')\nchallenger.name\n>>> 'New Challenger Name'\nSettings\uf0c1\nUse get_challenger_models_settings()\nand update_challenger_models_settings()\nto retrieve and update challenger model settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_challenger_models_settings(challenger_models_enabled=True)\nsettings = deployment.get_challenger_models_settings()\nsettings\n>>> {'enabled': True}\nUse get_challenger_replay_settings()\nand update_challenger_replay_settings()\nto retrieve and update challenger replay settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_challenger_replay_settings(enabled=True)\nsettings = deployment.get_challenger_replay_settings()\nsettings['enabled']\n>>> True\nSettings\uf0c1\nDrift Tracking Settings\uf0c1\nDrift tracking is used to help analyze and monitor the performance of a model after it is deployed.\nWhen the model of a deployment is replaced drift tracking status will not be altered.\nUse get_drift_tracking_settings() to retrieve the current tracking status for target drift and feature drift.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_drift_tracking_settings()\nsettings\n>>> {'target_drift': {'enabled': True}, 'feature_drift': {'enabled': True}}\nUse update_drift_tracking_settings() to update target drift and feature drift tracking status.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_drift_tracking_settings(target_drift_enabled=True, feature_drift_enabled=True)\nAssociation ID Settings\uf0c1\nAssociation ID is used to identify predictions, so that when actuals are acquired, accuracy can be calculated.\nUse get_association_id_settings() to retrieve current association ID settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_association_id_settings()\nsettings\n>>> {'column_names': ['application_id'], 'required_in_prediction_requests': True}\nUse update_association_id_settings() to update association ID settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_association_id_settings(column_names=['application_id'], required_in_prediction_requests=True)\nPredictions By Forecast Date\uf0c1\nForecast date setting for the deployment.\nUse get_predictions_by_forecast_date_settings() to retrieve current predictions by forecast date settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_predictions_by_forecast_date_settings()\nsettings\n>>> {'enabled': False, 'column_name': 'date (actual)', 'datetime_format': '%Y-%m-%d'}\nUse update_predictions_by_forecast_date_settings() to update predictions by forecast date settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_predictions_by_forecast_date_settings(\nenable_predictions_by_forecast_date=True,\nforecast_date_column_name='date (actual)',\nforecast_date_format='%Y-%m-%d')\nHealth Settings\uf0c1\nHealth settings APIs can be used to customize definitions for deployment health status.\nUse get_health_settings() to retrieve current health settings,\nand get_default_health_settings() to retrieve default health settings.\nTo perform updates, use update_health_settings().\nimport datarobot as dr\n# get current data drift threshold\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_health_settings()\nsettings['data_drift']['drift_threshold']\n>>> 0.15\n# update accuracy health metric\nsettings['accuracy']['metric'] = 'AUC'\nsettings = deployment.update_health_settings(accuracy=settings['accuracy'])\nsettings['accuracy']['metric']\n>>> 'AUC'\n# set accuracy health metric to default\ndefault_settings = deployment.get_default_health_settings()\nsettings = deployment.update_health_settings(accuracy=default_settings['accuracy'])\nsettings['accuracy']['metric']\n>>> 'LogLoss'\nSegment Analysis Settings\uf0c1\nSegment analysis is a deployment utility that filters data drift and accuracy statistics into unique segment attributes and values.\nUse get_segment_analysis_settings() to retrieve current segment analysis settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_segment_analysis_settings()\nsettings\n>>> {'enabled': False, 'attributes': []}\nUse update_segment_analysis_settings() to update segment analysis settings. Any categorical column can be a segment attribute.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_segment_analysis_settings(\nsegment_analysis_enabled=True,\nsegment_analysis_attributes=[\"country_code\", \"is_customer\"])\nPredictions Data Collection Settings\uf0c1\nPredictions Data Collection configures whether prediction requests and results should be saved to\nPredictions Data Storage.\nUse get_predictions_data_collection_settings() to retrieve current\nsettings of predictions data collection.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_predictions_data_collection_settings()\nsettings\n>>> {'enabled': True}\nUse update_predictions_data_collection_settings() to update predictions data\ncollection settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_predictions_data_collection_settings(enabled=True)\nPrediction Warning Settings\uf0c1\nPrediction Warning is used to enable Humble AI for a deployment which determines if a\nmodel is misbehaving when a prediction goes outside of the calculated boundaries.\nUse get_prediction_warning_settings() to retrieve the current prediction warning settings.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_prediction_warning_settings()\nsettings\n>>> { {'enabled': True}, 'custom_boundaries': {'upper': 1337, 'lower': 0} }\nUse update_prediction_warning_settings() to update current prediction warning settings.\nimport datarobot as dr\n# Set custom boundaries\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_prediction_warning_settings(\nprediction_warning_enabled=True,\nuse_default_boundaries=False,\nlower_boundary=1337,\nupper_boundary=2000,\n)\n# Reset boundaries\ndeployment.update_prediction_warning_settings(\nprediction_warning_enabled=True,\nuse_default_boundaries=True,\n)\nSecondary Dataset Config Settings\uf0c1\nThe secondary dataset config for a deployed Feature discovery model can be replaced and retrieved.\nSecondary dataset config is used to specify which secondary datasets to use during\nprediction for a given deployment.\nUse update_secondary_dataset_config() to update the secondary dataset config.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nconfig = deployment.update_secondary_dataset_config(secondary_dataset_config_id='5f48cb94408673683eca0fab')\nconfig\n>>> '5f48cb94408673683eca0fab'\nUse get_secondary_dataset_config() to get the secondary dataset config.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nconfig = deployment.get_secondary_dataset_config()\nconfig\n>>> '5f48cb94408673683eca0fab'\nShare deployments\uf0c1\nYou can grant or revoke other users\u2019 access to a deployment.\nAccess levels\uf0c1\nFor deployments, there are 3 access levels:\nOWNER - Allows all actions on a deployment.\nUSER - Can see the deployment in the DataRobot UI and see the prediction statistics of the deployment, but cannot edit or delete the deployment.\nCONSUMER - Can only make predictions on the deployment. Cannot see the deployment in the DataRobot UI or retrieve prediction statistics for the deployment in the API.\nSharing\uf0c1\nUse list_shared_roles() to get a list of users, groups, and organizations that\ncurrently have a role on the project. Each role will be returned as a datarobot.models.deployment.DeploymentSharedRole.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'},\n{'role': 'USER', 'id': '5c939e08962d741e34f609f1', 'share_recipient_type': 'group', 'name': 'Example Group'},\n{'role': 'CONSUMER', 'id': '5c939e08962d741e34f609f2', 'share_recipient_type': 'organization', 'name': 'Example Org'}]\nUse update_shared_roles() to grant and revoke roles on the deployment. This function\ntakes a list of datarobot.models.deployment.DeploymentGrantSharedRoleWithId and\ndatarobot.models.deployment.DeploymentGrantSharedRoleWithUsername objects and updates roles accordingly.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'}]\nnew_role = DeploymentGrantSharedRoleWithUsername(username='[email\u00a0protected]', role='OWNER')\nresponse = deployment.update_shared_roles([new_role])\nresponse.status_code\n>>> 204\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'},\n{'role': 'OWNER', 'id': '5c939e08962d741e34f609f1', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'}]\nrevoke_role =  DeploymentGrantSharedRoleWithUsername(username='[email\u00a0protected]', role='NO_ROLE')\nresponse = deployment.update_shared_roles([revoke_role])\nresponse.status_code\n>>> 204\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'}]",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/model_registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/challenger-models.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "create_from_registered_model_version()",
        "registered_model_version_id",
        "datarobot.PredictionServer.list",
        "import datarobot as dr\n\nproject = dr.Project.get('6527eb38b9e5dead5fc12491')\nmodel = project.get_models()[0]\nprediction_server = dr.PredictionServer.list()[0]\n\nregistered_model_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\n    model_id=model.id,\n    name=\"Name of the version(aka model package)\",\n    registered_model_name='Name of the registered model unique across the org '\n)\n\n\n\ndeployment = dr.Deployment.create_from_registered_model_version(\n    registered_model_version.id, label='New Deployment', description='A new deployment',\n    default_prediction_server_id=prediction_server.id)\n>>> Deployment('New Deployment')",
        "import datarobot as dr\n\ndeployments = dr.Deployment.list()\ndeployments\n>>> [Deployment('New Deployment'), Deployment('Previous Deployment')]",
        "import datarobot as dr\n\nfilters = dr.models.deployment.DeploymentListFilters(\n    role='OWNER',\n    accuracy_health=dr.enums.DEPLOYMENT_ACCURACY_HEALTH_STATUS.FAILING\n)\ndeployments = dr.Deployment.list(filters=filters)\ndeployments\n>>> [Deployment('Deployment Owned by Me w/ Failing Accuracy 1'), Deployment('Deployment Owned by Me w/ Failing Accuracy 2')]",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.id\n>>> '5c939e08962d741e34f609f0'\ndeployment.label\n>>> 'New Deployment'",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update(label='new label')",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.delete()",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.activate()\ndeployment.status\n>>> 'active'",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.deactivate()\ndeployment.status\n>>> 'inactive'",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n# To note: `source` can be a file path, a file, or a pandas DataFrame\nprediction_results_as_dataframe = deployment.predict_batch(\n    source=\"./my_local_file.csv\",\n)",
        "MODEL_REPLACEMENT_REASON",
        "import datarobot as dr\nfrom datarobot.enums import MODEL_REPLACEMENT_REASON\n\nproject = dr.Project.get('5cc899abc191a20104ff446a')\nmodel = project.get_models()[0]\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.model['id'], deployment.model['type']\n>>> ('5c0a979859b00004ba52e431', 'Decision Tree Classifier (Gini)')\n\ndeployment.replace_model('5c0a969859b00004ba52e41b', MODEL_REPLACEMENT_REASON.ACCURACY)\ndeployment.model['id'], deployment.model['type']\n>>> ('5c0a969859b00004ba52e41b', 'Support Vector Classifier (Linear Kernel)')",
        "validate_replacement_model()",
        "validate_replacement_model()",
        "import datarobot as dr\n\nproject = dr.Project.get('5cc899abc191a20104ff446a')\nmodel = project.get_models()[0]\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nstatus, message, checks = deployment.validate_replacement_model(new_model_id=model.id)\nstatus\n>>> 'passing'\n\n# `checks` can be inspected for detail, showing two examples here:\nchecks['target']\n>>> {'status': 'passing', 'message': 'Target is compatible.'}\nchecks['permission']\n>>> {'status': 'passing', 'message': 'User has permission to replace model.'}",
        "from datarobot.models import Deployment, ServiceStats\n\ndeployment_id = '5c939e08962d741e34f609f0'\n\n# call `get` functions on a `Deployment` object\ndeployment = Deployment.get(deployment_id)\nservice_stats = deployment.get_service_stats()\n\n# directly fetch without a `Deployment` object\nservice_stats = ServiceStats.get(deployment_id)",
        "from datetime import datetime\nfrom datarobot.enums import SERVICE_STAT_METRIC\nfrom datarobot.helpers.partitioning_methods import construct_duration_string\nfrom datarobot.models import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nservice_stats = deployment.get_service_stats(\n    start_time=datetime(2019, 8, 1, hour=15),\n    end_time=datetime(2019, 8, 8, hour=15)\n)\nservice_stats[SERVICE_STAT_METRIC.TOTAL_PREDICTIONS]\n>>> 12597\n\ntotal_predictions = deployment.get_service_stats_over_time(\n    start_time=datetime(2019, 8, 1, hour=15),\n    end_time=datetime(2019, 8, 8, hour=15),\n    bucket_size=construct_duration_string(days=1),\n    metric=SERVICE_STAT_METRIC.TOTAL_PREDICTIONS\n)\ntotal_predictions.bucket_values\n>>> OrderedDict([(datetime.datetime(2019, 8, 1, 15, 0, tzinfo=tzutc()), 1610),\n                 (datetime.datetime(2019, 8, 2, 15, 0, tzinfo=tzutc()), 2249),\n                 (datetime.datetime(2019, 8, 3, 15, 0, tzinfo=tzutc()), 254),\n                 (datetime.datetime(2019, 8, 4, 15, 0, tzinfo=tzutc()), 943),\n                 (datetime.datetime(2019, 8, 5, 15, 0, tzinfo=tzutc()), 1967),\n                 (datetime.datetime(2019, 8, 6, 15, 0, tzinfo=tzutc()), 2810),\n                 (datetime.datetime(2019, 8, 7, 15, 0, tzinfo=tzutc()), 2775)])",
        "datarobot.models.deployment.TargetDrift",
        "datarobot.models.deployment.FeatureDrift",
        "from datetime import datetime\nfrom datarobot.enums import DATA_DRIFT_METRIC\nfrom datarobot.models import Deployment, FeatureDrift\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ntarget_drift = deployment.get_target_drift(\n    start_time=datetime(2019, 8, 1, hour=15),\n    end_time=datetime(2019, 8, 8, hour=15)\n)\ntarget_drift.drift_score\n>>> 0.00408514\n\nfeature_drift_data = FeatureDrift.list(\n    deployment_id='5c939e08962d741e34f609f0',\n    start_time=datetime(2019, 8, 1, hour=15),\n    end_time=datetime(2019, 8, 8, hour=15),\n    metric=DATA_DRIFT_METRIC.HELLINGER\n)\nfeature_drift = feature_drift_data[0]\nfeature_drift.name\n>>> 'age'\nfeature_drift.drift_score\n>>> 4.16981594",
        "from datetime import datetime\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models import Deployment\n\n# deployment with regression target type\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_over_time(\n    start_time=datetime(2023, 4, 1),\n    end_time=datetime(2023, 4, 30),\n    bucket_size=BUCKET_SIZE.P1D,\n)\npredicted = [bucket['mean_predicted_value'] for bucket in predictions_over_time.buckets]\npredicted\n>>> [0.3772, 0.6642, ...., 0.7937]\n\n# deployment with binary target type\ndeployment = Deployment.get(deployment_id='62fff28a0f5fee488587ce92')\npredictions_over_time = deployment.get_predictions_over_time(\n    start_time=datetime(2023, 4, 1),\n    end_time=datetime(2023, 4, 22),\n    bucket_size=BUCKET_SIZE.P7D,\n)\npredicted = [\n    {item['class_name']: item['value'] for item in bucket['mean_probabilities']}.get('True')\n    for bucket in predictions_over_time.buckets\n]\npredicted\n>>> [0.3955, 0.4274, None]",
        "from datetime import datetime\nfrom datarobot.enums import ACCURACY_METRIC\nfrom datarobot.helpers.partitioning_methods import construct_duration_string\nfrom datarobot.models import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\naccuracy = deployment.get_accuracy(\n    start_time=datetime(2019, 8, 1, hour=15),\n    end_time=datetime(2019, 8, 1, 15, 0)\n)\naccuracy[ACCURACY_METRIC.RMSE]\n>>> 943.225\n\nrmse = deployment.get_accuracy_over_time(\n    start_time=datetime(2019, 8, 1),\n    end_time=datetime(2019, 8, 3),\n    bucket_size=construct_duration_string(days=1),\n    metric=ACCURACY_METRIC.RMSE\n)\nrmse.bucket_values\n>>> OrderedDict([(datetime.datetime(2019, 8, 1, 15, 0, tzinfo=tzutc()), 1777.190657),\n                 (datetime.datetime(2019, 8, 2, 15, 0, tzinfo=tzutc()), 1613.140772)])",
        "from datarobot.enums import ACCURACY_METRIC\nfrom datarobot.models import Deployment\n\naccuracy_over_time = AccuracyOverTime.get_as_dataframe(\n    ram_app.id, [ACCURACY_METRIC.RMSE, ACCURACY_METRIC.GAMMA_DEVIANCE, ACCURACY_METRIC.MAD])",
        "from datetime import datetime\nfrom datarobot.enums import BUCKET_SIZE\nfrom datarobot.models import Deployment\n\n# deployment with regression target type\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\npredictions_over_time = deployment.get_predictions_vs_actuals_over_time(\n    start_time=datetime(2023, 4, 1),\n    end_time=datetime(2023, 4, 30),\n    bucket_size=BUCKET_SIZE.P1D,\n)\npredicted = [bucket['mean_actual_value'] for bucket in predictions_over_time.buckets]\npredicted\n>>> [0.2806, 0.9170, ...., 0.0314]\n\n# deployment with binary target type\ndeployment = Deployment.get(deployment_id='62fff28a0f5fee488587ce92')\npredictions_over_time = deployment.get_predictions_vs_actuals_over_time(\n    start_time=datetime(2023, 4, 1),\n    end_time=datetime(2023, 4, 22),\n    bucket_size=BUCKET_SIZE.P7D,\n)\npredicted = [\n    {item['class_name']: item['value'] for item in bucket['mean_predicted_value']}.get('True')\n    for bucket in predictions_over_time.buckets\n]\npredicted\n>>> [0.5822, 0.6305, None]",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.delete_monitoring_data(model_id=deployment.model['id'])",
        "from datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n\nprediction_data_exports = deployment.list_prediction_data_exports(limit=0)\n\nprediction_data_exports\n>>> [PredictionDataExport('65fbe59aaa3f847bd5acc75b'),\n     PredictionDataExport('65fbe59aaa3f847bd5acc75c'),\n     PredictionDataExport('65fbe59aaa3f847bd5acc75a')]",
        "from datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n\nprediction_data_exports = deployment.list_prediction_data_exports(\n    model_id=\"6444482e5583f6ee2e572265\",\n    batch=False,\n    status=ExportStatus.SUCCEEDED,\n    limit=100,\n    offset=50,\n)",
        "from datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n\nactuals_data_exports = deployment.list_actuals_data_exports(limit=0)\n\nactuals_data_exports\n>>> [ActualsDataExport('660456a332d0081029ee5031'),\n     ActualsDataExport('660456a332d0081029ee5032'),\n     ActualsDataExport('660456a332d0081029ee5033')]",
        "from datarobot.enums import ExportStatus\nfrom datarobot.models import Deployment\n\ndeployment = Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n\n actuals_data_exports = deployment.list_actuals_data_exports(\n    deployment_id='5c939e08962d741e34f609f0',\n    offset=500,\n    limit=50,\n    status=ExportStatus.SUCCEEDED\n)",
        "from datarobot.models.deployment import TrainingDataExport\n\ntraining_data_exports = TrainingDataExport.list(deployment_id='5c939e08962d741e34f609f0')\n\ntraining_data_exports\n>>> [TrainingDataExport('6565fbf2356124f1daa3acc522')]",
        "from datarobot.models import Deployment\n\ndeployment = Deployment.get('66903c40f18e6ec90fd7c8c7')\ndata_quality_exports = deployment.list_data_quality_exports(start='2024-07-01', end='2024-08-01')\n\ndata_quality_exports\n>>> [DataQualityExport(6447ca39c6a04df6b5b0ed19c6101e3c),\n ...\n DataQualityExport(0ff46fd3636545a9ac3e15ee1dbd8638)]",
        "import datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsegment_attributes_service_health = deployment.get_segment_attributes(DEPLOYMENT_MONITORING_TYPE.SERVICE_HEALTH)\n>>>['DataRobot-Consumer', 'DataRobot-Host-IP', 'DataRobot-Remote-IP']\nsegment_attributes_data_drift = deployment.get_segment_attributes(DEPLOYMENT_MONITORING_TYPE.DATA_DRIFT)\n>>>['DataRobot-Consumer', 'attribute_1', 'attribute_2']\nsegment_values = deployment.get_segment_values(segmentAttribute=ReservedSegmentAttributes.CONSUMER)\n>>>['DataRobot-Consumer', '[email\u00a0protected]']",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nchallenger = deployment.list_challengers()[-1]\nchallenger.update(name='New Challenger Name')\nchallenger.name\n>>> 'New Challenger Name'",
        "get_challenger_models_settings()",
        "update_challenger_models_settings()",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_challenger_models_settings(challenger_models_enabled=True)\nsettings = deployment.get_challenger_models_settings()\nsettings\n>>> {'enabled': True}",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_challenger_replay_settings(enabled=True)\nsettings = deployment.get_challenger_replay_settings()\nsettings['enabled']\n>>> True",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_drift_tracking_settings()\nsettings\n>>> {'target_drift': {'enabled': True}, 'feature_drift': {'enabled': True}}",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_drift_tracking_settings(target_drift_enabled=True, feature_drift_enabled=True)",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_association_id_settings()\nsettings\n>>> {'column_names': ['application_id'], 'required_in_prediction_requests': True}",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_association_id_settings(column_names=['application_id'], required_in_prediction_requests=True)",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_predictions_by_forecast_date_settings()\nsettings\n>>> {'enabled': False, 'column_name': 'date (actual)', 'datetime_format': '%Y-%m-%d'}",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_predictions_by_forecast_date_settings(\n    enable_predictions_by_forecast_date=True,\n    forecast_date_column_name='date (actual)',\n    forecast_date_format='%Y-%m-%d')",
        "import datarobot as dr\n\n# get current data drift threshold\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_health_settings()\nsettings['data_drift']['drift_threshold']\n>>> 0.15\n\n# update accuracy health metric\nsettings['accuracy']['metric'] = 'AUC'\nsettings = deployment.update_health_settings(accuracy=settings['accuracy'])\nsettings['accuracy']['metric']\n>>> 'AUC'\n\n# set accuracy health metric to default\ndefault_settings = deployment.get_default_health_settings()\nsettings = deployment.update_health_settings(accuracy=default_settings['accuracy'])\nsettings['accuracy']['metric']\n>>> 'LogLoss'",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_segment_analysis_settings()\nsettings\n>>> {'enabled': False, 'attributes': []}",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_segment_analysis_settings(\n    segment_analysis_enabled=True,\n    segment_analysis_attributes=[\"country_code\", \"is_customer\"])",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_predictions_data_collection_settings()\nsettings\n>>> {'enabled': True}",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_predictions_data_collection_settings(enabled=True)",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nsettings = deployment.get_prediction_warning_settings()\nsettings\n>>> { {'enabled': True}, 'custom_boundaries': {'upper': 1337, 'lower': 0} }",
        "import datarobot as dr\n\n# Set custom boundaries\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\ndeployment.update_prediction_warning_settings(\n    prediction_warning_enabled=True,\n    use_default_boundaries=False,\n    lower_boundary=1337,\n    upper_boundary=2000,\n)\n\n# Reset boundaries\ndeployment.update_prediction_warning_settings(\n    prediction_warning_enabled=True,\n    use_default_boundaries=True,\n)",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nconfig = deployment.update_secondary_dataset_config(secondary_dataset_config_id='5f48cb94408673683eca0fab')\nconfig\n>>> '5f48cb94408673683eca0fab'",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nconfig = deployment.get_secondary_dataset_config()\nconfig\n>>> '5f48cb94408673683eca0fab'",
        "datarobot.models.deployment.DeploymentSharedRole",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'},\n {'role': 'USER', 'id': '5c939e08962d741e34f609f1', 'share_recipient_type': 'group', 'name': 'Example Group'},\n {'role': 'CONSUMER', 'id': '5c939e08962d741e34f609f2', 'share_recipient_type': 'organization', 'name': 'Example Org'}]",
        "datarobot.models.deployment.DeploymentGrantSharedRoleWithId",
        "datarobot.models.deployment.DeploymentGrantSharedRoleWithUsername",
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'}]\n\nnew_role = DeploymentGrantSharedRoleWithUsername(username='[email\u00a0protected]', role='OWNER')\nresponse = deployment.update_shared_roles([new_role])\nresponse.status_code\n>>> 204\n\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'},\n  {'role': 'OWNER', 'id': '5c939e08962d741e34f609f1', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'}]\n\nrevoke_role =  DeploymentGrantSharedRoleWithUsername(username='[email\u00a0protected]', role='NO_ROLE')\nresponse = deployment.update_shared_roles([revoke_role])\nresponse.status_code\n>>> 204\n\nroles = deployment.list_shared_roles()\n[role.to_dict() for role in roles]\n>>> [{'role': 'OWNER', 'id': '5c939e08962d741e34f609f0', 'share_recipient_type': 'user', 'name': '[email\u00a0protected]'}]"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html",
      "title": "MLOps\uf0c1",
      "description": "DataRobot MLOps provides a central hub to deploy, monitor, manage, and govern all your models in production.",
      "content": "MLOps\uf0c1\nDataRobot MLOps provides a central hub to deploy, monitor, manage, and govern all your models in production.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/jobs.html",
      "title": "Jobs\uf0c1",
      "description": "Jobs allow you to run your code as jobs on the DataRobot platform to implement various workloads (tests, metrics etc).",
      "content": "Jobs\uf0c1\nJobs allow you to run your code as jobs on the DataRobot platform to implement various workloads (tests, metrics etc).\nManage jobs\uf0c1\nUse the following commands to manage jobs:\nCreate job\uf0c1\nTo create a job, use dr.registry.Job.create, as shown in the following example:\nimport os\nimport datarobot as dr\n# add files content using `file_data` argument\njob = dr.registry.Job.create(\n\"my-job\",\nenvironment_id=\"65c4f3ed001d3e27a382608f\",\nfile_data={\"run.sh\": \"echo 'hello world'\"},\n)\n# or add files from the folder\njob_folder = \"my-folder/files\"\njob_2 = dr.registry.Job.create(\n\"my-job\",\nenvironment_id=\"65c4f3ed001d3e27a382608f\",\nfolder_path=job_folder,\n)\n# or add files as a list of individual file paths\njob_3 = dr.registry.Job.create(\n\"my-job\",\nenvironment_id=\"65c4f3ed001d3e27a382608f\",\nfiles=[(os.path.join(job_folder, 'run.sh'), 'run.sh')],\n)\n# if the files should be added to the root of the job filesystem with\n# with the same names as on the local file system, the above can be simplified to the following:\njob_4 = dr.registry.Job.create(\n\"my-job\",\nenvironment_id=\"65c4f3ed001d3e27a382608f\",\nfiles=[os.path.join(job_folder, 'run.sh')],\n)\n# or a job can be created without the files,\n# and the files can be added later using the `update` method\njob_5 = dr.registry.Job.create(\"my-job\")\nCreate hosted custom metric job from template\uf0c1\nTo create a hosted custom metric job from gallery template,\nuse dr.registry.Job.create_from_custom_metric_gallery_template, as shown in the following example:\nimport datarobot as dr\ntemplates = dr.models.deployment.custom_metrics.HostedCustomMetricTemplate.list()\ntemplate_id = templates[0].id\njob = dr.registry.Job.create_from_custom_metric_gallery_template(\ntemplate_id = template_id,\nname = \"my-job\",\n)\nList jobs\uf0c1\nTo list all jobs available to the current user, use dr.registry.Job.list, as in the following example:\nimport datarobot as dr\njobs = dr.registry.Job.list()\njobs\n>>> [Job('my-job')]\nRetrieve jobs\uf0c1\nTo get a job by unique identifier, use dr.registry.Job.get, as in the following example:\nimport datarobot as dr\njob = dr.registry.Job.get(\"65f4453e6ea907cb0405ff7f\")\njob\n>>> Job('my-job')\nUpdate jobs\uf0c1\nTo get a job by unique identifier and update it, use dr.registry.Job.get() and then update(), as in the following example:\nimport datarobot as dr\njob = dr.registry.Job.get(\"65f4453e6ea907cb0405ff7f\")\njob.update(\nenvironment_id=\"65c4f3ed001d3e27a382608f\",\ndescription=\"My Job\",\nfolder_path=job_folder,\nfile_data={\"README.md\": \"My README file\"},\n)\nDelete jobs\uf0c1\nTo get a job by unique identifier and delete it, use dr.registry.Job.get() and then delete(), as in the following example:\nimport datarobot as dr\njob = dr.registry.Job.get(\"65f4453e6ea907cb0405ff7f\")\njob.delete()\nManage job runs\uf0c1\nUse the following commands to manage job runs:\nCreate job runs\uf0c1\nTo create a job run, use dr.registry.JobRun.create, as shown in the following example:\nimport datarobot as dr\nimport time\njob_id = \"65f4453e6ea907cb0405ff7f\"\n# block until job run is finished\njob_run = dr.registry.JobRun.create(job_id)\n# or run job without blocking the thread, and check the job run status manually\njob_run = dr.registry.JobRun.create(job_id, max_wait=None)\nwhile job_run.status == dr.registry.JobRunStatus.RUNNING:\ntime.sleep(1)\njob_run.refresh()\nList job runs\uf0c1\nTo list all job runs, use dr.registry.JobRun.list, as in the following example:\nimport datarobot as dr\njob_id = \"65f4453e6ea907cb0405ff7f\"\njob_runs = dr.registry.JobRun.list(job_id)\njob_runs\n>>> [JobRun('65f856957d897d46b0e54b37'),\nJobRun('65f8567f7d897d46b0e54b32'),\nJobRun('65f856617d897d46b0e54b2d')]\nRetrieve job runs\uf0c1\nTo get a job run with an identifier, use dr.registry.JobRun.get, as in the following example:\nimport datarobot as dr\njob_id = \"65f4453e6ea907cb0405ff7f\"\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\njob_run\n>>> JobRun('65f856957d897d46b0e54b37')\nUpdate job runs\uf0c1\nTo get a job run by unique identifier and update it, use dr.registry.JobRun.get() and then update(), as in the following example:\nimport datarobot as dr\njob_id = \"65f4453e6ea907cb0405ff7f\"\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\njob_run.update(description=\"The description of this job run\")\nCancel a job run\uf0c1\nTo get a running job run by identifier and cancel it, use dr.registry.JobRun.get() and then cancel(), as in the following example:\nimport datarobot as dr\njob_id = \"65f4453e6ea907cb0405ff7f\"\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\njob_run.cancel()\nRetrieve job run logs\uf0c1\nTo get job run logs, use dr.registry.JobRun.get_logs, as in the following example:\nimport datarobot as dr\njob_id = \"65f4453e6ea907cb0405ff7f\"\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\njob_run.get_logs()\n>>> 2024-03-18T16:06:46.044946476Z Some log output\nDelete job run logs\uf0c1\nTo delete job run logs, use dr.registry.JobRun.delete_logs, as in the following example:\nimport datarobot as dr\njob_id = \"65f4453e6ea907cb0405ff7f\"\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\njob_run.delete_logs()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "dr.registry.Job.create",
        "import os\nimport datarobot as dr\n\n# add files content using `file_data` argument\njob = dr.registry.Job.create(\n    \"my-job\",\n    environment_id=\"65c4f3ed001d3e27a382608f\",\n    file_data={\"run.sh\": \"echo 'hello world'\"},\n)\n\n# or add files from the folder\njob_folder = \"my-folder/files\"\n\njob_2 = dr.registry.Job.create(\n    \"my-job\",\n    environment_id=\"65c4f3ed001d3e27a382608f\",\n    folder_path=job_folder,\n)\n\n# or add files as a list of individual file paths\njob_3 = dr.registry.Job.create(\n    \"my-job\",\n    environment_id=\"65c4f3ed001d3e27a382608f\",\n    files=[(os.path.join(job_folder, 'run.sh'), 'run.sh')],\n)\n\n# if the files should be added to the root of the job filesystem with\n# with the same names as on the local file system, the above can be simplified to the following:\njob_4 = dr.registry.Job.create(\n    \"my-job\",\n    environment_id=\"65c4f3ed001d3e27a382608f\",\n    files=[os.path.join(job_folder, 'run.sh')],\n)\n\n# or a job can be created without the files,\n# and the files can be added later using the `update` method\njob_5 = dr.registry.Job.create(\"my-job\")",
        "dr.registry.Job.create_from_custom_metric_gallery_template",
        "import datarobot as dr\n\ntemplates = dr.models.deployment.custom_metrics.HostedCustomMetricTemplate.list()\ntemplate_id = templates[0].id\n\njob = dr.registry.Job.create_from_custom_metric_gallery_template(\n    template_id = template_id,\n    name = \"my-job\",\n)",
        "import datarobot as dr\n\njobs = dr.registry.Job.list()\n\njobs\n>>> [Job('my-job')]",
        "import datarobot as dr\n\njob = dr.registry.Job.get(\"65f4453e6ea907cb0405ff7f\")\n\njob\n>>> Job('my-job')",
        "dr.registry.Job.get()",
        "import datarobot as dr\n\njob = dr.registry.Job.get(\"65f4453e6ea907cb0405ff7f\")\n\njob.update(\n    environment_id=\"65c4f3ed001d3e27a382608f\",\n    description=\"My Job\",\n    folder_path=job_folder,\n    file_data={\"README.md\": \"My README file\"},\n)",
        "dr.registry.Job.get()",
        "import datarobot as dr\n\njob = dr.registry.Job.get(\"65f4453e6ea907cb0405ff7f\")\njob.delete()",
        "dr.registry.JobRun.create",
        "import datarobot as dr\nimport time\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\n# block until job run is finished\njob_run = dr.registry.JobRun.create(job_id)\n\n# or run job without blocking the thread, and check the job run status manually\njob_run = dr.registry.JobRun.create(job_id, max_wait=None)\n\nwhile job_run.status == dr.registry.JobRunStatus.RUNNING:\n    time.sleep(1)\n    job_run.refresh()",
        "dr.registry.JobRun.list",
        "import datarobot as dr\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\njob_runs = dr.registry.JobRun.list(job_id)\n\njob_runs\n>>> [JobRun('65f856957d897d46b0e54b37'),\n     JobRun('65f8567f7d897d46b0e54b32'),\n     JobRun('65f856617d897d46b0e54b2d')]",
        "dr.registry.JobRun.get",
        "import datarobot as dr\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\n\njob_run\n>>> JobRun('65f856957d897d46b0e54b37')",
        "dr.registry.JobRun.get()",
        "import datarobot as dr\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\n\njob_run.update(description=\"The description of this job run\")",
        "dr.registry.JobRun.get()",
        "import datarobot as dr\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\n\njob_run.cancel()",
        "dr.registry.JobRun.get_logs",
        "import datarobot as dr\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\n\njob_run.get_logs()\n>>> 2024-03-18T16:06:46.044946476Z Some log output",
        "dr.registry.JobRun.delete_logs",
        "import datarobot as dr\n\njob_id = \"65f4453e6ea907cb0405ff7f\"\n\njob_run = dr.registry.JobRun.get(job_id, \"65f856957d897d46b0e54b37\")\n\njob_run.delete_logs()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/key_values.html",
      "title": "Key Values\uf0c1",
      "description": "Key values associated with a DataRobot model, deployment, job or other DataRobot entities are key-value pairs containing information about the related entity. Each key-value pair has the following:",
      "content": "Key Values\uf0c1\nKey values associated with a DataRobot model, deployment, job or other DataRobot entities are key-value pairs containing information about the related entity. Each key-value pair has the following:\nName: The unique and descriptive name of the key (for the model package or version).\nValue type: The data type of the value associated with the key. The possible types are string, numeric, boolean, URL, image, dataset, pickle, binary, JSON, or YAML.\nCategory: The type of model information provided by the key value. The possible types are training parameter, metric, tag, artifact, and runtime parameter.\nValue: The stored data or file.\nYou can include string, numeric, boolean, image, and dataset key values in custom compliance documentation templates.\nIn addition, with key values for registered models, when you generate compliance documentation for a model package and reference a supported key value in the template, DataRobot inserts the matching values from the associated model package.\nManage Key Values\uf0c1\nUse the following commands to manage key values:\nCreate a Key Value\uf0c1\nTo create a key value, use dr.KeyValue.create, as shown in the following example:\nimport datarobot as dr\nregistered_model_id = \"65ccb597732422fa2297199e\"\nkey_value = dr.KeyValue.create(\nregistered_model_id,\ndr.KeyValueEntityType.REGISTERED_MODEL,\n\"my-kv-name\",\ndr.KeyValueCategory.TAG,\ndr.KeyValueType.STRING,\n\"tag-name\",\n)\nkey_value.id\n>>> '65f32822be17d11dec9ebdfb'\nList Key Values\uf0c1\nTo list all key values available to the current user, use dr.KeyValue.list, as in the following example:\nimport datarobot as dr\nregistered_model_id = \"65ccb597732422fa2297199e\"\nkey_values = dr.KeyValue.list(registered_model_id, dr.KeyValueEntityType.REGISTERED_MODEL)\nkey_values\n>>> [KeyValue('my-kv-name')]\nRetrieve Key Value\uf0c1\nTo get a key value by unique identifier, use dr.KeyValue.get, as in the following example:\nimport datarobot as dr\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\nkey_value\n>>> KeyValue('my-kv-name')\nFind Key Value By Name\uf0c1\nTo find a key value by name, use dr.KeyValue.find. Provide the entity ID, entity type, and key value name, as in the following example:\nimport datarobot as dr\nkey_value = dr.KeyValue.find(\"65f32822be17d11dec9ebdfb\", dr.KeyValueEntityType.REGISTERED_MODEL, \"my-kv-name\")\nkey_value\n>>> KeyValue('my-kv-name')\nUpdate Key Value\uf0c1\nTo get a key value by unique identifier and update it, use dr.KeyValue.get() and then update(), as in the following example:\nimport datarobot as dr\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\nkey_value.update(value=4.7)\nkey_value.update(value_type=dr.KeyValueType.STRING, value=\"abc\")\nkey_value.update(name=\"new-kv-name\")\nGet Key Value Data\uf0c1\nTo get the value from a key value, use dr.KeyValue.get_value(). Provide the key value ID,  as in the following example:\nimport datarobot as dr\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\nkey_value.update(value=4.7)\nkey_value.get_value()\n>>> 4.7\nkey_value.update(value_type=dr.KeyValueType.STRING, value=\"abc\")\nkey_value.get_value()\n>>> \"abc\"\nkey_value.update(value_type=dr.KeyValueType.BOOLEAN, value=True)\nkey_value.get_value()\n>>> True\nDelete Key Value\uf0c1\nTo get a key value by unique identifier and delete it, use dr.KeyValue.get() and then delete(), as in the following example:\nimport datarobot as dr\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\nkey_value.delete()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\nregistered_model_id = \"65ccb597732422fa2297199e\"\n\nkey_value = dr.KeyValue.create(\n    registered_model_id,\n    dr.KeyValueEntityType.REGISTERED_MODEL,\n    \"my-kv-name\",\n    dr.KeyValueCategory.TAG,\n    dr.KeyValueType.STRING,\n    \"tag-name\",\n)\n\nkey_value.id\n>>> '65f32822be17d11dec9ebdfb'",
        "import datarobot as dr\n\nregistered_model_id = \"65ccb597732422fa2297199e\"\n\nkey_values = dr.KeyValue.list(registered_model_id, dr.KeyValueEntityType.REGISTERED_MODEL)\n\nkey_values\n>>> [KeyValue('my-kv-name')]",
        "import datarobot as dr\n\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\n\nkey_value\n>>> KeyValue('my-kv-name')",
        "import datarobot as dr\n\nkey_value = dr.KeyValue.find(\"65f32822be17d11dec9ebdfb\", dr.KeyValueEntityType.REGISTERED_MODEL, \"my-kv-name\")\n\nkey_value\n>>> KeyValue('my-kv-name')",
        "import datarobot as dr\n\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\n\nkey_value.update(value=4.7)\nkey_value.update(value_type=dr.KeyValueType.STRING, value=\"abc\")\nkey_value.update(name=\"new-kv-name\")",
        "dr.KeyValue.get_value()",
        "import datarobot as dr\n\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\n\nkey_value.update(value=4.7)\nkey_value.get_value()\n>>> 4.7\n\nkey_value.update(value_type=dr.KeyValueType.STRING, value=\"abc\")\nkey_value.get_value()\n>>> \"abc\"\n\nkey_value.update(value_type=dr.KeyValueType.BOOLEAN, value=True)\nkey_value.get_value()\n>>> True",
        "import datarobot as dr\n\nkey_value = dr.KeyValue.get(\"65f32822be17d11dec9ebdfb\")\nkey_value.delete()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/model_registry.html",
      "title": "Model Registry\uf0c1",
      "description": "Registered models are generic containers that group multiple versions of models which can be deployed, used as a challenger model, or replace a deployed model.\nEach registered model can have multiple versions. Each version can be created from a DataRobot model, custom model, or external model.\nRegistered models can have versions of different types (leaderboard, custom, or external) simultaneously as long as they have same target properties and time series settings where applicable.",
      "content": "Model Registry\uf0c1\nRegistered models are generic containers that group multiple versions of models which can be deployed, used as a challenger model, or replace a deployed model.\nEach registered model can have multiple versions. Each version can be created from a DataRobot model, custom model, or external model.\nRegistered models can have versions of different types (leaderboard, custom, or external) simultaneously as long as they have same target properties and time series settings where applicable.\nCreate registered model & version\uf0c1\nThe following command can be used to either create a registered model from or add version to the existing model.\nLEADERBOARD_MODEL_ID = \"650c2372c538ffa4480567d1\"\n# passing registered_model_name creates new version\nfirst_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\nmodel_id=LEADERBOARD_MODEL_ID,\nname=\"Name of the version(aka model package)\",\nregistered_model_name='DEMO 3: Name of the registered model unique across the org '\n)\n# add custom model as a version\n# passing registered_model_id adds version to existing registered model\nCUSTOM_MODEL_VERSION_ID = \"619679c86c1abbc2bd628ed1\"\nsecond_version_from_custom = dr.RegisteredModelVersion.create_for_custom_model_version(\ncustom_model_version_id=CUSTOM_MODEL_VERSION_ID,\nregistered_model_id=first_version.registered_model_id,\nname=\"Another Name of the version(aka model package)\",\n)\n# add external model as a version\nsecond_version_from_external = dr.RegisteredModelVersion.create_for_external(\nname='Another name',\ntarget={'name': 'Target', 'type': 'Regression'},\nregistered_model_id=first_version.registered_model_id,\n)\nList and filter registered models\uf0c1\nUse the following command to list registered models.\nYou can filter the registered models that are returned by passing an instance of the\nRegisteredModelListFilters class to the filters keyword argument.\nYou can also filter the registered model versions that are returned by passing an instance of the\nRegisteredModelVersionsListFilters class to the filters keyword argument.\ndemo_registered_models = dr.RegisteredModel.list(search=\"DEMO\")\nregistered_model_filters = dr.models.model_registry.RegisteredModelListFilters(\ncreated_at_start=datetime.datetime(2020, 1, 1),\ncreated_at_end=datetime.datetime(2024, 1, 2),\nmodified_at_start=datetime.datetime(2020, 1, 1),\nmodified_at_end=datetime.datetime(2024, 1, 2),\ntarget_name='readmitted',\ntarget_type='Binary',\ncreated_by='[email\u00a0protected]',\ncompatible_with_model_package_id='650a9f57d3f427ce1cc64747',\nprediction_threshold=0.5,\nimported=False,\nfor_challenger=False,\n)\nregistered_models = dr.RegisteredModel.list(filters=registered_model_filters, search=\"10k\")\nregistered_model = registered_models[0]\nversions = registered_model.list_versions()\n# similarily to registered models, versions also support fine-grain filtering and search\nfilters = dr.models.model_registry.RegisteredModelVersionsListFilters(\ntarget_name='readmitted',\n)\nversions_with_search = registered_model.list_versions(search=\"Elastic\", filters=filters)\nArchive, update and share registered models\uf0c1\nUse the following command to archive registered models. Archiving registered models archives all the versions of the registered model.\nREGISTERED_MODEL_ID = \"651bd2317aed25ed7d4bca7f\"\ndr.RegisteredModel.archive(REGISTERED_MODEL_ID)\nUse the following command to update registered models.\nREGISTERED_MODEL_ID = \"651bd2317aed25ed7d4bca7f\"\ndr.RegisteredModel.update(REGISTERED_MODEL_ID, name=\"New name\")\nThe following commands can be used to share registered models with other users or groups or retrieve existing roles on the deployment.\nregistered_model = dr.RegisteredModel.get('645b62d5373ed49b485d73e9')\n# EXISTING ROLES\nroles = registered_model.get_shared_roles()\nrole = dr.SharingRole(\nshare_recipient_type=\"user\",\nid='5ca19879a950d002c61ea3e7',\nrole=\"USER\",\n)\nregistered_model.share([role])\nList deployments associated with a registered model\uf0c1\nUse the following command to list deployments associated with registered model. The deployment is considered associated if one of the versions of the registered model is either a champion or a challenger model.\nmodel_with_deployments = dr.RegisteredModel.get('65035d911e9ff5b07f00f2ea')\n# we can list deployments associated with this registered model. Method is searchable and paginated.\nmodel_associated_deployments = model_with_deployments.list_associated_deployments()\n# we can also list deployments associated with specific version of the registered model\nversion = model_with_deployments.list_versions()[1]\nversion.list_associated_deployments()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "LEADERBOARD_MODEL_ID = \"650c2372c538ffa4480567d1\"\n# passing registered_model_name creates new version\nfirst_version = dr.RegisteredModelVersion.create_for_leaderboard_item(\n    model_id=LEADERBOARD_MODEL_ID,\n    name=\"Name of the version(aka model package)\",\n    registered_model_name='DEMO 3: Name of the registered model unique across the org '\n)\n# add custom model as a version\n# passing registered_model_id adds version to existing registered model\nCUSTOM_MODEL_VERSION_ID = \"619679c86c1abbc2bd628ed1\"\nsecond_version_from_custom = dr.RegisteredModelVersion.create_for_custom_model_version(\n    custom_model_version_id=CUSTOM_MODEL_VERSION_ID,\n    registered_model_id=first_version.registered_model_id,\n    name=\"Another Name of the version(aka model package)\",\n)\n\n# add external model as a version\nsecond_version_from_external = dr.RegisteredModelVersion.create_for_external(\n    name='Another name',\n    target={'name': 'Target', 'type': 'Regression'},\n    registered_model_id=first_version.registered_model_id,\n)",
        "RegisteredModelListFilters",
        "RegisteredModelVersionsListFilters",
        "demo_registered_models = dr.RegisteredModel.list(search=\"DEMO\")\nregistered_model_filters = dr.models.model_registry.RegisteredModelListFilters(\n    created_at_start=datetime.datetime(2020, 1, 1),\n    created_at_end=datetime.datetime(2024, 1, 2),\n    modified_at_start=datetime.datetime(2020, 1, 1),\n    modified_at_end=datetime.datetime(2024, 1, 2),\n    target_name='readmitted',\n    target_type='Binary',\n    created_by='[email\u00a0protected]',\n    compatible_with_model_package_id='650a9f57d3f427ce1cc64747',\n    prediction_threshold=0.5,\n    imported=False,\n    for_challenger=False,\n)\nregistered_models = dr.RegisteredModel.list(filters=registered_model_filters, search=\"10k\")\nregistered_model = registered_models[0]\nversions = registered_model.list_versions()\n# similarily to registered models, versions also support fine-grain filtering and search\nfilters = dr.models.model_registry.RegisteredModelVersionsListFilters(\n    target_name='readmitted',\n)\nversions_with_search = registered_model.list_versions(search=\"Elastic\", filters=filters)",
        "REGISTERED_MODEL_ID = \"651bd2317aed25ed7d4bca7f\"\ndr.RegisteredModel.archive(REGISTERED_MODEL_ID)",
        "REGISTERED_MODEL_ID = \"651bd2317aed25ed7d4bca7f\"\ndr.RegisteredModel.update(REGISTERED_MODEL_ID, name=\"New name\")",
        "registered_model = dr.RegisteredModel.get('645b62d5373ed49b485d73e9')\n# EXISTING ROLES\nroles = registered_model.get_shared_roles()\n\nrole = dr.SharingRole(\n    share_recipient_type=\"user\",\n    id='5ca19879a950d002c61ea3e7',\n    role=\"USER\",\n)\nregistered_model.share([role])",
        "model_with_deployments = dr.RegisteredModel.get('65035d911e9ff5b07f00f2ea')\n# we can list deployments associated with this registered model. Method is searchable and paginated.\nmodel_associated_deployments = model_with_deployments.list_associated_deployments()\n# we can also list deployments associated with specific version of the registered model\nversion = model_with_deployments.list_versions()[1]\nversion.list_associated_deployments()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/blueprint.html",
      "title": "Blueprints\uf0c1",
      "description": "Blueprints are a set of computation paths that a dataset passes through before producing\npredictions from data. A blueprint can be trained on a dataset to generate a model.",
      "content": "Blueprints\uf0c1\nBlueprints are a set of computation paths that a dataset passes through before producing\npredictions from data. A blueprint can be trained on a dataset to generate a model.\nTo modify blueprints using Python, reference the Blueprint Workshop documentation.\nThe following code block summarizes the interactions available for blueprints.\n# Get the set of blueprints recommended by datarobot\nimport datarobot as dr\nmy_projects = dr.Project.list()\nproject = my_projects[0]\nmenu = project.get_blueprints()\nfirst_blueprint = menu[0]\nproject.train(first_blueprint)\nList blueprints\uf0c1\nWhen you upload a file to a project and set a target, you receive a set of recommended blueprints that are appropriate for the task at hand.\nUse get_blueprints to get the list of blueprints recommended for a project:\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nmenu = project.get_blueprints()\nblueprint = menu[0]\nGet a blueprint\uf0c1\nIf you already have a blueprint_id from a model you can retrieve the blueprint directly.\nproject_id = '5506fcd38bd88f5953219da0'\nproject = dr.Project.get(project_id)\nmodels = project.get_models()\nmodel = models[0]\nblueprint = Blueprint.get(project_id, model.blueprint_id)\nGet a blueprint chart\uf0c1\nYou can retrieve charts for all blueprints that are either from a blueprint menu or are already used in a model. You can also get a blueprint\u2019s representation in Graphviz DOT format to render it into the format you need.\nproject_id = '5506fcd38bd88f5953219da0'\nblueprint_id = '4321fcd38bd88f595321554223'\nbp_chart = BlueprintChart.get(project_id, blueprint_id)\nprint(bp_chart.to_graphviz())\nGet blueprint documentation\uf0c1\nYou can retrieve documentation for tasks used in a blueprint. The documentation contains information about\nthe task, its parameters, and links and references to additional sources. All documents are instances of the BlueprintTaskDocument class.\nproject_id = '5506fcd38bd88f5953219da0'\nblueprint_id = '4321fcd38bd88f595321554223'\nbp = Blueprint.get(project_id, blueprint_id)\ndocs = bp.get_documents()\nprint(docs[0].task)\n>>> Average Blend\nprint(docs[0].links[0]['url'])\n>>> https://en.wikipedia.org/wiki/Ensemble_learning\nBlueprint attributes\uf0c1\nThe Blueprint class holds the data required to use the blueprint\nfor modeling. This includes the blueprint_id and project_id.\nThere are also two attributes that help distinguish blueprints: model_type\nand processes.\nprint(blueprint.id)\n>>> u'8956e1aeecffa0fa6db2b84640fb3848'\nprint(blueprint.project_id)\n>>> u5506fcd38bd88f5953219da0'\nprint(blueprint.model_type)\n>>> Logistic Regression\nprint(blueprint.processes)\n>>> [u'One-Hot Encoding',\nu'Missing Values Imputed',\nu'Standardize',\nu'Logistic Regression']\nBuild a model from a blueprint\uf0c1\nYou can also use a blueprint to train a model. The model is trained on the associated project\u2019s dataset by default.\nNote that Project.train is used for non-datetime partitioned projects.\nProject.train_datetime should be used for datetime partitioned\nprojects.\nmodel_job_id = project.train(blueprint)\n# For datetime partitioned projects\nmodel_job = project.train_datetime(blueprint.id)\nBoth Project.train and Project.train_datetime\nwill put a new modeling job into the queue. However, note that Project.train returns the ID of the created\nModelJob, while Project.train_datetime returns the ModelJob object itself.\nYou can pass a ModelJob ID to wait_for_async_model_creation function,\nwhich polls the async model creation status and returns the newly created model when it\u2019s finished.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://docs.datarobot.com/en/docs/api/reference/bp-workshop/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/blueprints.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/job.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "# Get the set of blueprints recommended by datarobot\nimport datarobot as dr\nmy_projects = dr.Project.list()\nproject = my_projects[0]\nmenu = project.get_blueprints()\n\nfirst_blueprint = menu[0]\nproject.train(first_blueprint)",
        "project = dr.Project.get('5506fcd38bd88f5953219da0')\nmenu = project.get_blueprints()\nblueprint = menu[0]",
        "project_id = '5506fcd38bd88f5953219da0'\nproject = dr.Project.get(project_id)\nmodels = project.get_models()\nmodel = models[0]\nblueprint = Blueprint.get(project_id, model.blueprint_id)",
        "project_id = '5506fcd38bd88f5953219da0'\nblueprint_id = '4321fcd38bd88f595321554223'\nbp_chart = BlueprintChart.get(project_id, blueprint_id)\nprint(bp_chart.to_graphviz())",
        "project_id = '5506fcd38bd88f5953219da0'\nblueprint_id = '4321fcd38bd88f595321554223'\nbp = Blueprint.get(project_id, blueprint_id)\ndocs = bp.get_documents()\nprint(docs[0].task)\n>>> Average Blend\nprint(docs[0].links[0]['url'])\n>>> https://en.wikipedia.org/wiki/Ensemble_learning",
        "print(blueprint.id)\n>>> u'8956e1aeecffa0fa6db2b84640fb3848'\nprint(blueprint.project_id)\n>>> u5506fcd38bd88f5953219da0'\nprint(blueprint.model_type)\n>>> Logistic Regression\nprint(blueprint.processes)\n>>> [u'One-Hot Encoding',\n     u'Missing Values Imputed',\n     u'Standardize',\n     u'Logistic Regression']",
        "Project.train_datetime",
        "model_job_id = project.train(blueprint)\n\n# For datetime partitioned projects\nmodel_job = project.train_datetime(blueprint.id)",
        "Project.train_datetime",
        "Project.train_datetime"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
      "title": "Modeling\uf0c1",
      "description": "The Modeling section provides information to help you easily navigate the process of building, understanding, and analyzing models.",
      "content": "Modeling\uf0c1\nThe Modeling section provides information to help you easily navigate the process of building, understanding, and analyzing models.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/external_testset.html",
      "title": "External Testset\uf0c1",
      "description": "Testing with external datasets allows better evaluation model performance, you can compute metric\nscores and insights on external test dataset to ensure consistent performance prior to deployment.",
      "content": "External Testset\uf0c1\nTesting with external datasets allows better evaluation model performance, you can compute metric\nscores and insights on external test dataset to ensure consistent performance prior to deployment.\nNote\nNot available for Time series models.\nRequesting External Scores and Insights\uf0c1\nTo compute scores and insights on a dataset\nUpload a prediction dataset that contains the target column PredictionDataset.contains_target_values == True.\nDataset should be in the same structure as the original project.\nimport datarobot as dr\n# Upload dataset\nproject = dr.Project(project_id)\ndataset = project.upload_dataset('./test_set.csv')\ndataset.contains_target_values\n>>>True\n# request external test to compute metric scores and insights on dataset\n# select model using project.get_models()\nexternal_test_job = model.request_external_test(dataset.id)\n# once job is complete, scores and insights are ready for retrieving\nexternal_test_job.wait_for_completion()\nRetrieving External Metric Scores and Insights\uf0c1\nAfter completion of external test job, metric scores and insights for external testsets will be ready.\nNote\nPlease check PredictionDataset.data_quality_warnings for dataset warnings.\nInsights are not available if dataset is too small (less than 10 rows).\nROC curve cannot be calculated if dataset has only one class in target column\nRetrieving External Metric Scores\uf0c1\nimport datarobot as dr\n# retrieving list of external metric scores on multiple datasets\nmetric_scores_list = dr.ExternalScores.list(project_id, model_id)\n# retrieving external metric scores on one dataset\nmetric_scores = dr.ExternalScores.get(project_id, model_id, dataset_id)\nRetrieving External Lift Chart\uf0c1\nimport datarobot as dr\n# retrieving list of lift charts on multiple datasets\nlift_list = dr.ExternalLiftChart.list(project_id, model_id)\n# retrieving one lift chart for dataset\nlift = dr.ExternalLiftChart.get(project_id, model_id, dataset_id)\nRetrieving External Multiclass Lift Chart\uf0c1\nLift chart for Multiclass models only\nimport datarobot as dr\n# retrieving list of lift charts on multiple datasets\nlift_list = ExternalMulticlassLiftChart.list(project_id, model_id)\n# retrieving one lift chart for dataset and a target class\nlift = ExternalMulticlassLiftChart.get(project_id, model_id, dataset_id, target_class)\nRetrieving External ROC Curve\uf0c1\nAvailable for Binary classification models only\nimport datarobot as dr\n# retrieving list of roc curves on multiple datasets\nroc_list = ExternalRocCurve.list(project_id, model_id)\n# retrieving one ROC curve for dataset\nroc = ExternalRocCurve.get(project_id, model_id, dataset_id)\nRetrieving Multiclass Confusion Matrix\uf0c1\nAvailable for Multiclass classification models only\nimport datarobot as dr\n# retrieving list of confusion charts on multiple datasets\nconfusion_list = ExternalConfusionChart.list(project_id, model_id)\n# retrieving one confusion chart for dataset\nconfusion = ExternalConfusionChart.get(project_id, model_id, dataset_id)\nRetrieving Residuals Chart\uf0c1\nAvailable for Regression models only\nimport datarobot as dr\n# retrieving list of residuals charts on multiple datasets\nresiduals_list = ExternalResidualsChart.list(project_id, model_id)\n# retrieving one residuals chart for dataset\nresiduals = ExternalResidualsChart.get(project_id, model_id, dataset_id)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n# Upload dataset\nproject = dr.Project(project_id)\ndataset = project.upload_dataset('./test_set.csv')\ndataset.contains_target_values\n>>>True\n# request external test to compute metric scores and insights on dataset\n# select model using project.get_models()\nexternal_test_job = model.request_external_test(dataset.id)\n# once job is complete, scores and insights are ready for retrieving\nexternal_test_job.wait_for_completion()",
        "import datarobot as dr\n# retrieving list of external metric scores on multiple datasets\nmetric_scores_list = dr.ExternalScores.list(project_id, model_id)\n# retrieving external metric scores on one dataset\nmetric_scores = dr.ExternalScores.get(project_id, model_id, dataset_id)",
        "import datarobot as dr\n# retrieving list of lift charts on multiple datasets\nlift_list = dr.ExternalLiftChart.list(project_id, model_id)\n# retrieving one lift chart for dataset\nlift = dr.ExternalLiftChart.get(project_id, model_id, dataset_id)",
        "import datarobot as dr\n# retrieving list of lift charts on multiple datasets\nlift_list = ExternalMulticlassLiftChart.list(project_id, model_id)\n# retrieving one lift chart for dataset and a target class\nlift = ExternalMulticlassLiftChart.get(project_id, model_id, dataset_id, target_class)",
        "import datarobot as dr\n# retrieving list of roc curves on multiple datasets\nroc_list = ExternalRocCurve.list(project_id, model_id)\n# retrieving one ROC curve for dataset\nroc = ExternalRocCurve.get(project_id, model_id, dataset_id)",
        "import datarobot as dr\n# retrieving list of confusion charts on multiple datasets\nconfusion_list = ExternalConfusionChart.list(project_id, model_id)\n# retrieving one confusion chart for dataset\nconfusion = ExternalConfusionChart.get(project_id, model_id, dataset_id)",
        "import datarobot as dr\n# retrieving list of residuals charts on multiple datasets\nresiduals_list = ExternalResidualsChart.list(project_id, model_id)\n# retrieving one residuals chart for dataset\nresiduals = ExternalResidualsChart.get(project_id, model_id, dataset_id)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/automated_documentation.html",
      "title": "Automated Documentation\uf0c1",
      "description": "DataRobot can generate Automated Documentation about various entities within the platform, such\nas specific models or projects. These reports can be downloaded and shared to help with\nregulatory compliance as well as to provide a general understanding of the AI lifecycle.",
      "content": "Automated Documentation\uf0c1\nDataRobot can generate Automated Documentation about various entities within the platform, such\nas specific models or projects. These reports can be downloaded and shared to help with\nregulatory compliance as well as to provide a general understanding of the AI lifecycle.\nCheck Available Document Types\uf0c1\nAutomated Documentation is available behind different feature flags set up according to your POC\nsettings or subscription plan. MODEL_COMPLIANCE documentation is a premium add-on DataRobot\nproduct, while AUTOPILOT_SUMMARY report is available behind an optional feature flag for\nSelf-Service and other platforms.\nimport datarobot as dr\n# Connect to your DataRobot platform with your token\ndr.Client(token=my_token, endpoint=endpoint)\noptions = dr.AutomatedDocument.list_available_document_types()\nIn response, you get a data dictionary with a list of document types that are available for\ngeneration with your account.\nGenerate Automated Documents\uf0c1\nNow that you know which documents you can generate, create one with AutomatedDocument .generate method. Note that for AUTOPILOT_SUMMARY report, you need to assign a project ID\nto the entity_id parameter, while MODEL_COMPLIANCE expects an ID of a model with the\nentity_id parameter.\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc_type = \"AUTOPILOT_SUMMARY\"\nentity_id = \"5e8b6a34d2426053ab9a39ed\"  #  This is an ID of a project\nfile_format=\"docx\"\ndoc = dr.AutomatedDocument(document_type=doc_type, entity_id=entity_id, output_format=file_format)\ndoc.generate()\nYou can specify other attributes. For example, filepath presets the file location and name to\nuse when downloading the document. Please see the API Reference for more details.\nDownload Automated Documents\uf0c1\nIf you followed the steps above to generate an automated document, you can use the\nAutomatedDocument.download method right away to get the document.\ndoc.filepath = \"Users/jeremy/DR_project_docs/autopilot_report_staff_2021.docx\"\ndoc.download()\nYou can set a desired filepath (that includes the future file\u2019s name) before you download a\ndocument. Otherwise, it will be automatically downloaded to the directory from which you launched\nyour script.\nPlease note that to download the document, you need its ID. When you generate a document with the\nPython client, the ID is set automatically without your interference. However, if the document\nhas already been generated from the application interface (or REST API) and you want to download\nit using the Python client, you need to provide the ID of the document you want to download:\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc_id = \"604f81f0f3d6397d250c35bc\"\npath = \"Users/jeremy/DR_project_docs/xgb_model_doc_staff_project_2021.docx\"\ndoc = dr.AutomatedDocument(id=doc_id, filepath=path)\ndoc.download()\nList Previously Generated Automated Documents\uf0c1\nYou can retrieve information about previously generated documents available for your account. The\ninformation includes document ID and type, ID of the entity it was generated for, time of\ncreation, and other information. Documents are sorted by creation time  \u2013 created_at key \u2013\nfrom most recent to oldest.\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = dr.AutomatedDocument.list_generated_documents()\nThis returns list of AutomatedDocument objects. You can request a list of specific documents.\nFor example, get a list of all MODEL_COMPLIANCE documents:\nmodel_docs = dr.AutomatedDocument.list_generated_documents(document_types=[\"MODEL_COMPLIANCE\"])\nOr get a list of documents created for specific entities:\notv_project_reports = dr.AutomatedDocument.list_generated_documents(\nentity_ids=[\"604f81f0f3d6397d250c35bc\", \"5ed60de32f18d97d250c3db5\"]\n)\nFor more information about all query options, see AutomatedDocument .list_generated_documents in the API Reference.\nDelete Automated Documents\uf0c1\nTo delete a document from the DataRobot application, use the AutomatedDocument.delete method.\nimport datarobot as dr\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(id=\"604f81f0f3d6397d250c35bc\")\ndoc.delete()\nAll locally saved automated documents will remain intact.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/compliance-documentation.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\n# Connect to your DataRobot platform with your token\ndr.Client(token=my_token, endpoint=endpoint)\noptions = dr.AutomatedDocument.list_available_document_types()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ndoc_type = \"AUTOPILOT_SUMMARY\"\nentity_id = \"5e8b6a34d2426053ab9a39ed\"  #  This is an ID of a project\nfile_format=\"docx\"\n\ndoc = dr.AutomatedDocument(document_type=doc_type, entity_id=entity_id, output_format=file_format)\ndoc.generate()",
        "doc.filepath = \"Users/jeremy/DR_project_docs/autopilot_report_staff_2021.docx\"\ndoc.download()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\n\ndoc_id = \"604f81f0f3d6397d250c35bc\"\npath = \"Users/jeremy/DR_project_docs/xgb_model_doc_staff_project_2021.docx\"\ndoc = dr.AutomatedDocument(id=doc_id, filepath=path)\ndoc.download()",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndocs = dr.AutomatedDocument.list_generated_documents()",
        "model_docs = dr.AutomatedDocument.list_generated_documents(document_types=[\"MODEL_COMPLIANCE\"])",
        "otv_project_reports = dr.AutomatedDocument.list_generated_documents(\n    entity_ids=[\"604f81f0f3d6397d250c35bc\", \"5ed60de32f18d97d250c3db5\"]\n    )",
        "import datarobot as dr\n\ndr.Client(token=my_token, endpoint=endpoint)\ndoc = dr.AutomatedDocument(id=\"604f81f0f3d6397d250c35bc\")\ndoc.delete()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html",
      "title": "Model Insights\uf0c1",
      "description": "The Modeling section provides information to help you easily navigate the process of building, understanding, and analyzing models.",
      "content": "Model Insights\uf0c1\nThe Modeling section provides information to help you easily navigate the process of building, understanding, and analyzing models.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/rating_table.html",
      "title": "Rating Table\uf0c1",
      "description": "A rating table is an exportable csv representation of a Generalized Additive Model. They contain\ninformation about the features and coefficients used to make predictions. Users can influence\npredictions by downloading and editing values in a rating table, then re-uploading the table and\nusing it to create a new model.",
      "content": "Rating Table\uf0c1\nA rating table is an exportable csv representation of a Generalized Additive Model. They contain\ninformation about the features and coefficients used to make predictions. Users can influence\npredictions by downloading and editing values in a rating table, then re-uploading the table and\nusing it to create a new model.\nSee the page about interpreting Generalized Additive Models\u2019 output in the DataRobot user guide for\nmore details on how to interpret and edit rating tables.\nDownload A Rating Table\uf0c1\nYou can retrieve a rating table from the list of rating tables in a project:\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nproject = dr.Project.get(project_id)\nrating_tables = project.get_rating_tables()\nrating_table = rating_tables[0]\nOr you can retrieve a rating table from a specific model. The model must already exist:\nimport datarobot as dr\nfrom datarobot.models import RatingTableModel, RatingTable\nproject_id = '5506fcd38bd88f5953219da0'\nproject = dr.Project.get(project_id)\n# Get model from list of models with a rating table\nrating_table_models = project.get_rating_table_models()\nrating_table_model = rating_table_models[0]\n# Or retrieve model by id. The model must have a rating table.\nmodel_id = '5506fcd98bd88f1641a720a3'\nrating_table_model = dr.RatingTableModel.get(project=project_id, model_id=model_id)\n# Then retrieve the rating table from the model\nrating_table_id = rating_table_model.rating_table_id\nrating_table = dr.RatingTable.get(projcet_id, rating_table_id)\nThen you can download the contents of the rating table:\nrating_table.download('./my_rating_table.csv')\nUploading A Rating Table\uf0c1\nAfter you\u2019ve retrieved the rating table CSV and made the necessary edits, you\ncan re-upload the CSV so you can create a new model from it:\njob = dr.RatingTable.create(project_id, model_id, './my_rating_table.csv')\nnew_rating_table = job.get_result_when_complete()\njob = new_rating_table.create_model()\nmodel = job.get_result_when_complete()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nproject = dr.Project.get(project_id)\nrating_tables = project.get_rating_tables()\nrating_table = rating_tables[0]",
        "import datarobot as dr\nfrom datarobot.models import RatingTableModel, RatingTable\nproject_id = '5506fcd38bd88f5953219da0'\nproject = dr.Project.get(project_id)\n\n# Get model from list of models with a rating table\nrating_table_models = project.get_rating_table_models()\nrating_table_model = rating_table_models[0]\n\n# Or retrieve model by id. The model must have a rating table.\nmodel_id = '5506fcd98bd88f1641a720a3'\nrating_table_model = dr.RatingTableModel.get(project=project_id, model_id=model_id)\n\n# Then retrieve the rating table from the model\nrating_table_id = rating_table_model.rating_table_id\nrating_table = dr.RatingTable.get(projcet_id, rating_table_id)",
        "job = dr.RatingTable.create(project_id, model_id, './my_rating_table.csv')\nnew_rating_table = job.get_result_when_complete()\njob = new_rating_table.create_model()\nmodel = job.get_result_when_complete()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/prediction_explanations.html",
      "title": "Prediction Explanations\uf0c1",
      "description": "To compute prediction explanations you need to have feature impact\ncomputed for a model, and predictions for an uploaded dataset\ncomputed with a selected model.",
      "content": "Prediction Explanations\uf0c1\nTo compute prediction explanations you need to have feature impact\ncomputed for a model, and predictions for an uploaded dataset\ncomputed with a selected model.\nComputing prediction explanations is a resource-intensive task, but you can configure it with\nmaximum explanations per row and prediction value thresholds to speed up the process.\nQuick Reference\uf0c1\nimport datarobot as dr\n# Get project\nmy_projects = dr.Project.list()\nproject = my_projects[0]\n# Get model\nmodels = project.get_models()\nmodel = models[0]\n# Compute feature impact\nfeature_impacts = model.get_or_request_feature_impact()\n# Upload dataset\ndataset = project.upload_dataset('./data_to_predict.csv')\n# Compute predictions\npredict_job = model.request_predictions(dataset.id)\npredict_job.wait_for_completion()\n# Initialize prediction explanations\npei_job = dr.PredictionExplanationsInitialization.create(project.id, model.id)\npei_job.wait_for_completion()\n# Compute prediction explanations with default parameters\npe_job = dr.PredictionExplanations.create(project.id, model.id, dataset.id)\npe = pe_job.get_result_when_complete()\n# Iterate through predictions with prediction explanations\nfor row in pe.get_rows():\nprint(row.prediction)\nprint(row.prediction_explanations)\n# download to a CSV file\npe.download_to_csv('prediction_explanations.csv')\nList Prediction Explanations\uf0c1\nYou can use the PredictionExplanations.list() method to return a list of prediction\nexplanations computed for a project\u2019s models:\nimport datarobot as dr\nprediction_explanations = dr.PredictionExplanations.list('58591727100d2b57196701b3')\nprint(prediction_explanations)\n>>> [PredictionExplanations(id=585967e7100d2b6afc93b13b,\nproject_id=58591727100d2b57196701b3,\nmodel_id=585932c5100d2b7c298b8acf),\nPredictionExplanations(id=58596bc2100d2b639329eae4,\nproject_id=58591727100d2b57196701b3,\nmodel_id=585932c5100d2b7c298b8ac5),\nPredictionExplanations(id=58763db4100d2b66759cc187,\nproject_id=58591727100d2b57196701b3,\nmodel_id=585932c5100d2b7c298b8ac5),\n...]\npe = prediction_explanations[0]\npe.project_id\n>>> u'58591727100d2b57196701b3'\npe.model_id\n>>> u'585932c5100d2b7c298b8acf'\nYou can pass following parameters to filter the result:\nmodel_id \u2013 str, used to filter returned prediction explanations by model_id.\nlimit \u2013 int, limit for number of items returned, default: no limit.\noffset \u2013 int, number of items to skip, default: 0.\nList Prediction Explanations Example:\nproject_id = '58591727100d2b57196701b3'\nmodel_id = '585932c5100d2b7c298b8acf'\ndr.PredictionExplanations.list(project_id, model_id=model_id, limit=20, offset=100)\nInitialize Prediction Explanations\uf0c1\nIn order to compute prediction explanations you have to initialize it for a particular model.\ndr.PredictionExplanationsInitialization.create(project_id, model_id)\nCompute Prediction Explanations on New Data\uf0c1\nIf all prerequisites are in place, you can compute prediction explanations in the following way:\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\ndataset_id = '5506fcd98bd88a8142b725c8'\npe_job = dr.PredictionExplanations.create(project_id, model_id, dataset_id,\nmax_explanations=2, threshold_low=0.2, threshold_high=0.8)\npe = pe_job.get_result_when_complete()\nWhere:\nmax_explanations are the maximum number of prediction explanations to compute for each row.\nthreshold_low and threshold_high are thresholds for the value of the prediction of the\nrow. Prediction explanations will be computed for a row if the row\u2019s prediction value is higher\nthan threshold_high or lower than threshold_low. If no thresholds are specified,\nprediction explanations will be computed for all rows.\nCompute Prediction Explanations on Training Data\uf0c1\nTo compute Prediction Explanations on training data, use the code snippet below.\nThe prerequisites are generally the same as computing on newly uploaded data:\nFeature Impact calculations must have completed.\nPrediction Explanations must be initialized.\nPredictions on training data must first be computed for the model.\nThe dataset_id parameter is the ID of the feature list that was used to train the model.\nimport datarobot as dr\nproject_id = '67771742b4d4cf44277b1ff0'\nmodel_id = '677859cfeaea57c1bc9a150a'\nmodel = dr.Model.get(project_id, model_id)\ndataset_id = model.featurelist_id\n# Request feature impact if not done yet.\nmodel.request_feature_impact()\n# Request training predictions for the model if not done yet.\n# The subset 'all' includes training, validation, and holdout data.\nmodel.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\n# Initialize explanations.\ndr.PredictionExplanationsInitialization.create(project_id, model_id)\n# Request and download explanations for the full training data.\npe_job = dr.PredictionExplanations.create_on_training_data(project_id, model_id, dataset_id)\nresult = pe_job.get_result_when_done()\ndf = result.get_all_as_dataframe()\nRetrieving Prediction Explanations\uf0c1\nYou have three options for retrieving prediction explanations.\nNote\nPredictionExplanations.get_all_as_dataframe() and\nPredictionExplanations.download_to_csv() reformat\nprediction explanations to match the schema of CSV file downloaded from UI (RowId,\nPrediction, Explanation 1 Strength, Explanation 1 Feature, Explanation 1 Value, \u2026,\nExplanation N Strength, Explanation N Feature, Explanation N Value)\nGet prediction explanations rows one by one as\nPredictionExplanationsRow\nobjects:\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\nfor row in pe.get_rows():\nprint(row.prediction_explanations)\nGet all rows as pandas.DataFrame:\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\nprediction_explanations_df = pe.get_all_as_dataframe()\nDownload all rows to a file as CSV document:\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\npe.download_to_csv('prediction_explanations.csv')\nAdjusted Predictions In Prediction Explanations\uf0c1\nIn some projects such as insurance projects, the prediction adjusted by exposure is more useful\ncompared with raw prediction. For example, the raw prediction (e.g. claim counts) is divided by\nexposure (e.g. time) in the project with exposure column. The adjusted prediction provides insights\nwith regard to the predicted claim counts per unit of time. To include that information, set\nexclude_adjusted_predictions to False in correspondent method calls.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\npe.download_to_csv('prediction_explanations.csv', exclude_adjusted_predictions=False)\nprediction_explanations_df = pe.get_all_as_dataframe(exclude_adjusted_predictions=False)\nMulticlass/Clustering Prediction Explanation Modes\uf0c1\nWhen calculating prediction explanations for the multiclass or clustering model you need to specify\nwhich classes should be explained in each row. By default we only explain the predicted class but\nit can be set with the mode parameter of PredictionExplanations.create\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\ndataset_id = '5506fcd98bd88a8142b725c8'\n# Explain predicted and second-best class results in each row\npe_job = dr.PredictionExplanations.create(project_id, model_id, dataset_id,\nmode=dr.models.TopPredictionsMode(2))\npe = pe_job.get_result_when_complete()\n# Explain results for classes \"setosa\" and \"versicolor\" in each row\npe_job = dr.PredictionExplanations.create(project_id, model_id, dataset_id,\nmode=dr.models.ClassListMode([\"setosa\", \"versicolor\"]))\npe = pe_job.get_result_when_complete()\nSHAP based prediction explanations\uf0c1\nThere are two types of SHAP prediction explanations available, universal SHAP explanations and\nmodel-specific SHAP explanations. All models support universal SHAP explanations, which use the\npermutation based explainer algorithm. Selected models support SHAP explanations such as the tree-based\nexplainer or kernel explainer.\nUniversal SHAP explanations can be computed and retrieved very simply and do not require any pre-requisites. They\ncan be computed for any available partition, and can be restricted to specific data slices.\nimport datarobot as dr\nfrom datarobot.insights import ShapMatrix\nproject_id = '5ea6d3354cfad121cf33a5e1'\nmodel_id = '5ea6d38b4cfad121cf33a60d'\nproject = dr.Project.get(project_id)\nmodel = dr.Model.get(project=project_id, model_id=model_id)\n# Additional parameters can be passed to specify the partition,\n# data slice, and other parametrers.\nshap_insight = ShapMatrix.create(model_id)\n# Get all computed SHAP matrices\nall_shap_insights = ShapMatrix.list(model_id)\n# Retrieve the SHAP matrix as a numpy array\nmatrix = shap_insight.matrix\n# Retrieve the SHAP matrix columns\ncolumns = shap_insight.columns\n# Retrieve the SHAP base value for additivity checks\nbase_value = shap_insight.base_value\nYou can request model-specific SHAP based prediction explanations using previously uploaded scoring dataset for\nsupported models. Unlike for XEMP prediction explanations you do not need to have\nfeature impact computed for a model, and predictions for an\nuploaded dataset. See datarobot.models.ShapMatrix.create() reference\nfor a description of the types of parameters that can be passed in.\nimport datarobot as dr\nproject_id = '5ea6d3354cfad121cf33a5e1'\nmodel_id = '5ea6d38b4cfad121cf33a60d'\nproject = dr.Project.get(project_id)\nmodel = dr.Model.get(project=project_id, model_id=model_id)\n# check if model supports SHAP\nmodel_capabilities = model.get_supported_capabilities()\nprint(model_capabilities.get('supportsShap'))\n>>> True\n# upload dataset to generate prediction explanations\ndataset_from_path = project.upload_dataset('./data_to_predict.csv')\nshap_matrix_job = ShapMatrix.create(project_id=project_id, model_id=model_id, dataset_id=dataset_from_path.id)\nshap_matrix_job\n>>> Job(shapMatrix, status=inprogress)\n# wait for job to finish\nshap_matrix = shap_matrix_job.get_result_when_complete()\nshap_matrix\n>>> ShapMatrix(id='5ea84b624cfad1361c53f65d', project_id='5ea6d3354cfad121cf33a5e1', model_id='5ea6d38b4cfad121cf33a60d', dataset_id='5ea84b464cfad1361c53f655')\n# retrieve SHAP matrix as pandas.DataFrame\ndf = shap_matrix.get_as_dataframe()\n# list as available SHAP matrices for a project\nshap_matrices = dr.ShapMatrix.list(project_id)\nshap_matrices\n>>> [ShapMatrix(id='5ea84b624cfad1361c53f65d', project_id='5ea6d3354cfad121cf33a5e1', model_id='5ea6d38b4cfad121cf33a60d', dataset_id='5ea84b464cfad1361c53f655')]\nshap_matrix = shap_matrices[0]\n# retrieve SHAP matrix as pandas.DataFrame\ndf = shap_matrix.get_as_dataframe()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/model.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/insights.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n# Get project\nmy_projects = dr.Project.list()\nproject = my_projects[0]\n# Get model\nmodels = project.get_models()\nmodel = models[0]\n# Compute feature impact\nfeature_impacts = model.get_or_request_feature_impact()\n# Upload dataset\ndataset = project.upload_dataset('./data_to_predict.csv')\n# Compute predictions\npredict_job = model.request_predictions(dataset.id)\npredict_job.wait_for_completion()\n# Initialize prediction explanations\npei_job = dr.PredictionExplanationsInitialization.create(project.id, model.id)\npei_job.wait_for_completion()\n# Compute prediction explanations with default parameters\npe_job = dr.PredictionExplanations.create(project.id, model.id, dataset.id)\npe = pe_job.get_result_when_complete()\n# Iterate through predictions with prediction explanations\nfor row in pe.get_rows():\n    print(row.prediction)\n    print(row.prediction_explanations)\n# download to a CSV file\npe.download_to_csv('prediction_explanations.csv')",
        "import datarobot as dr\nprediction_explanations = dr.PredictionExplanations.list('58591727100d2b57196701b3')\nprint(prediction_explanations)\n>>> [PredictionExplanations(id=585967e7100d2b6afc93b13b,\n                 project_id=58591727100d2b57196701b3,\n                 model_id=585932c5100d2b7c298b8acf),\n     PredictionExplanations(id=58596bc2100d2b639329eae4,\n                 project_id=58591727100d2b57196701b3,\n                 model_id=585932c5100d2b7c298b8ac5),\n     PredictionExplanations(id=58763db4100d2b66759cc187,\n                 project_id=58591727100d2b57196701b3,\n                 model_id=585932c5100d2b7c298b8ac5),\n     ...]\npe = prediction_explanations[0]\n\npe.project_id\n>>> u'58591727100d2b57196701b3'\npe.model_id\n>>> u'585932c5100d2b7c298b8acf'",
        "project_id = '58591727100d2b57196701b3'\nmodel_id = '585932c5100d2b7c298b8acf'\ndr.PredictionExplanations.list(project_id, model_id=model_id, limit=20, offset=100)",
        "dr.PredictionExplanationsInitialization.create(project_id, model_id)",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\ndataset_id = '5506fcd98bd88a8142b725c8'\npe_job = dr.PredictionExplanations.create(project_id, model_id, dataset_id,\n                               max_explanations=2, threshold_low=0.2, threshold_high=0.8)\npe = pe_job.get_result_when_complete()",
        "import datarobot as dr\nproject_id = '67771742b4d4cf44277b1ff0'\nmodel_id = '677859cfeaea57c1bc9a150a'\nmodel = dr.Model.get(project_id, model_id)\ndataset_id = model.featurelist_id\n# Request feature impact if not done yet.\nmodel.request_feature_impact()\n# Request training predictions for the model if not done yet.\n# The subset 'all' includes training, validation, and holdout data.\nmodel.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\n# Initialize explanations.\ndr.PredictionExplanationsInitialization.create(project_id, model_id)\n# Request and download explanations for the full training data.\npe_job = dr.PredictionExplanations.create_on_training_data(project_id, model_id, dataset_id)\nresult = pe_job.get_result_when_done()\ndf = result.get_all_as_dataframe()",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\nfor row in pe.get_rows():\n    print(row.prediction_explanations)",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\nprediction_explanations_df = pe.get_all_as_dataframe()",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\npe.download_to_csv('prediction_explanations.csv')",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nprediction_explanations_id = '5506fcd98bd88f1641a720a3'\npe = dr.PredictionExplanations.get(project_id, prediction_explanations_id)\npe.download_to_csv('prediction_explanations.csv', exclude_adjusted_predictions=False)\nprediction_explanations_df = pe.get_all_as_dataframe(exclude_adjusted_predictions=False)",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\ndataset_id = '5506fcd98bd88a8142b725c8'\n# Explain predicted and second-best class results in each row\npe_job = dr.PredictionExplanations.create(project_id, model_id, dataset_id,\n                                          mode=dr.models.TopPredictionsMode(2))\npe = pe_job.get_result_when_complete()\n# Explain results for classes \"setosa\" and \"versicolor\" in each row\npe_job = dr.PredictionExplanations.create(project_id, model_id, dataset_id,\n                                          mode=dr.models.ClassListMode([\"setosa\", \"versicolor\"]))\npe = pe_job.get_result_when_complete()",
        "import datarobot as dr\nfrom datarobot.insights import ShapMatrix\n\nproject_id = '5ea6d3354cfad121cf33a5e1'\nmodel_id = '5ea6d38b4cfad121cf33a60d'\nproject = dr.Project.get(project_id)\nmodel = dr.Model.get(project=project_id, model_id=model_id)\n\n# Additional parameters can be passed to specify the partition,\n# data slice, and other parametrers.\nshap_insight = ShapMatrix.create(model_id)\n\n# Get all computed SHAP matrices\nall_shap_insights = ShapMatrix.list(model_id)\n\n# Retrieve the SHAP matrix as a numpy array\nmatrix = shap_insight.matrix\n\n# Retrieve the SHAP matrix columns\ncolumns = shap_insight.columns\n\n# Retrieve the SHAP base value for additivity checks\nbase_value = shap_insight.base_value",
        "datarobot.models.ShapMatrix.create()",
        "import datarobot as dr\nproject_id = '5ea6d3354cfad121cf33a5e1'\nmodel_id = '5ea6d38b4cfad121cf33a60d'\nproject = dr.Project.get(project_id)\nmodel = dr.Model.get(project=project_id, model_id=model_id)\n# check if model supports SHAP\nmodel_capabilities = model.get_supported_capabilities()\nprint(model_capabilities.get('supportsShap'))\n>>> True\n# upload dataset to generate prediction explanations\ndataset_from_path = project.upload_dataset('./data_to_predict.csv')\n\nshap_matrix_job = ShapMatrix.create(project_id=project_id, model_id=model_id, dataset_id=dataset_from_path.id)\nshap_matrix_job\n>>> Job(shapMatrix, status=inprogress)\n# wait for job to finish\nshap_matrix = shap_matrix_job.get_result_when_complete()\nshap_matrix\n>>> ShapMatrix(id='5ea84b624cfad1361c53f65d', project_id='5ea6d3354cfad121cf33a5e1', model_id='5ea6d38b4cfad121cf33a60d', dataset_id='5ea84b464cfad1361c53f655')\n\n# retrieve SHAP matrix as pandas.DataFrame\ndf = shap_matrix.get_as_dataframe()\n\n# list as available SHAP matrices for a project\nshap_matrices = dr.ShapMatrix.list(project_id)\nshap_matrices\n>>> [ShapMatrix(id='5ea84b624cfad1361c53f65d', project_id='5ea6d3354cfad121cf33a5e1', model_id='5ea6d38b4cfad121cf33a60d', dataset_id='5ea84b464cfad1361c53f655')]\n\nshap_matrix = shap_matrices[0]\n# retrieve SHAP matrix as pandas.DataFrame\ndf = shap_matrix.get_as_dataframe()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/shap_insights.html",
      "title": "SHAP insights\uf0c1",
      "description": "SHAP is an open-source method for explaining the predictions from machine learning models.\n(You can find more information about SHAP at its repository on GitHub: https://github.com/slundberg/shap)\nDataRobot supports SHAP computations for all regression and binary classification blueprints. You can\ncompute three different insights:",
      "content": "SHAP insights\uf0c1\nSHAP is an open-source method for explaining the predictions from machine learning models.\n(You can find more information about SHAP at its repository on GitHub: https://github.com/slundberg/shap)\nDataRobot supports SHAP computations for all regression and binary classification blueprints. You can\ncompute three different insights:\n\u201cSHAP matrix\u201d: Raw SHAP values for each feature column and each row.\n\u201cSHAP impact\u201d: Overall importance for each feature column across all rows, based on aggregated\nSHAP matrix values.\n\u201cSHAP preview\u201d: SHAP values for the most important features in each row, presented with the values\nof the features in that row.\nThe following example code assumes that you have a trained model object called model.\nimport datarobot as dr\nfrom datarobot.insights.shap_matrix import ShapMatrix\nfrom datarobot.insights.shap_impact import ShapImpact\nfrom datarobot.insights.shap_preview import ShapPreview\nmodel_id = model.id  # or model_id = 'YOUR_MODEL_ID'\n# request SHAP Matrix, and wait for it to complete\nresult = ShapMatrix.create(entity_id=model_id)  # default source is 'validation'\n# view the properties of the SHAP Matrix\nprint(result.columns)\n>>> ['AUCGUART', 'Color', 'Make', ...\nprint(result.matrix)\n>>> [[ 1.22604372e-02  1.98424454e-01  2.23308013e-01  ...] ... ]\n# request SHAP Matrix on a different partition, and return immediately with job reference\njob = ShapMatrix.compute(entity_id=model_id, source='holdout')\n# wait for the job to complete\nresult = job.get_result_when_complete()\nprint(result.columns)\n>>> ['AUCGUART', 'Color', 'Make', ...\nprint(result.matrix)\n>>> [[-0.11443075 -0.01130723  0.22330801 ... ] ... ]\n# request SHAP Impact; only works for training currently\njob = ShapImpact.compute(entity_id=model_id, source='training', row_count=100)\nresult = job.get_result_when_complete()\n# Impacts are listed as [feature_name, normalized_impact, unnormalized_impact]\nprint(result.shap_impacts)\n>>> [['AUCGUART', 0.07989059458051094, 0.022147886593333888], ...]\n# list all matrices computed for this model, including each partition\nmatrix_list = ShapMatrix.list(entity_id=model_id)\nprint(matrix_list)\n>>> [<datarobot.insights.shap_matrix.ShapMatrix object at 0x114e52090>, ...]\nprint([(matrix_obj, matrix_obj.source) for matrix_obj in matrix_list])\n>>> [(<datarobot.insights.shap_matrix.ShapMatrix object at 0x114e52090>, 'validation'), ... ]\n# upload a file to the AI Catalog\ndataset = dr.Dataset.upload(\"./path/to/dataset.csv\")\n# request explanations for that file in the \"preview\" format\njob = ShapPreview.compute(entity_id=model_id, source='externalTestSet', external_dataset_id=dataset.id)\nresult = job.get_result_when_complete()\nprint(result.previews[0])\n>>> {'row_index': 0,\n>>> 'prediction_value': 0.3024851286385187,\n>>>  'preview_values': [{'feature_rank': 1,\n>>>    'feature_name': 'BYRNO',\n>>>    'feature_value': '21973',\n>>>    'shap_value': 0.22025144078391848,\n>>>    'has_text_explanations': False,\n>>>    'text_explanations': []},\n>>> ... }\nSHAP insights for custom models\uf0c1\nYou can compute SHAP insights for custom models, not just native DataRobot models. To do this, first\ncomplete the following setup:\nCreate a custom model version with an execution environment and a training dataset; note the version ID.\nRegister the custom model version as a registered model.\nInitialize the registered model for insights, using the AutomatedDocument.initialize_model_compliance method.\nAt this point, the model is ready for SHAP insights computation. Once these steps are completed for\na given registered model version, they do not have to be repeated.\nAs an example, the code snippet below outlines the preparation steps and then requests a ShapMatrix\ncomputation on an external dataset via the AI Catalog. It assumes that you have a Scoring Code file,\nmodel.jar, for the custom model, which you will run using the Java drop-in execution environment,\nas well as a training dataset called training.csv.\nimport datarobot as dr\nfrom datarobot.insights.shap_matrix import ShapMatrix\n# 1: create a custom model version with an execution environment and a training dataset, and note the version id\nmodel_args = {\n\"target_type\": dr.TARGET_TYPE.REGRESSION,\n\"target_name\": \"time_in_hospital\",\n\"language\": \"java\",\n}\ntraining_dataset = dr.Dataset.create_from_file(file_path=\"path/to/training.csv\")\nexecution_environment = dr.ExecutionEnvironment.list(search_for=\"java\")[0]\ncustom_model = dr.CustomInferenceModel.create(\nname=\"model.jar\",\n**model_args,\n)\ncustom_model_version = dr.CustomModelVersion.create_clean(\ncustom_model_id=custom_model.id,\nbase_environment_id=execution_environment.id,\ntraining_dataset_id=dataset.id,\nfiles=[(\"path/to/model.jar\", \"model.jar\")],\n)\ncustom_model_version_id = custom_model_version.id\n# 2. register the custom model version as a registered model\nregistered_model = dr.RegisteredModelVersion.create_for_custom_model_version(\ncustom_model_version_id=custom_model_version.id, name=model_name, registered_model_name=model_name\n)\n# 3. initialize the registered model for insights\nautodocs = dr.AutomatedDocument(\nentity_id=registered_model.id,\ndocument_type=\"MODEL_COMPLIANCE\",\n)\nautodocs.initialize_model_compliance()\nassert autodocs.is_model_compliance_initialized[0]\n# Add the scoring dataset to the AI catalog\nscoring_dataset = dr.Dataset.create_from_file(file_path=\"path/to/scoring_dataset.csv\")\n# Request the ShapMatrix computation, and retrieve results when it finishes\njob = ShapMatrix.compute(\nentity_id=custom_model_version_id,\nsource='externalTestSet',\nexternal_dataset_id=scoring_dataset.id,\nentity_type=\"customModel\",\n)\nresult = job.get_result_when_complete()\nprint(result.columns)\n>>> ['AUCGUART', 'Color', 'Make', ...\nprint(result.matrix)\n>>> [[ 1.22604372e-02  1.98424454e-01  2.23308013e-01  ...] ... ]",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/insights/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nfrom datarobot.insights.shap_matrix import ShapMatrix\nfrom datarobot.insights.shap_impact import ShapImpact\nfrom datarobot.insights.shap_preview import ShapPreview\nmodel_id = model.id  # or model_id = 'YOUR_MODEL_ID'\n# request SHAP Matrix, and wait for it to complete\nresult = ShapMatrix.create(entity_id=model_id)  # default source is 'validation'\n# view the properties of the SHAP Matrix\nprint(result.columns)\n>>> ['AUCGUART', 'Color', 'Make', ...\nprint(result.matrix)\n>>> [[ 1.22604372e-02  1.98424454e-01  2.23308013e-01  ...] ... ]\n# request SHAP Matrix on a different partition, and return immediately with job reference\njob = ShapMatrix.compute(entity_id=model_id, source='holdout')\n# wait for the job to complete\nresult = job.get_result_when_complete()\nprint(result.columns)\n>>> ['AUCGUART', 'Color', 'Make', ...\nprint(result.matrix)\n>>> [[-0.11443075 -0.01130723  0.22330801 ... ] ... ]\n# request SHAP Impact; only works for training currently\njob = ShapImpact.compute(entity_id=model_id, source='training', row_count=100)\nresult = job.get_result_when_complete()\n# Impacts are listed as [feature_name, normalized_impact, unnormalized_impact]\nprint(result.shap_impacts)\n>>> [['AUCGUART', 0.07989059458051094, 0.022147886593333888], ...]\n# list all matrices computed for this model, including each partition\nmatrix_list = ShapMatrix.list(entity_id=model_id)\nprint(matrix_list)\n>>> [<datarobot.insights.shap_matrix.ShapMatrix object at 0x114e52090>, ...]\nprint([(matrix_obj, matrix_obj.source) for matrix_obj in matrix_list])\n>>> [(<datarobot.insights.shap_matrix.ShapMatrix object at 0x114e52090>, 'validation'), ... ]\n# upload a file to the AI Catalog\ndataset = dr.Dataset.upload(\"./path/to/dataset.csv\")\n# request explanations for that file in the \"preview\" format\njob = ShapPreview.compute(entity_id=model_id, source='externalTestSet', external_dataset_id=dataset.id)\nresult = job.get_result_when_complete()\nprint(result.previews[0])\n>>> {'row_index': 0,\n>>> 'prediction_value': 0.3024851286385187,\n>>>  'preview_values': [{'feature_rank': 1,\n>>>    'feature_name': 'BYRNO',\n>>>    'feature_value': '21973',\n>>>    'shap_value': 0.22025144078391848,\n>>>    'has_text_explanations': False,\n>>>    'text_explanations': []},\n>>> ... }",
        "AutomatedDocument.initialize_model_compliance",
        "import datarobot as dr\nfrom datarobot.insights.shap_matrix import ShapMatrix\n\n# 1: create a custom model version with an execution environment and a training dataset, and note the version id\nmodel_args = {\n    \"target_type\": dr.TARGET_TYPE.REGRESSION,\n    \"target_name\": \"time_in_hospital\",\n    \"language\": \"java\",\n}\ntraining_dataset = dr.Dataset.create_from_file(file_path=\"path/to/training.csv\")\nexecution_environment = dr.ExecutionEnvironment.list(search_for=\"java\")[0]\n\ncustom_model = dr.CustomInferenceModel.create(\n    name=\"model.jar\",\n    **model_args,\n)\n\ncustom_model_version = dr.CustomModelVersion.create_clean(\n    custom_model_id=custom_model.id,\n    base_environment_id=execution_environment.id,\n    training_dataset_id=dataset.id,\n    files=[(\"path/to/model.jar\", \"model.jar\")],\n)\ncustom_model_version_id = custom_model_version.id\n\n# 2. register the custom model version as a registered model\nregistered_model = dr.RegisteredModelVersion.create_for_custom_model_version(\n    custom_model_version_id=custom_model_version.id, name=model_name, registered_model_name=model_name\n)\n\n# 3. initialize the registered model for insights\nautodocs = dr.AutomatedDocument(\n    entity_id=registered_model.id,\n    document_type=\"MODEL_COMPLIANCE\",\n)\nautodocs.initialize_model_compliance()\nassert autodocs.is_model_compliance_initialized[0]\n\n# Add the scoring dataset to the AI catalog\nscoring_dataset = dr.Dataset.create_from_file(file_path=\"path/to/scoring_dataset.csv\")\n\n# Request the ShapMatrix computation, and retrieve results when it finishes\njob = ShapMatrix.compute(\n    entity_id=custom_model_version_id,\n    source='externalTestSet',\n    external_dataset_id=scoring_dataset.id,\n    entity_type=\"customModel\",\n)\nresult = job.get_result_when_complete()\nprint(result.columns)\n>>> ['AUCGUART', 'Color', 'Make', ...\nprint(result.matrix)\n>>> [[ 1.22604372e-02  1.98424454e-01  2.23308013e-01  ...] ... ]"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/job.html",
      "title": "Jobs\uf0c1",
      "description": "The Job class is a generic representation of jobs running\nin a project\u2019s queue.  Many tasks for modeling, such as creating a new model or\ncomputing Feature Impact for a model, use a job to track the worker usage and progress of\nthe associated task.",
      "content": "Jobs\uf0c1\nThe Job class is a generic representation of jobs running\nin a project\u2019s queue.  Many tasks for modeling, such as creating a new model or\ncomputing Feature Impact for a model, use a job to track the worker usage and progress of\nthe associated task.\nCheck the contents of the queue\uf0c1\nTo see what jobs running or waiting in the queue for a project, use the Project.get_all_jobs\nmethod.\nfrom datarobot.enums import QUEUE_STATUS\njobs_list = project.get_all_jobs()  # gives all jobs queued or inprogress\njobs_by_type = {}\nfor job in jobs_list:\nif job.job_type not in jobs_by_type:\njobs_by_type[job.job_type] = [0, 0]\nif job.status == QUEUE_STATUS.QUEUE:\njobs_by_type[job.job_type][0] += 1\nelse:\njobs_by_type[job.job_type][1] += 1\nfor type in jobs_by_type:\n(num_queued, num_inprogress) = jobs_by_type[type]\nprint('{} jobs: {} queued, {} inprogress'.format(type, num_queued, num_inprogress))\nCancel a job\uf0c1\nIf a job is taking too long to run or no longer necessary, it can be cancelled from the\nJob object.\nfrom datarobot.enums import QUEUE_STATUS\nproject.pause_autopilot()\nbad_jobs = project.get_all_jobs(status=QUEUE_STATUS.QUEUE)\nfor job in bad_jobs:\njob.cancel()\nproject.unpause_autopilot()\nRetrieve results from a job\uf0c1\nYou can retrieve the results of a job once it is complete. Note that the type of the returned\nobject varies depending on the job_type. All return types\nare documented in Job.get_result.\nfrom datarobot.enums import JOB_TYPE\ntime_to_wait = 60 * 60  # how long to wait for the job to finish (in seconds) - i.e. an hour\nassert my_job.job_type == JOB_TYPE.MODEL\nmy_model = my_job.get_result_when_complete(max_wait=time_to_wait)\nModel jobs\uf0c1\nModel creation is an asynchronous process. This means that when explicitly invoking\nnew model creation (with project.train or model.train for example), all you get\nis the ID of the process responsible for model creation. With this ID, you can\nget info about the model that is being created\u2014or the model itself, once\nthe creation process is finished\u2014by using the ModelJob class.\nGet an existing model job\uf0c1\nTo retrieve existing model jobs, use the ModelJob.get method.\nFor this, you need the ID of the project from which the model was built and the ID of the model job.\nThe model job is useful if you want to know the parameters for a model\u2019s creation (automatically chosen by the API backend)\nbefore the actual model was created.\nIf the model is already created, ModelJob.get will raise the PendingJobFinished exception.\nimport time\nimport datarobot as dr\nblueprint_id = '5506fcd38bd88f5953219da0'\nmodel_job_id = project.train(blueprint_id)\nmodel_job = dr.ModelJob.get(project_id=project.id,\nmodel_job_id=model_job_id)\nmodel_job.sample_pct\n>>> 64.0\n# wait for model to be created (in a very inefficient way)\ntime.sleep(10 * 60)\nmodel_job = dr.ModelJob.get(project_id=project.id,\nmodel_job_id=model_job_id)\n>>> datarobot.errors.PendingJobFinished\n# get the job attached to the model\nmodel_job.model\n>>> Model('5d518cd3962d741512605e2b')\nGet a created model\uf0c1\nAfter a model is created, you can use ModelJob.get_model to get the newly-created model.\nimport datarobot as dr\nmodel = dr.ModelJob.get_model(project_id=project.id,\nmodel_job_id=model_job_id)\nAsync model creation\uf0c1\nIf you want to get the created model after getting the model job ID, you\ncan use the wait_for_async_model_creation function.\nIt will poll for the status of the model creation process until it\u2019s finished, and\nthen return the newly-created model. Note the differences below between datetime partitioned projects and\nnon-datetime partitioned projects.\nfrom datarobot.models.modeljob import wait_for_async_model_creation\n# Used during training based on blueprint\nmodel_job_id = project.train(blueprint, sample_pct=33)\nnew_model = wait_for_async_model_creation(\nproject_id=project.id,\nmodel_job_id=model_job_id,\n)\n# Used during training based on existing model\nmodel_job_id = existing_model.train(sample_pct=33)\nnew_model = wait_for_async_model_creation(\nproject_id=existing_model.project_id,\nmodel_job_id=model_job_id,\n)\n# For datetime-partitioned projects, use project.train_datetime. Note that train_datetime returns a model job instead\n# of just an ID.\nmodel_job = project.train_datetime(blueprint)\nnew_model = wait_for_async_model_creation(\nproject_id=project.id,\nmodel_job_id=model_job.id\n)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "from datarobot.enums import QUEUE_STATUS\n\njobs_list = project.get_all_jobs()  # gives all jobs queued or inprogress\njobs_by_type = {}\nfor job in jobs_list:\n    if job.job_type not in jobs_by_type:\n        jobs_by_type[job.job_type] = [0, 0]\n    if job.status == QUEUE_STATUS.QUEUE:\n        jobs_by_type[job.job_type][0] += 1\n    else:\n        jobs_by_type[job.job_type][1] += 1\nfor type in jobs_by_type:\n    (num_queued, num_inprogress) = jobs_by_type[type]\n    print('{} jobs: {} queued, {} inprogress'.format(type, num_queued, num_inprogress))",
        "from datarobot.enums import QUEUE_STATUS\n\nproject.pause_autopilot()\nbad_jobs = project.get_all_jobs(status=QUEUE_STATUS.QUEUE)\nfor job in bad_jobs:\n    job.cancel()\nproject.unpause_autopilot()",
        "from datarobot.enums import JOB_TYPE\n\ntime_to_wait = 60 * 60  # how long to wait for the job to finish (in seconds) - i.e. an hour\nassert my_job.job_type == JOB_TYPE.MODEL\nmy_model = my_job.get_result_when_complete(max_wait=time_to_wait)",
        "import time\n\nimport datarobot as dr\n\nblueprint_id = '5506fcd38bd88f5953219da0'\nmodel_job_id = project.train(blueprint_id)\nmodel_job = dr.ModelJob.get(project_id=project.id,\n                            model_job_id=model_job_id)\nmodel_job.sample_pct\n>>> 64.0\n\n# wait for model to be created (in a very inefficient way)\ntime.sleep(10 * 60)\nmodel_job = dr.ModelJob.get(project_id=project.id,\n                            model_job_id=model_job_id)\n>>> datarobot.errors.PendingJobFinished\n\n# get the job attached to the model\nmodel_job.model\n>>> Model('5d518cd3962d741512605e2b')",
        "import datarobot as dr\n\nmodel = dr.ModelJob.get_model(project_id=project.id,\n                              model_job_id=model_job_id)",
        "from datarobot.models.modeljob import wait_for_async_model_creation\n\n# Used during training based on blueprint\nmodel_job_id = project.train(blueprint, sample_pct=33)\nnew_model = wait_for_async_model_creation(\n    project_id=project.id,\n    model_job_id=model_job_id,\n)\n\n# Used during training based on existing model\nmodel_job_id = existing_model.train(sample_pct=33)\nnew_model = wait_for_async_model_creation(\n    project_id=existing_model.project_id,\n    model_job_id=model_job_id,\n)\n\n# For datetime-partitioned projects, use project.train_datetime. Note that train_datetime returns a model job instead\n# of just an ID.\nmodel_job = project.train_datetime(blueprint)\nnew_model = wait_for_async_model_creation(\n    project_id=project.id,\n    model_job_id=model_job.id\n)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/model_recommendation.html",
      "title": "Model recommendation\uf0c1",
      "description": "During Autopilot, DataRobot recommends a model for deployment based on its accuracy and complexity.",
      "content": "Model recommendation\uf0c1\nDuring Autopilot, DataRobot recommends a model for deployment based on its accuracy and complexity.\nWhen running Autopilot in Full or Comprehensive mode, DataRobot uses the following deployment preparation process:\nFirst, DataRobot calculates Feature Impact for the selected model and uses it to generate a reduced feature list.\nNext, DataRobot retrains the selected model on the reduced feature list. If the new model performs better than the original model, DataRobot uses the new model for the next stage. Otherwise, the original model is used.\nDataRobot then retrains the selected model at an up-to-holdout sample size (typically 80%). As long as the sample is under the frozen threshold (1.5GB), the stage is not frozen.\nFinally, DataRobot retrains the selected model as a frozen run (hyperparameters are not changed from the up-to-holdout run) using a 100% sample size and selects it as Recommended for Deployment.\nNote\nThe higher sample size DataRobot uses in Step 3 is either:\nUp to holdout if the training sample size does not exceed the maximum Autopilot size threshold: sample size is the training set plus the validation set (for TVH) or 5-folds (for CV). In this case, DataRobot compares retrained and original models on the holdout score.\nUp to validation if the training sample size does exceed the maximum Autopilot size threshold: sample size is the training set (for TVH) or 4-folds (for CV). In this case, DataRobot compares retrained and original models on the validation score.\nDataRobot gives one model the Recommended for Deployment* badge. This is the most accurate individual, non-blender model on the Leaderboard. After completing the steps described above, it will receive the Prepared for Deployment badge.\nRetrieve all recommendations\uf0c1\nThe following code will return all models recommended for the project.\nimport datarobot as dr\nrecommendations = dr.ModelRecommendation.get_all(project_id)\nRetrieve a default recommendation\uf0c1\nIf you are unsure about the tradeoffs between the various types of recommendations, DataRobot can make this choice\nfor you. The following route will return the \u201cRecommended for Deployment\u201d model to use for predictions for the project.\nimport datarobot as dr\nrecommendation = dr.ModelRecommendation.get(project_id)\nRetrieve a specific recommendation\uf0c1\nIf you know which recommendation you want to use, you can select a specific recommendation using the\nfollowing code.\nimport datarobot as dr\nrecommendation_type = dr.enums.RECOMMENDED_MODEL_TYPE.RECOMMENDED_FOR_DEPLOYMENT\nrecommendations = dr.ModelRecommendation.get(project_id, recommendation_type)\nGet recommended model\uf0c1\nYou can use method get_model() of a recommendation object to retrieve a recommended model.\nimport datarobot as dr\nrecommendation = dr.ModelRecommendation.get(project_id)\nrecommended_model = recommendation.get_model()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\nrecommendations = dr.ModelRecommendation.get_all(project_id)",
        "import datarobot as dr\n\nrecommendation = dr.ModelRecommendation.get(project_id)",
        "import datarobot as dr\n\nrecommendation_type = dr.enums.RECOMMENDED_MODEL_TYPE.RECOMMENDED_FOR_DEPLOYMENT\nrecommendations = dr.ModelRecommendation.get(project_id, recommendation_type)",
        "import datarobot as dr\n\nrecommendation = dr.ModelRecommendation.get(project_id)\nrecommended_model = recommendation.get_model()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/model.html",
      "title": "Models\uf0c1",
      "description": "When a blueprint has been trained on a specific dataset at a specified sample\nsize, the result is a model. Models can be inspected to analyze their accuracy.",
      "content": "Models\uf0c1\nWhen a blueprint has been trained on a specific dataset at a specified sample\nsize, the result is a model. Models can be inspected to analyze their accuracy.\nStart training a model\uf0c1\nTo start training a model, use the Project.train method with\na blueprint object:\nimport datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nblueprints = project.get_blueprints()\nmodel_job_id = project.train(blueprints[0].id)\nFor a datetime partitioned project (see the specialized workflows section), use\nProject.train_datetime:\nimport datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nblueprints = project.get_blueprints()\nmodel_job_id = project.train_datetime(blueprints[0].id)\nList finished models\uf0c1\nYou can use the Project.get_models method to\nreturn a list of the project models that have finished training:\nimport datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nmodels = project.get_models()\nprint(models[:5])\n>>> [Model(Decision Tree Classifier (Gini)),\nModel(Auto-tuned K-Nearest Neighbors Classifier (Minkowski Distance)),\nModel(Gradient Boosted Trees Classifier (R)),\nModel(Gradient Boosted Trees Classifier),\nModel(Logistic Regression)]\nmodel = models[0]\nproject.id\n>>> u'5506fcd38bd88f5953219da0'\nmodel.id\n>>> u'5506fcd98bd88f1641a720a3'\nYou can pass following parameters to change the result:\nsearch_params - A dict. Used to filter returned projects. Currently, you can query models by name, sample_pct, and is_starred.\norder_by \u2014 A str or list. If passed, returned models are ordered by this attribute(s). You can sort by the metric and sample_pct attributes.\nIf the sort attribute is preceded by a hyphen, models will be sorted in descending\norder, otherwise, in ascending order. Multiple sort attributes can be included as a comma-delimited string or in a list,\ne.g., order_by='sample_pct,-metric' or order_by=['sample_pct', '-metric']. Using metric to sort will result\nin models being sorted according to their validation score by how well they did according to the project metric.\nwith_metric \u2013 A str. If not set as None, the returned models will only have scores for this metric. Otherwise, all the metrics are returned.\nReview an example of listing models below.\nimport datarobot as dr\ndr.Project('5506fcd38bd88f5953219da0').get_models(order_by=['sample_pct', '-metric'])\n# Getting models that contain \"Ridge\" in name\n# and with sample_pct more than 64\ndr.Project('5506fcd38bd88f5953219da0').get_models(\nsearch_params={\n'sample_pct__gt': 64,\n'name': \"Ridge\"\n})\n# Getting models marked as starred\ndr.Project('5506fcd38bd88f5953219da0').get_models(\nsearch_params={\n'is_starred': True\n})\nRetrieve a known model\uf0c1\nIf you know the model_id and project_id values of a model, you can\nretrieve it directly:\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\nmodel_id=model_id)\nYou can also use an instance of Project as the parameter for\nModel.get.\nmodel = dr.Model.get(project=project,\nmodel_id=model_id)\nRetrieve the highest scoring model for a given metric\uf0c1\nYou can retrieve the highest scoring model for a project based on a metric of your\nchoice.\nIf you decide not to pass a metric to this method or if you pass the default project metric (\nthe value of the metric attribute of your project instance), the result of\nProject.recommended_model is returned.\nimport datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\ntop_model_r_squared = project.get_top_model(metric=\"R Squared\")\nTrain a model on a different sample size\uf0c1\nOne of the key insights into a model and the data behind it is how its\nperformance varies with more training data.\nIn Autopilot, DataRobot runs at several sample sizes by default,\nbut you can also create a job that will run at a specific sample size,\nor specify a feature list that should be used for training the new model.\nThe Model.train method of a Model instance will\nput a new modeling job into the queue and return the ID of the created\nModelJob.\nYou can pass the model job ID to the wait_for_async_model_creation function,\nwhich polls the async model creation status and returns the newly-created model when it\u2019s finished.\nimport datarobot as dr\nmodel_job_id = model.train(sample_pct=33)\n# Retrain a model on a custom featurelist using cross validation.\n# Note that you can specify a custom value for `sample_pct`.\nmodel_job_id = model.train(\nsample_pct=55,\nfeaturelist_id=custom_featurelist.id,\nscoring_type=dr.SCORING_TYPE.cross_validation,\n)\nCross-validating a model\uf0c1\nBy default, models are evaluated on the first validation partition. To start\ncross-validation, use Model.cross_validate:\nimport datarobot as dr\nmodel_job_id = model.cross_validate()\nFor a :doc:datetime partitioned project , backtesting is\nthe only cross-validation method supported. To run backtesting for a datetime model, use the\nDatetimeModel.score_backtests method:\nimport datarobot as dr\n# `model` here must be an instance of `dr.DatetimeModel`.\nmodel_job_id = model.score_backtests()\nFind the features used\uf0c1\nBecause each project can have many associated feature lists, it is\nimportant to know which features a model requires in order to run. This helps ensure that the necessary features are provided when generating predictions.\nfeature_names = model.get_features_used()\nprint(feature_names)\n>>> ['MonthlyIncome',\n'VisitsLast8Weeks',\n'Age']\nFeature Impact\uf0c1\nFeature Impact measures how much worse a model\u2019s error score would be if DataRobot made predictions\nafter randomly shuffling a particular column (a technique sometimes called\nPermutation Importance).\nThe following example code snippet shows how a feature list with just the features with the highest\nfeature impact could be created.\nimport datarobot as dr\nmax_num_features = 10\ntime_to_wait_for_impact = 4 * 60  # seconds\nfeature_impacts = model.get_or_request_feature_impact(time_to_wait_for_impact)\nfeature_impacts.sort(key=lambda x: x['impactNormalized'], reverse=True)\nfinal_names = [f['featureName'] for f in feature_impacts[:max_num_features]]\nproject.create_featurelist('highest_impact', final_names)\nFor datetime-aware models, Feature Impact can be calculated for any backtest and holdout.\nimport datarobot as dr\ndatetime_model = dr.Model.get(project=project_id, model_id=model_id)\nfeature_impacts = datetime_model.get_or_request_feature_impact(backtest=1, with_metadata=True)\nFeature Effects\uf0c1\nFeature Effects helps to understand how changing a single feature affects the target while holding all other\nfeatures constant. Feature Effects provides partial dependence plot and prediction vs accuracy plot data.\nimport datarobot as dr\nfeature_effects = model.get_or_request_feature_effect(source='validation')\nFor multiclass models use request_feature_effects_multiclass and get_feature_effects_multiclass or\nget_or_request_feature_effects_multiclass methods.\nimport datarobot as dr\nfeature_effects = model.get_feature_effect(source='validation')\nPredict new data\uf0c1\nAfter creating models, you can use them to generate predictions on new data.\nSee the predictions documentation for further information on how to request predictions\nfrom a model.\nModel IDs vs. blueprint IDs\uf0c1\nEach model has both a model_id and a blueprint_id.\nA model is the result of training a blueprint on a dataset at a specified\nsample percentage. The blueprint_id is used to keep track of which\nblueprint was used to train the model, while the model_id is used to\nlocate the trained model in the system.\nModel parameters\uf0c1\nSome models can have parameters that provide data needed to reproduce their predictions.\nFor additional usage information see Coefficients.\nimport datarobot as dr\nmodel = dr.Model.get(project=project, model_id=model_id)\nmp = model.get_parameters()\nprint(mp.derived_features)\n>>> [{\n'coefficient': -0.015,\n'originalFeature': u'A1Cresult',\n'derivedFeature': u'A1Cresult->7',\n'type': u'CAT',\n'transformations': [{'name': u'One-hot', 'value': u\"'>7'\"}]\n}]\nCreate a blender model\uf0c1\nYou can blend multiple models; in many cases, the resulting blender model is more accurate\nthan the parent models. To do so, you need to select parent models and a blender method from\ndatarobot.enums.BLENDER_METHOD. If this is a time series project, only methods in\ndatarobot.enums.TS_BLENDER_METHOD are allowed.\nBe aware that the tradeoff for better prediction accuracy is bigger resource consumption\nand slower predictions.\nimport datarobot as dr\npr = dr.Project.get(pid)\nmodels = pr.get_models()\nparent_models = [model.id for model in models[:2]]\npr.blend(parent_models, dr.enums.BLENDER_METHOD.AVERAGE)\nLift chart retrieval\uf0c1\nYou can use the Model methods get_lift_chart and get_all_lift_charts to retrieve\nlift chart data. The first will get it from specific source (validation data, cross validation, or\nunlocked Holdout) and the second will list all available data.\nFor multiclass models, you can get a list of per-class lift charts using the Model method get_multiclass_lift_chart.\nROC curve retrieval\uf0c1\nSame as with the lift chart, you can use Model methods get_roc_curve and\nget_all_roc_curves to retrieve ROC curve data. More information about working with ROC\ncurves can be found in ROC curve.\nResiduals chart retrieval\uf0c1\nJust as with the lift and ROC charts, you can use Model methods get_residuals_chart and\nget_all_residuals_charts to retrieve residuals chart data. The first will get it from a\nspecific source (validation data, cross-validation data, or unlocked Holdout). The second\nretrieves all available data.\nWord cloud\uf0c1\nIf your dataset contains text columns, DataRobot can create text processing models that will\ncontain word cloud insight data. An example of such a model is any \u201cAuto-Tuned Word N-Gram Text\nModeler\u201d model. You can use the {meth}`Model.get_word_cloud <datarobot.models.Model.get_word_cloud> method to retrieve those insights \u2014 it\nprovides up to the 200 most important ngrams in the model and coefficients corresponding to their influence.\nScoring Code\uf0c1\nA subset of models support code generation. For each of those models, you can download\na JAR file with Scoring Code to make predictions locally using\nmodel.download_scoring_code. For details on how to do so, see Scoring Code. Optionally, you can download source code in Java to see\nwhat calculations those models do internally.\nBe aware that the source code JAR isn\u2019t compiled so it cannot be used for making predictions.\nGet a model blueprint chart\uf0c1\nFor any model, you can retrieve its blueprint chart. You can also get its representation in graphviz DOT format to render it into the format you need.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\nmodel_id=model_id)\nbp_chart = model.get_model_blueprint_chart()\nprint(bp_chart.to_graphviz())\nGet a model missing values report\uf0c1\nFor the majority of models, you can retrieve their missing values reports on training data\nper each numeric and categorical feature. Model needs to have at least one of the supported tasks\nin the blueprint in order to have a missing values report (blenders are not supported).\nReport is gathered for Numerical Imputation tasks and Categorical converters like Ordinal Encoding,\nOne-Hot Encoding, etc.\nMissing values report is available to users with access to full blueprint docs.\nA report is collected for those features which are considered eligible by a given blueprint task.\nFor instance, a categorical feature with a lot of unique values may not be considered as eligible in\nthe One-Hot encoding task.\nPlease refer to Missing report attributes description\nfor report interpretation.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id, model_id=model_id)\nmissing_reports_per_feature = model.get_missing_report_info()\nfor report_per_feature in missing_reports_per_feature:\nprint(report_per_feature)\nConsider the following example of a Decision Tree Classifier (Gini) blueprint chart representation. A summary of the results is outlined below.\nprint(blueprint_chart.to_graphviz())\n>>> digraph \"Blueprint Chart\" {\ngraph [rankdir=LR]\n0 [label=\"Data\"]\n-2 [label=\"Numeric Variables\"]\n2 [label=\"Missing Values Imputed\"]\n3 [label=\"Decision Tree Classifier (Gini)\"]\n4 [label=\"Prediction\"]\n-1 [label=\"Categorical Variables\"]\n1 [label=\"Ordinal encoding of categorical variables\"]\n0 -> -2\n-2 -> 2\n2 -> 3\n3 -> 4\n0 -> -1\n-1 -> 1\n1 -> 3\n}\nAnd a missing report:\nprint(report_per_feature1)\n>>> {'feature': 'Veh Year',\n'type': 'Numeric',\n'missing_count': 150,\n'missing_percentage': 50.00,\n'tasks': [\n{'id': u'2',\n'name': u'Missing Values Imputed',\n'descriptions': [u'Imputed value: 2006']\n}\n]\n}\nprint(report_per_feature2)\n>>> {'feature': 'Model',\n'type': 'Categorical',\n'missing_count': 100,\n'missing_percentage': 33.33,\n'tasks': [\n{'id': u'1',\n'name': u'Ordinal encoding of categorical variables',\n'descriptions': [u'Imputed value: -2']\n}\n]\n}\nThe numeric feature \u201cVeh Year\u201d has 150 missing values and, respectively, 50% in training data.\nIt was transformed by the \u201cMissing Values Imputed\u201d task with imputed value 2006. Task has ID 2, and its\noutput goes into Decision Tree Classifier (Gini), which can be inferred from the chart.\nThe \u201cModel\u201d categorical feature was transformed by \u201cOrdinal encoding of categorical variables\u201d task with\nimputed value -2.\nGet a blueprint\u2019s documentation\uf0c1\nYou can retrieve documentation on tasks used to build a model. It will contain information about the task, its parameters and (when available) links and references to additional sources.\nAll documents are instances of BlueprintTaskDocument class.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\nmodel_id=model_id)\ndocs = model.get_model_blueprint_documents()\nprint(docs[0].task)\n>>> Average Blend\nprint(docs[0].links[0]['url'])\n>>> https://en.wikipedia.org/wiki/Ensemble_learning\nRequest training predictions\uf0c1\nYou can request a model\u2019s predictions for a particular subset of its training data.\nSee datarobot.models.Model.request_training_predictions() reference for all the valid subsets.\nSee training predictions reference for more details.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\nmodel_id=model_id)\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.HOLDOUT)\ntraining_predictions = training_predictions_job.get_result_when_complete()\nfor row in training_predictions.iterate_rows():\nprint(row.row_id, row.prediction)\nAdvanced tuning\uf0c1\nYou can perform advanced tuning on a model \u2014 generate a new model by taking an existing\nmodel and rerunning it with modified tuning parameters.\nThe AdvancedTuningSession class exists to track the creation of an advanced tuning model on the\nclient. It enables browsing and setting advanced tuning parameters one at a time, and\nusing human-readable parameter names rather than requiring opaque parameter IDs in all cases.\nNo information is sent to the server until the run() method is called on the\nAdvancedTuningSession.\nSee datarobot.models.Model.get_advanced_tuning_parameters() reference for a description\nof the types of parameters that can be passed in.\nAs of v2.17 of the Python client, all models other than blenders, open source, and user-created models support\nAdvanced Tuning. The use of Advanced Tuning via the API for non-Eureqa models is in beta, but is enabled\nby default for all users.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\nmodel_id=model_id)\ntune = model.start_advanced_tuning_session()\n# Get available task names,\n# and available parameter names for a task name that exists on this model\ntune.get_task_names()\ntune.get_parameter_names('Eureqa Generalized Additive Model Classifier (3000 Generations)')\ntune.set_parameter(\ntask_name='Eureqa Generalized Additive Model Classifier (3000 Generations)',\nparameter_name='EUREQA_building_block__sine',\nvalue=1)\njob = tune.run()\nSHAP Feature Impact\uf0c1\nSHAP Feature Impact is computed by calculating the SHAP values on a sample of training data and then taking\nthe mean absolute value for each column. A larger value of impact indicates a more important feature.\nSee datarobot.models.ShapImpact.create() reference for a description of the types of parameters\nthat can be passed in.\nimport datarobot as dr\nproject_id = '5ec3d6884cfad17cd8c0ed62'\nmodel_id = '5ec3d6f44cfad17cd8c0ed78'\nshap_impact_job = dr.ShapImpact.create(project_id=project_id, model_id=model_id)\nshap_impact = shap_impact_job.get_result_when_complete()\nprint(shap_impact)\n>>> [ShapImpact(count=36)]\nprint(shap_impact.shap_impacts[:1])\n>>> [{'feature_name': 'number_inpatient', 'impact_normalized': 1.0, 'impact_unnormalized': 0.07670175497683789}]\nshap_impact = dr.ShapImpact.get(project_id=project_id, model_id=model_id)\nprint(shap_impact.shap_impacts[:1])\n>>> [{'feature_name': 'number_inpatient', 'impact_normalized': 1.0, 'impact_unnormalized': 0.07670175497683789}]\nNumber of iterations trained\uf0c1\nEarly-stopping models will train a subset of max estimators/iterations that are defined in advanced tuning.\nThis method allows the user to retrieve the actual number of estimators that were trained by an early-stopping\ntree-based model (currently the only model type supported). The method returns the projectId, modelId, and\na list of dictionaries containing the number of iterations trained for each model stage. In the case of single-stage models,\nthis dictionary will contain only one entry.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\nmodel_id=model_id)\nnum_iterations = model.get_num_iterations_trained()\nprint(num_iterations)\n>>> {\"projectId\": \"5506fcd38bd88f5953219da0\", \"modelId\": \"5506fcd98bd88f1641a720a3\", \"data\" [{\"stage\": \"FREQ\", \"numIterations\":250}, {\"stage\":\"SEV\", \"numIterations\":50}]}",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/job.html",
        "https://docs.datarobot.com/en/docs/workbench/nxt-console/nxt-predictions/index.html",
        "https://docs.datarobot.com/en/docs/workbench/wb-experiment/experiment-insights/ml-coefficients.html",
        "https://docs.datarobot.com/en/docs/workbench/wb-experiment/experiment-insights/ml-roc-curve.html",
        "https://docs.datarobot.com/en/docs/predictions/port-pred/scoring-code/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/predict_job.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nblueprints = project.get_blueprints()\nmodel_job_id = project.train(blueprints[0].id)",
        "Project.train_datetime",
        "import datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nblueprints = project.get_blueprints()\nmodel_job_id = project.train_datetime(blueprints[0].id)",
        "import datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\nmodels = project.get_models()\nprint(models[:5])\n>>> [Model(Decision Tree Classifier (Gini)),\n     Model(Auto-tuned K-Nearest Neighbors Classifier (Minkowski Distance)),\n     Model(Gradient Boosted Trees Classifier (R)),\n     Model(Gradient Boosted Trees Classifier),\n     Model(Logistic Regression)]\nmodel = models[0]\n\nproject.id\n>>> u'5506fcd38bd88f5953219da0'\nmodel.id\n>>> u'5506fcd98bd88f1641a720a3'",
        "import datarobot as dr\n\ndr.Project('5506fcd38bd88f5953219da0').get_models(order_by=['sample_pct', '-metric'])\n\n# Getting models that contain \"Ridge\" in name\n# and with sample_pct more than 64\ndr.Project('5506fcd38bd88f5953219da0').get_models(\n    search_params={\n        'sample_pct__gt': 64,\n        'name': \"Ridge\"\n    })\n\n# Getting models marked as starred\ndr.Project('5506fcd38bd88f5953219da0').get_models(\n    search_params={\n        'is_starred': True\n    })",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\n                     model_id=model_id)",
        "model = dr.Model.get(project=project,\n                     model_id=model_id)",
        "Project.recommended_model",
        "import datarobot as dr\nproject = dr.Project.get('5506fcd38bd88f5953219da0')\ntop_model_r_squared = project.get_top_model(metric=\"R Squared\")",
        "import datarobot as dr\n\nmodel_job_id = model.train(sample_pct=33)\n\n# Retrain a model on a custom featurelist using cross validation.\n# Note that you can specify a custom value for `sample_pct`.\nmodel_job_id = model.train(\n    sample_pct=55,\n    featurelist_id=custom_featurelist.id,\n    scoring_type=dr.SCORING_TYPE.cross_validation,\n)",
        "import datarobot as dr\n\nmodel_job_id = model.cross_validate()",
        "DatetimeModel.score_backtests",
        "import datarobot as dr\n\n# `model` here must be an instance of `dr.DatetimeModel`.\nmodel_job_id = model.score_backtests()",
        "feature_names = model.get_features_used()\nprint(feature_names)\n>>> ['MonthlyIncome',\n     'VisitsLast8Weeks',\n     'Age']",
        "Permutation Importance",
        "import datarobot as dr\n\nmax_num_features = 10\ntime_to_wait_for_impact = 4 * 60  # seconds\n\nfeature_impacts = model.get_or_request_feature_impact(time_to_wait_for_impact)\n\nfeature_impacts.sort(key=lambda x: x['impactNormalized'], reverse=True)\nfinal_names = [f['featureName'] for f in feature_impacts[:max_num_features]]\n\nproject.create_featurelist('highest_impact', final_names)",
        "import datarobot as dr\n\ndatetime_model = dr.Model.get(project=project_id, model_id=model_id)\nfeature_impacts = datetime_model.get_or_request_feature_impact(backtest=1, with_metadata=True)",
        "import datarobot as dr\n\nfeature_effects = model.get_or_request_feature_effect(source='validation')",
        "import datarobot as dr\n\nfeature_effects = model.get_feature_effect(source='validation')",
        "import datarobot as dr\n\nmodel = dr.Model.get(project=project, model_id=model_id)\nmp = model.get_parameters()\nprint(mp.derived_features)\n>>> [{\n         'coefficient': -0.015,\n         'originalFeature': u'A1Cresult',\n         'derivedFeature': u'A1Cresult->7',\n         'type': u'CAT',\n         'transformations': [{'name': u'One-hot', 'value': u\"'>7'\"}]\n    }]",
        "datarobot.enums.BLENDER_METHOD",
        "datarobot.enums.TS_BLENDER_METHOD",
        "import datarobot as dr\n\npr = dr.Project.get(pid)\nmodels = pr.get_models()\nparent_models = [model.id for model in models[:2]]\npr.blend(parent_models, dr.enums.BLENDER_METHOD.AVERAGE)",
        "model.download_scoring_code",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\n                     model_id=model_id)\nbp_chart = model.get_model_blueprint_chart()\nprint(bp_chart.to_graphviz())",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id, model_id=model_id)\nmissing_reports_per_feature = model.get_missing_report_info()\nfor report_per_feature in missing_reports_per_feature:\n    print(report_per_feature)",
        "print(report_per_feature1)\n>>> {'feature': 'Veh Year',\n     'type': 'Numeric',\n     'missing_count': 150,\n     'missing_percentage': 50.00,\n     'tasks': [\n                {'id': u'2',\n                'name': u'Missing Values Imputed',\n                'descriptions': [u'Imputed value: 2006']\n                }\n        ]\n      }\nprint(report_per_feature2)\n>>> {'feature': 'Model',\n     'type': 'Categorical',\n     'missing_count': 100,\n     'missing_percentage': 33.33,\n     'tasks': [\n                {'id': u'1',\n                'name': u'Ordinal encoding of categorical variables',\n                'descriptions': [u'Imputed value: -2']\n                }\n          ]\n        }",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\n                     model_id=model_id)\ndocs = model.get_model_blueprint_documents()\nprint(docs[0].task)\n>>> Average Blend\nprint(docs[0].links[0]['url'])\n>>> https://en.wikipedia.org/wiki/Ensemble_learning",
        "datarobot.models.Model.request_training_predictions()",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\n                     model_id=model_id)\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.HOLDOUT)\ntraining_predictions = training_predictions_job.get_result_when_complete()\nfor row in training_predictions.iterate_rows():\n    print(row.row_id, row.prediction)",
        "datarobot.models.Model.get_advanced_tuning_parameters()",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\n                     model_id=model_id)\ntune = model.start_advanced_tuning_session()\n\n# Get available task names,\n# and available parameter names for a task name that exists on this model\ntune.get_task_names()\ntune.get_parameter_names('Eureqa Generalized Additive Model Classifier (3000 Generations)')\n\ntune.set_parameter(\n    task_name='Eureqa Generalized Additive Model Classifier (3000 Generations)',\n    parameter_name='EUREQA_building_block__sine',\n    value=1)\n\njob = tune.run()",
        "datarobot.models.ShapImpact.create()",
        "import datarobot as dr\n\nproject_id = '5ec3d6884cfad17cd8c0ed62'\nmodel_id = '5ec3d6f44cfad17cd8c0ed78'\nshap_impact_job = dr.ShapImpact.create(project_id=project_id, model_id=model_id)\nshap_impact = shap_impact_job.get_result_when_complete()\nprint(shap_impact)\n>>> [ShapImpact(count=36)]\nprint(shap_impact.shap_impacts[:1])\n>>> [{'feature_name': 'number_inpatient', 'impact_normalized': 1.0, 'impact_unnormalized': 0.07670175497683789}]\n\nshap_impact = dr.ShapImpact.get(project_id=project_id, model_id=model_id)\nprint(shap_impact.shap_impacts[:1])\n>>> [{'feature_name': 'number_inpatient', 'impact_normalized': 1.0, 'impact_unnormalized': 0.07670175497683789}]",
        "import datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nmodel = dr.Model.get(project=project_id,\n                     model_id=model_id)\nnum_iterations = model.get_num_iterations_trained()\nprint(num_iterations)\n>>> {\"projectId\": \"5506fcd38bd88f5953219da0\", \"modelId\": \"5506fcd98bd88f1641a720a3\", \"data\" [{\"stage\": \"FREQ\", \"numIterations\":250}, {\"stage\":\"SEV\", \"numIterations\":50}]}"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/prime.html",
      "title": "DataRobot Prime\uf0c1",
      "description": "DataRobot Prime allows the download of executable code approximating models. For more information about this feature, see the documentation within the\nDataRobot webapp. Contact your Account Executive or CFDS for information on enabling DataRobot Prime, if needed.",
      "content": "DataRobot Prime\uf0c1\nDataRobot Prime allows the download of executable code approximating models. For more information about this feature, see the documentation within the\nDataRobot webapp. Contact your Account Executive or CFDS for information on enabling DataRobot Prime, if needed.\nApproximate a Model\uf0c1\nGiven a Model you wish to approximate, Model.request_approximation will start a job creating\nseveral Ruleset objects approximating the parent model.  Each of those rulesets will identify\nhow many rules were used to approximate the model, as well as the validation score\nthe approximation achieved.\nrulesets_job = model.request_approximation()\nrulesets = rulesets_job.get_result_when_complete()\nfor ruleset in rulesets:\ninfo = (ruleset.id, ruleset.rule_count, ruleset.score)\nprint('id: {}, rule_count: {}, score: {}'.format(*info))\nPrime Models vs. Models\uf0c1\nGiven a ruleset, you can create a model based on that ruleset.  We consider such models to be Prime\nmodels.  The PrimeModel class inherits from the Model class, so anything a Model can do,\nas PrimeModel can do as well.\nThe PrimeModel objects available within a Project can be listed by\nproject.get_prime_models, or a particular one can be retrieve via PrimeModel.get.  If a\nruleset has not yet had a model built for it, ruleset.request_model can be used to start\na job to make a PrimeModel using a particular ruleset.\nrulesets = parent_model.get_rulesets()\nselected_ruleset = sorted(rulesets, key=lambda x: x.score)[-1]\nif selected_ruleset.model_id:\nprime_model = PrimeModel.get(selected_ruleset.project_id, selected_ruleset.model_id)\nelse:\nprime_job = selected_ruleset.request_model()\nprime_model = prime_job.get_result_when_complete()\nThe PrimeModel class has two additional attributes and one additional method.  The attributes\nare ruleset, which is the Ruleset used in the PrimeModel, and parent_model_id which is\nthe id of the model it approximates.\nFinally, the new method defined is request_download_validation which is used to prepare code\ndownload for the model and is discussed later on in this document.\nRetrieving Code from a PrimeModel\uf0c1\nGiven a PrimeModel, you can download the code used to approximate the parent model, and view\nand execute it locally.\nThe first step is to validate the PrimeModel, which runs some basic validation of the generated\ncode, as well as preparing it for download.  We use the PrimeFile object to represent code\nthat is ready to download.  PrimeFiles can be prepared by the request_download_validation\nmethod on PrimeModel objects, and listed from a project with the get_prime_files method.\nOnce you have a PrimeFile you can check the is_valid attribute to verify the code passed\nbasic validation, and then download it to a local file with download.\nvalidation_job = prime_model.request_download_validation(enums.PRIME_LANGUAGE.PYTHON)\nprime_file = validation_job.get_result_when_complete()\nif not prime_file.is_valid:\nraise ValueError('File was not valid')\nprime_file.download('/home/myuser/drCode/primeModelCode.py')",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "Model.request_approximation",
        "rulesets_job = model.request_approximation()\nrulesets = rulesets_job.get_result_when_complete()\nfor ruleset in rulesets:\n    info = (ruleset.id, ruleset.rule_count, ruleset.score)\n    print('id: {}, rule_count: {}, score: {}'.format(*info))",
        "project.get_prime_models",
        "ruleset.request_model",
        "rulesets = parent_model.get_rulesets()\nselected_ruleset = sorted(rulesets, key=lambda x: x.score)[-1]\nif selected_ruleset.model_id:\n    prime_model = PrimeModel.get(selected_ruleset.project_id, selected_ruleset.model_id)\nelse:\n    prime_job = selected_ruleset.request_model()\n    prime_model = prime_job.get_result_when_complete()",
        "validation_job = prime_model.request_download_validation(enums.PRIME_LANGUAGE.PYTHON)\nprime_file = validation_job.get_result_when_complete()\nif not prime_file.is_valid:\n    raise ValueError('File was not valid')\nprime_file.download('/home/myuser/drCode/primeModelCode.py')"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/project.html",
      "title": "Projects\uf0c1",
      "description": "All of the modeling within DataRobot happens within a project. Each project\nhas one dataset that is used as the source from which to train models.",
      "content": "Projects\uf0c1\nAll of the modeling within DataRobot happens within a project. Each project\nhas one dataset that is used as the source from which to train models.\nCreate a project\uf0c1\nYou can create a project from previously-created Datasets or directly from a data source.\nimport datarobot as dr\ndataset = Dataset.create_from_file(file_path='/home/user/data/last_week_data.csv')\nproject = dr.Project.create_from_dataset(dataset.id, project_name='New Project')\nThe following command creates a new project directly from a data source. You must specify a path\nto data file, file object URL (starting with http://, https://, file://, or s3://),\nraw file contents, or a pandas.DataFrame object when creating a new project.\nPath to file can be either a path to a local file or a publicly accessible URL.\nimport datarobot as dr\nproject = dr.Project.create('/home/user/data/last_week_data.csv',\nproject_name='New Project')\nYou can use the following commands to view the project ID and name:\nproject.id\n>>> u'5506fcd38bd88f5953219da0'\nproject.project_name\n>>> u'New Project'\nSelect modeling parameters\uf0c1\nThe final information needed to begin modeling includes the target feature, queue mode, metric for comparing models, and optional parameters such as weights, offset, exposure, and downsampling.\nTarget\uf0c1\nThe target must be the name of one of the columns of data uploaded to the project.\nMetric\uf0c1\nThe optimization metric used to compare models is an important factor in building accurate models. If a metric is not specified, the default metric recommended by DataRobot will be used. You can use the following code to view a list of valid metrics for a specified target:\ntarget_name = 'ItemsPurchased'\nproject.get_metrics(target_name)\n>>> {'available_metrics': [\n'Gini Norm',\n'Weighted Gini Norm',\n'Weighted R Squared',\n'Weighted RMSLE',\n'Weighted MAPE',\n'Weighted Gamma Deviance',\n'Gamma Deviance',\n'RMSE',\n'Weighted MAD',\n'Tweedie Deviance',\n'MAD',\n'RMSLE',\n'Weighted Tweedie Deviance',\n'Weighted RMSE',\n'MAPE',\n'Weighted Poisson Deviance',\n'R Squared',\n'Poisson Deviance'],\n'feature_name': 'SalePrice'}\nPartitioning method\uf0c1\nDataRobot projects always have a Holdout set used for final model validation. You can use two different approaches for testing prior to the Holdout set:\nSplit the remaining data into training and validation sets.\nCross-validation, in which the remaining data is split into a number of folds (partitions); each fold serves as a validation set, with models trained on the other folds and evaluated on that fold.\nThere are several other options you can control. To specify a partition method, create an instance of one of the Partition Classes, and pass it as the partitioning_method argument in your call to project.analyze_and_model or project.start.  As of v3.0 of the Python client, you can alternately use project.set_partitioning_method.  See here for more information on using datetime partitioning.\nSeveral partitioning methods include parameters for validation_pct and holdout_pct, specifying desired percentages for the validation and holdout sets. Note that there may be constraints that prevent the actual percentages used from exactly (or some cases, even closely) matching the requested percentages.\nQueue mode\uf0c1\nYou can use the API to set the DataRobot modeling process to run Autopilot in manual, quick, or comprehensive mode.\nAutopilot mode means that the modeling process will proceed completely\nautomatically, including running recommended models, running at\ndifferent sample sizes, and blending.\nManual mode means that DataRobot will populate a list of recommended models, but will not insert any of them into the queue. This mode lets you specify which models to execute before starting the modeling process.\nQuick mode means that a smaller set of blueprints is used, so Autopilot finishes faster.\nWeights\uf0c1\nDataRobot also supports using a weight parameter, which are often used to help compensate for rare events in data. You can specify a column name in the project dataset to be used as a weight column.\nOffsets\uf0c1\nStarting with Python client v2.6, DataRobot also supports using an offset parameter. Offsets are commonly used in insurance modeling to include effects that are outside of the training data due to regulatory compliance or constraints. You can specify the names of several columns in the project dataset to be used as the offset columns.\nExposure\uf0c1\nStarting with version v2.6, DataRobot also supports using an exposure parameter. Exposure is often used to model insurance premiums where strict proportionality of premiums to duration is required. You can specify the name of the column in the project dataset to be used as an exposure column.\nStart modeling\uf0c1\nOnce you have selected modeling parameters, you can use the following code structure to specify parameters and start the modeling process.\nimport datarobot as dr\nproject.analyze_and_model(target='ItemsPurchased',\nmetric='Tweedie Deviance',\nmode=dr.AUTOPILOT_MODE.FULL_AUTO)\nYou can also pass additional parameters to project.analyze_and_model to change parts of\nthe modeling process. Some of those parameters include:\nworker_count - int, sets number of workers used for modeling.\npartitioning_method - PartitioningMethod object.\npositive_class - str, float, or int; Specifies a level of the target column that should be treated as the positive class for binary classification.  May only be specified for binary classification targets.\nadvanced_options - AdvancedOptions object; Used to set advanced options of modeling process. Can alternatively call set_options on a project instance which will be used automatically if nothing is passed here.\ntarget_type - str; Overrides the automatically selected target_type. An example usage would be setting the target_type=TARGET_TYPE.MULTICLASS when you want to perform a multiclass classification task on a numeric column that has a low cardinality.\nYou can run different Autopilot modes with the mode parameter. AUTOPILOT_MODE.FULL_AUTO\nis the default, which will trigger modeling with no further actions necessary. Other accepted modes\ninclude AUTOPILOT_MODE.MANUAL for manual mode (choose your own models to run rather than use the\nDataRobot autopilot), AUTOPILOT_MODE.QUICK (run on a more limited set of models\nto get insights more quickly), and AUTOPILOT_MODE.COMPREHENSIVE (used to invest more time to find\nthe most accurate model to serve your use case).\nFor a full reference of available parameters, see Project.analyze_and_model.\nClone a project\uf0c1\nOnce a project has been successfully created, you may clone it using the following code structure:\nnew_project = project.clone_project(new_project_name='This is my new project')\nnew_project.project_name\n>> 'This is my new project'\nnew_project.id != project.id\n>> True\nThe new_project_name attribute is optional. If it is omitted, the default new project name will be \u2018Copy of <project.name>\u2019.\nInteract with a project\uf0c1\nThe following commands can be used to manage DataRobot projects.\nList projects\uf0c1\nReturns a list of projects associated with current API user.\nimport datarobot as dr\ndr.Project.list()\n>>> [Project(Project One), Project(Two)]\ndr.Project.list(search_params={'project_name': 'One'})\n>>> [Project(One)]\nYou can pass following parameter to change the result:\nsearch_params \u2013 dict; Used to filter returned projects. You can only query projects by project_name.\nGet an existing project\uf0c1\nRather than querying the full list of projects every time you need\nto interact with a project, you can retrieve its ID value and use that to reference the project.\nimport datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nproject.id\n>>> '5506fcd38bd88f5953219da0'\nproject.project_name\n>>> 'Churn Projection'\nGet feature association statistics for an existing project\uf0c1\nYou can retrieve either feature association or correlation statistics and metadata on informative\nfeatures for a given project.\nimport datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nassociation_data = project.get_associations(assoc_type='association', metric='mutualInfo')\nassociation_data.keys()\n>>> ['strengths', 'features']\nGet whether your featurelists have association statistics\uf0c1\nGet whether an association matrix job has been run on each of your feature lists.\nimport datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelists = project.get_association_featurelists()\nfeaturelists['featurelists'][0]\n>>> {\"featurelistId\": \"54e510ef8bd88f5aeb02a3ed\", \"hasFam\": True, \"title\": \"Informative Features\"}\nCreate association statistics for a featurelist\uf0c1\nGenerate the feature association statistics for all features in a feature list.\nimport datarobot as dr\nfrom datarobot.models.feature_association_matrix import FeatureAssociationMatrix\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelist = project.get_featurelist_by_name(\"Raw Features\")\nstatus = FeatureAssociationMatrix.create(project.id, featurelist.id)\n# two ways to wait for completion\n# option 1\nstatus.wait_for_completion()\nfam = FeatureAssociationMatrix.get(project_id=project.id, featurelist_id=featurelist.id)\n# or option 2\n# fam = status.get_result_when_complete()\nGet a project\u2019s feature list by name\uf0c1\nGet a feature list by name.\nimport datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelist = project.get_featurelist_by_name(\"Raw Features\")\nfeaturelist\n>>> Featurelist(Raw Features)\n# Trying to get feature list that does not exist\nfeaturelist = project.get_featurelist_by_name(\"Flying Circus\")\nfeaturelist is None\n>>> True\nCreate project feature lists\uf0c1\nUsing a project\u2019s create_featurelist() method, you can create feature lists in multiple ways:\nimport datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelist_one = project.create_featurelist(\nname=\"Testing featurelist creation\",\nfeatures=[\"age\", \"weight\", \"number_diagnoses\"],\n)\nfeaturelist_one\n>>> Featurelist(Testing featurelist creation)\nfeaturelist_one.features\n>>> ['age', 'weight', 'number_diagnoses']\n# Create a feature list using another feature list as a starting point (`starting_featurelist`)\n# To Note: this example passes the `featurelist` object but you can also pass the\n# id (`starting_featurelist_id`) or the name (`starting_featurelist_name`)\nfeaturelist_two = project.create_featurelist(\nstarting_featurelist=featurelist_one,\nfeatures_to_exclude=[\"number_diagnoses\"],  # Please see docs for use of `features_to_include`\n)\nfeaturelist_two  # Note below we have an auto-generated name because we did not pass `name`\n>>> Featurelist(Testing featurelist creation - 2022-07-12)\n>>> # Note below we have a new feature list which has `\"number_diagnoses\"` excluded\nfeaturelist_two.features\n>>> ['age', 'weight']\nGet values for a pair of features in an existing project\uf0c1\nGet a sample of the exact values used in the feature association matrix plotting.\nimport datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeature_values = project.get_association_matrix_details(feature1='foo', feature2='bar')\nfeature_values.keys()\n>>> ['features', 'types', 'values']\nUpdate a project\uf0c1\nYou can update various attributes of a project.\nTo update the name of the project:\nproject.rename(new_name)\nTo update the number of workers used by your project (this will fail if you request more workers than you have\navailable; the special value -1 will request your maximum number):\nproject.set_worker_count(num_workers)\nTo unlock the Holdout set, allowing holdout scores to be shown and models to be trained on more data:\nproject.unlock_holdout()\nTo add or change the project description:\nproject.set_project_description(project_description)\nTo add or change the project\u2019s advanced_options:\n# Using kwargs\nproject.set_options(blend_best_models=False)\n# Using an ``AdvancedOptions`` instance\nproject.set_options(AdvancedOptions(blend_best_models=False))\nDelete a project\uf0c1\nUse the following command to delete a project:\nproject.delete()\nWait for Autopilot to finish\uf0c1\nOnce the modeling Autopilot is started, in some cases you will want to wait for Autopilot to finish:\nproject.wait_for_autopilot()\nPlay/Pause Autopilot\uf0c1\nIf your project is running in Autopilot, it will continually use\navailable workers, subject to the number of workers allocated to the project\nand the total number of simultaneous workers allowed according to the user\npermissions.\nTo pause a project running in Autopilot:\nproject.pause_autopilot()\nTo resume running a paused project:\nproject.unpause_autopilot()\nStart Autopilot on another feature list\uf0c1\nYou can start Autopilot on an existing feature list.\nimport datarobot as dr\nfeaturelist = project.create_featurelist('test', ['feature 1', 'feature 2'])\nproject.start_autopilot(featurelist.id)\n>>> True\n# Starting autopilot that is already running on the provided featurelist\nproject.start_autopilot(featurelist.id)\n>>> dr.errors.AppPlatformError\nNote\nThis method should be used on a project where the target has already been\nset. An error will be raised if autopilot is currently running on\nor has already finished running on the provided feature list.\nStart preparing a specific model for deployment\uf0c1\nYou can start preparing a specific model for deployment. The model will then go through the various\nrecommendation stages including retraining on a reduced feature list and retraining the model on\na higher sample size (recent data for datetime partitioned).\n# prepare a specific model for deployment and wait for the process to complete\nproject.start_prepare_model_for_deployment(model_id=model.id)\nproject.wait_for_autopilot(check_interval=5, timeout=600)\n# get the prepared model\nprepared_for_deployment_model = dr.models.ModelRecommendation.get(\nproject.id, recommendation_type=RECOMMENDED_MODEL_TYPE.PREPARED_FOR_DEPLOYMENT\n)\nprepared_for_deployment_model_id = prepared_for_deployment_model.model_id\nNote\nThis method should be used on a project where the target has already been\nset. An error will be raised if autopilot is currently running on the project or\nanother model in the project is being prepared for deployment.\nUsing credential data\uf0c1\nFor methods that accept credential data instead of user/password or credential ID, please see Credential Data documentation.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/dataset.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/datetime_partition.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\ndataset = Dataset.create_from_file(file_path='/home/user/data/last_week_data.csv')\nproject = dr.Project.create_from_dataset(dataset.id, project_name='New Project')",
        "import datarobot as dr\nproject = dr.Project.create('/home/user/data/last_week_data.csv',\n                            project_name='New Project')",
        "project.id\n>>> u'5506fcd38bd88f5953219da0'\nproject.project_name\n>>> u'New Project'",
        "target_name = 'ItemsPurchased'\nproject.get_metrics(target_name)\n>>> {'available_metrics': [\n         'Gini Norm',\n         'Weighted Gini Norm',\n         'Weighted R Squared',\n         'Weighted RMSLE',\n         'Weighted MAPE',\n         'Weighted Gamma Deviance',\n         'Gamma Deviance',\n         'RMSE',\n         'Weighted MAD',\n         'Tweedie Deviance',\n         'MAD',\n         'RMSLE',\n         'Weighted Tweedie Deviance',\n         'Weighted RMSE',\n         'MAPE',\n         'Weighted Poisson Deviance',\n         'R Squared',\n         'Poisson Deviance'],\n     'feature_name': 'SalePrice'}",
        "project.analyze_and_model",
        "project.set_partitioning_method",
        "import datarobot as dr\nproject.analyze_and_model(target='ItemsPurchased',\n                   metric='Tweedie Deviance',\n                   mode=dr.AUTOPILOT_MODE.FULL_AUTO)",
        "project.analyze_and_model",
        "Project.analyze_and_model",
        "new_project = project.clone_project(new_project_name='This is my new project')\nnew_project.project_name\n>> 'This is my new project'\nnew_project.id != project.id\n>> True",
        "import datarobot as dr\ndr.Project.list()\n>>> [Project(Project One), Project(Two)]\n\ndr.Project.list(search_params={'project_name': 'One'})\n>>> [Project(One)]",
        "import datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nproject.id\n>>> '5506fcd38bd88f5953219da0'\nproject.project_name\n>>> 'Churn Projection'",
        "import datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nassociation_data = project.get_associations(assoc_type='association', metric='mutualInfo')\nassociation_data.keys()\n>>> ['strengths', 'features']",
        "import datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelists = project.get_association_featurelists()\nfeaturelists['featurelists'][0]\n>>> {\"featurelistId\": \"54e510ef8bd88f5aeb02a3ed\", \"hasFam\": True, \"title\": \"Informative Features\"}",
        "import datarobot as dr\nfrom datarobot.models.feature_association_matrix import FeatureAssociationMatrix\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelist = project.get_featurelist_by_name(\"Raw Features\")\nstatus = FeatureAssociationMatrix.create(project.id, featurelist.id)\n# two ways to wait for completion\n# option 1\nstatus.wait_for_completion()\nfam = FeatureAssociationMatrix.get(project_id=project.id, featurelist_id=featurelist.id)\n# or option 2\n# fam = status.get_result_when_complete()",
        "import datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeaturelist = project.get_featurelist_by_name(\"Raw Features\")\nfeaturelist\n>>> Featurelist(Raw Features)\n\n# Trying to get feature list that does not exist\nfeaturelist = project.get_featurelist_by_name(\"Flying Circus\")\nfeaturelist is None\n>>> True",
        "import datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\n\nfeaturelist_one = project.create_featurelist(\n    name=\"Testing featurelist creation\",\n    features=[\"age\", \"weight\", \"number_diagnoses\"],\n)\nfeaturelist_one\n>>> Featurelist(Testing featurelist creation)\nfeaturelist_one.features\n>>> ['age', 'weight', 'number_diagnoses']\n\n# Create a feature list using another feature list as a starting point (`starting_featurelist`)\n# To Note: this example passes the `featurelist` object but you can also pass the\n# id (`starting_featurelist_id`) or the name (`starting_featurelist_name`)\nfeaturelist_two = project.create_featurelist(\n    starting_featurelist=featurelist_one,\n    features_to_exclude=[\"number_diagnoses\"],  # Please see docs for use of `features_to_include`\n)\nfeaturelist_two  # Note below we have an auto-generated name because we did not pass `name`\n>>> Featurelist(Testing featurelist creation - 2022-07-12)\n>>> # Note below we have a new feature list which has `\"number_diagnoses\"` excluded\nfeaturelist_two.features\n>>> ['age', 'weight']",
        "import datarobot as dr\nproject = dr.Project.get(project_id='5506fcd38bd88f5953219da0')\nfeature_values = project.get_association_matrix_details(feature1='foo', feature2='bar')\nfeature_values.keys()\n>>> ['features', 'types', 'values']",
        "project.rename(new_name)",
        "project.set_worker_count(num_workers)",
        "project.unlock_holdout()",
        "project.set_project_description(project_description)",
        "# Using kwargs\nproject.set_options(blend_best_models=False)\n\n# Using an ``AdvancedOptions`` instance\nproject.set_options(AdvancedOptions(blend_best_models=False))",
        "project.wait_for_autopilot()",
        "project.pause_autopilot()",
        "project.unpause_autopilot()",
        "import datarobot as dr\n\nfeaturelist = project.create_featurelist('test', ['feature 1', 'feature 2'])\nproject.start_autopilot(featurelist.id)\n>>> True\n\n# Starting autopilot that is already running on the provided featurelist\nproject.start_autopilot(featurelist.id)\n>>> dr.errors.AppPlatformError",
        "# prepare a specific model for deployment and wait for the process to complete\nproject.start_prepare_model_for_deployment(model_id=model.id)\nproject.wait_for_autopilot(check_interval=5, timeout=600)\n# get the prepared model\nprepared_for_deployment_model = dr.models.ModelRecommendation.get(\n    project.id, recommendation_type=RECOMMENDED_MODEL_TYPE.PREPARED_FOR_DEPLOYMENT\n)\nprepared_for_deployment_model_id = prepared_for_deployment_model.model_id"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/binary_data.html",
      "title": "Working with binary data\uf0c1",
      "description": "Working with binary files using the DataRobot API requires prior dataset preparation in one of the\nsupported formats. See \u201cPrepare the dataset\u201d\nfor more detail. When the dataset is ready, you can start a project following one of the methods\ndescribed in working with Datasets and Projects.",
      "content": "Working with binary data\uf0c1\nPreparing data for training\uf0c1\nWorking with binary files using the DataRobot API requires prior dataset preparation in one of the\nsupported formats. See \u201cPrepare the dataset\u201d\nfor more detail. When the dataset is ready, you can start a project following one of the methods\ndescribed in working with Datasets and Projects.\nPreparing data for predictions\uf0c1\nFor project creation and a lot of the prediction options, DataRobot allows you to upload\narchives with binary files (e.g. images files). Whenever possible it is recommended to use this\noption. However, in a few cases the API routes only allow you to upload your dataset in the JSON\nor CSV format. In these cases, you can add the binary files as base64 strings to your dataset.\nProcessing images\uf0c1\nInstallation\uf0c1\nTo enable support for processing images, install the datarobot library with the images option:\npip install datarobot[images]\nThis will install all needed dependencies for image processing.\nProcessing images\uf0c1\nWhen working with image files, helper functions may first transform your images before encoding\ntheir binary data as base64 strings.\nSpecifically, helper functions will perform these steps:\nRetrieve binary data from the file in the specified location (local path or URL).\nResize images to the image size used by DataRobot and save them in a different format\nConvert binary data to base64-encoded strings.\nWorking with images locally and located on external servers differs only in the steps related\nto binary file retrieval. The following steps for transformation and conversion to base64-encoded\nstrings are the same.\nThis examples uses data stored in a folder structure:\n/home/user/data/predictions\n\u251c\u2500\u2500 images\n\u251c\u00a0 \u251c\u2500\u2500animal01.jpg\n\u251c\u00a0 \u251c\u2500\u2500animal02.jpg\n\u251c\u00a0 \u251c\u2500\u2500animal03.png\n\u251c\u2500\u2500 data.csv\nAs an input for processing, DataRobot needs a collection of image locations. Helper functions\nwill process the images and return base64-encoded strings in the same order. The first example\nuses the contents of data.csv as an input. This file holds data needed for model predictions\nand also the image storage locations (in the \u201cimage_path\u201d column).\nContents of data.csv:\nweight_in_grams,age_in_months,image_path\n5000,34,/home/user/data/predictions/images/animal01.jpg\n4300,56,/home/user/data/predictions/images/animal02.jpg\n4200,22,/home/user/data/predictions/images/animal03.png\nThis code snippet will read each image from the \u201cimage_path\u201d column and store the base64-string\nwith image data in the \u201cimage_base64\u201d column.\nimport os\nimport pandas as pd\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\ndataset_dir = '/home/user/data/predictions'\nfile_in = os.path.join(dataset_dir, 'data.csv')\nfile_out = os.path.join(dataset_dir, 'out.csv')\ndf = pd.read_csv(file_in)\ndf['image_base64'] = get_encoded_image_contents_from_paths(df['image_path'])\ndf.to_csv(file_out, index=False)\nThe same helper function will work with other iterables:\nimport os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\nimages_dir = '/home/user/data/predictions/images'\nimages_absolute_paths = [\nos.path.join(images_dir, file) for file in ['animal01.jpg', 'animal02.jpg', 'animal03.png']\n]\nimages_base64 = get_encoded_image_contents_from_paths(images_absolute_paths)\nAbove examples used absolute paths. When working with relative paths, by default the helper function will resolve them relative to the script location. To override this behavior, use base_path parameter to specify the base path for relative paths.\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\nimages_dir = '/home/user/data/predictions/images'\nimages_relative_paths = ['animal01.jpg', 'animal02.jpg', 'animal03.png']\nimages_base64 = get_encoded_image_contents_from_paths(\nimages_relative_paths, base_path=images_dir\n)\nThere is also one helper function to work with remote data. This function retrieves binary content\nfrom specified URLs, transforms the images, and returns base64-encoded strings (in the the same way\nas it does for images loaded from local paths).\nExample:\nimport os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_urls\nimage_urls = [\n'https://<YOUR_SERVER_ADDRESS>/animal01.jpg',\n'https://<YOUR_SERVER_ADDRESS>/animal02.jpg',\n'https://<YOUR_SERVER_ADDRESS>/animal03.png'\n]\nimages_base64 = get_encoded_image_contents_from_urls(image_urls)\nExamples of helper functions up to this points have used default settings. If needed, the following\nfunctions allow for further customization by passing explicit parameters related to error handling,\nimage transformations, and request header customization.\nCustom image transformations\uf0c1\nBy default helper functions will apply transformations, which have proven good results. The default\nvalues align with the preprocessing used for images uploaded in archives for training.\nTherefore, using default values should be the first choice when preparing datasets with images\nfor predictions. However, you can also specify custom image transformation settings to override\ndefault transformations before converting data into base64 strings. To override the default\nbehavior, create an instance of the ImageOptions class and pass it as an additional parameter\nto the helper function.\nNote that there is no guarantee that images converted by DataRobot during archive dataset upload\nmatch images converted by you on a pixel level, even if the default ImageOptions are\nused. However, if you use ImageOptions, you most likely will not be able to visually identify any differences.\nExamples:\nimport os\nfrom datarobot.helpers.image_utils import ImageOptions\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\nimages_dir = '/home/user/data/predictions/images'\nimages_absolute_paths = [\nos.path.join(images_dir, file) for file in ['animal01.jpg', 'animal02.jpg', 'animal03.png']\n]\n# Override the default behavior for image quality and subsampling, but the images\n# will still be resized because that's the default behavior. Note: the `keep_quality`\n# parameter for JPEG files by default preserves the quality of the original images,\n# so this behavior must be disabled to manually override the quality setting with an\n# explicit value.\nimage_options = ImageOptions(keep_quality=False, image_quality=80, image_subsampling=0)\nimages_base64 = get_encoded_image_contents_from_paths(\npaths=images_absolute_paths, image_options=image_options\n)\n# overwrite default behavior for image resizing, this will keep image aspect\n# ratio and will resize all images using specified size: width=300 and height=300.\n# Note: if image had different aspect ratio originally it will generate image\n# thumbnail, not larger than the original, that will fit in requested image size\nimage_options = ImageOptions(image_size=(300, 300))\nimages_base64 = get_encoded_image_contents_from_paths(\npaths=images_absolute_paths, image_options=image_options\n)\n# Override the default behavior for image resizing, This will force the image\n# to be resized to size: width=300 and height=300. When the image originally\n# had a different aspect ratio - than resizing it using `force_size` parameter\n# will alter its aspect ratio modifying the image (e.g. stretching)\nimage_options = ImageOptions(image_size=(300, 300), force_size=True)\nimages_base64 = get_encoded_image_contents_from_paths(\npaths=images_absolute_paths, image_options=image_options\n)\n# overwrite default behavior and retain original image sizes\nimage_options = ImageOptions(should_resize=False)\nimages_base64 = get_encoded_image_contents_from_paths(\npaths=images_absolute_paths, image_options=image_options\n)\nCustom request headers\uf0c1\nIf needed, you can specify custom request headers for downloading binary data.\nExample:\nimport os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_urls\ntoken = 'Nl69vmABaEuchUsj88N0eOoH2kfUbhCCByhoFDf4whJyJINTf7NOhhPrNQKqVVJJ'\ncustom_headers = {\n'User-Agent': 'My User Agent',\n'Authorization': 'Bearer {}'.format(token)\n}\nimage_urls = [\n'https://<YOUR_SERVER_ADDRESS>/animal01.jpg',\n'https://<YOUR_SERVER_ADDRESS>/animal02.jpg',\n'https://<YOUR_SERVER_ADDRESS>/animal03.png',\n]\nimages_base64 = get_encoded_image_contents_from_urls(image_urls, custom_headers)\nHandling errors\uf0c1\nWhen processing multiple images, any error during processing will, by default, stop operations\n(i.e., the helper function will raise datarobot.errors.ContentRetrievalTerminatedError and\nterminate further processing). In the case of an error during content retrieval (\u201cconnectivity\nissue\u201d, \u201cfile not found\u201d etc), you can override this behavior by passing continue_on_error=True\nto the helper function. When specified, processing will continue. In rows where the error was\nraised, the value``None`` value will be returned instead of a base64-encoded string. This applies\nonly to errors during content retrieval, other errors will always terminate execution.\nExample:\nimport os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\nimages_dir = '/home/user/data/predictions/images'\nimages_absolute_paths = [\nos.path.join(images_dir, file) for file in ['animal01.jpg', 'missing.jpg', 'animal03.png']\n]\n# This execution will print None for missing files and base64 strings for exising files\nimages_base64 = get_encoded_image_contents_from_paths(images_absolute_paths, continue_on_error=True)\nfor value in images_base64:\nprint(value)\n# This execution will raise error during processing of missing file terminating operation\nimages_base64 = get_encoded_image_contents_from_paths(images_absolute_paths)\nProcessing other binary files\uf0c1\nOther binary files can be processed by dedicated functions. These functions work similarly to the\nfunctions used for images, although they do not provide functionality for any transformations.\nProcessing follows two steps instead of three:\nRetrieve binary data from the file in the specified location (local path or URL).\nConvert binary data to base64-encoded strings.\nTo process documents into base64-encoded strings use these functions:\nTo retrieve files from local paths: get_encoded_file_contents_from_paths - t\nTo retrieve files from locations specified as URLs: get_encoded_file_contents_from_urls -\nExamples:\nimport os\nfrom datarobot.helpers.binary_data_utils import get_encoded_file_contents_from_urls\ndocument_urls = [\n'https://<YOUR_SERVER_ADDRESS>/document01.pdf',\n'https://<YOUR_SERVER_ADDRESS>/missing.pdf',\n'https://<YOUR_SERVER_ADDRESS>/document03.pdf',\n]\n# this call will return base64 strings for existing documents and None for missing files\ndocuments_base64 = get_encoded_file_contents_from_urls(document_urls, continue_on_error=True)\nfor value in documents_base64:\nprint(value)\n# This execution will raise error during processing of missing file terminating operation\ndocuments_base64 = get_encoded_file_contents_from_urls(document_urls)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://docs.datarobot.com/en/docs/modeling/special-workflows/visual-ai/vai-model.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/dataset.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/project.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "pip install datarobot[images]",
        "import os\nimport pandas as pd\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\n\ndataset_dir = '/home/user/data/predictions'\nfile_in = os.path.join(dataset_dir, 'data.csv')\nfile_out = os.path.join(dataset_dir, 'out.csv')\n\ndf = pd.read_csv(file_in)\ndf['image_base64'] = get_encoded_image_contents_from_paths(df['image_path'])\ndf.to_csv(file_out, index=False)",
        "import os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\n\nimages_dir = '/home/user/data/predictions/images'\nimages_absolute_paths = [\n    os.path.join(images_dir, file) for file in ['animal01.jpg', 'animal02.jpg', 'animal03.png']\n]\n\nimages_base64 = get_encoded_image_contents_from_paths(images_absolute_paths)",
        "from datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\n\nimages_dir = '/home/user/data/predictions/images'\nimages_relative_paths = ['animal01.jpg', 'animal02.jpg', 'animal03.png']\n\nimages_base64 = get_encoded_image_contents_from_paths(\n  images_relative_paths, base_path=images_dir\n)",
        "import os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_urls\n\nimage_urls = [\n    'https://<YOUR_SERVER_ADDRESS>/animal01.jpg',\n    'https://<YOUR_SERVER_ADDRESS>/animal02.jpg',\n    'https://<YOUR_SERVER_ADDRESS>/animal03.png'\n]\n\nimages_base64 = get_encoded_image_contents_from_urls(image_urls)",
        "import os\nfrom datarobot.helpers.image_utils import ImageOptions\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\n\nimages_dir = '/home/user/data/predictions/images'\nimages_absolute_paths = [\n    os.path.join(images_dir, file) for file in ['animal01.jpg', 'animal02.jpg', 'animal03.png']\n]\n\n# Override the default behavior for image quality and subsampling, but the images\n# will still be resized because that's the default behavior. Note: the `keep_quality`\n# parameter for JPEG files by default preserves the quality of the original images,\n# so this behavior must be disabled to manually override the quality setting with an\n# explicit value.\nimage_options = ImageOptions(keep_quality=False, image_quality=80, image_subsampling=0)\nimages_base64 = get_encoded_image_contents_from_paths(\n    paths=images_absolute_paths, image_options=image_options\n)\n\n\n# overwrite default behavior for image resizing, this will keep image aspect\n# ratio and will resize all images using specified size: width=300 and height=300.\n# Note: if image had different aspect ratio originally it will generate image\n# thumbnail, not larger than the original, that will fit in requested image size\nimage_options = ImageOptions(image_size=(300, 300))\nimages_base64 = get_encoded_image_contents_from_paths(\n    paths=images_absolute_paths, image_options=image_options\n)\n\n# Override the default behavior for image resizing, This will force the image\n# to be resized to size: width=300 and height=300. When the image originally\n# had a different aspect ratio - than resizing it using `force_size` parameter\n# will alter its aspect ratio modifying the image (e.g. stretching)\nimage_options = ImageOptions(image_size=(300, 300), force_size=True)\nimages_base64 = get_encoded_image_contents_from_paths(\n    paths=images_absolute_paths, image_options=image_options\n)\n\n# overwrite default behavior and retain original image sizes\nimage_options = ImageOptions(should_resize=False)\nimages_base64 = get_encoded_image_contents_from_paths(\n    paths=images_absolute_paths, image_options=image_options\n)",
        "import os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_urls\n\ntoken = 'Nl69vmABaEuchUsj88N0eOoH2kfUbhCCByhoFDf4whJyJINTf7NOhhPrNQKqVVJJ'\ncustom_headers = {\n    'User-Agent': 'My User Agent',\n    'Authorization': 'Bearer {}'.format(token)\n}\n\nimage_urls = [\n    'https://<YOUR_SERVER_ADDRESS>/animal01.jpg',\n    'https://<YOUR_SERVER_ADDRESS>/animal02.jpg',\n    'https://<YOUR_SERVER_ADDRESS>/animal03.png',\n]\n\nimages_base64 = get_encoded_image_contents_from_urls(image_urls, custom_headers)",
        "datarobot.errors.ContentRetrievalTerminatedError",
        "import os\nfrom datarobot.helpers.binary_data_utils import get_encoded_image_contents_from_paths\n\nimages_dir = '/home/user/data/predictions/images'\nimages_absolute_paths = [\n    os.path.join(images_dir, file) for file in ['animal01.jpg', 'missing.jpg', 'animal03.png']\n]\n\n# This execution will print None for missing files and base64 strings for exising files\nimages_base64 = get_encoded_image_contents_from_paths(images_absolute_paths, continue_on_error=True)\nfor value in images_base64:\n    print(value)\n\n# This execution will raise error during processing of missing file terminating operation\nimages_base64 = get_encoded_image_contents_from_paths(images_absolute_paths)",
        "import os\nfrom datarobot.helpers.binary_data_utils import get_encoded_file_contents_from_urls\n\ndocument_urls = [\n    'https://<YOUR_SERVER_ADDRESS>/document01.pdf',\n    'https://<YOUR_SERVER_ADDRESS>/missing.pdf',\n    'https://<YOUR_SERVER_ADDRESS>/document03.pdf',\n]\n\n# this call will return base64 strings for existing documents and None for missing files\ndocuments_base64 = get_encoded_file_contents_from_urls(document_urls, continue_on_error=True)\nfor value in documents_base64:\n    print(value)\n\n# This execution will raise error during processing of missing file terminating operation\ndocuments_base64 = get_encoded_file_contents_from_urls(document_urls)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/custom_task.html",
      "title": "Composable ML\uf0c1",
      "description": "Composable ML consists of two major components: the DataRobot Blueprint Workshop and custom tasks, detailed below.",
      "content": "Composable ML\uf0c1\nComposable ML consists of two major components: the DataRobot Blueprint Workshop and custom tasks, detailed below.\nCustom tasks provide users the ability to train models with arbitrary code in an environment defined by the user.\nFor details on using environments, see: Manage Execution Environments.\nManage Custom Tasks\uf0c1\nBefore you can upload code for a custom task, you need to create the entity that holds all the\nmetadata.\nimport datarobot as dr\nfrom datarobot.enums import CUSTOM_TASK_TARGET_TYPE\ntransform = dr.CustomTask.create(\nname=\"a convenient display name\",  # required\ntarget_type=CUSTOM_TASK_TARGET_TYPE.TRANSFORM,  # required\nlanguage=\"python\",\ndescription=\"a longer description of the task\"\n)\nbinary = dr.CustomTask.create(\nname=\"this or that\",\ntarget_type=CUSTOM_TASK_TARGET_TYPE.BINARY,\n)\nA task, by itself is an empty metadata container. Before using your tasks, you need create a\nCustomTaskVersion associated with it. A task that is ready for use\nwill have a latest_version field populated with this task.\nbinary.latest_version\n>>> None\nexecution_environment = dr.ExecutionEnvironment.create(\nname=\"Python3 PyTorch Environment\",\ndescription=\"This environment contains Python3 pytorch library.\",\n)\ncustom_task_folder = \"datarobot-user-tasks/task_templates/python3_pytorch\"\ntask_version = dr.CustomTaskVersion.create_clean(\ncustom_task_id=binary.id,\nbase_environment_id=execution_environment.id,\nfolder_path=custom_task_folder,\n)\nbinary.refresh()  # In order to see the change, you need to GET it from DataRobot\nbinary.latest_version\n>>> CustomTaskVersion('v1.0')\nIf you create a new version, that will be returned as the latest_version. You can\ndownload the latest version as a zip file.\nbinary.latest_version\n>>> CustomTaskVersion('v1.0')\ncustom_task_folder = \"/home/my-user-name/tasks/my-updated-task/\"\ntask_version = dr.CustomTaskVersion.create_clean(\ncustom_task_id=binary.id,\nbase_environment_id=execution_environment.id,\nfolder_path=custom_task_folder,\n)\nbinary.refresh()\nbinary.latest_version\n>>> CustomTaskVersion('v2.0')\nbinary.download_latest_version(\"/home/my-user-name/downloads/my-task-files.zip\")\nYou can get, list, copy, exactly as you would expect. copy makes a complete copy of the\ntask: new copies of the metadata, new copies of the versions, new copies of uploaded files for the\nnew versions.\nall_tasks = CustomTask.list()\nassert {el.id for el in all_tasks} == {binary.id, transform.id}\nnew_binary = CustomTask.copy(binary.id)\nassert new_binary.latest_version.id != binary.latest_version.id\noriginal_binary = CustomTask.get(binary.id)\nassert len(CustomTask.list()) == 3\nYou can update the metadata of a task. When you do this, the object is also updated to the latest\ndata.\nassert binary.description == new_binary.description\nbinary.update(description=\"totally new description\")\nassert binary.description != new_binary.description\nassert original_binary.description != binary.description  # hasn't refreshed from the server yet\noriginal_binary.refresh()\nassert original_binary.description == binary.description\nAnd finally, you can delete only if the task is not in use by any of the following:\nTrained models\nDeployments\nBlueprints in the AI catalog\nOnce you have deleted the objects that use the task, you will be able to delete the task itself.\nManage Custom Task Versions\uf0c1\nCode for Custom Tasks can be uploaded by creating a Custom Task Version.\nWhen creating a Custom Task Version, the version must be associated with a base execution\nenvironment.  If the base environment supports additional task dependencies\n(R or Python environments) and the Custom Task Version\ncontains a valid requirements.txt file, the task version will run in an environment based on\nthe base environment with the additional dependencies installed.\nCreate Custom Task Version\uf0c1\nUpload actual custom task content by creating a clean Custom Task Version:\nimport os\nfrom datarobot.enums import CustomTaskOutboundNetworkPolicy\ncustom_task_id = binary.id\ncustom_task_folder = \"datarobot-user-tasks/task_templates/python3_pytorch\"\n# add files from the folder to the custom task\ntask_version = dr.CustomTaskVersion.create_clean(\ncustom_task_id=custom_task_id,\nbase_environment_id=execution_environment.id,\nfolder_path=custom_task_folder,\noutbound_network_policy=CustomTaskOutboundNetworkPolicy.PUBLIC,\n)\nTo create a new Custom Task Version from a previous one, with just some files added or removed, do the following:\nimport os\nimport datarobot as dr\nnew_files_folder = \"datarobot-user-tasks/task_templates/my_files_to_add_to_pytorch_task\"\nfile_to_delete = task_version.items[0].id\ntask_version_2 = dr.CustomTaskVersion.create_from_previous(\ncustom_task_id=custom_task_id,\nbase_environment_id=execution_environment.id,\nfolder_path=new_files_folder,\n)\nPlease refer to CustomTaskFileItem for description of custom task file properties.\nList Custom Task Versions\uf0c1\nUse the following command to list Custom Task Versions available to the user:\nimport datarobot as dr\ndr.CustomTaskVersion.list(custom_task_id)\n>>> [CustomTaskVersion('v2.0'), CustomTaskVersion('v1.0')]\nRetrieve Custom Task Version\uf0c1\nTo retrieve a specific Custom Task Version, run:\nimport datarobot as dr\ndr.CustomTaskVersion.get(custom_task_id, custom_task_version_id='5ebe96b84024035cc6a6560b')\n>>> CustomTaskVersion('v2.0')\nUpdate Custom Task Version\uf0c1\nTo update Custom Task Version description execute the following:\nimport datarobot as dr\ncustom_task_version = dr.CustomTaskVersion.get(\ncustom_task_id,\ncustom_task_version_id='5ebe96b84024035cc6a6560b',\n)\ncustom_task_version.update(description='new description')\ncustom_task_version.description\n>>> 'new description'\nDownload Custom Task Version\uf0c1\nDownload content of the Custom Task Version as a ZIP archive:\nimport datarobot as dr\npath_to_download = '/home/user/Documents/myTask.zip'\ncustom_task_version = dr.CustomTaskVersion.get(\ncustom_task_id,\ncustom_task_version_id='5ebe96b84024035cc6a6560b',\n)\ncustom_task_version.download(path_to_download)\nPreparing a Custom Task Version for Use\uf0c1\nIf your custom task version has dependencies, a dependency build must be completed before the task\ncan be used.  The dependency build installs your task\u2019s dependencies into the base environment\nassociated with the task version.\nsee: Preparing a Custom Model Version for Use",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://blueprint-workshop.datarobot.com/",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/mlops/custom_model.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/blueprints.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nfrom datarobot.enums import CUSTOM_TASK_TARGET_TYPE\n\ntransform = dr.CustomTask.create(\n    name=\"a convenient display name\",  # required\n    target_type=CUSTOM_TASK_TARGET_TYPE.TRANSFORM,  # required\n    language=\"python\",\n    description=\"a longer description of the task\"\n)\n\nbinary = dr.CustomTask.create(\n    name=\"this or that\",\n    target_type=CUSTOM_TASK_TARGET_TYPE.BINARY,\n)",
        "binary.latest_version\n>>> None\n\nexecution_environment = dr.ExecutionEnvironment.create(\n    name=\"Python3 PyTorch Environment\",\n    description=\"This environment contains Python3 pytorch library.\",\n)\ncustom_task_folder = \"datarobot-user-tasks/task_templates/python3_pytorch\"\ntask_version = dr.CustomTaskVersion.create_clean(\n    custom_task_id=binary.id,\n    base_environment_id=execution_environment.id,\n    folder_path=custom_task_folder,\n)\n\nbinary.refresh()  # In order to see the change, you need to GET it from DataRobot\nbinary.latest_version\n>>> CustomTaskVersion('v1.0')",
        "binary.latest_version\n>>> CustomTaskVersion('v1.0')\n\ncustom_task_folder = \"/home/my-user-name/tasks/my-updated-task/\"\ntask_version = dr.CustomTaskVersion.create_clean(\n    custom_task_id=binary.id,\n    base_environment_id=execution_environment.id,\n    folder_path=custom_task_folder,\n)\n\nbinary.refresh()\nbinary.latest_version\n>>> CustomTaskVersion('v2.0')\n\nbinary.download_latest_version(\"/home/my-user-name/downloads/my-task-files.zip\")",
        "import os\n\nfrom datarobot.enums import CustomTaskOutboundNetworkPolicy\n\ncustom_task_id = binary.id\ncustom_task_folder = \"datarobot-user-tasks/task_templates/python3_pytorch\"\n\n# add files from the folder to the custom task\ntask_version = dr.CustomTaskVersion.create_clean(\n    custom_task_id=custom_task_id,\n    base_environment_id=execution_environment.id,\n    folder_path=custom_task_folder,\n    outbound_network_policy=CustomTaskOutboundNetworkPolicy.PUBLIC,\n)",
        "import os\n\nimport datarobot as dr\n\nnew_files_folder = \"datarobot-user-tasks/task_templates/my_files_to_add_to_pytorch_task\"\n\nfile_to_delete = task_version.items[0].id\n\ntask_version_2 = dr.CustomTaskVersion.create_from_previous(\n    custom_task_id=custom_task_id,\n    base_environment_id=execution_environment.id,\n    folder_path=new_files_folder,\n)",
        "import datarobot as dr\n\ndr.CustomTaskVersion.list(custom_task_id)\n\n>>> [CustomTaskVersion('v2.0'), CustomTaskVersion('v1.0')]",
        "import datarobot as dr\n\ndr.CustomTaskVersion.get(custom_task_id, custom_task_version_id='5ebe96b84024035cc6a6560b')\n\n>>> CustomTaskVersion('v2.0')",
        "import datarobot as dr\n\ncustom_task_version = dr.CustomTaskVersion.get(\n    custom_task_id,\n    custom_task_version_id='5ebe96b84024035cc6a6560b',\n)\n\ncustom_task_version.update(description='new description')\n\ncustom_task_version.description\n>>> 'new description'",
        "import datarobot as dr\n\npath_to_download = '/home/user/Documents/myTask.zip'\n\ncustom_task_version = dr.CustomTaskVersion.get(\n    custom_task_id,\n    custom_task_version_id='5ebe96b84024035cc6a6560b',\n)\n\ncustom_task_version.download(path_to_download)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/datetime_partition.html",
      "title": "Datetime Partitioned Projects\uf0c1",
      "description": "If your dataset is modeling events taking place over time, datetime partitioning may be appropriate.\nDatetime partitioning ensures that when partitioning the dataset for training and validation, rows\nare ordered according to the value of the date partition feature.",
      "content": "Datetime Partitioned Projects\uf0c1\nIf your dataset is modeling events taking place over time, datetime partitioning may be appropriate.\nDatetime partitioning ensures that when partitioning the dataset for training and validation, rows\nare ordered according to the value of the date partition feature.\nSetting Up a Datetime Partitioned Project\uf0c1\nAfter creating a project and before setting the target, create a\nDatetimePartitioningSpecification to define how the project should\nbe partitioned.  By passing the specification into DatetimePartitioning.generate, the full\npartitioning can be previewed before finalizing the partitioning.  After verifying that the\npartitioning is correct for the project dataset, pass the specification into Project.analyze_and_model\nvia the partitioning_method argument. Alternatively, as of v3.0, by using Project.set_datetime_partitioning(),\nthe partitioning (and individual options of the partitioning specification) can be updated (with repeated\nmethod calls) up until calling Project.analyze_and_model. Once modeling begins, the project can be used as normal.\nThe following code block shows the basic workflow for creating datetime partitioned projects.\nimport datarobot as dr\nproject = dr.Project.create('some_data.csv')\nspec = dr.DatetimePartitioningSpecification('my_date_column')\n# can customize the spec as needed\npartitioning_preview = dr.DatetimePartitioning.generate(project.id, spec)\n# the preview generated is based on the project's data\nprint(partitioning_preview.to_dataframe())\n# hmm ... I want more backtests\nspec.number_of_backtests = 5\npartitioning_preview = dr.DatetimePartitioning.generate(project.id, spec)\nprint(partitioning_preview.to_dataframe())\n# looks good\nproject.analyze_and_model('target_column')\n# As of v3.0, ``Project.set_datetime_partitioning()`` and ``Project.list_datetime_partition_spec()``\n# are available as an alternative:\n# view settings\nproject.list_datetime_partition_spec()\n# maybe I want to also disable holdout before starting modeling\nproject.set_datetime_partitioning(disable_holdout=True)\n# view settings\nproject.list_datetime_partition_spec()\n# all of the settings look good\n# don't need to pass the spec into ``analyze_and_model`` because it's already been set\nproject.analyze_and_model('target_column')\n# I can retrieve the partitioning settings after the target has been set too\npartitioning = dr.DatetimePartitioning.get(project.id)\nConfiguring Backtests\uf0c1\nBacktests are configurable using one of two methods:\nMethod 1:\nindex (int): The index from zero of this backtest.\ngap_duration (str): A duration string such as those returned by the partitioning_methods.construct_duration_string helper method. This represents the gap between\ntraining and validation scoring data for this backtest.\nvalidation_start_date (datetime.datetime): Represents the start date of the validation scoring data for this backtest.\nvalidation_duration (str): A duration string such as those returned by the partitioning_methods.construct_duration_string helper method. This represents the desired duration\nof the validation scoring data for this backtest.\nimport datarobot as dr\nfrom datetime import datetime\npartitioning_spec = dr.DatetimePartitioningSpecification(\nbacktests=[\n# modify the first backtest using option 1\ndr.BacktestSpecification(\nindex=0,\ngap_duration=dr.partitioning_methods.construct_duration_string(),\nvalidation_start_date=datetime(year=2010, month=1, day=1),\nvalidation_duration=dr.partitioning_methods.construct_duration_string(years=1),\n)\n],\n# other partitioning settings...\n)\nMethod 2 (New in version v2.20):\nvalidation_start_date (datetime.datetime): Represents the start date of the validation scoring data for this backtest.\nvalidation_end_date (datetime.datetime): Represents the end date of the validation scoring data for this backtest.\nprimary_training_start_date (datetime.datetime): Represents the desired start date of the training partition for this backtest.\nprimary_training_end_date (datetime.datetime): Represents the desired end date of the training partition for this backtest.\nimport datarobot as dr\nfrom datetime import datetime\npartitioning_spec = dr.DatetimePartitioningSpecification(\nbacktests=[\n# modify the first backtest using option 2\ndr.BacktestSpecification(\nindex=0,\nprimary_training_start_date=datetime(year=2005, month=1, day=1),\nprimary_training_end_date=datetime(year=2010, month=1, day=1),\nvalidation_start_date=datetime(year=2010, month=1, day=1),\nvalidation_end_date=datetime(year=2011, month=1, day=1),\n)\n],\n# other partitioning settings...\n)\nNote that Method 2 allows you to directly configure the start and end dates of each partition, including the training\npartition. The gap partition is calculated as the time between primary_training_end_date and\nvalidation_start_date. Using the same date for both primary_training_end_date and validation_start_date will\nresult in no gap being created.\nAfter configuring backtests, you can set use_project_settings to True in calls to\nModel.train_datetime. This will create models that are trained\nand validated using your custom backtest training partition start and end dates.\nModeling with a Datetime Partitioned Project\uf0c1\nWhile Model objects can still be used to interact with the project,\nDatetimeModel objects, which are only retrievable from datetime partitioned\nprojects, provide more information including which date ranges and how many rows are used in\ntraining and scoring the model as well as scores and statuses for individual backtests.\nThe autopilot workflow is the same as for other projects, but to manually train a model,\nProject.train_datetime and Model.train_datetime should be used in the place of\nProject.train and Model.train.  To create frozen models,\nModel.request_frozen_datetime_model should be used in place of\nDatetimeModel.request_frozen_datetime_model.  Unlike other projects, to trigger computation of\nscores for all backtests use DatetimeModel.score_backtests instead of using the scoring_type\nargument in the train methods.\nAccuracy Over Time Plots\uf0c1\nFor datetime partitioned model you can retrieve the Accuracy over Time plot. To do so use\nDatetimeModel.get_accuracy_over_time_plot.\nYou can also retrieve the detailed metadata using DatetimeModel.get_accuracy_over_time_plots_metadata,\nand the preview plot using DatetimeModel.get_accuracy_over_time_plot_preview.\nDates, Datetimes, and Durations\uf0c1\nWhen specifying a date or datetime for datetime partitioning, the client expects to receive and\nwill return a datetime.  Timezones may be specified, and will be assumed to be UTC if left\nunspecified.  All dates returned from DataRobot are in UTC with a timezone specified.\nDatetimes may include a time, or specify only a date; however, they may have a non-zero time\ncomponent only if the partition column included a time component in its date format. If the\npartition column included only dates like \u201c24/03/2015\u201d, then the time component of any datetimes,\nif present, must be zero.\nWhen date ranges are specified with a start and an end date, the end date is exclusive, so only\ndates earlier than the end date are included, but the start date is inclusive, so dates equal to or\nlater than the start date are included.  If the start and end date are the same, then no dates are\nincluded in the range.\nDurations are specified using a subset of ISO8601.  Durations will be of the form PnYnMnDTnHnMnS\nwhere each \u201cn\u201d may be replaced with an integer value.  Within the duration string,\nnY represents the number of years\nthe nM following the \u201cP\u201d represents the number of months\nnD represents the number of days\nnH represents the number of hours\nthe nM following the \u201cT\u201d represents the number of minutes\nnS represents the number of seconds\nand \u201cP\u201d is used to indicate that the string represents a period and \u201cT\u201d indicates the beginning of\nthe time component of the string.  Any section with a value of 0 may be excluded.  As with\ndatetimes, if the partition column did not include a time component in its date format, the time\ncomponent of any duration must be either unspecified or consist only of zeros.\nExample Durations:\n\u201cP3Y6M\u201d (three years, six months)\n\u201cP1Y0M0DT0H0M0S\u201d (one year)\n\u201cP1Y5DT10H\u201d (one year, 5 days, 10 hours)\ndatarobot.helpers.partitioning_methods.construct_duration_string is a\nhelper method that can be used to construct appropriate duration strings.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "Project.analyze_and_model",
        "Project.set_datetime_partitioning()",
        "Project.analyze_and_model",
        "import datarobot as dr\n\nproject = dr.Project.create('some_data.csv')\nspec = dr.DatetimePartitioningSpecification('my_date_column')\n# can customize the spec as needed\n\npartitioning_preview = dr.DatetimePartitioning.generate(project.id, spec)\n# the preview generated is based on the project's data\n\nprint(partitioning_preview.to_dataframe())\n# hmm ... I want more backtests\nspec.number_of_backtests = 5\npartitioning_preview = dr.DatetimePartitioning.generate(project.id, spec)\nprint(partitioning_preview.to_dataframe())\n# looks good\nproject.analyze_and_model('target_column')\n\n# As of v3.0, ``Project.set_datetime_partitioning()`` and ``Project.list_datetime_partition_spec()``\n# are available as an alternative:\n\n# view settings\nproject.list_datetime_partition_spec()\n# maybe I want to also disable holdout before starting modeling\nproject.set_datetime_partitioning(disable_holdout=True)\n# view settings\nproject.list_datetime_partition_spec()\n# all of the settings look good\n# don't need to pass the spec into ``analyze_and_model`` because it's already been set\nproject.analyze_and_model('target_column')\n\n# I can retrieve the partitioning settings after the target has been set too\npartitioning = dr.DatetimePartitioning.get(project.id)",
        "import datarobot as dr\nfrom datetime import datetime\n\n    partitioning_spec = dr.DatetimePartitioningSpecification(\n        backtests=[\n            # modify the first backtest using option 1\n            dr.BacktestSpecification(\n                index=0,\n                gap_duration=dr.partitioning_methods.construct_duration_string(),\n                validation_start_date=datetime(year=2010, month=1, day=1),\n                validation_duration=dr.partitioning_methods.construct_duration_string(years=1),\n            )\n        ],\n        # other partitioning settings...\n    )",
        "import datarobot as dr\nfrom datetime import datetime\n\n    partitioning_spec = dr.DatetimePartitioningSpecification(\n        backtests=[\n            # modify the first backtest using option 2\n            dr.BacktestSpecification(\n                index=0,\n                primary_training_start_date=datetime(year=2005, month=1, day=1),\n                primary_training_end_date=datetime(year=2010, month=1, day=1),\n                validation_start_date=datetime(year=2010, month=1, day=1),\n                validation_end_date=datetime(year=2011, month=1, day=1),\n            )\n        ],\n        # other partitioning settings...\n    )",
        "Project.train_datetime",
        "Model.request_frozen_datetime_model",
        "DatetimeModel.request_frozen_datetime_model",
        "DatetimeModel.score_backtests",
        "DatetimeModel.get_accuracy_over_time_plot",
        "DatetimeModel.get_accuracy_over_time_plots_metadata",
        "DatetimeModel.get_accuracy_over_time_plot_preview"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
      "title": "Specialized workflows\uf0c1",
      "description": "The following sections describe alternative workflows for a variety of specialized data types.",
      "content": "Specialized workflows\uf0c1\nThe following sections describe alternative workflows for a variety of specialized data types.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/monotonic_constraints.html",
      "title": "Monotonic Constraints\uf0c1",
      "description": "Training with monotonic constraints allows users to force models to learn monotonic relationships with respect to some features and the target. This helps users create accurate models that comply with regulations (e.g. insurance, banking). Currently, only certain blueprints (e.g. xgboost) support this feature, and it is only supported for regression and binary classification projects. Typically working with monotonic constraints follows the following two workflows:",
      "content": "Monotonic Constraints\uf0c1\nTraining with monotonic constraints allows users to force models to learn monotonic relationships with respect to some features and the target. This helps users create accurate models that comply with regulations (e.g. insurance, banking). Currently, only certain blueprints (e.g. xgboost) support this feature, and it is only supported for regression and binary classification projects. Typically working with monotonic constraints follows the following two workflows:\nWorkflow one - Running a project with default monotonic constraints\nset the target and specify default constraint lists for the project\nwhen running autopilot or manually training models without overriding constraint settings, all blueprints that support monotonic constraints will use the specified default constraint featurelists\nWorkflow two - Running a model with specific monotonic constraints\ncreate featurelists for monotonic constraints\ntrain a blueprint that supports monotonic constraints while specifying monotonic constraint featurelists\nthe specified constraints will be used, regardless of the defaults on the blueprint\nCreating featurelists\uf0c1\nWhen specifying monotonic constraints, users must pass a reference to a featurelist containing only the features to be constrained, one for features that should monotonically increase with the target and another for those that should monotonically decrease with the target.\nimport datarobot as dr\nproject = dr.Project.get(project_id)\nfeatures_mono_up = ['feature_0', 'feature_1']  # features that have monotonically increasing relationship with target\nfeatures_mono_down = ['feature_2', 'feature_3']  # features that have monotonically decreasing relationship with target\nflist_mono_up = project.create_featurelist(name='mono_up',\nfeatures=features_mono_up)\nflist_mono_down = project.create_featurelist(name='mono_down',\nfeatures=features_mono_down)\nSpecify default monotonic constraints for a project\uf0c1\nUsers can specify default monotonic constraints for the project, to ensure that autopilot models use the desired settings, and optionally to ensure that only blueprints supporting monotonic constraints appear in the project. Regardless of the defaults specified via advanced options selection, the user can override them when manually training a particular model.\nimport datarobot as dr\nfrom datarobot.enums import AUTOPILOT_MODE\nproject = dr.Project.get(project_id)\n# As of v3.0, ``Project.set_options`` may be used as an alternative to passing `advanced_options`` into ``Project.analyze_and_model``.\nproject.set_options(\nmonotonic_increasing_featurelist_id=flist_mono_up.id,\nmonotonic_decreasing_featurelist_id=flist_mono_down.id,\nonly_include_monotonic_blueprints=True\n)\nproject.analyze_and_model(target='target', mode=AUTOPILOT_MODE.FULL_AUTO)\nIf Project.set_options is not used, alternatively, an advanced options instance may be passed directly to project.analyze_and_model:\nproject.analyze_and_model(\ntarget='target',\nmode=AUTOPILOT_MODE.FULL_AUTO,\nadvanced_options=AdvancedOptions(monotonic_increasing_featurelist_id=flist_mono_up.id, monotonic_decreasing_featurelist_id=flist_mono_down.id, only_include_monotonic_blueprints=True)\n)\nRetrieve models and blueprints using monotonic constraints\uf0c1\nWhen retrieving models, users can inspect to see which supports monotonic constraints, and which actually enforces them. Some models will not support monotonic constraints at all, and some may support constraints but not have any constrained features specified.\nimport datarobot as dr\nproject = dr.Project.get(project_id)\nmodels = project.get_models()\n# retrieve models that support monotonic constraints\nmodels_support_mono = [model for model in models if model.supports_monotonic_constraints]\n# retrieve models that support and enforce monotonic constraints\nmodels_enforce_mono = [model for model in models\nif (model.monotonic_increasing_featurelist_id or\nmodel.monotonic_decreasing_featurelist_id)]\nWhen retrieving blueprints, users can check if they support monotonic constraints and see what default constraint lists are associated with them. The monotonic featurelist ids associated with a blueprint will be used every time it is trained, unless the user specifically overrides them at model submission time.\nimport datarobot as dr\nproject = dr.Project.get(project_id)\nblueprints = project.get_blueprints()\n# retrieve blueprints that support monotonic constraints\nblueprints_support_mono = [blueprint for blueprint in blueprints if blueprint.supports_monotonic_constraints]\n# retrieve blueprints that support and enforce monotonic constraints\nblueprints_enforce_mono = [blueprint for blueprint in blueprints\nif (blueprint.monotonic_increasing_featurelist_id or\nblueprint.monotonic_decreasing_featurelist_id)]\nTrain a model with specific monotonic constraints\uf0c1\nEven after specifying default settings for the project, users can override them to train a new model with different constraints, if desired.\nimport datarobot as dr\nfeatures_mono_up = ['feature_2', 'feature_3']  # features that have monotonically increasing relationship with target\nfeatures_mono_down = ['feature_0', 'feature_1']  # features that have monotonically decreasing relationship with target\nproject = dr.Project.get(project_id)\nflist_mono_up = project.create_featurelist(name='mono_up',\nfeatures=features_mono_up)\nflist_mono_down = project.create_featurelist(name='mono_down',\nfeatures=features_mono_down)\nmodel_job_id = project.train(\nblueprint,\nsample_pct=55,\nfeaturelist_id=featurelist.id,\nmonotonic_increasing_featurelist_id=flist_mono_up.id,\nmonotonic_decreasing_featurelist_id=flist_mono_down.id\n)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\nproject = dr.Project.get(project_id)\nfeatures_mono_up = ['feature_0', 'feature_1']  # features that have monotonically increasing relationship with target\nfeatures_mono_down = ['feature_2', 'feature_3']  # features that have monotonically decreasing relationship with target\nflist_mono_up = project.create_featurelist(name='mono_up',\n                                           features=features_mono_up)\nflist_mono_down = project.create_featurelist(name='mono_down',\n                                             features=features_mono_down)",
        "import datarobot as dr\nfrom datarobot.enums import AUTOPILOT_MODE\nproject = dr.Project.get(project_id)\n# As of v3.0, ``Project.set_options`` may be used as an alternative to passing `advanced_options`` into ``Project.analyze_and_model``.\nproject.set_options(\n    monotonic_increasing_featurelist_id=flist_mono_up.id,\n    monotonic_decreasing_featurelist_id=flist_mono_down.id,\n    only_include_monotonic_blueprints=True\n)\nproject.analyze_and_model(target='target', mode=AUTOPILOT_MODE.FULL_AUTO)",
        "project.analyze_and_model",
        "project.analyze_and_model(\n    target='target',\n    mode=AUTOPILOT_MODE.FULL_AUTO,\n    advanced_options=AdvancedOptions(monotonic_increasing_featurelist_id=flist_mono_up.id, monotonic_decreasing_featurelist_id=flist_mono_down.id, only_include_monotonic_blueprints=True)\n)",
        "import datarobot as dr\nproject = dr.Project.get(project_id)\nmodels = project.get_models()\n# retrieve models that support monotonic constraints\nmodels_support_mono = [model for model in models if model.supports_monotonic_constraints]\n# retrieve models that support and enforce monotonic constraints\nmodels_enforce_mono = [model for model in models\n                       if (model.monotonic_increasing_featurelist_id or\n                           model.monotonic_decreasing_featurelist_id)]",
        "import datarobot as dr\nproject = dr.Project.get(project_id)\nblueprints = project.get_blueprints()\n# retrieve blueprints that support monotonic constraints\nblueprints_support_mono = [blueprint for blueprint in blueprints if blueprint.supports_monotonic_constraints]\n# retrieve blueprints that support and enforce monotonic constraints\nblueprints_enforce_mono = [blueprint for blueprint in blueprints\n                           if (blueprint.monotonic_increasing_featurelist_id or\n                               blueprint.monotonic_decreasing_featurelist_id)]",
        "import datarobot as dr\nfeatures_mono_up = ['feature_2', 'feature_3']  # features that have monotonically increasing relationship with target\nfeatures_mono_down = ['feature_0', 'feature_1']  # features that have monotonically decreasing relationship with target\nproject = dr.Project.get(project_id)\nflist_mono_up = project.create_featurelist(name='mono_up',\n                                           features=features_mono_up)\nflist_mono_down = project.create_featurelist(name='mono_down',\n                                             features=features_mono_down)\nmodel_job_id = project.train(\n    blueprint,\n    sample_pct=55,\n    featurelist_id=featurelist.id,\n    monotonic_increasing_featurelist_id=flist_mono_up.id,\n    monotonic_decreasing_featurelist_id=flist_mono_down.id\n)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/segmented_modeling.html",
      "title": "Segmented Modeling Projects\uf0c1",
      "description": "Many time series multiseries projects introduce complex forecasting use cases that require using different models for subsets of series (i.e., sales of groceries and clothing can be very different). Within the segmented modeling framework, DataRobot runs multiple time series projects (one per segment / group of series), selects the best models for each segment, and then combines those models to make predictions.",
      "content": "Segmented Modeling Projects\uf0c1\nMany time series multiseries projects introduce complex forecasting use cases that require using different models for subsets of series (i.e., sales of groceries and clothing can be very different). Within the segmented modeling framework, DataRobot runs multiple time series projects (one per segment / group of series), selects the best models for each segment, and then combines those models to make predictions.\nSegment\uf0c1\nA segment is a group of series in a multiseries project. For example, given store and country columns in dataset, you can use the former as the series identifier and the latter  as the segment identifier. For the best results, group series with similar patterns into segments (instead of random selection).\nSegmentation Task\uf0c1\nA segmentation task is an entity that defines how input dataset is partitioned. Currently only user-defined segmentation is supported. That is, the dataset must have a separate column that is used to identify segment (and the user must select it). All records within a series must have the same segment identifier.\nCombined Model\uf0c1\nA combined model in a segmented modeling project can be thought of as a meta-model made of references to the best model within each segment. While being quite different from a standard DataRobot model in its creation, its use is very much the same after the model is complete (for example, deploying or making predictions).\nThe following examples illustrate how to set up, run, and manage a segmented modeling project using the Python public API client. For details please refer to Segmented Modeling API Reference.\nStarting a Segmentation Project with a User Defined Segment ID\uf0c1\nTime series modeling must be enabled for your account to run segmented modeling projects.\nUse the standard method to create a DataRobot project:\nfrom datarobot import DatetimePartitioningSpecification\nfrom datarobot import enums\nfrom datarobot import Project\nfrom datarobot import SegmentationTask\nproject_name = \"Segmentation Demo with Segmentation ID\"\nproject_dataset = \"multiseries_segmentation.csv\"\nproject = Project.create(project_dataset, project_name=project_name)\ndatetime_partition_column = \"timestamp\"\nmultiseries_id_column = \"series_id\"\nuser_defined_segment_id_column = \"\u7269\u7c7bsegment_id\"\ntarget = \"target\"\nCreate a simple datetime specification for a time series project:\nspec = DatetimePartitioningSpecification(\nuse_time_series=True,\ndatetime_partition_column=datetime_partition_column,\nmultiseries_id_columns=[multiseries_id_column],\n)\nCreate a segmentation task for the project:\nsegmentation_task_results = SegmentationTask.create(\nproject_id=project.id,\ntarget=target,\nuse_time_series=True,\ndatetime_partition_column=datetime_partition_column,\nmultiseries_id_columns=[multiseries_id_column],\nuser_defined_segment_id_columns=[user_defined_segment_id_column],\n)\nsegmentation_task = segmentation_task_results[\"completedJobs\"][0]\nStart a segmented project by passing the segmentation_task_id argument:\nproject.analyze_and_model(\ntarget=target,\npartitioning_method=spec,\nmode=enums.AUTOPILOT_MODE.QUICK,\nworker_count=-1,\nsegmentation_task_id=segmentation_task.id,\n)\nWorking with Combined Models\uf0c1\nRetrieve Combined Models:\nfrom datarobot import Project, CombinedModel\nproject_id = \"60ff165dde5f3ceacda0f2d6\"\n# Get an existing segmentation project\nproject = Project.get(segmented_project_id)\n# Retrieve list of all combined models in the project\ncombined_models = project.get_combined_models()\n# Or just an active (current) combined model\ncurrent_combined_model = project.get_active_combined_model()\nGet information about segments in the Combined Model:\nsegments_info = current_combined_model.get_segments_info()\n# Alternatively this information can be retrieved as a Pandas DataFrame\nsegments_df = current_combined_model.get_segments_as_dataframe()\n# Or even in CSV format\ncurrent_combined_model.get_segments_as_csv(\"combined_model_segments.csv\")\nEnsure Autopilot has completed for all segments:\nsegments_info = current_combined_model.get_segments_info()\nassert all(segment.autopilot_done for segment in segments_info)\nOptionally, view a list of all models associated with individual segments:\nsegments_and_child_models = project.get_segments_models(current_combined_model.id)\nSet a new champion for a segment in the Combined Model, specifying the project_id of the segmented  project and the model_id from that project:\nsegment_project_id = \"60ff165dde5f3ceacdaabcde\"\nnew_champion_id = \"60ff165dde5f3ceacdaa12f7\"\nCombinedModel.set_segment_champion(project_id=segment_project_id, model_id=new_champion_id)\nIf active Combined Model has already been deployed - changing champions is not allowed. In this case, create a copy of Combined Model, make it active, and set champion for it (deployed model remains unchanged):\nnew_combined_model = CombinedModel.set_segment_champion(project_id=segment_project_id, model_id=new_champion_id, clone=True)\nRun predictions on the Combined Model:\nprediction_dataset = \"multiseries_predictions.csv\"\n# Upload dataset\ndataset = project.upload_dataset(\nsource=prediction_dataset,\n)\n# Request predictions\npredictions_job = current_combined_model.request_predictions(\ndataset_id=dataset.id,\n)\npredictions_job.wait_for_completion()\npredictions = predictions.get_result()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "from datarobot import DatetimePartitioningSpecification\nfrom datarobot import enums\nfrom datarobot import Project\nfrom datarobot import SegmentationTask\n\nproject_name = \"Segmentation Demo with Segmentation ID\"\nproject_dataset = \"multiseries_segmentation.csv\"\nproject = Project.create(project_dataset, project_name=project_name)\n\ndatetime_partition_column = \"timestamp\"\nmultiseries_id_column = \"series_id\"\nuser_defined_segment_id_column = \"\u7269\u7c7bsegment_id\"\ntarget = \"target\"",
        "segmentation_task_results = SegmentationTask.create(\n    project_id=project.id,\n    target=target,\n    use_time_series=True,\n    datetime_partition_column=datetime_partition_column,\n    multiseries_id_columns=[multiseries_id_column],\n    user_defined_segment_id_columns=[user_defined_segment_id_column],\n)\nsegmentation_task = segmentation_task_results[\"completedJobs\"][0]",
        "project.analyze_and_model(\n    target=target,\n    partitioning_method=spec,\n    mode=enums.AUTOPILOT_MODE.QUICK,\n    worker_count=-1,\n    segmentation_task_id=segmentation_task.id,\n)",
        "from datarobot import Project, CombinedModel\nproject_id = \"60ff165dde5f3ceacda0f2d6\"\n\n# Get an existing segmentation project\nproject = Project.get(segmented_project_id)\n\n# Retrieve list of all combined models in the project\ncombined_models = project.get_combined_models()\n\n# Or just an active (current) combined model\ncurrent_combined_model = project.get_active_combined_model()",
        "segments_info = current_combined_model.get_segments_info()\n\n# Alternatively this information can be retrieved as a Pandas DataFrame\nsegments_df = current_combined_model.get_segments_as_dataframe()\n\n# Or even in CSV format\ncurrent_combined_model.get_segments_as_csv(\"combined_model_segments.csv\")",
        "segments_info = current_combined_model.get_segments_info()\nassert all(segment.autopilot_done for segment in segments_info)",
        "segments_and_child_models = project.get_segments_models(current_combined_model.id)",
        "segment_project_id = \"60ff165dde5f3ceacdaabcde\"\nnew_champion_id = \"60ff165dde5f3ceacdaa12f7\"\n\nCombinedModel.set_segment_champion(project_id=segment_project_id, model_id=new_champion_id)",
        "new_combined_model = CombinedModel.set_segment_champion(project_id=segment_project_id, model_id=new_champion_id, clone=True)",
        "prediction_dataset = \"multiseries_predictions.csv\"\n\n# Upload dataset\ndataset = project.upload_dataset(\n    source=prediction_dataset,\n)\n\n# Request predictions\npredictions_job = current_combined_model.request_predictions(\n    dataset_id=dataset.id,\n)\npredictions_job.wait_for_completion()\npredictions = predictions.get_result()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/time_series.html",
      "title": "Time series projects\uf0c1",
      "description": "Time series projects, like OTV projects, use datetime partitioning, and all\nthe workflow changes that apply to other datetime partitioned projects also apply to them.\nUnlike other projects, time series projects produce different types of models which forecast\nmultiple future predictions instead of an individual prediction for each row.",
      "content": "Time series projects\uf0c1\nTime series projects, like OTV projects, use datetime partitioning, and all\nthe workflow changes that apply to other datetime partitioned projects also apply to them.\nUnlike other projects, time series projects produce different types of models which forecast\nmultiple future predictions instead of an individual prediction for each row.\nDataRobot uses a general time series framework to configure how time series features are created\nand what future values the models will output. This framework consists of a Forecast Point\n(defining a time a prediction is being made), a Feature Derivation Window (a rolling window used\nto create features), and a Forecast Window (a rolling window of future values to predict). These\ncomponents are described in more detail below.\nTime series projects will automatically transform the dataset provided in order to apply this\nframework. During the transformation, DataRobot uses the Feature Derivation Window to derive\ntime series features (such as lags and rolling statistics), and uses the Forecast Window to provide\nexamples of forecasting different distances in the future (such as time shifts).\nAfter project creation, a new dataset and a new feature list are generated and used to train\nthe models. This process is reapplied automatically at prediction time as well in order to\ngenerate future predictions based on the original data features.\nThe time_unit and time_step used to define the Feature Derivation and Forecast Windows are\ntaken from the datetime partition column, and can be retrieved for a given column in the input data\nby looking at the corresponding attributes on the datarobot.models.Feature object.\nIf windows_basis_unit is set to ROW, then Feature Derivation and Forecast Windows will be\ndefined using number of the rows.\nSetting up a time series project\uf0c1\nTo set up a time series project, follow the standard datetime partitioning\nworkflow and use the six new time series specific parameters on the\ndatarobot.DatetimePartitioningSpecification object:\nuse_time_seriesbool, set this to True to enable time series for the project.\ndefault_to_known_in_advancebool, set this to True to default to treating all features as known in advance, or a priori, features. Otherwise,\nthey will not be handled as known in advance features. Individual features can be set to a value\ndifferent than the default by using the featureSettings parameter. See\nthe prediction documentation for more information.\ndefault_to_do_not_derivebool, set this to True to default to excluding all features from feature derivation.  Otherwise,\nthey will not be excluded and will be included in the feature derivation process.\nIndividual features can be set to a value different than the default by using the\nfeatureSettings parameter.\nfeature_derivation_window_startint, specifies how many units of the windows_basis_unit from the forecast point into the past is the start of\nthe feature derivation window\nfeature_derivation_window_endint, specifies how many units of the windows_basis_unit from the forecast point into the past is the end of the\nfeature derivation window\nforecast_window_startint, specifies how many units of the windows_basis_unit from the forecast point into the future is the start of\nthe forecast window\nforecast_window_endint, specifies how many units of the windows_basis_unit from the forecast point into the future is the end of\nthe forecast window\nwindows_basis_unitstring, set this to ROW to define feature derivation and forecast windows in terms of the\nrows, rather than time units. If omitted, will default to the detected time unit (one of the\ndatarobot.enums.TIME_UNITS).\nfeature_settingslist of FeatureSettings specifying per feature settings, can be left unspecified\nFeature Derivation Window\uf0c1\nThe Feature Derivation window represents the rolling window that is used to derive\ntime series features and lags, relative to the Forecast Point. It is defined in terms of\nfeature_derivation_window_start and feature_derivation_window_end which are integer values\nrepresenting datetime offsets in terms of the time_unit (e.g. hours or days).\nThe Feature Derivation Window start and end must be less than or equal to zero, indicating they are\npositioned before the forecast point. Additionally, the window must be specified as an integer\nmultiple of the time_step which defines the expected difference in time units between rows in\nthe data.\nThe window is closed, meaning the edges are considered to be inside the window.\nForecast window\uf0c1\nThe Forecast Window represents the rolling window of future values to predict, relative to the\nForecast Point. It is defined in terms of the forecast_window_start and forecast_window_end,\nwhich are positive integer values indicating datetime offsets in terms of the time_unit (e.g.\nhours or days).\nThe Forecast Window start and end must be positive integers, indicating they are\npositioned after the forecast point. Additionally, the window must be specified as an integer\nmultiple of the time_step which defines the expected difference in time units between rows in\nthe data.\nThe window is closed, meaning the edges are considered to be inside the window.\nMultiseries projects\uf0c1\nCertain time series problems represent multiple separate series of data, e.g. \u201cI have five different\nstores that all have different customer bases.  I want to predict how many units of a particular\nitem will sell, and account for the different behavior of each store\u201d.  When setting up the project,\na column specifying series ids must be identified, so that each row from the same series has the\nsame value in the multiseries id column.\nUsing a multiseries id column changes which partition columns are eligible for time series, as\neach series is required to be unique and regular, instead of the entire partition column being\nrequired to have those properties.  In order to use a multiseries id column for partitioning,\na detection job must first be run to analyze the relationship between the partition and multiseries\nid columns.  If needed, it will be automatically triggered by calling\ndatarobot.models.Feature.get_multiseries_properties() on the desired partition column. The\npreviously computed multiseries properties for a particular partition column can then be accessed\nvia that method.  The computation will also be automatically triggered when calling\ndatarobot.DatetimePartitioning.generate() or datarobot.models.Project.analyze_and_model()\nwith a multiseries id column specified.\nNote that currently only one multiseries id column is supported, but all interfaces accept lists\nof id columns to ensure multiple id columns will be able to be supported in the future.\nIn order to create a multiseries project:\nSet up a datetime partitioning specification with the desired partition column and multiseries\nid columns.\n(Optionally) Use datarobot.models.Feature.get_multiseries_properties() to confirm the\ninferred time step and time unit of the partition column when used with the specified\nmultiseries id column.\n(Optionally) Specify the multiseries id column in order to preview the full datetime\npartitioning settings using datarobot.DatetimePartitioning.generate().\nSpecify the multiseries id column when sending the target and partitioning settings via\ndatarobot.models.Project.analyze_and_model().\nproject = dr.Project.create('path/to/multiseries.csv', project_name='my multiseries project')\npartitioning_spec = dr.DatetimePartitioningSpecification(\n'timestamp', use_time_series=True, multiseries_id_columns=['multiseries_id']\n)\n# manually confirm time step and time unit are as expected\ndatetime_feature = dr.Feature.get(project.id, 'timestamp')\nmultiseries_props = datetime_feature.get_multiseries_properties(['multiseries_id'])\nprint(multiseries_props)\n# manually check out the partitioning settings like feature derivation window and backtests\n# to make sure they make sense before moving on\nfull_part = dr.DatetimePartitioning.generate(project.id, partitioning_spec)\nprint(full_part.feature_derivation_window_start, full_part.feature_derivation_window_end)\nprint(full_part.to_dataframe())\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', multiseries_id_columns=['series_id'])\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n# finalize the project and start the autopilot\nproject.analyze_and_model('target', partitioning_method=partitioning_spec)\nYou can also access optimized partitioning in the API where the target over time is inspected to\nensure that the default backtests cover regions of interest and adjust backtests avoid common\nproblems with missing target values or partitions with single values (e.g. zero-inflated datasets).\nIn this case you need to pass the target column when generating the partitioning specification (either\nby calling DatetimePartitioning.generate or Project.set_datetime_partitioning) and\nthen pass the full partitioning specification when starting autopilot (if Project.set_datetime_partitioning\nis not used).\nproject = dr.Project.create('path/to/multiseries.csv', project_name='my multiseries project')\npartitioning_spec = dr.DatetimePartitioningSpecification(\n'timestamp', use_time_series=True, multiseries_id_columns=['multiseries_id']\n)\n# Pass the target column to generate optimized partitions\nfull_part = dr.DatetimePartitioning.generate(project.id, partitioning_spec, 'target')\n# Or, as of v3.0, call ``Project.set_datetime_partitioning`` after specifying the project target\n# to generate optimized partitions.\nproject.target = 'target'\nproject.set_datetime_partitioning(datetime_partition_spec=partitioning_spec)\n# finalize the project and start the autopilot, passing in the full partitioning spec\n# (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model('target', partitioning_method=full_part.to_specification())\nFeature settings\uf0c1\ndatarobot.FeatureSettings constructor receives feature_name and settings. For now\nsettings known_in_advance and do_not_derive are supported.\n# I have 10 features, 8 of them are known in advance and two are not\n# Also, I do not want to derive new features from previous_day_sales\nnot_known_in_advance_features = ['previous_day_sales', 'amount_in_stock']\ndo_not_derive_features = ['previous_day_sales']\nfeature_settings = [dr.FeatureSettings(feat_name, known_in_advance=False) for feat_name in not_known_in_advance_features]\nfeature_settings += [dr.FeatureSettings(feat_name, do_not_derive=True) for feat_name in do_not_derive_features]\nspec = dr.DatetimePartitioningSpecification(\n# ...\ndefault_to_known_in_advance=True,\nfeature_settings=feature_settings\n)\nModeling data and time series features\uf0c1\nIn time series projects, a new set of modeling features is created after setting the\npartitioning options.  If a featurelist is specified with the partitioning options, it will be used\nto select which features should be used to derived modeling features; if a featurelist is not\nspecified, the default featurelist will be used.\nThese features are automatically derived from those in the project\u2019s\ndataset and are the features used for modeling - note that the Project methods\nget_featurelists and get_modeling_featurelists will return different data in time series\nprojects.  Modeling featurelists are the ones that can be used for modeling and will be accepted by\nthe backend, while regular featurelists will continue to exist but cannot be used.  Modeling\nfeatures are only accessible once the target and partitioning options have been\nset.  In projects that don\u2019t use time series modeling, once the target has been set,\nmodeling and regular features and featurelists will behave the same.\nRestoring discarded features\uf0c1\ndatarobot.models.restore_discarded_features.DiscardedFeaturesInfo can be used to get and\nrestore features that have been removed by the time series feature generation and reduction functionality.\nproject = Project(project_id)\ndiscarded_feature_info = project.get_discarded_features()\nrestored_features_info = project.restore_discarded_features(discarded_features_info.features)\nMaking predictions\uf0c1\nPrediction datasets are uploaded as normal. However, when uploading a\nprediction dataset, a new parameter forecast_point can be specified. The forecast point of a\nprediction dataset identifies the point in time relative which predictions should be generated, and\nif one is not specified when uploading a dataset, the server will choose the most recent possible\nforecast point. The forecast window specified when setting the partitioning options for the project\ndetermines how far into the future from the forecast point predictions should be calculated.\nTo simplify the predictions process, starting in version v2.20 a forecast point or prediction start and end dates can\nbe specified when requesting predictions, instead of being specified at dataset upload. Upon uploading a dataset,\nDataRobot will calculate the range of dates available for use as a forecast point or for batch predictions. To that end,\nPredictions objects now also contain the following new fields:\nforecast_point: The default point relative to which predictions will be generated\npredictions_start_date: The start date for bulk historical predictions.\npredictions_end_date: The end date for bulk historical predictions.\nSimilar settings are provided as part of the batch prediction API\nand the real-time prediction API\nto make predictions using deployed time series models.\ndatarobot.models.BatchPredictionJob.score\nWhen setting up a time series project, input features could be identified as known-in-advance features.\nThese features are not used to generate lags, and are expected to be known for the rows in the\nforecast window at predict time (e.g. \u201chow much money will have been spent on marketing\u201d, \u201cis this\na holiday\u201d).\nEnough rows of historical data must be provided to cover the span of the effective Feature\nDerivation Window (which may be longer than the project\u2019s Feature Derivation Window depending\non the differencing settings chosen).  The effective Feature Derivation Window of any model\ncan be checked via the effective_feature_derivation_window_start and\neffective_feature_derivation_window_end attributes of a\nDatetimeModel.\nWhen uploading datasets to a time series project, the dataset might look something like the\nfollowing, where \u201cTime\u201d is the datetime partition column, \u201cTarget\u201d is the target column, and \u201cTemp.\u201d\nis an input feature.  If the dataset was uploaded with a forecast point of \u201c2017-01-08\u201d and the\neffective feature derivation window start and end for the model are -5 and -3 and the forecast\nwindow start and end were set to 1 and 3, then rows 1 through 3 are historical data, row 6 is the\nforecast point, and rows 7 though 9 are forecast rows that will have predictions when predictions\nare computed.\nRow, Time, Target, Temp.\n1, 2017-01-03, 16443, 72\n2, 2017-01-04, 3013, 72\n3, 2017-01-05, 1643, 68\n4, 2017-01-06, ,\n5, 2017-01-07, ,\n6, 2017-01-08, ,\n7, 2017-01-09, ,\n8, 2017-01-10, ,\n9, 2017-01-11, ,\nOn the other hand, if the project instead used \u201cHoliday\u201d as an a priori input feature, the uploaded\ndataset might look like the following:\nRow, Time, Target, Holiday\n1, 2017-01-03, 16443, TRUE\n2, 2017-01-04, 3013, FALSE\n3, 2017-01-05, 1643, FALSE\n4, 2017-01-06, , FALSE\n5, 2017-01-07, , FALSE\n6, 2017-01-08, , FALSE\n7, 2017-01-09, , TRUE\n8, 2017-01-10, , FALSE\n9, 2017-01-11, , FALSE\nCalendars\uf0c1\nYou can upload a calendar file containing a list of events relevant to your\ndataset. When provided, DataRobot automatically derives and creates time series features based on the calendar\nevents (e.g., time until the next event, labeling the most recent event).\nThe calendar file:\nShould span the entire training data date range, as well as all future dates in which model will be forecasting.\nMust be in csv or xlsx format with a header row.\nMust have one date column which has values in the date-only format YYY-MM-DD (i.e., no hour, month, or second).\nCan optionally include a second column that provides the event name or type.\nCan optionally include a series ID column which specifies which series an event is applicable to. This column name\nmust match the name of the column set as the series ID.\nMultiseries ID columns are used to add an ability to specify different sets of events for different series, e.g.\nholidays for different regions.\nValues of the series ID may be absent for specific events. This means that the event is valid for all series in\nproject dataset (e.g. New Year\u2019s Day is a holiday in all series in the example below).\nIf a multiseries ID column is not provided, all listed events will be applicable to all series in the project\ndataset.\nCannot be updated in an active project. You must specify all future calendar events at project start. To update the\ncalendar file, you will have to train a new project.\nAn example of a valid calendar file:\nDate,        Name\n2019-01-01,  New Year's Day\n2019-02-14,  Valentine's Day\n2019-04-01,  April Fools\n2019-05-05,  Cinco de Mayo\n2019-07-04,  July 4th\nAn example of a valid multiseries calendar file:\nDate,        Name,                   Country\n2019-01-01,  New Year's Day,\n2019-05-27,  Memorial Day,           USA\n2019-07-04,  July 4th,               USA\n2019-11-28,  Thanksgiving,           USA\n2019-02-04,  Constitution Day,       Mexico\n2019-03-18,  Benito Ju\u00e1rez's birth,  Mexico\n2019-12-25,  Christmas Day,\nOnce created, a calendar can be used with a time series project by specifying the calendar_id field in the datarobot.DatetimePartitioningSpecification object for the project:\nimport datarobot as dr\n# create the project\nproject = dr.Project.create('input_data.csv')\n# create the calendar\ncalendar = dr.CalendarFile.create('calendar_file.csv')\n# specify the calendar_id in the partitioning specification\ndatetime_spec = dr.DatetimePartitioningSpecification(\nuse_time_series=True,\ndatetime_partition_column='date'\ncalendar_id=calendar.id\n)\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', calendar_id=calendar.id)\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n# start the project, specifying the partitioning method (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model(\ntarget='project target',\npartitioning_method=datetime_spec\n)\nAs of version v2.23 it is possible to ask DataRobot to generate a calendar file for you using\nCalendarFile.create_calendar_from_country_code.\nThis method allows you to provide a country code specifying which country\u2019s holidays to use in generating the calendar,\nalong with a start and end date indicating the bounds of the calendar. Allowed country codes can be retrieved using\nCalendarFile.get_allowed_country_codes. See the following code block for example usage:\nimport datarobot as dr\nfrom datetime import datetime\n# create the project\nproject = dr.Project.create('input_data.csv')\n# retrieve the allowed country codes and use the first one\ncountry_code = dr.CalendarFile.get_allowed_country_codes()[0]['code']\ncalendar = dr.CalendarFile.create_calendar_from_country_code(\ncountry_code, datetime(2018, 1, 1), datetime(2018, 7, 4)\n)\n# specify the calendar_id in the partitioning specification\ndatetime_spec = dr.DatetimePartitioningSpecification(\nuse_time_series=True,\ndatetime_partition_column='date'\ncalendar_id=calendar.id\n)\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', calendar_id=calendar.id)\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n# Start the project, specifying the partitioning method (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model(\ntarget='project target',\npartitioning_method=datetime_spec\n)\nDatetime trend plots\uf0c1\nAs a version v2.25, it is possible to retrieve Datetime Trend Plots for time series models\nto estimate the accuracy of the model. This includes Accuracy over Time and Forecast vs Actual for supervised projects,\nand Anomaly over Time for unsupervised projects. You can retrieve respective plots using following methods:\nDatetimeModel.get_accuracy_over_time_plot\nDatetimeModel.get_forecast_vs_actual_plot\nDatetimeModel.get_anomaly_over_time_plot\nBy default, the plots would be automatically computed when accessed via retrieval methods. You can compute Datetime Trend Plots separately\nusing a common method DatetimeModel.compute_datetime_trend_plots.\nIn addition, you can retrieve the respective detailed metadata for each plot type:\nDatetimeModel.get_accuracy_over_time_plots_metadata\nDatetimeModel.get_forecast_vs_actual_plots_metadata\nDatetimeModel.get_anomaly_over_time_plots_metadata\nAnd the preview plots:\nDatetimeModel.get_accuracy_over_time_plot_preview\nDatetimeModel.get_forecast_vs_actual_plot_preview\nDatetimeModel.get_anomaly_over_time_plot_preview\nPrediction intervals\uf0c1\nFor each model, prediction intervals estimate the range of values DataRobot expects actual values of the target to fall within.\nThey are similar to a confidence interval of a prediction, but are based on the residual errors measured during the\nbacktesting for the selected model.\nNote that because calculation depends on the backtesting values, prediction intervals are not available for predictions\non models that have not had all backtests completed. To that end, note that creating a prediction with prediction intervals through the API will\nautomatically complete all backtests if they were not already completed. For start-end retrained models, the parent model will be used for backtesting.\nAdditionally, prediction intervals are not available when the number of points per forecast distance is less than 10, due to insufficient data.\nIn a prediction request, users can specify a prediction interval\u2019s size, which specifies the desired probability of actual values\nfalling within the interval range. Larger values are less precise, but more conservative. For example, specifying a size\nof 80 will result in a lower bound of 10% and an upper bound of 90%. More generally, for a specific prediction_intervals_size,\nthe upper and lower bounds will be calculated as follows:\nprediction_interval_upper_bound = 50% + (prediction_intervals_size / 2)\nprediction_interval_lower_bound = 50% - (prediction_intervals_size / 2)\nPrediction intervals can be calculated for a DatetimeModel using the\nDatetimeModel.calculate_prediction_intervals method.\nUsers can also retrieve which intervals have already been calculated for the model using the\nDatetimeModel.get_calculated_prediction_intervals method.\nTo view prediction intervals data for a prediction, the prediction needs to have been created using the\nDatetimeModel.request_predictions method and specifying\ninclude_prediction_intervals = True. The size for the prediction interval can be specified with the prediction_intervals_size\nparameter for the same function, and will default to 80 if left unspecified. Specifying either of these fields will\nresult in prediction interval bounds being included in the retrieved prediction data for that request (see the\nPredictions class for retrieval methods). Note that if the specified interval\nsize has not already been calculated, this request will automatically calculate the specified size.\nPrediction intervals are also supported for time series model deployments, and should be specified in deployment settings\nif desired. Use Deployment.get_prediction_intervals_settings\nto retrieve current prediction intervals settings for a deployment, and Deployment.update_prediction_intervals_settings\nto update prediction intervals settings for a deployment.\nPartial history predictions\uf0c1\nAs of version v2.24 it is possible to ask DataRobot to allow to make predictions with incomplete historical data\nmultiseries regression projects. To make predictions in regular project user has to provide enough data for the\nfeature derivation. By setting the datetime partitioning attribute allow_partial_history_time_series_predictions\nto true (datarobot.DatetimePartitioningSpecification object),\nthe project would be created that allow to make such predictions. The number of models are significantly\nsmaller compared to regular multiseries model, but they are designed to make predictions on unseen series with\nreasonable accuracy.\nExternal baseline predictions\uf0c1\nAs of version v2.26  it is possible to ask DataRobot to scale accuracy metric by external predictions. Users can\nupload data into a Dataset (see Dataset documentation) and compare the external time series\npredictions with DataRobot models\u2019 accuracy performance. To use the external predictions dataset in the autopilot,\nthe dataset must be validated first (see\nProject.validate_external_time_series_baseline).\nOnce the dataset is validated, it can be used with a time series project by specifying external_time_series_baseline_dataset_id\nfield in AdvancedOptions and passes the advanced options to the project.\nSee the following code block for example usage:\nimport datarobot as dr\nfrom datarobot.helpers import AdvancedOptions\nfrom datarobot.models import Dataset\n# create the project\nproject = dr.Project.create('input_data.csv')\n# prepare datetime partitioning for external baseline validation\ndatetime_spec = dr.DatetimePartitioningSpecification(\nuse_time_series=True,\ndatetime_partition_column='date',\nmultiseries_id_columns=['series_id'],\n)\ndatetime_partitioning = dr.DatetimePartitioning.generate(\nproject_id=project.id,\nspec=datetime_spec,\ntarget='target',\n)\n# create external baseline prediction dataset from local file\nexternal_baseline_dataset = Dataset.create_from_file(file_path='external_predictions.csv')\n# validate the external baseline prediction dataset\nvalidation_info = project.validate_external_time_series_baseline(\ncatalog_version_id=external_baseline_dataset.version_id,\ntarget='target',\ndatetime_partitioning=datetime_partitioning,\n)\nprint(\n'External baseline predictions passes validation check:',\nvalidation_info.is_external_baseline_dataset_valid\n)\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', multiseries_id_columns=['series_id'])\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n# As of v3.0, add the validated dataset version id into advanced options\nproject.set_options(\nexternal_time_series_baseline_dataset_id=external_baseline_dataset.version_id\n)\n# start the project, specifying the partitioning method (if ``Project.set_datetime_partitioning`` and ``Project.set_options`` were not used)\nproject.analyze_and_model(\ntarget='target',\npartitioning_method=datetime_spec\nadvanced_options=AdvancedOptions(external_time_series_baseline_dataset_id)\n)\nTime Series Data Prep\uf0c1\nAs of version v2.27 it is possible to prepare a dataset for time series modeling in the AI catalog\nusing the API client. Users can upload unprepped modeling data into a Dataset\n(see Dataset documentation) and the prep the data set for time series modeling by\naggregating data to a regular time step and filling gaps via a generated Spark SQL query in the AI\ncatalog. Once the dataset is uploaded, the time series data prep query generator can be created\nusing DataEngineQueryGenerator.create.\nAs of version v3.1 convenience methods have been added to streamline the process of applying\ntime series data prep for predictions.\nSee the following code block for example usage:\nimport datarobot as dr\nfrom datarobot.models.data_engine_query_generator import (\nQueryGeneratorDataset,\nQueryGeneratorSettings,\n)\nfrom datetime import datetime\n# upload the dataset to the AI Catalog\ndataset = dr.Dataset.create_from_file('input_data.csv')\n# create a time series data prep query generator\nquery_generator_dataset = QueryGeneratorDataset(\nalias='input_data_csv',\ndataset_id=dataset.id,\ndataset_version_id=dataset.version_id,\n)\nquery_generator_settings = QueryGeneratorSettings(\ndatetime_partition_column=\"date\",\ntime_unit=\"DAY\",\ntime_step=1,\ndefault_numeric_aggregation_method=\"sum\",\ndefault_categorical_aggregation_method=\"mostFrequent\",\ntarget=\"y\",\nmultiseries_id_columns=[\"id\"],\ndefault_text_aggregation_method=\"concat\",\nstart_from_series_min_datetime=True,\nend_to_series_max_datetime=True,\n)\nquery_generator = dr.DataEngineQueryGenerator.create(\ngenerator_type='TimeSeries',\ndatasets = [query_generator_dataset],\ngenerator_settings=query_generator_settings,\n)\n# prep the training dataset\ntraining_dataset = query_generator.create_dataset()\n# create a project\nproject = dr.Project.create_from_dataset(training_dataset.id, project_name='prepped_dataset')\n# set up datetime partitioning, target, and train model(s)\npartitioning_spec = dr.DatetimePartitioningSpecification(\ndatetime_partition_column='date', use_time_series=True\n)\nproject.analyze_and_model(target='y', mode='manual', partitioning_method=partitioning_spec)\nblueprints = project.get_blueprints()\nmodel_job = project.train_datetime(blueprints[0].id)\nmodel = model_job.get_result_when_complete()\n# query generator can be retrieved from the project if necessary\n# query_generator = dr.DataEngineQueryGenerator.get(project.query_generator_id)\n# prep and upload a prediction dataset to the project\nprediction_dataset = query_generator.prepare_prediction_dataset(\n'prediction_data.csv', project.id\n)\n# make predictions within the project\n# Either forecast point or predictions start/end dates must be specified\nmodel.request_predictions(prediction_dataset.id, forecast_point=datetime(2023, 1, 1))\n# query generator can be retrieved from a deployed model via project if necessary\n# deployment = dr.Deployment.get(deployment_id)\n# project = dr.Project.get(deployment.model['project_id'])\n# query_generator = dr.DataEngineQueryGenerator.get(project.query_generator_id)\n# Deploy the model\nprediction_servers = dr.PredictionServer.list()\ndeployment = dr.Deployment.create_from_learning_model(\nmodel.id, 'prepped_deployment', default_prediction_server_id=prediction_servers[0].id\n)\n# Make batch predictions from batch prediction job, supports localFile or dataset for intake\n# and all types for output\ntimeseries_settings = {'type': 'forecast', 'forecast_point': datetime(2023, 1, 1)}\nintake_settings = {'type': 'localFile', 'file': 'prediction_data.csv'}\noutput_settings = {'type': 'localFile', 'path': 'predictions_out.csv'}\nbatch_predictions_job = dr.BatchPredictionJob.apply_time_series_data_prep_and_score(\ndeployment, intake_settings, timeseries_settings, output_settings=output_settings\n)",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/datetime_partition.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/features.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/predict_job.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
        "https://docs.datarobot.com/en/docs/predictions/api/dr-predapi.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/dataset.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "datarobot.models.Feature",
        "datarobot.DatetimePartitioningSpecification",
        "datarobot.enums.TIME_UNITS",
        "datarobot.models.Feature.get_multiseries_properties()",
        "datarobot.DatetimePartitioning.generate()",
        "datarobot.models.Project.analyze_and_model()",
        "datarobot.models.Feature.get_multiseries_properties()",
        "datarobot.DatetimePartitioning.generate()",
        "datarobot.models.Project.analyze_and_model()",
        "project = dr.Project.create('path/to/multiseries.csv', project_name='my multiseries project')\npartitioning_spec = dr.DatetimePartitioningSpecification(\n    'timestamp', use_time_series=True, multiseries_id_columns=['multiseries_id']\n)\n\n# manually confirm time step and time unit are as expected\ndatetime_feature = dr.Feature.get(project.id, 'timestamp')\nmultiseries_props = datetime_feature.get_multiseries_properties(['multiseries_id'])\nprint(multiseries_props)\n\n# manually check out the partitioning settings like feature derivation window and backtests\n# to make sure they make sense before moving on\nfull_part = dr.DatetimePartitioning.generate(project.id, partitioning_spec)\nprint(full_part.feature_derivation_window_start, full_part.feature_derivation_window_end)\nprint(full_part.to_dataframe())\n\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n # The spec options can be passed individually:\n project.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', multiseries_id_columns=['series_id'])\n # Or the whole spec object can be passed:\n project.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n\n# finalize the project and start the autopilot\nproject.analyze_and_model('target', partitioning_method=partitioning_spec)",
        "Project.set_datetime_partitioning",
        "Project.set_datetime_partitioning",
        "project = dr.Project.create('path/to/multiseries.csv', project_name='my multiseries project')\npartitioning_spec = dr.DatetimePartitioningSpecification(\n    'timestamp', use_time_series=True, multiseries_id_columns=['multiseries_id']\n)\n\n# Pass the target column to generate optimized partitions\nfull_part = dr.DatetimePartitioning.generate(project.id, partitioning_spec, 'target')\n\n# Or, as of v3.0, call ``Project.set_datetime_partitioning`` after specifying the project target\n# to generate optimized partitions.\nproject.target = 'target'\nproject.set_datetime_partitioning(datetime_partition_spec=partitioning_spec)\n\n# finalize the project and start the autopilot, passing in the full partitioning spec\n# (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model('target', partitioning_method=full_part.to_specification())",
        "datarobot.FeatureSettings",
        "# I have 10 features, 8 of them are known in advance and two are not\n# Also, I do not want to derive new features from previous_day_sales\nnot_known_in_advance_features = ['previous_day_sales', 'amount_in_stock']\ndo_not_derive_features = ['previous_day_sales']\nfeature_settings = [dr.FeatureSettings(feat_name, known_in_advance=False) for feat_name in not_known_in_advance_features]\nfeature_settings += [dr.FeatureSettings(feat_name, do_not_derive=True) for feat_name in do_not_derive_features]\nspec = dr.DatetimePartitioningSpecification(\n    # ...\n    default_to_known_in_advance=True,\n    feature_settings=feature_settings\n)",
        "get_modeling_featurelists",
        "datarobot.models.restore_discarded_features.DiscardedFeaturesInfo",
        "project = Project(project_id)\ndiscarded_feature_info = project.get_discarded_features()\nrestored_features_info = project.restore_discarded_features(discarded_features_info.features)",
        "datarobot.DatetimePartitioningSpecification",
        "import datarobot as dr\n\n# create the project\nproject = dr.Project.create('input_data.csv')\n# create the calendar\ncalendar = dr.CalendarFile.create('calendar_file.csv')\n\n# specify the calendar_id in the partitioning specification\ndatetime_spec = dr.DatetimePartitioningSpecification(\n    use_time_series=True,\n    datetime_partition_column='date'\n    calendar_id=calendar.id\n)\n\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', calendar_id=calendar.id)\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n\n# start the project, specifying the partitioning method (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model(\n    target='project target',\n    partitioning_method=datetime_spec\n)",
        "import datarobot as dr\nfrom datetime import datetime\n\n# create the project\nproject = dr.Project.create('input_data.csv')\n# retrieve the allowed country codes and use the first one\ncountry_code = dr.CalendarFile.get_allowed_country_codes()[0]['code']\ncalendar = dr.CalendarFile.create_calendar_from_country_code(\n    country_code, datetime(2018, 1, 1), datetime(2018, 7, 4)\n)\n# specify the calendar_id in the partitioning specification\ndatetime_spec = dr.DatetimePartitioningSpecification(\n    use_time_series=True,\n    datetime_partition_column='date'\n    calendar_id=calendar.id\n)\n\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', calendar_id=calendar.id)\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n\n# Start the project, specifying the partitioning method (if ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method``)\nproject.analyze_and_model(\n    target='project target',\n    partitioning_method=datetime_spec\n)",
        "DatetimeModel.get_accuracy_over_time_plot",
        "DatetimeModel.get_forecast_vs_actual_plot",
        "DatetimeModel.get_anomaly_over_time_plot",
        "DatetimeModel.compute_datetime_trend_plots",
        "DatetimeModel.get_accuracy_over_time_plots_metadata",
        "DatetimeModel.get_forecast_vs_actual_plots_metadata",
        "DatetimeModel.get_anomaly_over_time_plots_metadata",
        "DatetimeModel.get_accuracy_over_time_plot_preview",
        "DatetimeModel.get_forecast_vs_actual_plot_preview",
        "DatetimeModel.get_anomaly_over_time_plot_preview",
        "DatetimeModel.calculate_prediction_intervals",
        "DatetimeModel.get_calculated_prediction_intervals",
        "DatetimeModel.request_predictions",
        "datarobot.DatetimePartitioningSpecification",
        "Project.validate_external_time_series_baseline",
        "import datarobot as dr\nfrom datarobot.helpers import AdvancedOptions\nfrom datarobot.models import Dataset\n\n# create the project\nproject = dr.Project.create('input_data.csv')\n\n# prepare datetime partitioning for external baseline validation\ndatetime_spec = dr.DatetimePartitioningSpecification(\n    use_time_series=True,\n    datetime_partition_column='date',\n    multiseries_id_columns=['series_id'],\n)\ndatetime_partitioning = dr.DatetimePartitioning.generate(\n    project_id=project.id,\n    spec=datetime_spec,\n    target='target',\n)\n\n# create external baseline prediction dataset from local file\nexternal_baseline_dataset = Dataset.create_from_file(file_path='external_predictions.csv')\n\n# validate the external baseline prediction dataset\nvalidation_info = project.validate_external_time_series_baseline(\n    catalog_version_id=external_baseline_dataset.version_id,\n    target='target',\n    datetime_partitioning=datetime_partitioning,\n)\nprint(\n    'External baseline predictions passes validation check:',\n    validation_info.is_external_baseline_dataset_valid\n)\n\n# As of v3.0, can use ``Project.set_datetime_partitioning`` instead of passing the spec into ``Project.analyze_and_model`` via ``partitioning_method``.\n# The spec options can be passed individually:\nproject.set_datetime_partitioning(use_time_series=True, datetime_partition_column='date', multiseries_id_columns=['series_id'])\n# Or the whole spec object can be passed:\nproject.set_datetime_partitioning(datetime_partitioning_spec=datetime_spec)\n\n# As of v3.0, add the validated dataset version id into advanced options\nproject.set_options(\n    external_time_series_baseline_dataset_id=external_baseline_dataset.version_id\n)\n\n# start the project, specifying the partitioning method (if ``Project.set_datetime_partitioning`` and ``Project.set_options`` were not used)\nproject.analyze_and_model(\n    target='target',\n    partitioning_method=datetime_spec\n    advanced_options=AdvancedOptions(external_time_series_baseline_dataset_id)\n)",
        "import datarobot as dr\nfrom datarobot.models.data_engine_query_generator import (\n    QueryGeneratorDataset,\n    QueryGeneratorSettings,\n)\nfrom datetime import datetime\n\n# upload the dataset to the AI Catalog\ndataset = dr.Dataset.create_from_file('input_data.csv')\n\n# create a time series data prep query generator\nquery_generator_dataset = QueryGeneratorDataset(\n    alias='input_data_csv',\n    dataset_id=dataset.id,\n    dataset_version_id=dataset.version_id,\n)\nquery_generator_settings = QueryGeneratorSettings(\n    datetime_partition_column=\"date\",\n    time_unit=\"DAY\",\n    time_step=1,\n    default_numeric_aggregation_method=\"sum\",\n    default_categorical_aggregation_method=\"mostFrequent\",\n    target=\"y\",\n    multiseries_id_columns=[\"id\"],\n    default_text_aggregation_method=\"concat\",\n    start_from_series_min_datetime=True,\n    end_to_series_max_datetime=True,\n)\nquery_generator = dr.DataEngineQueryGenerator.create(\n    generator_type='TimeSeries',\n    datasets = [query_generator_dataset],\n    generator_settings=query_generator_settings,\n)\n\n# prep the training dataset\ntraining_dataset = query_generator.create_dataset()\n\n# create a project\nproject = dr.Project.create_from_dataset(training_dataset.id, project_name='prepped_dataset')\n\n# set up datetime partitioning, target, and train model(s)\npartitioning_spec = dr.DatetimePartitioningSpecification(\n    datetime_partition_column='date', use_time_series=True\n)\nproject.analyze_and_model(target='y', mode='manual', partitioning_method=partitioning_spec)\nblueprints = project.get_blueprints()\nmodel_job = project.train_datetime(blueprints[0].id)\nmodel = model_job.get_result_when_complete()\n\n# query generator can be retrieved from the project if necessary\n# query_generator = dr.DataEngineQueryGenerator.get(project.query_generator_id)\n\n# prep and upload a prediction dataset to the project\nprediction_dataset = query_generator.prepare_prediction_dataset(\n    'prediction_data.csv', project.id\n)\n\n# make predictions within the project\n# Either forecast point or predictions start/end dates must be specified\nmodel.request_predictions(prediction_dataset.id, forecast_point=datetime(2023, 1, 1))\n\n# query generator can be retrieved from a deployed model via project if necessary\n# deployment = dr.Deployment.get(deployment_id)\n# project = dr.Project.get(deployment.model['project_id'])\n# query_generator = dr.DataEngineQueryGenerator.get(project.query_generator_id)\n\n# Deploy the model\nprediction_servers = dr.PredictionServer.list()\ndeployment = dr.Deployment.create_from_learning_model(\n    model.id, 'prepped_deployment', default_prediction_server_id=prediction_servers[0].id\n)\n\n# Make batch predictions from batch prediction job, supports localFile or dataset for intake\n# and all types for output\ntimeseries_settings = {'type': 'forecast', 'forecast_point': datetime(2023, 1, 1)}\nintake_settings = {'type': 'localFile', 'file': 'prediction_data.csv'}\noutput_settings = {'type': 'localFile', 'path': 'predictions_out.csv'}\nbatch_predictions_job = dr.BatchPredictionJob.apply_time_series_data_prep_and_score(\n    deployment, intake_settings, timeseries_settings, output_settings=output_settings\n)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/unsupervised_anomaly.html",
      "title": "Unsupervised Projects (Anomaly Detection)\uf0c1",
      "description": "When the data is not labelled and the problem can be interpreted either as anomaly detection or time\nseries anomaly detection, projects in unsupervised mode become useful.",
      "content": "Unsupervised Projects (Anomaly Detection)\uf0c1\nWhen the data is not labelled and the problem can be interpreted either as anomaly detection or time\nseries anomaly detection, projects in unsupervised mode become useful.\nCreating Unsupervised Projects\uf0c1\nIn order to create an unsupervised project set unsupervised_mode to True when setting the target.\n>>> import datarobot as dr\n>>> project = Project.create('dataset.csv', project_name='unsupervised')\n>>> project.analyze_and_model(unsupervised_mode=True)\nCreating Time Series Unsupervised Projects\uf0c1\nTo create a time series unsupervised project pass  unsupervised_mode=True to\ndatetime partitioning creation and to project aim. The forecast window will be automatically set to nowcasting,\ni.e. forecast distance zero (FW = 0, 0).\n>>> import datarobot as dr\n>>> project = Project.create('dataset.csv', project_name='unsupervised')\n>>> spec = DatetimePartitioningSpecification('date',\n...    use_time_series=True, unsupervised_mode=True,\n...    feature_derivation_window_start=-4, feature_derivation_window_end=0)\n# this step is optional - preview the default partitioning which will be applied\n>>> partitioning_preview = DatetimePartitioning.generate(project.id, spec)\n>>> full_spec = partitioning_preview.to_specification()\n# As of v3.0, can use ``Project.set_datetime_partitioning`` and ``Project.list_datetime_partitioning_spec`` instead\n>>> project.set_datetime_partitioning(datetime_partition_spec=spec)\n>>> project.list_datetime_partitioning_spec()\n# If ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method`` in ``Project.analyze_and_model``\n>>> project.analyze_and_model(unsupervised_mode=True, partitioning_method=full_spec)\nUnsupervised Project Metrics\uf0c1\nIn unsupervised projects, metrics are not used for the model optimization. Instead, they are used for the\npurpose of model ranking. There are two available unsupervised metrics \u2013 Synthetic AUC and\nsynthetic LogLoss \u2013 both of which are calculated on artificially-labelled validation samples.\nEstimating Accuracy of Unsupervised Anomaly Detection Datetime Partitioned Models\uf0c1\nFor datetime partitioned unsupervised model you can retrieve the Anomaly over Time plot. To do so use\nDatetimeModel.get_anomaly_over_time_plot.\nYou can also retrieve the detailed metadata using DatetimeModel.get_anomaly_over_time_plots_metadata,\nand the preview plot using DatetimeModel.get_anomaly_over_time_plot_preview.\nExplaining Unsupervised Time Series Anomaly Detection Models Predictions\uf0c1\nWithin a timeseries unsupervised project for models supporting calculation of Shapley values,\nAnomaly Assessment insight can be computed to explain anomalies.\nExample 1: computation, retrieval and deletion of the anomaly assessment insight.\n>>> import datarobot as dr\n# Initialize Anomaly Assessment for the backtest 0, training subset and series \"series1\"\n>>> model = dr.DatetimeModel.get(project_id, model_id)\n>>> anomaly_assessment_record = model.initialize_anomaly_assessment(0, \"training\", \"series1\")\n# Get available Anomaly Assessment for the project and model\n>>> all_records = model.get_anomaly_assessment_records()\n# Get most recent anomaly assessment explanations\n>>> all_records[0].get_latest_explanations()\n# Get anomaly assessment explanations in the range\n>>> all_records[0].get_explanations(start_date=\"2020-01-01\", points_count=500)\n# Get anomaly assessment predictions preview\n>>> all_records[0].get_predictions_preview()\n# Delete record\n>>> all_records[0].delete()\nExample 2: Find explanations for the anomalous regions (regions with maximum anomaly score >=0.6)\nfor the multiseries project. Leave only explanations for the rows with anomaly score >= 0.5.\n>>> def collect_explanations(model, backtest, source, series_ids):\n... for series in series_ids:\n...     try:\n...         model.initialize_anomaly_assessment(backtest, source, series)\n...      except ClientError:\n...         # when insight was already computed\n...         pass\n... records_for_series = model.get_anomaly_assessment_records(source=source, backtest=backtest, with_data_only=True, limit=0)\n... result = {}\n... for record in records_for_series:\n...     preview = record.get_predictions_preview()\n...     anomalous_regions = preview.find_anomalous_regions(max_prediction_threshold=0.6)\n...     if anomalous_regions:\n...         result[record.series_id] = record.get_explanations_data_in_regions(anomalous_regions, prediction_threshold=0.5)\n... return result\n>>> import datarobot as dr\n>>> model = dr.DatetimeModel.get(project_id, model_id)\n>>> collect_explanations(model, 0, \"validation\", series_ids)\nAssessing Unsupervised Anomaly Detection Models on External Test Set\uf0c1\nIn unsupervised projects, if there is some labelled data, it may be used to assess anomaly detection\nmodels by checking computed classification metrics such as AUC and LogLoss, etc. and insights such as ROC and Lift.\nSuch data is uploaded as a prediction dataset with a specified actual value column name, and, if it\nis a time series project, a prediction date range. The actual value column can contain only zeros and ones or True/False,\nand it should not have been seen during training time.\nRequesting External Scores and Insights (Time Series)\uf0c1\nThere are two ways to specify an actual value column and compute scores and insights:\n1. Upload a prediction dataset, specifying predictions_start_date, predictions_end_date,\nand actual_value_column, and request predictions on that dataset using a specific model.\n>>> import datarobot as dr\n# Upload dataset\n>>> project = dr.Project(project_id)\n>>> dataset = project.upload_dataset(\n...    './data_to_predict.csv',\n...    predictions_start_date=datetime(2000, 1, 1),\n...    predictions_end_date=datetime(2015, 1, 1),\n...    actual_value_column='actuals'\n...    )\n# run prediction job which also will calculate requested scores and insights.\n>>> predict_job = model.request_predictions(dataset.id)\n# prediction output will have column with actuals\n>>> result = pred_job.get_result_when_complete()\n2. Upload a prediction dataset without specifying any options, and request predictions for a specific model with\npredictions_start_date, predictions_end_date, and actual_value_column specified.\nNote, these settings cannot be changed for the dataset after making predictions.\n>>> import datarobot as dr\n# Upload dataset\n>>> project = dr.Project(project_id)\n>>> dataset = project.upload_dataset('./data_to_predict.csv')\n# Check which columns are candidates for actual value columns\n>>> dataset.detected_actual_value_columns\n[{'missing_count': 25, 'name': 'label_column'}]\n# run prediction job which also will calculate requested scores and insights.\n>>> predict_job = model.request_predictions(\n...    dataset.id,\n...    predictions_start_date=datetime(2000, 1, 1),\n...    predictions_end_date=datetime(2015, 1, 1),\n...    actual_value_column='label_column'\n...  )\n>>> result = pred_job.get_result_when_complete()\nRequesting External Scores and Insights for AutoML models\uf0c1\nTo compute scores and insights on an external dataset for unsupervised AutoML models (Non Time series)\nUpload a prediction dataset that contains label column(s), request compute external test on one\nof PredictionDataset.detected_actual_value_columns\nimport datarobot as dr\n# Upload dataset\nproject = dr.Project(project_id)\ndataset = project.upload_dataset('./test_set.csv')\ndataset.detected_actual_value_columns\n>>>['label_column_1', 'label_column_2']\n# request external test to compute metric scores and insights on dataset\nexternal_test_job = model.request_external_test(dataset.id, actual_value_column='label_column_1')\n# once job is complete, scores and insights are ready for retrieving\nexternal_test_job.wait_for_completion()\nRetrieving External Scores and Insights\uf0c1\nUpon completion of prediction, external scores and insights can be retrieved to assess model\nperformance. For unsupervised projects Lift Chart and ROC Curve are computed.\nIf the dataset is too small insights will not be computed. If the actual value column contained\nonly one class, the ROC Curve will not be computed. Information about the dataset can be retrieved\nusing PredictionDataset.get.\n>>> import datarobot as dr\n# Check which columns are candidates for actual value columns\n>>> scores_list = ExternalScores.list(project_id)\n>>> scores = ExternalScores.get(project_id, dataset_id=dataset_id, model_id=model_id)\n>>> lift_list = ExternalLiftChart.list(project_id, model_id)\n>>> roc = ExternalRocCurve.get(project_id, model, dataset_id)\n# check dataset warnings, need to be called after predictions are computed.\n>>> dataset = PredictionDataset.get(project_id, dataset_id)\n>>> dataset.data_quality_warnings\n{'single_class_actual_value_column': True,\n'insufficient_rows_for_evaluating_models': False,\n'has_kia_missing_values_in_forecast_window': False}",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        ">>> import datarobot as dr\n>>> project = Project.create('dataset.csv', project_name='unsupervised')\n>>> project.analyze_and_model(unsupervised_mode=True)",
        ">>> import datarobot as dr\n>>> project = Project.create('dataset.csv', project_name='unsupervised')\n>>> spec = DatetimePartitioningSpecification('date',\n...    use_time_series=True, unsupervised_mode=True,\n...    feature_derivation_window_start=-4, feature_derivation_window_end=0)\n\n# this step is optional - preview the default partitioning which will be applied\n>>> partitioning_preview = DatetimePartitioning.generate(project.id, spec)\n>>> full_spec = partitioning_preview.to_specification()\n\n# As of v3.0, can use ``Project.set_datetime_partitioning`` and ``Project.list_datetime_partitioning_spec`` instead\n>>> project.set_datetime_partitioning(datetime_partition_spec=spec)\n>>> project.list_datetime_partitioning_spec()\n\n# If ``Project.set_datetime_partitioning`` was used there is no need to pass ``partitioning_method`` in ``Project.analyze_and_model``\n>>> project.analyze_and_model(unsupervised_mode=True, partitioning_method=full_spec)",
        "DatetimeModel.get_anomaly_over_time_plot",
        "DatetimeModel.get_anomaly_over_time_plots_metadata",
        "DatetimeModel.get_anomaly_over_time_plot_preview",
        ">>> import datarobot as dr\n# Initialize Anomaly Assessment for the backtest 0, training subset and series \"series1\"\n>>> model = dr.DatetimeModel.get(project_id, model_id)\n>>> anomaly_assessment_record = model.initialize_anomaly_assessment(0, \"training\", \"series1\")\n# Get available Anomaly Assessment for the project and model\n>>> all_records = model.get_anomaly_assessment_records()\n# Get most recent anomaly assessment explanations\n>>> all_records[0].get_latest_explanations()\n# Get anomaly assessment explanations in the range\n>>> all_records[0].get_explanations(start_date=\"2020-01-01\", points_count=500)\n # Get anomaly assessment predictions preview\n>>> all_records[0].get_predictions_preview()\n# Delete record\n>>> all_records[0].delete()",
        ">>> def collect_explanations(model, backtest, source, series_ids):\n... for series in series_ids:\n...     try:\n...         model.initialize_anomaly_assessment(backtest, source, series)\n...      except ClientError:\n...         # when insight was already computed\n...         pass\n... records_for_series = model.get_anomaly_assessment_records(source=source, backtest=backtest, with_data_only=True, limit=0)\n... result = {}\n... for record in records_for_series:\n...     preview = record.get_predictions_preview()\n...     anomalous_regions = preview.find_anomalous_regions(max_prediction_threshold=0.6)\n...     if anomalous_regions:\n...         result[record.series_id] = record.get_explanations_data_in_regions(anomalous_regions, prediction_threshold=0.5)\n... return result\n>>> import datarobot as dr\n>>> model = dr.DatetimeModel.get(project_id, model_id)\n>>> collect_explanations(model, 0, \"validation\", series_ids)",
        ">>> import datarobot as dr\n# Upload dataset\n>>> project = dr.Project(project_id)\n>>> dataset = project.upload_dataset(\n...    './data_to_predict.csv',\n...    predictions_start_date=datetime(2000, 1, 1),\n...    predictions_end_date=datetime(2015, 1, 1),\n...    actual_value_column='actuals'\n...    )\n# run prediction job which also will calculate requested scores and insights.\n>>> predict_job = model.request_predictions(dataset.id)\n# prediction output will have column with actuals\n>>> result = pred_job.get_result_when_complete()",
        ">>> import datarobot as dr\n# Upload dataset\n>>> project = dr.Project(project_id)\n>>> dataset = project.upload_dataset('./data_to_predict.csv')\n# Check which columns are candidates for actual value columns\n>>> dataset.detected_actual_value_columns\n[{'missing_count': 25, 'name': 'label_column'}]\n\n# run prediction job which also will calculate requested scores and insights.\n>>> predict_job = model.request_predictions(\n...    dataset.id,\n...    predictions_start_date=datetime(2000, 1, 1),\n...    predictions_end_date=datetime(2015, 1, 1),\n...    actual_value_column='label_column'\n...  )\n>>> result = pred_job.get_result_when_complete()",
        "import datarobot as dr\n# Upload dataset\nproject = dr.Project(project_id)\ndataset = project.upload_dataset('./test_set.csv')\ndataset.detected_actual_value_columns\n>>>['label_column_1', 'label_column_2']\n# request external test to compute metric scores and insights on dataset\nexternal_test_job = model.request_external_test(dataset.id, actual_value_column='label_column_1')\n# once job is complete, scores and insights are ready for retrieving\nexternal_test_job.wait_for_completion()",
        ">>> import datarobot as dr\n# Check which columns are candidates for actual value columns\n >>> scores_list = ExternalScores.list(project_id)\n >>> scores = ExternalScores.get(project_id, dataset_id=dataset_id, model_id=model_id)\n >>> lift_list = ExternalLiftChart.list(project_id, model_id)\n >>> roc = ExternalRocCurve.get(project_id, model, dataset_id)\n# check dataset warnings, need to be called after predictions are computed.\n >>> dataset = PredictionDataset.get(project_id, dataset_id)\n >>> dataset.data_quality_warnings\n{'single_class_actual_value_column': True,\n'insufficient_rows_for_evaluating_models': False,\n'has_kia_missing_values_in_forecast_window': False}"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/unsupervised_clustering.html",
      "title": "Unsupervised Projects (Clustering)\uf0c1",
      "description": "Use clustering when data is not labelled and the problem can be interpreted as grouping a set of\nobjects in such a way that objects in the same group (called a cluster) are more similar\nto each other than to those in other groups (clusters). It is a common task in data exploration\nwhen finding groups and similarities is needed.",
      "content": "Unsupervised Projects (Clustering)\uf0c1\nUse clustering when data is not labelled and the problem can be interpreted as grouping a set of\nobjects in such a way that objects in the same group (called a cluster) are more similar\nto each other than to those in other groups (clusters). It is a common task in data exploration\nwhen finding groups and similarities is needed.\nCreating Unsupervised Projects\uf0c1\nTo create an unsupervised project, set unsupervised_mode to True when setting the target.\nTo specify clustering, set unsupervised_type to CLUSTERING. When setting the modeling mode\nis required, clustering supports either AUTOPILOT_MODE.COMPREHENSIVE for DataRobot-run Autopilot\nor AUTOPILOT_MODE.MANUAL for user control of which models/parameters to use.\nExample:\nfrom datarobot import Project\nfrom datarobot.enums import UnsupervisedTypeEnum\nfrom datarobot.enums import AUTOPILOT_MODE\nproject = Project.create(\"dataset.csv\", project_name=\"unsupervised clustering\")\nproject.analyze_and_model(\nunsupervised_mode=True,\nmode=AUTOPILOT_MODE.COMPREHENSIVE,\nunsupervised_type=UnsupervisedTypeEnum.CLUSTERING,\n)\nYou can optionally specify list of explicit cluster numbers. To do this, pass a list of integer\nvalues to optional autopilot_cluster_list parameter using the analyze_and_model() method.\nproject.analyze_and_model(\nunsupervised_mode=True,\nmode=AUTOPILOT_MODE.COMPREHENSIVE,\nunsupervised_type=UnsupervisedTypeEnum.CLUSTERING,\nautopilot_cluster_list=[7, 9, 11, 15, 19],\n)\nYou can also do both in one step using the Project.start() method. This method by default will\nuse AUTOPILOT_MODE.COMPREHENSIVE mode.\nfrom datarobot import Project\nfrom datarobot.enums import UnsupervisedTypeEnum\nproject = Project.start(\n\"dataset.csv\",\nunsupervised_mode=True,\nproject_name=\"unsupervised clustering project\",\nunsupervised_type=UnsupervisedTypeEnum.CLUSTERING,\n)\nUnsupervised Clustering Project Metric\uf0c1\nUnsupervised clustering projects use the Silhouette Score metric for model ranking (instead of\nusing it for model optimization). It measures the average similarity of objects within a cluster\nand their distance to the other objects in the other clusters.\nRetrieving information about Clusters\uf0c1\nIn a trained model, you can retrieve information about clusters in along with standard model\ninformation. To do this, when training completes, retrieve a model and view basic clustering\ninformation:\nn_clusters : number of clusters for model\nis_n_clusters_dynamically_determined : how clustering model picks number of clusters\nHere is a code snippet to retrieve information about the number of clusters for model:\nfrom datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\nprint(\"{} clusters found\".format(model.n_clusters))\nYou can retrieve more details about clusters and their data using cluster insights.\nWorking with Clusters Insights\uf0c1\nYou can compute insights to gain deep insights into clusters and their characteristics. This\nprocess will perform calculations and return detailed information about each feature and its\nimportance, as well as a detailed per-cluster breakdown.\nTo compute and retrieve cluster insights, use the ClusteringModel and its compute_insights\nmethod. The method starts the cluster insights compute job, waits for its completion for the number\nof seconds specified in the optional parameter max_wait (default: 600), and returns results\nwhen insights are ready.\nIf clusters are already computed,  access them using the insights property of the\nClusteringModel method.\nfrom datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\ninsights = model.compute_insights()\nThis call, with the specified wait_time, will run and wait for specified time:\nfrom datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\ninsights = model.compute_insights(max_wait=60)\nIf computation fails to finish before max_wait expires, the method will raise\nan AsyncTimeoutError. You can retrieve cluster insights after jobs computation finishes.\nTo retrieve cluster insights already computed:\nfrom datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\nfor insight in model.insights:\nprint(insight)\nWorking with Clusters\uf0c1\nBy default, DataRobot names clusters \u201cCluster 1\u201d, \u201cCluster 2\u201d, \u2026 , \u201cCluster N\u201d .\nYou can retrieve these names and alter them according to preference. When retrieving\nclusters before computing insights, clusters will contain only names. After insight computation\ncompletes, each cluster will also hold information about the percentage of data that is represented\nby the Cluster.\nFor example:\nfrom datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\n# helper function\ndef print_summary(name, percent):\nif not percent:\npercent = \"?\"\nprint(\"'{}' holds {} % of data\".format(name, percent))\nfor cluster in model.clusters:\nprint_summary(cluster.name, cluster.percent)\nmodel.compute_insights()\nfor cluster in model.clusters:\nprint_summary(cluster.name, cluster.percent)\nFor a model with three clusters, the code snippet will output:\n'Cluster 1' holds ? % of data\n'Cluster 2' holds ? % of data\n'Cluster 3' holds ? % of data\n-- Cluster insights computation finished --\n'Cluster 1' holds 27.1704180064 % of data\n'Cluster 2' holds 36.9131832797 % of data\n'Cluster 3' holds 35.9163987138 % of data\nUse the following methods of ClusteringModel class to alter cluster names:\nupdate_cluster_names - changes multiple cluster names using mapping in dictionary\nupdate_cluster_name - changes one cluster name\nAfter update, each method will return a list of clusters with changed names.\nFor example:\nfrom datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\n# update multiple\ncluster_name_mappings = [\n(\"Cluster 1\", \"AAA\"),\n(\"Cluster 2\", \"BBB\"),\n(\"Cluster 3\", \"CCC\")\n]\nclusters = model.update_cluster_names(cluster_name_mappings)\n# update single\nclusters = model.update_cluster_name(\"CCC\", \"DDD\")\nClustering Classes Reference\uf0c1\nClusteringModel\uf0c1\nclass datarobot.models.model.ClusteringModel\uf0c1\nClusteringModel extends Model class.\nIt provides provides properties and methods specific to clustering projects.\ncompute_insights(max_wait=600)\uf0c1\nCompute and retrieve cluster insights for model. This method awaits completion of\njob computing cluster insights and returns results after it is finished. If computation\ntakes longer than specified max_wait exception will be raised.\nParameters:\nproject_id (str) \u2013 Project to start creation in.\nmodel_id (str) \u2013 Project\u2019s model to start creation in.\nmax_wait (int) \u2013 Maximum number of seconds to wait before giving up\nReturn type:\nList of ClusterInsight\nRaises:\nClientError \u2013 Server rejected creation due to client error.\nMost likely cause is bad project_id or model_id.\nAsyncFailureError \u2013 If any of the responses from the server are unexpected\nAsyncProcessUnsuccessfulError \u2013 If the cluster insights computation has failed or was cancelled.\nAsyncTimeoutError \u2013 If the cluster insights computation did not resolve in time\nproperty insights: List[ClusterInsight]\uf0c1\nReturn actual list of cluster insights if already computed.\nReturn type:\nList of ClusterInsight\nproperty clusters: List[Cluster]\uf0c1\nReturn actual list of Clusters.\nReturn type:\nList of Cluster\nupdate_cluster_names(cluster_name_mappings)\uf0c1\nChange many cluster names at once based on list of name mappings.\nParameters:\ncluster_name_mappings (List of tuples) \u2013 Cluster names mapping consisting of current cluster name and old cluster name.\nExample:\ncluster_name_mappings = [\n(\"current cluster name 1\", \"new cluster name 1\"),\n(\"current cluster name 2\", \"new cluster name 2\")]\nReturn type:\nList of Cluster\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected update of cluster names.\nPossible reasons include: incorrect format of mapping, mapping introduces duplicates.\nupdate_cluster_name(current_name, new_name)\uf0c1\nChange cluster name from current_name to new_name.\nParameters:\ncurrent_name (str) \u2013 Current cluster name.\nnew_name (str) \u2013 New cluster name.\nReturn type:\nList of Cluster\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected update of cluster names.\nCluster\uf0c1\nclass datarobot.models.model.Cluster\uf0c1\nRepresentation of a single cluster.\nVariables:\nname (str) \u2013 Current cluster name\npercent (float) \u2013 Percent of data contained in the cluster. This value is reported after cluster insights\nare computed for the model.\nclassmethod list(project_id, model_id)\uf0c1\nRetrieve a list of clusters in the model.\nParameters:\nproject_id (str) \u2013 ID of the project that the model is part of.\nmodel_id (str) \u2013 ID of the model.\nReturn type:\nList of clusters\nclassmethod update_multiple_names(project_id, model_id, cluster_name_mappings)\uf0c1\nUpdate many clusters at once based on list of name mappings.\nParameters:\nproject_id (str) \u2013 ID of the project that the model is part of.\nmodel_id (str) \u2013 ID of the model.\ncluster_name_mappings (List of tuples) \u2013 Cluster name mappings, consisting of current and previous names for each cluster.\nExample:\ncluster_name_mappings = [\n(\"current cluster name 1\", \"new cluster name 1\"),\n(\"current cluster name 2\", \"new cluster name 2\")]\nReturn type:\nList of clusters\nRaises:\ndatarobot.errors.ClientError \u2013 Server rejected update of cluster names.\nValueError \u2013 Invalid cluster name mapping provided.\nclassmethod update_name(project_id, model_id, current_name, new_name)\uf0c1\nChange cluster name from current_name to new_name\nParameters:\nproject_id (str) \u2013 ID of the project that the model is part of.\nmodel_id (str) \u2013 ID of the model.\ncurrent_name (str) \u2013 Current cluster name\nnew_name (str) \u2013 New cluster name\nReturn type:\nList of Cluster\nClusterInsight\uf0c1\nclass datarobot.models.model.ClusterInsight\uf0c1\nHolds data on all insights related to feature as well as breakdown per cluster.\nParameters:\nfeature_name (str) \u2013 Name of a feature from the dataset.\nfeature_type (str) \u2013 Type of feature.\ninsights (List[ClusterInsight]) \u2013 List provides information regarding the importance of a specific feature in relation\nto each cluster. Results help understand how the model is grouping data and what each\ncluster represents.\nfeature_impact (float) \u2013 Impact of a feature ranging from 0 to 1.\nclassmethod compute(project_id, model_id, max_wait=600)\uf0c1\nStarts creation of cluster insights for the model and if successful, returns computed\nClusterInsights. This method allows calculation to continue for a specified time and\nif not complete, cancels the request.\nParameters:\nproject_id (str) \u2013 ID of the project to begin creation of cluster insights for.\nmodel_id (str) \u2013 ID of the project model to begin creation of cluster insights for.\nmax_wait (int) \u2013 Maximum number of seconds to wait canceling the request.\nReturn type:\nList[ClusterInsight]\nRaises:\nClientError \u2013 Server rejected creation due to client error.\nMost likely cause is bad project_id or model_id.\nAsyncFailureError \u2013 Indicates whether any of the responses from the server are unexpected.\nAsyncProcessUnsuccessfulError \u2013 Indicates whether the cluster insights computation failed or was cancelled.\nAsyncTimeoutError \u2013 Indicates whether the cluster insights computation did not resolve within the specified\ntime limit (max_wait).",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/errors.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "from datarobot import Project\nfrom datarobot.enums import UnsupervisedTypeEnum\nfrom datarobot.enums import AUTOPILOT_MODE\n\nproject = Project.create(\"dataset.csv\", project_name=\"unsupervised clustering\")\nproject.analyze_and_model(\n    unsupervised_mode=True,\n    mode=AUTOPILOT_MODE.COMPREHENSIVE,\n    unsupervised_type=UnsupervisedTypeEnum.CLUSTERING,\n)",
        "project.analyze_and_model(\n    unsupervised_mode=True,\n    mode=AUTOPILOT_MODE.COMPREHENSIVE,\n    unsupervised_type=UnsupervisedTypeEnum.CLUSTERING,\n    autopilot_cluster_list=[7, 9, 11, 15, 19],\n)",
        "from datarobot import Project\nfrom datarobot.enums import UnsupervisedTypeEnum\n\nproject = Project.start(\n    \"dataset.csv\",\n    unsupervised_mode=True,\n    project_name=\"unsupervised clustering project\",\n    unsupervised_type=UnsupervisedTypeEnum.CLUSTERING,\n)",
        "from datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\nprint(\"{} clusters found\".format(model.n_clusters))",
        "from datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\ninsights = model.compute_insights()",
        "from datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\ninsights = model.compute_insights(max_wait=60)",
        "from datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\nfor insight in model.insights:\n    print(insight)",
        "from datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\n\n# helper function\ndef print_summary(name, percent):\n    if not percent:\n        percent = \"?\"\n    print(\"'{}' holds {} % of data\".format(name, percent))\n\nfor cluster in model.clusters:\n    print_summary(cluster.name, cluster.percent)\nmodel.compute_insights()\nfor cluster in model.clusters:\n    print_summary(cluster.name, cluster.percent)",
        "from datarobot import ClusteringModel\nmodel = ClusteringModel.get(project_id, model_id)\n\n# update multiple\ncluster_name_mappings = [\n    (\"Cluster 1\", \"AAA\"),\n    (\"Cluster 2\", \"BBB\"),\n    (\"Cluster 3\", \"CCC\")\n]\nclusters = model.update_cluster_names(cluster_name_mappings)\n\n# update single\nclusters = model.update_cluster_name(\"CCC\", \"DDD\")"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/index.html",
      "title": "Predictions\uf0c1",
      "description": "The following sections describe the components to making predictions in DataRobot:",
      "content": "Predictions\uf0c1\nThe following sections describe the components to making predictions in DataRobot:\nGenerate predictions: Initiate a prediction job with the  Model.request_predictions() method. This method can use either a training dataset or predictions dataset for scoring.\nBatch predictions: Score large sets of data with batch predictions. You can define jobs and their schedule.\nPrediction API: Use DataRobot\u2019s Prediction API. to make predictions on both a dedicated and/or a standalone prediction server.\nScoring Code: Qualifying models allow you to export Scoring Code and use DataRobot-generated models outside of the platform",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://docs.datarobot.com/en/docs/predictions/api/dr-predapi.html",
        "https://docs.datarobot.com/en/docs/predictions/scoring-code/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "Model.request_predictions()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/visualai.html",
      "title": "Visual AI projects\uf0c1",
      "description": "With Visual AI, DataRobot allows you to use image data for modeling. You can create projects with one\nor multiple image features and also mix them with other DataRobot-supported feature types. You can\nfind more information about\nVisual AI\nin the Platform documentation.",
      "content": "Visual AI projects\uf0c1\nWith Visual AI, DataRobot allows you to use image data for modeling. You can create projects with one\nor multiple image features and also mix them with other DataRobot-supported feature types. You can\nfind more information about\nVisual AI\nin the Platform documentation.\nCreate a Visual AI project\uf0c1\nDataRobot offers you different ways to prepare your dataset and to start a Visual AI project. The\nvarious ways to do this are covered in detail in the documentation,\nPreparing the dataset.\nFor the examples given here the images are partitioned into named\ndirectories. In the following, images are partitioned into named directories, which serve as labels\nfor the project. For example, to predict on images of cat and dog breeds, labels could be\nabyssinian, american_bulldog, etc.\n/home/user/data/imagedataset\n\u251c\u2500\u2500 abyssinian\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 abyssinian01.jpg\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 abyssinian02.jpg\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 \u2026\n\u251c\u2500\u2500 american_bulldog\n\u2502   \u251c\u2500\u2500 american_bulldog01.jpg\n\u2502   \u251c\u2500\u2500 american_bulldog02.jpg\n\u2502   \u251c\u2500\u2500 \u2026\nYou then compress the directory containing the named directories into a\nZIP file, creating the dataset used for the project.\nfrom datarobot.models import Project, Dataset\ndataset = Dataset.create_from_file(file_path='/home/user/data/imagedataset.zip')\nproject = Project.create_from_dataset(dataset.id, project_name='My Image Project')\nTarget\uf0c1\nSince this example uses named directories the target name must be\nclass, which will contain the name of each directory in the ZIP\nfile.\nOther parameters\uf0c1\nSetting modeling parameters, such as partitioning method, queue mode,\netc, functions in the same way as starting a non-image project.\nStart modeling\uf0c1\nOnce you have set modeling parameters, use the following code snippet\nto specify parameters and start the modeling process.\nfrom datarobot import AUTOPILOT_MODE\nproject.analyze_and_model(target='class', mode=AUTOPILOT_MODE.QUICK)\nYou can also pass optional parameters to project.analyze_and_model\nto change aspects of the modeling process. Some of those parameters\ninclude:\nworker_count \u2013 int, sets the number of workers used for modeling.\npartitioning_method \u2013 PartitioningMethod object.\nFor a full reference of available parameters, see\nProject.analyze_and_model.\nYou can use the mode parameter to set the Autopilot mode.\nAUTOPILOT_MODE.FULL_AUTO, is the default, triggers modeling\nwith no further actions necessary. Other accepted modes include\nAUTOPILOT_MODE.MANUAL for manual mode (choose your own models to run\nrather than running the full Autopilot) and AUTOPILOT_MODE.QUICK to\nrun on a more limited set of models and get insights more quickly\n(\u201cquick run\u201d).\nInteract with a Visual AI project\uf0c1\nThe following code snippets may be used to access Visual AI images and\ninsights.\nList sample images\uf0c1\nSample images allow you to see a subset of images, chosen by DataRobot,\nin the dataset. The returned SampleImage objects have an associated\ntarget_value that will allow you to categorize the images (abyssinian, american_bulldog, etc).\nUntil you set the target and EDA2 has finished, the target_value will be None.\nimport io\nimport PIL.Image\nfrom datarobot.models.visualai import SampleImage\ncolumn_name = \"image\"\nnumber_of_images_to_show = 5\nfor sample in SampleImage.list(project.id, column_name)[:number_of_images_to_show]:\n# Display the image in the GUI\nbio = io.BytesIO(sample.image.image_bytes)\nimg = PIL.Image.open(bio)\nimg.show()\nThe results would be images such as:\nList duplicate images\uf0c1\nDuplicate images, images with different names but are determined by DataRobot\nto be the same, may exist in a dataset. If this happens, the code returns\none of the images and the number of times it occurs in the dataset.\nfrom datarobot.models.visualai import DuplicateImage\ncolumn_name = \"image\"\nfor duplicate in DuplicateImage.list(project.id, column_name):\n# To show an image see the previous sample image example\nprint(f\"Image id = {duplicate.image.id} has {duplicate.count} duplicates\")\nActivation maps\uf0c1\nActivation maps are overlaid on the images to show which image areas are driving model prediction\ndecisions.\nDetailed explanations are available in DataRobot Platform\ndocumentation, Model insights.\nCompute activation maps\uf0c1\nTo begin, you must first compute activation maps. The following snippet is an example of starting\nthe computation for a Keras model in a Visual AI project. The compute method returns a URL that\ncan be used to determine when the computation completes.\nfrom datarobot.models.visualai import ImageActivationMap\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\nstatus_url = ImageActivationMap.compute(project.id, keras_model.id)\nprint(status_url)\nList activation maps\uf0c1\nAfter activation maps are computed, you can download them from the\nDataRobot server. The following snippet is an example of how to get the\nactivation maps and how to plot them.\nimport PIL.Image\nfrom datarobot.models.visualai import ImageActivationMap\ncolumn_name = \"image\"\nmax_activation_maps = 5\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\nfor activation_map in ImageActivationMap.list(project.id, keras_model.id, column_name)[:max_activation_maps]:\nbio = io.BytesIO(activation_map.overlay_image.image_bytes)\nimg = PIL.Image.open(bio)\nimg.show()\nImage embeddings\uf0c1\nImage embeddings allow you to get an impression on how similar two images look to a featurizer\nnetwork. The embeddings project images from their high-dimensional feature space onto a 2D plane.\nThe closer the images appear in this plane, the more similar they look to the featurizer.\nDetailed explanations are available in the DataRobot Platform documentation,\nModel insights.\nCompute image embeddings\uf0c1\nYou must compute image embeddings before retrieving. The following snippet\nis an example of starting the computation for a Keras model in our Visual AI project. The\ncompute method returns a URL that can be used to determine when the computation is complete.\nfrom datarobot.models.visualai import ImageEmbedding\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\nstatus_url = ImageEmbedding.compute(project.id, keras_model.id)\nprint(status_url)\nList image embeddings\uf0c1\nAfter image embeddings are computed, you can download them from the\nDataRobot server. The following snippet is an example of how to get the\nembeddings for a model and plot them.\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport PIL.Image\nfrom datarobot.models.visualai import ImageEmbedding\ncolumn_name = \"image\"\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\nzoom = 0.15\nfig, ax = plt.subplots(figsize=(15,10))\nfor image_embedding in ImageEmbedding.list(project.id, keras_model.id, column_name):\nimage_bytes = image_embedding.image.image_bytes\nx_position = image_embedding.position_x\ny_position = image_embedding.position_y\nimage = PIL.Image.open(io.BytesIO(image_bytes))\noffset_image = OffsetImage(np.array(image), zoom=zoom)\nannotation_box = AnnotationBbox(offset_image, (x_position, y_position), xycoords='data', frameon=False)\nax.add_artist(annotation_box)\nax.update_datalim([(x_position, y_position)])\nax.autoscale()\nax.grid(True)\nfig.show()\nImage augmentation\uf0c1\nImage Augmentation is a processing step in the DataRobot blueprint that creates new images for\ntraining by randomly transforming existing images, thereby increasing the size of\n(i.e., \u201caugmenting\u201d) the training data.\nDetailed explanations are available in the DataRobot Platform documentation,\nCreating augmented models.\nCreate image augmentation list\uf0c1\nTo create image augmentation samples, you need to provide an image augmentation list. This list holds all\ninformation required to compute image augmentation samples. The following snippet shows\nhow to create an image augmentation list. It is then used to compute image augmentation samples.\nfrom datarobot.models.visualai import ImageAugmentationList\nblur_param = {\"name\": \"maximum_filter_size\", \"currentValue\": 10}\nblur = {\"name\": \"blur\", \"params\": [blur_param]}\nflip = {\"name\": \"horizontal_flip\", \"params\": []}\nimage_augmentation_list = ImageAugmentationList.create(\nname=\"my blur and flip augmentation list\",\nproject_id=project.id,\nfeature_name=\"image\",\ntransformation_probability=0.5,\nnumber_of_new_images=5,\ntransformations=[blur, flip],\n)\nprint(image_augmentation_list)\nList image augmentation lists\uf0c1\nYou can retrieve all available augmentation lists for a project by project_id.\nfrom datarobot.models.visualai import ImageAugmentationList\nimage_augmentation_lists = ImageAugmentationList.list(\nproject_id=project.id\n)\nprint(image_augmentation_lists)\nCompute and retrieve image augmentation samples\uf0c1\nYou must compute image augmentation samples before retrieving. To compute image augmentation sample, you will need an image augmentation list. This list holds all parameters and transformation information\nneeded to compute samples. You can either create a new one or retrieve an existing one.\nThe following snippet is an example of computing and retrieving image augmentation samples. It\nuses the previous snippet that creates an image augmentation list, but instead uses it to compute and\nretrieve image augmentation samples using the compute_samples method.\nfrom datarobot.models.visualai import ImageAugmentationList, ImageAugmentationSample\nimage_augmentation_list = ImageAugmentationList.get('<image_augmentation_list_id>')\nfor sample in image_augmentation_list.compute_samples():\n# Display the image in popup widows\nbio = io.BytesIO(sample.image.image_bytes)\nimg = PIL.Image.open(bio)\nimg.show()\nList image augmentation samples\uf0c1\nIf image augmentation samples were already computed instead of recomputing them we can retrieve\nthe last sample that was computed for image augmentation list from DataRobot server. The following\nsnippet is an example of how to get the image augmentation samples.\nimport io\nimport PIL.Image\nfrom datarobot.models.visualai import ImageAugmentationList\nimage_augmentation_list = ImageAugmentationList.get('<image_augmentation_list_id>')\nfor sample in image_augmentation_list.retrieve_samples():\n# Display the image in popup widows\nbio = io.BytesIO(sample.image.image_bytes)\nimg = PIL.Image.open(bio)\nimg.show()\nConfigure augmentations to use during training\uf0c1\nIn order to automatically augment a dataset during training the DataRobot server will\nlook for an augmentation list associated with the project that has the key\ninitial_list set to True.  An augmentation list like this can be created with the\nfollowing code snippet.  If it is created for the project before autopilot is started.\nit will be used to automatically augment the images in the training dataset.\nfrom datarobot.models.visualai import ImageAugmentationList\nblur_param = {\"name\": \"maximum_filter_size\", \"currentValue\": 10}\nblur = {\"name\": \"blur\", \"params\": [blur_param]}\nflip = {\"name\": \"horizontal_flip\", \"params\": []}\ntransforms_to_apply = ImageAugmentationList.create(name=\"blur and scale\", project_id=project.id,\nfeature_name='image', transformation_probability=0.5, number_of_new_images=5,\ntransformations=[blur, flip], initial_list=True)\nDetermine available transformations for augmentations\uf0c1\nThe Augmentation List in the example above supports horizontal flip and blur transformations,\nbut DataRobot supports several other transformations. To retrieve the list of supported\ntransformations use the ImageAugmentationOptions object as the example below shows.\nfrom datarobot.models.visualai import ImageAugmentationOptions\noptions = ImageAugmentationOptions.get(project.id)\nConverting images to base64-encoded strings for predictions\uf0c1\nIf your training dataset contained images, images in the prediction dataset need to be converted\nto a base64-encoded strings so it can be fully contained in the prediction request (for example, in a CSV\nfile or JSON). For more detail, see: working with binary data\nLicense\uf0c1\nFor the examples here we used the\nThe Oxford-IIIT Pet Dataset licensed under\nCreative Commons Attribution-ShareAlike 4.0 International License",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/index.html",
        "https://docs.datarobot.com/en/docs/modeling/special-workflows/visual-ai/index.html",
        "https://docs.datarobot.com/en/docs/modeling/special-workflows/visual-ai/vai-model.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/projects.html",
        "https://docs.datarobot.com/en/docs/modeling/special-workflows/visual-ai/vai-insights.html",
        "https://docs.datarobot.com/en/docs/modeling/special-workflows/visual-ai/tti-augment/ttia-introduction.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/modeling/spec/binary_data.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "from datarobot.models import Project, Dataset\ndataset = Dataset.create_from_file(file_path='/home/user/data/imagedataset.zip')\nproject = Project.create_from_dataset(dataset.id, project_name='My Image Project')",
        "from datarobot import AUTOPILOT_MODE\nproject.analyze_and_model(target='class', mode=AUTOPILOT_MODE.QUICK)",
        "project.analyze_and_model",
        "Project.analyze_and_model",
        "import io\nimport PIL.Image\n\nfrom datarobot.models.visualai import SampleImage\n\ncolumn_name = \"image\"\nnumber_of_images_to_show = 5\n\nfor sample in SampleImage.list(project.id, column_name)[:number_of_images_to_show]:\n    # Display the image in the GUI\n    bio = io.BytesIO(sample.image.image_bytes)\n    img = PIL.Image.open(bio)\n    img.show()",
        "from datarobot.models.visualai import DuplicateImage\n\ncolumn_name = \"image\"\n\nfor duplicate in DuplicateImage.list(project.id, column_name):\n    # To show an image see the previous sample image example\n    print(f\"Image id = {duplicate.image.id} has {duplicate.count} duplicates\")",
        "from datarobot.models.visualai import ImageActivationMap\n\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\n\nstatus_url = ImageActivationMap.compute(project.id, keras_model.id)\nprint(status_url)",
        "import PIL.Image\nfrom datarobot.models.visualai import ImageActivationMap\n\ncolumn_name = \"image\"\nmax_activation_maps = 5\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\n\nfor activation_map in ImageActivationMap.list(project.id, keras_model.id, column_name)[:max_activation_maps]:\n    bio = io.BytesIO(activation_map.overlay_image.image_bytes)\n    img = PIL.Image.open(bio)\n    img.show()",
        "from datarobot.models.visualai import ImageEmbedding\n\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\n\nstatus_url = ImageEmbedding.compute(project.id, keras_model.id)\nprint(status_url)",
        "from matplotlib.offsetbox import OffsetImage, AnnotationBbox\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport PIL.Image\n\nfrom datarobot.models.visualai import ImageEmbedding\n\ncolumn_name = \"image\"\nkeras_model = project.get_models(search_params={'name': 'Keras'})[0]\nzoom = 0.15\n\nfig, ax = plt.subplots(figsize=(15,10))\nfor image_embedding in ImageEmbedding.list(project.id, keras_model.id, column_name):\n    image_bytes = image_embedding.image.image_bytes\n    x_position = image_embedding.position_x\n    y_position = image_embedding.position_y\n    image = PIL.Image.open(io.BytesIO(image_bytes))\n    offset_image = OffsetImage(np.array(image), zoom=zoom)\n    annotation_box = AnnotationBbox(offset_image, (x_position, y_position), xycoords='data', frameon=False)\n    ax.add_artist(annotation_box)\n    ax.update_datalim([(x_position, y_position)])\nax.autoscale()\nax.grid(True)\nfig.show()",
        "from datarobot.models.visualai import ImageAugmentationList\n\nblur_param = {\"name\": \"maximum_filter_size\", \"currentValue\": 10}\nblur = {\"name\": \"blur\", \"params\": [blur_param]}\nflip = {\"name\": \"horizontal_flip\", \"params\": []}\n\nimage_augmentation_list = ImageAugmentationList.create(\n    name=\"my blur and flip augmentation list\",\n    project_id=project.id,\n    feature_name=\"image\",\n    transformation_probability=0.5,\n    number_of_new_images=5,\n    transformations=[blur, flip],\n)\n\nprint(image_augmentation_list)",
        "from datarobot.models.visualai import ImageAugmentationList\n\nimage_augmentation_lists = ImageAugmentationList.list(\n    project_id=project.id\n)\nprint(image_augmentation_lists)",
        "from datarobot.models.visualai import ImageAugmentationList, ImageAugmentationSample\n\nimage_augmentation_list = ImageAugmentationList.get('<image_augmentation_list_id>')\n\nfor sample in image_augmentation_list.compute_samples():\n     # Display the image in popup widows\n     bio = io.BytesIO(sample.image.image_bytes)\n     img = PIL.Image.open(bio)\n     img.show()",
        "import io\nimport PIL.Image\nfrom datarobot.models.visualai import ImageAugmentationList\n\nimage_augmentation_list = ImageAugmentationList.get('<image_augmentation_list_id>')\n\nfor sample in image_augmentation_list.retrieve_samples():\n    # Display the image in popup widows\n    bio = io.BytesIO(sample.image.image_bytes)\n    img = PIL.Image.open(bio)\n    img.show()",
        "from datarobot.models.visualai import ImageAugmentationList\n\nblur_param = {\"name\": \"maximum_filter_size\", \"currentValue\": 10}\nblur = {\"name\": \"blur\", \"params\": [blur_param]}\nflip = {\"name\": \"horizontal_flip\", \"params\": []}\ntransforms_to_apply = ImageAugmentationList.create(name=\"blur and scale\", project_id=project.id,\n    feature_name='image', transformation_probability=0.5, number_of_new_images=5,\n    transformations=[blur, flip], initial_list=True)",
        "from datarobot.models.visualai import ImageAugmentationOptions\noptions = ImageAugmentationOptions.get(project.id)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/batch_predictions.html",
      "title": "Batch Predictions\uf0c1",
      "description": "The Batch Prediction API provides a way to score large datasets using flexible options\nfor intake and output on the Prediction Servers you have already deployed.",
      "content": "Batch Predictions\uf0c1\nThe Batch Prediction API provides a way to score large datasets using flexible options\nfor intake and output on the Prediction Servers you have already deployed.\nThe main features are:\nFlexible options for intake and output.\nStream local files and start scoring while still uploading - while simultaneously downloading the results.\nScore large datasets from and to S3.\nConnect to your database using JDBC with bidirectional streaming of scoring data and results.\nIntake and output options can be mixed and doesn\u2019t need to match. So scoring from a JDBC source to an S3 target is also an option.\nProtection against overloading your prediction servers with the option to control the concurrency level for scoring.\nPrediction Explanations can be included (with option to add thresholds).\nPassthrough Columns are supported to correlate scored data with source data.\nPrediction Warnings can be included in the output.\nTo interact with Batch Predictions, you should use the BatchPredictionJob class.\nMake batch predictions with a deployment\uf0c1\nDataRobot provides a utility function to make batch predictions using a deployment: Deployment.predict_batch.\nimport datarobot as dr\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n# To note: `source` can be a file path, a file or a pandas DataFrame\nprediction_results_as_dataframe = deployment.predict_batch(\nsource=\"./my_local_file.csv\",\n)\nScoring local CSV files\uf0c1\nWe provide a small utility function for scoring from/to local CSV files: BatchPredictionJob.score_to_file.\nThe first parameter can be either:\nPath to a CSV dataset\nFile-like object\nPandas DataFrame\nFor larger datasets, you should avoid using a DataFrame, as that will load\nthe entire dataset into memory. The other options don\u2019t.\nimport datarobot as dr\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ndr.BatchPredictionJob.score_to_file(\ndeployment_id,\n'./data_to_predict.csv',\n'./predicted.csv',\n)\nThe input file will be streamed to our API and scoring will start immediately.\nAs soon as results start coming in, we will initiate the download concurrently.\nThe entire call will block until the file has been scored.\nScoring from and to S3\uf0c1\nWe provide a small utility function for scoring from/to CSV files hosted on S3 BatchPredictionJob.score_s3.\nThis requires that the intake and output buckets share the same credentials (see Credentials\nand Credential.create_s3) or that their access policy is set to public:\nimport datarobot as dr\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ncred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\njob = dr.BatchPredictionJob.score_s3(\ndeployment=deployment_id,\nsource_url='s3://mybucket/data_to_predict.csv',\ndestination_url='s3://mybucket/predicted.csv',\ncredential=cred,\n)\nNote\nThe S3 output functionality has a limit of 100 GB.\nScoring from and to Azure Cloud Storage\uf0c1\nLike with S3, we provide the same support for Azure through the utility function BatchPredictionJob.score_azure.\nThis required that an Azure connection string has been added to the DataRobot credentials store.\n(see Credentials and Credential.create_azure)\nimport datarobot as dr\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ncred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\njob = dr.BatchPredictionJob.score_azure(\ndeployment=deployment_id,\nsource_url='https://mybucket.blob.core.windows.net/bucket/data_to_predict.csv',\ndestination_url='https://mybucket.blob.core.windows.net/results/predicted.csv',\ncredential=cred,\n)\nScoring from and to Google Cloud Platform\uf0c1\nLike with Azure, we provide the same support for GCP through the utility function BatchPredictionJob.score_gcp.\nThis required that an Azure connection string has been added to the DataRobot credentials store. (see Credentials and\nCredential.create_gcp)\nimport datarobot as dr\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ncred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\njob = dr.BatchPredictionJob.score_gcp(\ndeployment=deployment_id,\nsource_url='gs:/bucket/data_to_predict.csv',\ndestination_url='gs://results/predicted.csv',\ncredential=cred,\n)\nWiring a Batch Prediction Job manually\uf0c1\nIf you can\u2019t use any of the utilities above, you are also free to configure\nyour job manually. This requires configuring an intake and output option:\nimport datarobot as dr\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ndr.BatchPredictionJob.score(\ndeployment_id,\nintake_settings={\n'type': 's3',\n'url': 's3://public-bucket/data_to_predict.csv',\n'credential_id': '5a8ac9ab07a57a0001be501f',\n},\noutput_settings={\n'type': 'localFile',\n'path': './predicted.csv',\n},\n)\nCredentials may be created with Credentials API.\nSupported intake types\uf0c1\nThese are the supported intake types and descriptions of their configuration parameters:\nLocal file intake\uf0c1\nThis requires you to pass either a path to a CSV dataset, file-like object or a Pandas\nDataFrame as the file parameter:\nintake_settings={\n'type': 'localFile',\n'file': './data_to_predict.csv',\n}\nS3 CSV intake\uf0c1\nThis requires you to pass an S3 URL to the CSV file your scoring in the url parameter:\nintake_settings={\n'type': 's3',\n'url': 's3://public-bucket/data_to_predict.csv',\n}\nIf the bucket is not publicly accessible, you can supply AWS credentials using the three\nparameters:\naws_access_key_id\naws_secret_access_key\naws_session_token\nAnd save it to the Credential API. Here is an example:\nimport datarobot as dr\n# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\nintake_settings={\n'type': 's3',\n'url': 's3://private-bucket/data_to_predict.csv',\n'credential_id': cred.credential_id,\n}\nJDBC intake\uf0c1\nThis requires you to create a DataStore and\nCredential for your database:\n# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5010'\ndata_store = dr.DataStore.get(datastore_id)\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\nintake_settings = {\n'type': 'jdbc',\n'table': 'table_name',\n'schema': 'public', # optional, if supported by database\n'catalog': 'master', # optional, if supported by database\n'data_store_id': data_store.id,\n'credential_id': cred.credential_id,\n}\nBigQuery intake\uf0c1\nThis requires you to create a GCS Credential for your database:\n# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\nintake_settings = {\n'type': 'bigquery',\n'dataset': 'dataset_name',\n'table': 'table_or_view_name',\n'bucket': 'bucket_in_gcs',\n'credential_id': cred.credential_id,\n}\nAI Catalog intake\uf0c1\nThis requires you to create a Dataset and identify the dataset_id of that to use as input.\n# get to make sure it exists\ndataset_id = '5a8ac9ab07a57a0001be501f'\ndataset = dr.Dataset.get(dataset_id)\nintake_settings={\n'type': 'dataset',\n'dataset': dataset\n}\nOr, in case you want another version_id than the latest, supply your own.\n# get to make sure it exists\ndataset_id = '5a8ac9ab07a57a0001be501f'\ndataset = dr.Dataset.get(dataset_id)\nintake_settings={\n'type': 'dataset',\n'dataset': dataset,\n'dataset_version_id': 'another_version_id'\n}\nDatasphere intake\uf0c1\nThis requires you to create a DataStore and\nCredential for your database:\n# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5011'\ndata_store = dr.DataStore.get(datastore_id)\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\nintake_settings = {\n'type': 'datasphere',\n'table': 'table_name',\n'schema': 'DATASPHERE_SPACE_NAME',\n'data_store_id': data_store.id,\n'credential_id': cred.credential_id,\n}\nSupported output types\uf0c1\nThese are the supported output types and descriptions of their configuration parameters:\nLocal file output\uf0c1\nFor local file output you have two options. You can either pass a path parameter and\nhave the client block and download the scored data concurrently. This is the fastest way\nto get predictions as it will upload, score and download concurrently:\noutput_settings={\n'type': 'localFile',\n'path': './predicted.csv',\n}\nAnother option is to leave out the parameter and subsequently call BatchPredictionJob.download\nat your own convenience. The BatchPredictionJob.score call will then return as soon as the upload is complete.\nIf the job is not finished scoring, the call to BatchPredictionJob.download will start\nstreaming the data that has been scored so far and block until more data is available.\nYou can poll for job completion using BatchPredictionJob.get_status or use\nBatchPredictionJob.wait_for_completion to wait.\nimport datarobot as dr\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\njob = dr.BatchPredictionJob.score(\ndeployment_id,\nintake_settings={\n'type': 'localFile',\n'file': './data_to_predict.csv',\n},\noutput_settings={\n'type': 'localFile',\n},\n)\njob.wait_for_completion()\nwith open('./predicted.csv', 'wb') as f:\njob.download(f)\nS3 CSV output\uf0c1\nThis requires you to pass an S3 URL to the CSV file where the scored data should be saved\nto in the url parameter:\noutput_settings={\n'type': 's3',\n'url': 's3://public-bucket/predicted.csv',\n}\nMost likely, the bucket is not publicly accessible for writes, but you can supply AWS\ncredentials using the three parameters:\naws_access_key_id\naws_secret_access_key\naws_session_token\nAnd save it to the Credential API. Here is an example:\n# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\noutput_settings={\n'type': 's3',\n'url': 's3://private-bucket/predicted.csv',\n'credential_id': cred.credential_id,\n}\nJDBC output\uf0c1\nSame as for the input, this requires you to create a DataStore and\nCredential for your database, but for output_settings you also need to specify\nstatement_type, which should be one of datarobot.enums.AVAILABLE_STATEMENT_TYPES:\n# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5010'\ndata_store = dr.DataStore.get(datastore_id)\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\noutput_settings = {\n'type': 'jdbc',\n'table': 'table_name',\n'schema': 'public', # optional, if supported by database\n'catalog': 'master', # optional, if supported by database\n'statement_type': 'insert',\n'data_store_id': data_store.id,\n'credential_id': cred.credential_id,\n}\nBigQuery output\uf0c1\nSame as for the input, this requires you to create a GCS Credential\nto access BigQuery:\n# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\noutput_settings = {\n'type': 'bigquery',\n'dataset': 'dataset_name',\n'table': 'table_name',\n'bucket': 'bucket_in_gcs',\n'credential_id': cred.credential_id,\n}\nDatasphere output\uf0c1\nSame as for the input, this requires you to create a DataStore and\nCredential for your database:\n# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5010'\ndata_store = dr.DataStore.get(datastore_id)\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\noutput_settings = {\n'type': 'datasphere',\n'table': 'table_name',\n'schema': 'DATASPHERE_SPACE_NAME',\n'data_store_id': data_store.id,\n'credential_id': cred.credential_id,\n}\nCopying a previously submitted job\uf0c1\nWe provide a small utility function for submitting a job using parameters from a job previously submitted:\nBatchPredictionJob.score_from_existing.\nThe first parameter is the job id of another job.\nimport datarobot as dr\npreviously_submitted_job_id = '5dc5b1015e6e762a6241f9aa'\ndr.BatchPredictionJob.score_from_existing(\npreviously_submitted_job_id,\n)\nScoring an in-memory Pandas DataFrame\uf0c1\nWhen working with DataFrames, we provide a method for scoring the data without first writing it to a\nCSV file and subsequently reading the data back from a CSV file.\nThis will also take care of joining the computed predictions into the existing DataFrame.\nUse the method BatchPredictionJob.score_pandas.\nThe first parameter is the deployment ID and then the DataFrame to score.\nimport datarobot as dr\nimport pandas as pd\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ndf = pd.read_csv('testdata/titanic_predict.csv')\njob, df = dr.BatchPredictionJob.score_pandas(deployment_id, df)\nThe method returns a copy of the job status and the updated DataFrame with the predictions added.\nSo your DataFrame will now contain the following extra columns:\nSurvived_1_PREDICTION\nSurvived_0_PREDICTION\nSurvived_PREDICTION\nTHRESHOLD\nPOSITIVE_CLASS\nprediction_status\nprint(df)\nPassengerId  Pclass                                          Name  ... Survived_PREDICTION  THRESHOLD  POSITIVE_CLASS\n0            892       3                              Kelly, Mr. James  ...                   0        0.5               1\n1            893       3              Wilkes, Mrs. James (Ellen Needs)  ...                   1        0.5               1\n2            894       2                     Myles, Mr. Thomas Francis  ...                   0        0.5               1\n3            895       3                              Wirz, Mr. Albert  ...                   0        0.5               1\n4            896       3  Hirvonen, Mrs. Alexander (Helga E Lindqvist)  ...                   1        0.5               1\n..           ...     ...                                           ...  ...                 ...        ...             ...\n413         1305       3                            Spector, Mr. Woolf  ...                   0        0.5               1\n414         1306       1                  Oliva y Ocana, Dona. Fermina  ...                   0        0.5               1\n415         1307       3                  Saether, Mr. Simon Sivertsen  ...                   0        0.5               1\n416         1308       3                           Ware, Mr. Frederick  ...                   0        0.5               1\n417         1309       3                      Peter, Master. Michael J  ...                   1        0.5               1\n[418 rows x 16 columns]\nIf you don\u2019t want all of them or if you\u2019re not happy with the names of the added columns, they\ncan be modified using column remapping:\nimport datarobot as dr\nimport pandas as pd\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\ndf = pd.read_csv('testdata/titanic_predict.csv')\njob, df = dr.BatchPredictionJob.score_pandas(\ndeployment_id,\ndf,\ncolumn_names_remapping={\n'Survived_1_PREDICTION': None,       # discard column\n'Survived_0_PREDICTION': None,       # discard column\n'Survived_PREDICTION': 'predicted',  # rename column\n'THRESHOLD': None,                   # discard column\n'POSITIVE_CLASS': None,              # discard column\n},\n)\nAny column mapped to None will be discarded. Any column mapped to a string will be renamed.\nAny column not mentioned will be kept in the output untouched.\nSo your DataFrame will now contain the following extra columns:\npredicted\nprediction_status\nRefer to the documentation for BatchPredictionJob.score\nfor the full range of available options.\nBatch Prediction Job Definitions\uf0c1\nTo submit a working Batch Prediction job, you must supply a variety of elements to the datarobot.models.BatchPredictionJob.score()\nrequest payload depending on what type of prediction is required. Additionally, you must consider the type of intake\nand output adapters used for a given job.\nEvery time a new Batch Prediction is created, the same amount of information must be stored somewhere outside of\nDataRobot and re-submitted every time.\nFor example, a request could look like:\nimport datarobot as dr\ndeployment_id = \"5dc5b1015e6e762a6241f9aa\"\njob = dr.BatchPredictionJob.score(\ndeployment_id,\nintake_settings={\n\"type\": \"s3\",\n\"url\": \"s3://bucket/container/file.csv\",\n\"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n},\noutput_settings={\n\"type\": \"s3\",\n\"url\": \"s3://bucket/container/output.csv\",\n\"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n},\n)\njob.wait_for_completion()\nwith open(\"./predicted.csv\", \"wb\") as f:\njob.download(f)\nJob Definitions\uf0c1\nIf your use case requires the same, or close to the same, type of prediction to be done multiple times, you can choose to\ncreate a Job Definition of the Batch Prediction job and store this inside DataRobot for future use.\nThe method for creating job definitions is identical to the existing datarobot.models.BatchPredictionJob.score() method,\nexcept for the addition of a enabled, name and schedule parameter: datarobot.models.BatchPredictionJobDefinition.create()\n>>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 4,\n...    \"deployment_id\": \"5dc5b1015e6e762a6241f9aa\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\",\n...        \"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\",\n...        \"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n...    },\n...}\n>>> definition = BatchPredictionJobDefinition.create(\n...    enabled=False,\n...    batch_prediction_job=job_spec,\n...    name=\"some_definition_name\",\n...    schedule=None\n... )\n>>> definition\nBatchPredictionJobDefinition(foobar)\nNote\nThe name parameter must be unique across your organization. If you attempt to create multiple definitions\nwith the same name, the request will fail. If you wish to free up a name, you must first datarobot.models.BatchPredictionJobDefinition.delete()\nthe existing definition before creating this one. Alternatively you can just datarobot.models.BatchPredictionJobDefinition.update()\nthe existing definition with a new name.\nExecuting a job definition\uf0c1\nManual job execution\uf0c1\nTo submit a stored job definition for scoring, you can either do so on a scheduled basis, described\nbelow, or manually submit the definition ID using datarobot.models.BatchPredictionJobDefinition.run_once(),\nas such:\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get(\"5dc5b1015e6e762a6241f9aa\")\n>>> job = definition.run_once()\n>>> job.wait_for_completion()\nScheduled job execution\uf0c1\nA Scheduled Batch Prediction job works just like a regular Batch Prediction job, except DataRobot handles the execution\nof the job.\nIn order to schedule the execution of a Batch Prediction job, a definition must first be created, using\ndatarobot.models.BatchPredictionJobDefinition.create(), or updated, using\ndatarobot.models.BatchPredictionJobDefinition.update(), where enabled is set to True and a schedule\npayload is provided.\nAlternatively, you can use a short-hand version with datarobot.models.BatchPredictionJobDefinition.run_on_schedule()\nas such:\n>>> import datarobot as dr\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        16\n...    ],\n...    \"minute\": [\n...        0\n...    ],\n...    \"day_of_month\": [\n...        1\n...    ]\n...}\n>>> definition = dr.BatchPredictionJob.get(\"5dc5b1015e6e762a6241f9aa\")\n>>> job = definition.run_on_schedule(schedule)\nIf the created job was not enabled previously, this method will also enable it.\nThe Schedule payload\uf0c1\nThe schedule payload defines at what intervals the job should run, which can be combined in various ways to construct\ncomplex scheduling terms if needed. In all of the elements in the objects, you can supply either an asterisk [\"*\"]\ndenoting \u201cevery\u201d time denomination or an array of integers (e.g. [1, 2, 3]) to define a specific interval.\nThe schedule payload elements\uf0c1\nKey\nPossible values\nExample\nDescription\nminute\n[\"*\"] or [0 ... 59]\n[15, 30, 45]\nThe job will run at these minute values for every hour of the day.\nhour\n[\"*\"] or [0 ... 23]\n[12,23]\nThe hour(s) of the day that the job will run.\nmonth\n[\"*\"] or [1 ... 12]\n[\"jan\"]\nStrings, either 3-letter abbreviations or the full name of the month, can be used interchangeably (e.g., \u201cjan\u201d or \u201coctober\u201d).\nMonths that are not compatible with day_of_month are ignored, for example {\"day_of_month\": [31], \"month\":[\"feb\"]}.\nday_of_week\n[\"*\"] or [0 ... 6] where (Sunday=0)\n[\"sun\"]\nThe day(s) of the week that the job will run. Strings, either 3-letter abbreviations or the full name of the day, can be used interchangeably (e.g., \u201csunday\u201d, \u201cSunday\u201d, \u201csun\u201d, or \u201cSun\u201d, all map to [0]).\nNOTE: This field is additive with day_of_month, meaning the job will run both on the date specified by day_of_month and the day defined in this field.\nday_of_month\n[\"*\"] or [1 ... 31]\n[1, 25]\nThe date(s) of the month that the job will run. Allowed values are either [1 ... 31] or [\"*\"] for all days of the month.\nNOTE: This field is additive with day_of_week, meaning the job will run both on the date(s) defined in this field and the day specified\nby day_of_week (for example, dates 1st, 2nd, 3rd, plus every Tuesday). If day_of_month is set to [\"*\"] and day_of_week is defined,\nthe scheduler will trigger on every day of  the month that matches day_of_week (for example, Tuesday the 2nd, 9th, 16th, 23rd, 30th).\nInvalid dates such as February 31st are ignored.\nDisabling a scheduled job\uf0c1\nJob definitions are only be executed by the scheduler if enabled is set to True. If you have a job definition\nthat was previously running as a scheduled job, but should now be stopped, simply\ndatarobot.models.BatchPredictionJobDefinition.delete() to remove it completely, or datarobot.models.BatchPredictionJobDefinition.update()\nit with enabled=False if you want to keep the definition, but stop the scheduled job from executing at intervals.\nIf a job is currently running, this will finish execution regardless.\n>>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get(\"5dc5b1015e6e762a6241f9aa\")\n>>> definition.delete()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/deployment-management.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/admin/credentials.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/credentials.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/database_connectivity.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/data/dataset.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\ndeployment = dr.Deployment.get(deployment_id='5c939e08962d741e34f609f0')\n# To note: `source` can be a file path, a file or a pandas DataFrame\nprediction_results_as_dataframe = deployment.predict_batch(\n    source=\"./my_local_file.csv\",\n)",
        "import datarobot as dr\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ndr.BatchPredictionJob.score_to_file(\n    deployment_id,\n    './data_to_predict.csv',\n    './predicted.csv',\n)",
        "import datarobot as dr\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ncred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n\njob = dr.BatchPredictionJob.score_s3(\n    deployment=deployment_id,\n    source_url='s3://mybucket/data_to_predict.csv',\n    destination_url='s3://mybucket/predicted.csv',\n    credential=cred,\n)",
        "import datarobot as dr\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ncred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n\njob = dr.BatchPredictionJob.score_azure(\n    deployment=deployment_id,\n    source_url='https://mybucket.blob.core.windows.net/bucket/data_to_predict.csv',\n    destination_url='https://mybucket.blob.core.windows.net/results/predicted.csv',\n    credential=cred,\n)",
        "import datarobot as dr\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ncred = dr.Credential.get('5a8ac9ab07a57a0001be501f')\n\njob = dr.BatchPredictionJob.score_gcp(\n    deployment=deployment_id,\n    source_url='gs:/bucket/data_to_predict.csv',\n    destination_url='gs://results/predicted.csv',\n    credential=cred,\n)",
        "import datarobot as dr\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ndr.BatchPredictionJob.score(\n    deployment_id,\n    intake_settings={\n        'type': 's3',\n        'url': 's3://public-bucket/data_to_predict.csv',\n        'credential_id': '5a8ac9ab07a57a0001be501f',\n    },\n    output_settings={\n        'type': 'localFile',\n        'path': './predicted.csv',\n    },\n)",
        "import datarobot as dr\n\n# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\nintake_settings={\n    'type': 's3',\n    'url': 's3://private-bucket/data_to_predict.csv',\n    'credential_id': cred.credential_id,\n}",
        "# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5010'\ndata_store = dr.DataStore.get(datastore_id)\n\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\nintake_settings = {\n    'type': 'jdbc',\n    'table': 'table_name',\n    'schema': 'public', # optional, if supported by database\n    'catalog': 'master', # optional, if supported by database\n    'data_store_id': data_store.id,\n    'credential_id': cred.credential_id,\n}",
        "# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\nintake_settings = {\n    'type': 'bigquery',\n    'dataset': 'dataset_name',\n    'table': 'table_or_view_name',\n    'bucket': 'bucket_in_gcs',\n    'credential_id': cred.credential_id,\n}",
        "# get to make sure it exists\ndataset_id = '5a8ac9ab07a57a0001be501f'\ndataset = dr.Dataset.get(dataset_id)\n\nintake_settings={\n    'type': 'dataset',\n    'dataset': dataset\n}",
        "# get to make sure it exists\ndataset_id = '5a8ac9ab07a57a0001be501f'\ndataset = dr.Dataset.get(dataset_id)\n\nintake_settings={\n    'type': 'dataset',\n    'dataset': dataset,\n    'dataset_version_id': 'another_version_id'\n}",
        "# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5011'\ndata_store = dr.DataStore.get(datastore_id)\n\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\nintake_settings = {\n    'type': 'datasphere',\n    'table': 'table_name',\n    'schema': 'DATASPHERE_SPACE_NAME',\n    'data_store_id': data_store.id,\n    'credential_id': cred.credential_id,\n}",
        "import datarobot as dr\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\njob = dr.BatchPredictionJob.score(\n    deployment_id,\n    intake_settings={\n        'type': 'localFile',\n        'file': './data_to_predict.csv',\n    },\n    output_settings={\n        'type': 'localFile',\n    },\n)\n\njob.wait_for_completion()\n\nwith open('./predicted.csv', 'wb') as f:\n    job.download(f)",
        "# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\noutput_settings={\n    'type': 's3',\n    'url': 's3://private-bucket/predicted.csv',\n    'credential_id': cred.credential_id,\n}",
        "datarobot.enums.AVAILABLE_STATEMENT_TYPES",
        "# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5010'\ndata_store = dr.DataStore.get(datastore_id)\n\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\noutput_settings = {\n    'type': 'jdbc',\n    'table': 'table_name',\n    'schema': 'public', # optional, if supported by database\n    'catalog': 'master', # optional, if supported by database\n    'statement_type': 'insert',\n    'data_store_id': data_store.id,\n    'credential_id': cred.credential_id,\n}",
        "# get to make sure it exists\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\noutput_settings = {\n    'type': 'bigquery',\n    'dataset': 'dataset_name',\n    'table': 'table_name',\n    'bucket': 'bucket_in_gcs',\n    'credential_id': cred.credential_id,\n}",
        "# get to make sure it exists\ndatastore_id = '5a8ac9ab07a57a0001be5010'\ndata_store = dr.DataStore.get(datastore_id)\n\ncredential_id = '5a8ac9ab07a57a0001be501f'\ncred = dr.Credential.get(credential_id)\n\noutput_settings = {\n    'type': 'datasphere',\n    'table': 'table_name',\n    'schema': 'DATASPHERE_SPACE_NAME',\n    'data_store_id': data_store.id,\n    'credential_id': cred.credential_id,\n}",
        "import datarobot as dr\n\npreviously_submitted_job_id = '5dc5b1015e6e762a6241f9aa'\n\ndr.BatchPredictionJob.score_from_existing(\n    previously_submitted_job_id,\n)",
        "import datarobot as dr\nimport pandas as pd\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ndf = pd.read_csv('testdata/titanic_predict.csv')\n\njob, df = dr.BatchPredictionJob.score_pandas(deployment_id, df)",
        "print(df)\n     PassengerId  Pclass                                          Name  ... Survived_PREDICTION  THRESHOLD  POSITIVE_CLASS\n0            892       3                              Kelly, Mr. James  ...                   0        0.5               1\n1            893       3              Wilkes, Mrs. James (Ellen Needs)  ...                   1        0.5               1\n2            894       2                     Myles, Mr. Thomas Francis  ...                   0        0.5               1\n3            895       3                              Wirz, Mr. Albert  ...                   0        0.5               1\n4            896       3  Hirvonen, Mrs. Alexander (Helga E Lindqvist)  ...                   1        0.5               1\n..           ...     ...                                           ...  ...                 ...        ...             ...\n413         1305       3                            Spector, Mr. Woolf  ...                   0        0.5               1\n414         1306       1                  Oliva y Ocana, Dona. Fermina  ...                   0        0.5               1\n415         1307       3                  Saether, Mr. Simon Sivertsen  ...                   0        0.5               1\n416         1308       3                           Ware, Mr. Frederick  ...                   0        0.5               1\n417         1309       3                      Peter, Master. Michael J  ...                   1        0.5               1\n\n[418 rows x 16 columns]",
        "import datarobot as dr\nimport pandas as pd\n\ndeployment_id = '5dc5b1015e6e762a6241f9aa'\n\ndf = pd.read_csv('testdata/titanic_predict.csv')\n\njob, df = dr.BatchPredictionJob.score_pandas(\n    deployment_id,\n    df,\n    column_names_remapping={\n        'Survived_1_PREDICTION': None,       # discard column\n        'Survived_0_PREDICTION': None,       # discard column\n        'Survived_PREDICTION': 'predicted',  # rename column\n        'THRESHOLD': None,                   # discard column\n        'POSITIVE_CLASS': None,              # discard column\n    },\n)",
        "datarobot.models.BatchPredictionJob.score()",
        "import datarobot as dr\n\ndeployment_id = \"5dc5b1015e6e762a6241f9aa\"\n\njob = dr.BatchPredictionJob.score(\n    deployment_id,\n    intake_settings={\n        \"type\": \"s3\",\n        \"url\": \"s3://bucket/container/file.csv\",\n        \"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n    },\n    output_settings={\n        \"type\": \"s3\",\n        \"url\": \"s3://bucket/container/output.csv\",\n        \"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n    },\n)\n\njob.wait_for_completion()\n\nwith open(\"./predicted.csv\", \"wb\") as f:\n    job.download(f)",
        "datarobot.models.BatchPredictionJob.score()",
        "datarobot.models.BatchPredictionJobDefinition.create()",
        ">>> import datarobot as dr\n>>> job_spec = {\n...    \"num_concurrent\": 4,\n...    \"deployment_id\": \"5dc5b1015e6e762a6241f9aa\",\n...    \"intake_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\",\n...        \"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n...    },\n...    \"output_settings\": {\n...        \"url\": \"s3://foobar/123\",\n...        \"type\": \"s3\",\n...        \"format\": \"csv\",\n...        \"credential_id\": \"5dc5b1015e6e762a6241f9bb\"\n...    },\n...}\n>>> definition = BatchPredictionJobDefinition.create(\n...    enabled=False,\n...    batch_prediction_job=job_spec,\n...    name=\"some_definition_name\",\n...    schedule=None\n... )\n>>> definition\nBatchPredictionJobDefinition(foobar)",
        "datarobot.models.BatchPredictionJobDefinition.delete()",
        "datarobot.models.BatchPredictionJobDefinition.update()",
        "datarobot.models.BatchPredictionJobDefinition.run_once()",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get(\"5dc5b1015e6e762a6241f9aa\")\n>>> job = definition.run_once()\n>>> job.wait_for_completion()",
        "datarobot.models.BatchPredictionJobDefinition.create()",
        "datarobot.models.BatchPredictionJobDefinition.update()",
        "datarobot.models.BatchPredictionJobDefinition.run_on_schedule()",
        ">>> import datarobot as dr\n>>> schedule = {\n...    \"day_of_week\": [\n...        1\n...    ],\n...    \"month\": [\n...        \"*\"\n...    ],\n...    \"hour\": [\n...        16\n...    ],\n...    \"minute\": [\n...        0\n...    ],\n...    \"day_of_month\": [\n...        1\n...    ]\n...}\n>>> definition = dr.BatchPredictionJob.get(\"5dc5b1015e6e762a6241f9aa\")\n>>> job = definition.run_on_schedule(schedule)",
        "datarobot.models.BatchPredictionJobDefinition.delete()",
        "datarobot.models.BatchPredictionJobDefinition.update()",
        ">>> import datarobot as dr\n>>> definition = dr.BatchPredictionJobDefinition.get(\"5dc5b1015e6e762a6241f9aa\")\n>>> definition.delete()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/index.html",
      "title": "Use Cases\uf0c1",
      "description": "The Use Cases section provides details on how to utilize and manage DataRobot Use Cases in your Python code.",
      "content": "Use Cases\uf0c1\nThe Use Cases section provides details on how to utilize and manage DataRobot Use Cases in your Python code.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "api_reference",
      "code_examples": [],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/predict_job.html",
      "title": "Predictions\uf0c1",
      "description": "Predictions generation is an asynchronous process. This means that when starting\npredictions with Model.request_predictions() you will receive back a PredictJob for tracking\nthe process responsible for fulfilling your request.",
      "content": "Predictions\uf0c1\nPredictions generation is an asynchronous process. This means that when starting\npredictions with Model.request_predictions() you will receive back a PredictJob for tracking\nthe process responsible for fulfilling your request.\nWith this object you can get info about the predictions generation process before it\nhas finished and be rerouted to the predictions themselves when the\nprocess is finished. For this you should use the PredictJob class.\nStarting predictions generation\uf0c1\nBefore actually requesting predictions, you should upload the dataset you wish to predict via\nProject.upload_dataset.  Previously uploaded datasets can be seen under Project.get_datasets.\nWhen uploading the dataset you can provide the path to a local file, a file object, raw file content,\na pandas.DataFrame object, or the url to a publicly available dataset.\nTo start predicting on new data using a finished model use Model.request_predictions().\nIt will create a new predictions generation process and return a PredictJob object tracking this process.\nWith it, you can monitor an existing PredictJob and retrieve generated predictions when the corresponding\nPredictJob is finished.\nimport datarobot as dr\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nproject = dr.Project.get(project_id)\nmodel = dr.Model.get(\nproject=project_id,\nmodel_id=model_id,\n)\n# As of v3.0, in addition to passing a ``dataset_id``, you can pass in a ``dataset``, ``file``, ``file_path`` or\n# ``dataframe`` to `Model.request_predictions`.\npredict_job = model.request_predictions(file_path='./data_to_predict.csv')\n# Alternative version uploading the dataset from a local path and passing it by its id\ndataset_from_path = project.upload_dataset('./data_to_predict.csv')\npredict_job = model.request_predictions(dataset_id=dataset_from_path.id)\n# Alternative version: upload the dataset as a file object and pass it by using its dataset id\nwith open('./data_to_predict.csv') as data_to_predict:\ndataset_from_file = project.upload_dataset(data_to_predict)\npredict_job = model.request_predictions(dataset_id=dataset_from_file.id)  # OR predict_job = model.request_predictions(dataset_id=dataset_from_file.id)\nListing Predictions\uf0c1\nYou can use the Predictions.list() method to return a list of predictions generated on a project.\nimport datarobot as dr\npredictions = dr.Predictions.list('58591727100d2b57196701b3')\nprint(predictions)\n>>>[Predictions(prediction_id='5b6b163eca36c0108fc5d411',\nproject_id='5b61bd68ca36c04aed8aab7f',\nmodel_id='5b61bd7aca36c05744846630',\ndataset_id='5b6b1632ca36c03b5875e6a0'),\nPredictions(prediction_id='5b6b2315ca36c0108fc5d41b',\nproject_id='5b61bd68ca36c04aed8aab7f',\nmodel_id='5b61bd7aca36c0574484662e',\ndataset_id='5b6b1632ca36c03b5875e6a0'),\nPredictions(prediction_id='5b6b23b7ca36c0108fc5d422',\nproject_id='5b61bd68ca36c04aed8aab7f',\nmodel_id='5b61bd7aca36c0574484662e',\ndataset_id='55b6b1632ca36c03b5875e6a0')\n]\nYou can pass following parameters to filter the result:\nmodel_id \u2013 str, used to filter returned predictions by model_id.\ndataset_id \u2013 str, used to filter returned predictions by dataset_id.\nGet an existing PredictJob\uf0c1\nTo retrieve an existing PredictJob use the PredictJob.get method. This will give you\na PredictJob matching the latest status of the job if it has not completed.\nIf predictions have finished building, PredictJob.get will raise a PendingJobFinished\nexception.\nimport time\nimport datarobot as dr\npredict_job = dr.PredictJob.get(\nproject_id=project_id,\npredict_job_id=predict_job_id,\n)\npredict_job.status\n>>> 'queue'\n# wait for generation of predictions (in a very inefficient way)\ntime.sleep(10 * 60)\npredict_job = dr.PredictJob.get(\nproject_id=project_id,\npredict_job_id=predict_job_id,\n)\n>>> dr.errors.PendingJobFinished\n# now the predictions are finished\npredictions = dr.PredictJob.get_predictions(\nproject_id=project.id,\npredict_job_id=predict_job_id,\n)\nGet generated predictions\uf0c1\nAfter predictions are generated, you can use PredictJob.get_predictions\nto get newly generated predictions.\nIf predictions have not yet been finished, it will raise a JobNotFinished exception.\nimport datarobot as dr\npredictions = dr.PredictJob.get_predictions(\nproject_id=project.id,\npredict_job_id=predict_job_id,\n)\nWait for and Retrieve results\uf0c1\nIf you just want to get generated predictions from a PredictJob, you\ncan use the PredictJob.get_result_when_complete function.\nIt will poll the status of the predictions generation process until it has finished, and\nthen will return predictions.\ndataset = project.get_datasets()[0]\npredict_job = model.request_predictions(dataset.id)\npredictions = predict_job.get_result_when_complete()\nGet previously generated predictions\uf0c1\nIf you don\u2019t have a Model.predict_job on hand, there are two more ways to retrieve predictions from the\nPredictions interface:\nGet all prediction rows as a pandas.DataFrame object:\nimport datarobot as dr\npreds = dr.Predictions.get(\"5b61bd68ca36c04aed8aab7f\", prediction_id=\"5b6b163eca36c0108fc5d411\")\ndf = preds.get_all_as_dataframe()\ndf_with_serializer = preds.get_all_as_dataframe(serializer='csv')\nDownload all prediction rows to a file as a CSV document:\nimport datarobot as dr\npreds = dr.Predictions.get(\"5b61bd68ca36c04aed8aab7f\", prediction_id=\"5b6b163eca36c0108fc5d411\")\npreds.download_to_csv('predictions.csv')\npreds.download_to_csv('predictions_with_serializer.csv', serializer='csv')\nTraining predictions\uf0c1\nThe training predictions interface allows computing and retrieving out-of-sample predictions for a model\nusing the original project dataset. The predictions can be computed for all the rows, or restricted to validation\nor holdout data. As the predictions generated will be out-of-sample, they can be expected to have different\nresults than if the project dataset were re-uploaded as a prediction dataset.\nQuick reference\uf0c1\nTraining predictions generation is an asynchronous process. This means that when starting\npredictions with datarobot.models.Model.request_training_predictions() you will receive back a\ndatarobot.models.TrainingPredictionsJob for tracking the process responsible for fulfilling your request.\nActual predictions may be obtained with the help of a\ndatarobot.models.training_predictions.TrainingPredictions object returned as the result of\nthe training predictions job.\nThere are three ways to retrieve them:\nIterate prediction rows one by one as named tuples:\nimport datarobot as dr\n# Calculate new training predictions on all dataset\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\ntraining_predictions = training_predictions_job.get_result_when_complete()\n# Fetch rows from API and print them\nfor prediction in training_predictions.iterate_rows(batch_size=250):\nprint(prediction.row_id, prediction.prediction)\nGet all prediction rows as a pandas.DataFrame object:\nimport datarobot from dr\n# Calculate new training predictions on holdout partition of dataset\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.HOLDOUT)\ntraining_predictions = training_predictions_job.get_result_when_complete()\n# Fetch training predictions as data frame\ndataframe = training_predictions.get_all_as_dataframe()\nDownload all prediction rows to a file as a CSV document:\nimport datarobot from dr\n# Calculate new training predictions on all dataset\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\ntraining_predictions = training_predictions_job.get_result_when_complete()\n# Fetch training predictions and save them to file\ntraining_predictions.download_to_csv('my-training-predictions.csv')",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/predictions/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/datarobot-models.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/batch-predictions.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/jobs.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/training_predictions.html"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "Model.request_predictions()",
        "Project.upload_dataset",
        "Model.request_predictions()",
        "import datarobot as dr\n\nproject_id = '5506fcd38bd88f5953219da0'\nmodel_id = '5506fcd98bd88f1641a720a3'\nproject = dr.Project.get(project_id)\nmodel = dr.Model.get(\n    project=project_id,\n    model_id=model_id,\n)\n\n# As of v3.0, in addition to passing a ``dataset_id``, you can pass in a ``dataset``, ``file``, ``file_path`` or\n# ``dataframe`` to `Model.request_predictions`.\n\npredict_job = model.request_predictions(file_path='./data_to_predict.csv')\n\n# Alternative version uploading the dataset from a local path and passing it by its id\ndataset_from_path = project.upload_dataset('./data_to_predict.csv')\npredict_job = model.request_predictions(dataset_id=dataset_from_path.id)\n\n# Alternative version: upload the dataset as a file object and pass it by using its dataset id\nwith open('./data_to_predict.csv') as data_to_predict:\n    dataset_from_file = project.upload_dataset(data_to_predict)\npredict_job = model.request_predictions(dataset_id=dataset_from_file.id)  # OR predict_job = model.request_predictions(dataset_id=dataset_from_file.id)",
        "import datarobot as dr\npredictions = dr.Predictions.list('58591727100d2b57196701b3')\n\nprint(predictions)\n>>>[Predictions(prediction_id='5b6b163eca36c0108fc5d411',\n                project_id='5b61bd68ca36c04aed8aab7f',\n                model_id='5b61bd7aca36c05744846630',\n                dataset_id='5b6b1632ca36c03b5875e6a0'),\n    Predictions(prediction_id='5b6b2315ca36c0108fc5d41b',\n                project_id='5b61bd68ca36c04aed8aab7f',\n                model_id='5b61bd7aca36c0574484662e',\n                dataset_id='5b6b1632ca36c03b5875e6a0'),\n    Predictions(prediction_id='5b6b23b7ca36c0108fc5d422',\n                project_id='5b61bd68ca36c04aed8aab7f',\n                model_id='5b61bd7aca36c0574484662e',\n                dataset_id='55b6b1632ca36c03b5875e6a0')\n    ]",
        "import time\n\nimport datarobot as dr\n\npredict_job = dr.PredictJob.get(\n    project_id=project_id,\n    predict_job_id=predict_job_id,\n)\npredict_job.status\n>>> 'queue'\n\n# wait for generation of predictions (in a very inefficient way)\ntime.sleep(10 * 60)\npredict_job = dr.PredictJob.get(\n    project_id=project_id,\n    predict_job_id=predict_job_id,\n)\n>>> dr.errors.PendingJobFinished\n\n# now the predictions are finished\npredictions = dr.PredictJob.get_predictions(\n    project_id=project.id,\n    predict_job_id=predict_job_id,\n)",
        "import datarobot as dr\n\npredictions = dr.PredictJob.get_predictions(\n    project_id=project.id,\n    predict_job_id=predict_job_id,\n)",
        "dataset = project.get_datasets()[0]\npredict_job = model.request_predictions(dataset.id)\npredictions = predict_job.get_result_when_complete()",
        "import datarobot as dr\n\npreds = dr.Predictions.get(\"5b61bd68ca36c04aed8aab7f\", prediction_id=\"5b6b163eca36c0108fc5d411\")\ndf = preds.get_all_as_dataframe()\ndf_with_serializer = preds.get_all_as_dataframe(serializer='csv')",
        "import datarobot as dr\n\npreds = dr.Predictions.get(\"5b61bd68ca36c04aed8aab7f\", prediction_id=\"5b6b163eca36c0108fc5d411\")\npreds.download_to_csv('predictions.csv')\n\npreds.download_to_csv('predictions_with_serializer.csv', serializer='csv')",
        "datarobot.models.Model.request_training_predictions()",
        "datarobot.models.TrainingPredictionsJob",
        "datarobot.models.training_predictions.TrainingPredictions",
        "import datarobot as dr\n\n# Calculate new training predictions on all dataset\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\ntraining_predictions = training_predictions_job.get_result_when_complete()\n\n# Fetch rows from API and print them\nfor prediction in training_predictions.iterate_rows(batch_size=250):\n    print(prediction.row_id, prediction.prediction)",
        "import datarobot from dr\n\n# Calculate new training predictions on holdout partition of dataset\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.HOLDOUT)\ntraining_predictions = training_predictions_job.get_result_when_complete()\n\n# Fetch training predictions as data frame\ndataframe = training_predictions.get_all_as_dataframe()",
        "import datarobot from dr\n\n# Calculate new training predictions on all dataset\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\ntraining_predictions = training_predictions_job.get_result_when_complete()\n\n# Fetch training predictions and save them to file\ntraining_predictions.download_to_csv('my-training-predictions.csv')"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/use_cases.html",
      "title": "Use Cases\uf0c1",
      "description": "Use Cases are folder-like containers in DataRobot Workbench that allow you to group all assets related to solving a specific business problem inside of a single, manageable entity. These assets include datasets, models, experiments, No-Code AI Apps, and notebooks. You can share entire Use Cases or the individual assets they contain.",
      "content": "Use Cases\uf0c1\nUse Cases are folder-like containers in DataRobot Workbench that allow you to group all assets related to solving a specific business problem inside of a single, manageable entity. These assets include datasets, models, experiments, No-Code AI Apps, and notebooks. You can share entire Use Cases or the individual assets they contain.\nThe primary benefit of a Use Case is that it enables experiment-based, iterative workflows. By housing all key insights in a single location, data scientists have improved navigation of assets and a cleaner interface for experiment creation and model training, review, and evaluation.\nSpecifically, Use Cases allow you to:\nOrganize your work \u2014 group all related datasets, experiments, notebooks, etc. by the problem they solve.\nFind assets easily. Use Cases eliminate the need to search through hundreds of unrelated projects or scrape emails for hyperlinks to specific assets.\nShare collections of assets. You can share entire Use Cases, containing all the assets your team needs to participate.\nManage access. Add or remove members to a Use Case to control their access.\nMonitor changes. Receive notifications when a team member adds, removes, or modifies any asset in a Use Case.\nCurrently, Use Cases in the Python client support interactions with binary classification and regression projects, applications, and datasets. Development is ongoing, so see the release notes for a full list of supported capabilities.\nFor a more in-depth look at Use Cases and the DataRobot Workbench, refer to the Workbench documentation.\nAdd to a Use Case\uf0c1\nCurrently, only project, dataset, and application instances can be added to a Use Case via the Python client.\nThe process of adding a dataset is shown in the example below:\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\nrisk_use_case = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nnew_dataset = dr.Dataset.create_from_file(\nfile_path=\"/foo/bar/risk_data.csv\",\n)\nrisk_use_case.add(entity=new_dataset)\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]\nYou can add an application to a Use Case in a similar way. The primary difference is that you cannot create applications with the Python client. Instead, retrieve an application using its ID or pull it from a retrieved list of applications and then add it to a Use Case:\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\nrisk_use_case = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nexisting_application = dr.Application.list()[0]\nrisk_use_case.add(entity=existing_application)\nrisk_use_case.list_applications()\n>>> [Application(name='Financial Risk Detection')]\nAlternatively, the UseCaseReferenceEntity returned from UseCase.add can be used to share an entity between Use Cases:\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\nrisk_use_case_1 = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nrisk_use_case_2 = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment 2\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nnew_dataset = dr.Dataset.create_from_file(\nfile_path=\"/foo/bar/risk_data.csv\",\n)\ndataset_entity = risk_use_case_1.add(entity=new_dataset)\nrisk_use_case_2.add(entity=dataset_entity)\nrisk_use_case_2.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]\nTo add a project to a Use Case, it must meet the following conditions:\nIt must be binary classification or regression project\nThe associated dataset must be linked to the same Use Case\nModeling must be in progress (via UI, the analyze_and_model method, or any other methods that initiate modeling)\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\nrisk_use_case = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nnew_dataset = dr.Dataset.create_from_file(\nfile_path=\"/foo/bar/risk_data.csv\",\nuse_case=risk_use_case\n)\nrisk_use_case.add(entity=new_dataset)\nnew_project = dr.Project.create_from_dataset(\ndataset_id=new_dataset.dataset_id,\nproject_name=\"Risk Assessment v1\",\nuse_case=risk_use_case\n)\nnew_project.analyze_and_model(target=\"credit_risk\")\nrisk_use_case.add(entity=new_project)\nrisk_use_case.list_projects()\n>>> [Project(Risk Assessment v1)]\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]\nConfiguration\uf0c1\nThere are three primary ways of adding new projects or datasets to Use Cases once they\u2019ve been generated.\nThe easiest method is to directly pass a Use Case to one of the project or dataset creation methods. Passing the use case directly allows for you to finely control what is added to a Use Case in your code. For example, the following code example creates a new Use Case, then creates a new project that is automatically added to the Use Case.\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\nrisk_use_case = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nnew_project = dr.Project.create(\nsourcedata=\"/foo/bar/risk_data.csv\",\nproject_name=\"Risk Assessment v1\",\nuse_case=risk_use_case\n)\nrisk_use_case.list_projects()\n>>> [Project(Risk Assessment v1)]\nYou can also use a context manager to perform a series of actions that automatically result in projects or datasets being added to a Use Case without having to manually pass the Use Case yourself. This can be extremely useful if you have a series of calls you want to make that all should be added to a Use Case. For example:\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\nrisk_use_case = dr.UseCase.create(\nname=\"Financial Risk Experimentation Environment\",\ndescription=\"For running experiments on modeling financial risks to our business.\",\n)\nwith risk_use_case:\nnew_dataset = dr.Dataset.create_from_file(\nfile_path=\"/foo/bar/risk_data.csv\",\n)\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]\nYou can also set a global Use Case to automatically add all project and dataset instances that are created by your code. This is useful if all of the work you are doing should be contained in a single Use Case, but risks accidentally adding projects and datasets that should not be included in your Use Case. Setting a global default Use Case requires knowing the ID of your Use Case ahead of time. For example:\nimport datarobot as dr\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\", default_use_case=\"639ce542862e9b1b1bfa8f1b\")\nnew_dataset = dr.Dataset.create_from_file(file_path=\"/foo/bar/risk_data.csv\")\nrisk_use_case = dr.UseCase.get(id=\"639ce542862e9b1b1bfa8f1b\")\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]\nSharing\uf0c1\nOverview\uf0c1\nInstances of datarobot.models.sharing.SharingRole can be created to define a new role grant (or revocation).\nThe UseCase.share() instance method takes a list of SharingRole as its only argument. Calling this method\nwill apply the list of SharingRoles to the given UseCase.\nUse Cases support SHARING_ROLE.OWNER, SHARING_ROLE.EDITOR, SHARING_ROLE.CONSUMER and SHARING_ROLE.NO_ROLE as possible role designations (see datarobot.enums.SHARING_ROLE).\nCurrently, the only supported SHARING_RECIPIENT_TYPE is USER.\nExamples\uf0c1\nSuppose you had a list of user IDs you wanted to share this Use Case with. You could use\na loop to generate a list of SharingRole objects for them, and bulk share this Use Case.\n>>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_ids = [\"60912e09fd1f04e832a575c1\", \"639ce542862e9b1b1bfa8f1b\", \"63e185e7cd3a5f8e190c6393\"]\n>>> sharing_roles = []\n>>> for user_id in user_ids:\n...     new_sharing_role = SharingRole(\n...         role=SHARING_ROLE.CONSUMER,\n...         share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...         id=user_id,\n...         can_share=True,\n...     )\n...     sharing_roles.append(new_sharing_role)\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=sharing_roles)\nSimilarly, a SharingRole instance can be used to remove a user\u2019s access if the role\nis set to SHARING_ROLE.NO_ROLE, like in this example:\n>>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_to_remove = \"[email\u00a0protected]\"\n... remove_sharing_role = SharingRole(\n...     role=SHARING_ROLE.NO_ROLE,\n...     share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...     username=user_to_remove,\n...     can_share=False,\n... )\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=[remove_sharing_role])\nLooking beyond a Use Case\uf0c1\nUse Cases are a powerful tool for organizing your work, and can help if you need to focus only on those resources\nrelevant to a specific business problem. However, occasionally you may want to look outside of a Use Case\nat other available DataRobot resources. The following code snippet demonstrates how to retrieve all Projects that\nyour user has access to:\nimport datarobot as dr\nfrom datarobot.client import client_configuration\nwith client_configuration(default_use_case=[]):\nall_projects = dr.Project.list()",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/index.html",
        "https://docs.datarobot.com/en/docs/workbench/wb-getstarted/wb-overview.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/use-cases.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "api_reference",
      "code_examples": [
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\n\nrisk_use_case = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nnew_dataset = dr.Dataset.create_from_file(\n    file_path=\"/foo/bar/risk_data.csv\",\n)\n\nrisk_use_case.add(entity=new_dataset)\n\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]",
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\n\nrisk_use_case = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nexisting_application = dr.Application.list()[0]\n\nrisk_use_case.add(entity=existing_application)\n\nrisk_use_case.list_applications()\n>>> [Application(name='Financial Risk Detection')]",
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\n\nrisk_use_case_1 = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nrisk_use_case_2 = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment 2\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nnew_dataset = dr.Dataset.create_from_file(\n    file_path=\"/foo/bar/risk_data.csv\",\n)\n\ndataset_entity = risk_use_case_1.add(entity=new_dataset)\nrisk_use_case_2.add(entity=dataset_entity)\n\nrisk_use_case_2.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]",
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\n\nrisk_use_case = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nnew_dataset = dr.Dataset.create_from_file(\n    file_path=\"/foo/bar/risk_data.csv\",\n    use_case=risk_use_case\n)\n\nrisk_use_case.add(entity=new_dataset)\n\nnew_project = dr.Project.create_from_dataset(\n    dataset_id=new_dataset.dataset_id,\n    project_name=\"Risk Assessment v1\",\n    use_case=risk_use_case\n)\nnew_project.analyze_and_model(target=\"credit_risk\")\n\nrisk_use_case.add(entity=new_project)\n\nrisk_use_case.list_projects()\n>>> [Project(Risk Assessment v1)]\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]",
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\n\nrisk_use_case = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nnew_project = dr.Project.create(\n    sourcedata=\"/foo/bar/risk_data.csv\",\n    project_name=\"Risk Assessment v1\",\n    use_case=risk_use_case\n)\n\nrisk_use_case.list_projects()\n>>> [Project(Risk Assessment v1)]",
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\")\n\nrisk_use_case = dr.UseCase.create(\n    name=\"Financial Risk Experimentation Environment\",\n    description=\"For running experiments on modeling financial risks to our business.\",\n)\n\nwith risk_use_case:\n    new_dataset = dr.Dataset.create_from_file(\n        file_path=\"/foo/bar/risk_data.csv\",\n    )\n\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]",
        "import datarobot as dr\n\ndr.Client(token=\"<token>\", endpoint=\"https://app.datarobot.com/api/v2\", default_use_case=\"639ce542862e9b1b1bfa8f1b\")\n\nnew_dataset = dr.Dataset.create_from_file(file_path=\"/foo/bar/risk_data.csv\")\n\nrisk_use_case = dr.UseCase.get(id=\"639ce542862e9b1b1bfa8f1b\")\nrisk_use_case.list_datasets()\n>>> [Dataset(name='risk_data.csv', id='646e8bb507b108ce7b474b27')]",
        "datarobot.models.sharing.SharingRole",
        "datarobot.enums.SHARING_ROLE",
        ">>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_ids = [\"60912e09fd1f04e832a575c1\", \"639ce542862e9b1b1bfa8f1b\", \"63e185e7cd3a5f8e190c6393\"]\n>>> sharing_roles = []\n>>> for user_id in user_ids:\n...     new_sharing_role = SharingRole(\n...         role=SHARING_ROLE.CONSUMER,\n...         share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...         id=user_id,\n...         can_share=True,\n...     )\n...     sharing_roles.append(new_sharing_role)\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=sharing_roles)",
        ">>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_to_remove = \"[email\u00a0protected]\"\n... remove_sharing_role = SharingRole(\n...     role=SHARING_ROLE.NO_ROLE,\n...     share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...     username=user_to_remove,\n...     can_share=False,\n... )\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=[remove_sharing_role])",
        "import datarobot as dr\nfrom datarobot.client import client_configuration\n\nwith client_configuration(default_use_case=[]):\n    all_projects = dr.Project.list()"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/training_predictions.html",
      "title": "Training predictions\uf0c1",
      "description": "Lazily fetches training predictions from DataRobot API in chunks of specified size and then\niterates rows from responses as named tuples. Each row represents a training prediction\ncomputed for a dataset\u2019s row. Each named tuple has the following structure:",
      "content": "Training predictions\uf0c1\nclass datarobot.models.training_predictions.TrainingPredictionsIterator\uf0c1\nLazily fetches training predictions from DataRobot API in chunks of specified size and then\niterates rows from responses as named tuples. Each row represents a training prediction\ncomputed for a dataset\u2019s row. Each named tuple has the following structure:\nVariables:\nrow_id (int) \u2013 id of the record in original dataset for which training prediction is calculated\npartition_id (str or float) \u2013 The ID of the data partition that the row belongs to. \u201c0.0\u201d corresponds to the validation\npartition or backtest 1.\nprediction (float or str or list of str) \u2013 The model\u2019s prediction for this data row.\nprediction_values (list of dict) \u2013 An array of dictionaries with a schema described as PredictionValue.\ntimestamp (str or None) \u2013 (New in version v2.11) an ISO string representing the time of the prediction\nin time series project; may be None for non-time series projects\nforecast_point (str or None) \u2013 (New in version v2.11) an ISO string representing the point in time\nused as a basis to generate the predictions in time series project;\nmay be None for non-time series projects\nforecast_distance (str or None) \u2013 (New in version v2.11) how many time steps are between the forecast point and the\ntimestamp in time series project; None for non-time series projects\nseries_id (str or None) \u2013 (New in version v2.11) the id of the series in a multiseries project;\nmay be NaN for single series projects; None for non-time series projects\nprediction_explanations (list of dict or None) \u2013 (New in version v2.21) The prediction explanations for each feature. The total elements in\nthe array are bounded by max_explanations and feature count. Only present if prediction\nexplanations were requested. Schema described as PredictionExplanations.\nshap_metadata (dict or None) \u2013 (New in version v2.21) The additional information necessary to understand SHAP based\nprediction explanations. Only present if explanation_algorithm equals\ndatarobot.enums.EXPLANATIONS_ALGORITHM.SHAP was added in compute request. Schema\ndescribed as ShapMetadata.\nNotes\nEach PredictionValue dict contains these keys:\nlabeldescribes what this model output corresponds to. For regression\nprojects, it is the name of the target feature. For classification and multiclass\nprojects, it is a label from the target feature.\nvaluethe output of the prediction. For regression projects, it is the\npredicted value of the target. For classification and multiclass projects, it is\nthe predicted probability that the row belongs to the class identified by the label.\nEach PredictionExplanations dictionary contains these keys:\nlabel (str)describes what output was driven by this prediction explanation. For regression\nprojects, it is the name of the target feature. For classification projects, it is the\nclass whose probability increasing would correspond to a positive strength of this\nprediction explanation.\nfeature (str)the name of the feature contributing to the prediction\nfeature_value (object)the value the feature took on for this row. The type corresponds to the feature\n(boolean, integer, number, string)\nstrength (float)algorithm-specific explanation value attributed to feature in this row\nShapMetadata dictionary contains these keys:\nshap_remaining_total (float)The total of SHAP values for features beyond the max_explanations. This can be\nidentically 0 in all rows, if max_explanations is greater than the number of features\nand thus all features are returned.\nshap_base_value (float)the model\u2019s average prediction over the training data. SHAP values are deviations from\nthe base value.\nwarnings (dict or None)SHAP values calculation warnings (e.g. additivity check failures in XGBoost models).\nSchema described as ShapWarnings.\nShapWarnings dictionary contains these keys:\nmismatch_row_count (int)the count of rows for which additivity check failed\nmax_normalized_mismatch (float)the maximal relative normalized mismatch value\nExamples\nimport datarobot as dr\n# Fetch existing training predictions by their id\ntraining_predictions = dr.TrainingPredictions.get(project_id, prediction_id)\n# Iterate over predictions\nfor row in training_predictions.iterate_rows()\nprint(row.row_id, row.prediction)\nclass datarobot.models.training_predictions.TrainingPredictions\uf0c1\nRepresents training predictions metadata and provides access to prediction results.\nVariables:\nproject_id (str) \u2013 id of the project the model belongs to\nmodel_id (str) \u2013 id of the model\nprediction_id (str) \u2013 id of generated predictions\ndata_subset (datarobot.enums.DATA_SUBSET) \u2013 data set definition used to build predictions.\nChoices are:\ndatarobot.enums.DATA_SUBSET.ALLfor all data available. Not valid for models in datetime partitioned projects.\ndatarobot.enums.DATA_SUBSET.VALIDATION_AND_HOLDOUTfor all data except training set. Not valid for models in datetime partitioned projects.\ndatarobot.enums.DATA_SUBSET.HOLDOUTfor holdout data set only.\ndatarobot.enums.DATA_SUBSET.ALL_BACKTESTSfor downloading the predictions for all backtest validation folds.\nRequires the model to have successfully scored all backtests.\nDatetime partitioned projects only.\nexplanation_algorithm (datarobot.enums.EXPLANATIONS_ALGORITHM) \u2013 (New in version v2.21) Optional. If set to shap, the response will include prediction\nexplanations based on the SHAP explainer (SHapley Additive exPlanations). Defaults to null\n(no prediction explanations).\nmax_explanations (int) \u2013 (New in version v2.21) The number of top contributors that are included in prediction\nexplanations. Max 100. Defaults to null for datasets narrower than 100 columns, defaults to\n100 for datasets wider than 100 columns.\nshap_warnings (list) \u2013 (New in version v2.21) Will be present if explanation_algorithm was set to\ndatarobot.enums.EXPLANATIONS_ALGORITHM.SHAP and there were additivity failures during SHAP\nvalues calculation.\nNotes\nEach element in shap_warnings has the following schema:\npartition_name (str)the partition used for the prediction record.\nvalue (object)the warnings related to this partition.\nThe objects in value are:\nmismatch_row_count (int)the count of rows for which additivity check failed.\nmax_normalized_mismatch (float)the maximal relative normalized mismatch value.\nExamples\nCompute training predictions for a model on the whole dataset\nimport datarobot as dr\n# Request calculation of training predictions\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\ntraining_predictions = training_predictions_job.get_result_when_complete()\nprint('Training predictions {} are ready'.format(training_predictions.prediction_id))\n# Iterate over actual predictions\nfor row in training_predictions.iterate_rows():\nprint(row.row_id, row.partition_id, row.prediction)\nList all training predictions for a project\nimport datarobot as dr\n# Fetch all training predictions for a project\nall_training_predictions = dr.TrainingPredictions.list(project_id)\n# Inspect all calculated training predictions\nfor training_predictions in all_training_predictions:\nprint(\n'Prediction {} is made for data subset \"{}\"'.format(\ntraining_predictions.prediction_id,\ntraining_predictions.data_subset,\n)\n)\nRetrieve training predictions by id\nimport datarobot as dr\n# Getting training predictions by id\ntraining_predictions = dr.TrainingPredictions.get(project_id, prediction_id)\n# Iterate over actual predictions\nfor row in training_predictions.iterate_rows():\nprint(row.row_id, row.partition_id, row.prediction)\nclassmethod list(project_id)\uf0c1\nFetch all the computed training predictions for a project.\nParameters:\nproject_id (str) \u2013 id of the project\nReturn type:\nA list of TrainingPredictions objects\nclassmethod get(project_id, prediction_id)\uf0c1\nRetrieve training predictions on a specified data set.\nParameters:\nproject_id (str) \u2013 id of the project the model belongs to\nprediction_id (str) \u2013 id of the prediction set\nReturns:\nobject which is ready to operate with specified predictions\nReturn type:\nTrainingPredictions\niterate_rows(batch_size=None)\uf0c1\nRetrieve training prediction rows as an iterator.\nParameters:\nbatch_size (Optional[int]) \u2013 maximum number of training prediction rows to fetch per request\nReturns:\niterator \u2013 an iterator which yields named tuples representing training prediction rows\nReturn type:\nTrainingPredictionsIterator\nget_all_as_dataframe(class_prefix='class_', serializer='json')\uf0c1\nRetrieve all training prediction rows and return them as a pandas.DataFrame.\nReturned dataframe has the following structure:\nrow_id : row id from the original dataset\nprediction : the model\u2019s prediction for this row\nclass_<label> : the probability that the target is this class (only appears for\nclassification and multiclass projects)\ntimestamp : the time of the prediction (only appears for out of time validation or\ntime series projects)\nforecast_point : the point in time used as a basis to generate the predictions\n(only appears for time series projects)\nforecast_distance : how many time steps are between timestamp and forecast_point\n(only appears for time series projects)\nseries_id : he id of the series in a multiseries project\nor None for a single series project\n(only appears for time series projects)\nParameters:\nclass_prefix (Optional[str]) \u2013 The prefix to append to labels in the final dataframe. Default is class_\n(e.g., apple -> class_apple)\nserializer (Optional[str]) \u2013 Serializer to use for the download. Options: json (default) or csv.\nReturns:\ndataframe\nReturn type:\npandas.DataFrame\ndownload_to_csv(filename, encoding='utf-8', serializer='json')\uf0c1\nSave training prediction rows into CSV file.\nParameters:\nfilename (str or file object) \u2013 path or file object to save training prediction rows\nencoding (Optional[str]) \u2013 A string representing the encoding to use in the output file, defaults to\n\u2018utf-8\u2019\nserializer (Optional[str]) \u2013 Serializer to use for the download. Options: json (default) or csv.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html"
      ],
      "page_type": "documentation",
      "code_examples": [
        "datarobot.enums.EXPLANATIONS_ALGORITHM.SHAP",
        "import datarobot as dr\n\n# Fetch existing training predictions by their id\ntraining_predictions = dr.TrainingPredictions.get(project_id, prediction_id)\n\n# Iterate over predictions\nfor row in training_predictions.iterate_rows()\n    print(row.row_id, row.prediction)",
        "datarobot.enums.DATA_SUBSET",
        "datarobot.enums.EXPLANATIONS_ALGORITHM",
        "import datarobot as dr\n\n# Request calculation of training predictions\ntraining_predictions_job = model.request_training_predictions(dr.enums.DATA_SUBSET.ALL)\ntraining_predictions = training_predictions_job.get_result_when_complete()\nprint('Training predictions {} are ready'.format(training_predictions.prediction_id))\n\n# Iterate over actual predictions\nfor row in training_predictions.iterate_rows():\n    print(row.row_id, row.partition_id, row.prediction)",
        "import datarobot as dr\n\n# Fetch all training predictions for a project\nall_training_predictions = dr.TrainingPredictions.list(project_id)\n\n# Inspect all calculated training predictions\nfor training_predictions in all_training_predictions:\n    print(\n        'Prediction {} is made for data subset \"{}\"'.format(\n            training_predictions.prediction_id,\n            training_predictions.data_subset,\n        )\n    )",
        "import datarobot as dr\n\n# Getting training predictions by id\ntraining_predictions = dr.TrainingPredictions.get(project_id, prediction_id)\n\n# Iterate over actual predictions\nfor row in training_predictions.iterate_rows():\n    print(row.row_id, row.partition_id, row.prediction)"
      ],
      "success": true,
      "error": ""
    },
    {
      "url": "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/use-cases.html",
      "title": "Use cases\uf0c1",
      "description": "",
      "content": "Use cases\uf0c1\nclass datarobot.UseCase\uf0c1\nRepresentation of a Use Case.\nVariables:\nid (str) \u2013 The ID of the Use Case.\nname (str) \u2013 The name of the Use Case.\ndescription (str) \u2013 The description of the Use Case. Nullable.\ncreated_at (str) \u2013 The timestamp generated at record creation.\ncreated (UseCaseUser) \u2013 The user who created the Use Case.\nupdated_at (str) \u2013 The timestamp generated when the record was last updated.\nupdated (UseCaseUser) \u2013 The most recent user to update the Use Case.\nmodels_count (int) \u2013 The number of models in a Use Case.\nprojects_count (int) \u2013 The number of projects in a Use Case.\ndatasets_count (int) \u2013 The number of datasets in a Use Case.\nnotebooks_count (int) \u2013 The number of notebooks in a Use Case.\napplications_count (int) \u2013 The number of applications in a Use Case.\nplaygrounds_count (int) \u2013 The number of playgrounds in a Use Case.\nvector_databases_count (int) \u2013 The number of vector databases in a Use Case.\nowners (List[UseCaseUser]) \u2013 The most recent user to update the Use Case.\nmembers (List[UseCaseUser]) \u2013 The most recent user to update the Use Case.\nExamples\nimport datarobot\nwith UseCase.get(\"2348ac\"):\nprint(f\"The current use case is {dr.Context.use_case}\")\nget_uri()\uf0c1\nReturns:\nurl \u2013 Permanent static hyperlink to this Use Case.\nReturn type:\nstr\nclassmethod get(use_case_id)\uf0c1\nGets information about a Use Case.\nParameters:\nuse_case_id (str) \u2013 The identifier of the Use Case you want to load.\nReturns:\nuse_case \u2013 The queried Use Case.\nReturn type:\nUseCase\nclassmethod list(search_params=None)\uf0c1\nReturns the Use Cases associated with this account.\nParameters:\nsearch_params (dict, optional.) \u2013 If not None, the returned projects are filtered by lookup.\nNotes\nCurrently, you can query use cases by:\noffset - The number of records to skip over. Default 0.\nlimit - The number of records to return in the range from 1 to 100. Default 100.\nsearch - Only return Use Cases with names that match the given string.\nproject_id - Only return Use Cases associated with the given project ID.\napplication_id - Only return Use Cases associated with the given app.\norderBy - The order to sort the Use Cases.\norderBy queries can use the following options:\nid or -id\nname or -name\ndescription or -description\nprojects_count or -projects_count\ndatasets_count or -datasets_count\nnotebooks_count or -notebooks_count\napplications_count or -applications_count\ncreated_at or -created_at\ncreated_by or -created_by\nupdated_at or -updated_at\nupdated_by or -updated_by\nReturns:\nuse_cases \u2013 Contains a list of Use Cases associated with this user\naccount.\nReturn type:\nlist of UseCase instances\nRaises:\nTypeError \u2013 Raised if search_params parameter is provided,\nbut is not of supported type.\nclassmethod create(name=None, description=None)\uf0c1\nCreate a new Use Case.\nParameters:\nname (str) \u2013 Optional. The name of the new Use Case.\ndescription (str) \u2013 The description of the new Use Case. Optional.\nReturns:\nuse_case \u2013 The created Use Case.\nReturn type:\nUseCase\nclassmethod delete(use_case_id)\uf0c1\nDelete a Use Case.\nParameters:\nuse_case_id (str) \u2013 The ID of the Use Case to be deleted.\nReturn type:\nNone\nupdate(name=None, description=None)\uf0c1\nUpdate a Use Case\u2019s name or description.\nParameters:\nname (str) \u2013 The updated name of the Use Case.\ndescription (str) \u2013 The updated description of the Use Case.\nReturns:\nuse_case \u2013 The updated Use Case.\nReturn type:\nUseCase\nadd(entity=None, entity_type=None, entity_id=None)\uf0c1\nAdd an entity (project, dataset, etc.) to a Use Case. Can only accept either an entity or\nan entity type and entity ID, but not both.\nProjects and Applications can only be linked to a single Use Case. Datasets can be linked to multiple Use Cases.\nThere are some prerequisites for linking Projects to a Use Case which are explained in the\nuser guide.\nParameters:\nentity (Union[UseCaseReferenceEntity, Project, Dataset, Application]) \u2013 An existing entity to be linked to this Use Case.\nCannot be used if entity_type and entity_id are passed.\nentity_type (UseCaseEntityType) \u2013 The entity type of the entity to link to this Use Case. Cannot be used if entity is passed.\nentity_id (str) \u2013 The ID of the entity to link to this Use Case. Cannot be used if entity is passed.\nReturns:\nuse_case_reference_entity \u2013 The newly created reference link between this Use Case and the entity.\nReturn type:\nUseCaseReferenceEntity\nremove(entity=None, entity_type=None, entity_id=None)\uf0c1\nRemove an entity from a Use Case. Can only accept either an entity or\nan entity type and entity ID, but not both.\nParameters:\nentity (Union[UseCaseReferenceEntity, Project, Dataset, Application]) \u2013 An existing entity instance to be removed from a Use Case.\nCannot be used if entity_type and entity_id are passed.\nentity_type (UseCaseEntityType) \u2013 The entity type of the entity to link to this Use Case. Cannot be used if entity is passed.\nentity_id (str) \u2013 The ID of the entity to link to this Use Case.  Cannot be used if entity is passed.\nReturn type:\nNone\nshare(roles)\uf0c1\nShare this Use Case with or remove access from one or more user(s).\nParameters:\nroles (List[SharingRole]) \u2013 A list of SharingRole instances, each of which\nreferences a user and a role to be assigned.\nCurrently, the only supported roles for Use Cases are OWNER, EDITOR, and CONSUMER,\nand the only supported SHARING_RECIPIENT_TYPE is USER.\nTo remove access, set a user\u2019s role to datarobot.enums.SHARING_ROLE.NO_ROLE.\nReturn type:\nNone\nExamples\nThe SharingRole class is needed in order to\nshare a Use Case with one or more users.\nFor example, suppose you had a list of user IDs you wanted to share this Use Case with. You could use\na loop to generate a list of SharingRole objects for them,\nand bulk share this Use Case.\n>>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_ids = [\"60912e09fd1f04e832a575c1\", \"639ce542862e9b1b1bfa8f1b\", \"63e185e7cd3a5f8e190c6393\"]\n>>> sharing_roles = []\n>>> for user_id in user_ids:\n...     new_sharing_role = SharingRole(\n...         role=SHARING_ROLE.CONSUMER,\n...         share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...         id=user_id,\n...     )\n...     sharing_roles.append(new_sharing_role)\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=sharing_roles)\nSimilarly, a SharingRole instance can be used to\nremove a user\u2019s access if the role is set to SHARING_ROLE.NO_ROLE, like in this example:\n>>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_to_remove = \"[email\u00a0protected]\"\n... remove_sharing_role = SharingRole(\n...     role=SHARING_ROLE.NO_ROLE,\n...     share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...     username=user_to_remove,\n... )\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=[remove_sharing_role])\nget_shared_roles(offset=None, limit=None, id=None)\uf0c1\nRetrieve access control information for this Use Case.\nParameters:\noffset (Optional[int]) \u2013 The number of records to skip over. Optional. Default is 0.\nlimit (Optional[int]) \u2013 The number of records to return. Optional. Default is 100.\nid (Optional[str]) \u2013 Return the access control information for a user with this user ID. Optional.\nReturn type:\nList[SharingRole]\nlist_projects()\uf0c1\nList all projects associated with this Use Case.\nReturns:\nprojects \u2013 All projects associated with this Use Case.\nReturn type:\nList[Project]\nlist_datasets()\uf0c1\nList all datasets associated with this Use Case.\nReturns:\ndatasets \u2013 All datasets associated with this Use Case.\nReturn type:\nList[Dataset]\nlist_applications()\uf0c1\nList all applications associated with this Use Case.\nReturns:\napplications \u2013 All applications associated with this Use Case.\nReturn type:\nList[Application]\nclassmethod from_data(data)\uf0c1\nInstantiate an object of this class using a dict.\nParameters:\ndata (dict) \u2013 Correctly snake_cased keys and their values.\nReturn type:\nTypeVar(T, bound= APIObject)\nclassmethod from_server_data(data, keep_attrs=None)\uf0c1\nInstantiate an object of this class using the data directly from the server,\nmeaning that the keys may have the wrong camel casing\nParameters:\ndata (dict) \u2013 The directly translated dict of JSON from the server. No casing fixes have\ntaken place\nkeep_attrs (iterable) \u2013 List, set or tuple of the dotted namespace notations for attributes to keep within the\nobject structure even if their values are None\nReturn type:\nTypeVar(T, bound= APIObject)\nopen_in_browser()\uf0c1\nOpens class\u2019 relevant web browser location.\nIf default browser is not available the URL is logged.\nNote:\nIf text-mode browsers are used, the calling process will block\nuntil the user exits the browser.\nReturn type:\nNone\nclass datarobot.models.use_cases.use_case.UseCaseUser\uf0c1\nRepresentation of a Use Case user.\nVariables:\nid (str) \u2013 The id of the user.\nfull_name (str) \u2013 The full name of the user. Optional.\nemail (str) \u2013 The email address of the user. Optional.\nuserhash (str) \u2013 User\u2019s gravatar hash. Optional.\nusername (str) \u2013 The username of the user. Optional.\nclass datarobot.models.use_cases.use_case.UseCaseReferenceEntity\uf0c1\nAn entity associated with a Use Case.\nVariables:\nentity_type (UseCaseEntityType) \u2013 The type of the entity.\nuse_case_id (str) \u2013 The Use Case this entity is associated with.\nid (str) \u2013 The ID of the entity.\ncreated_at (str) \u2013 The date and time this entity was linked with the Use Case.\nis_deleted (bool) \u2013 Whether or not the linked entity has been deleted.\ncreated (UseCaseUser) \u2013 The user who created the link between this entity and the Use Case.",
      "links": [
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/index.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/reference/use_cases/use_cases.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/en/latest-release/data-registry.html",
        "https://datarobot-public-api-client.readthedocs-hosted.com/cdn-cgi/l/email-protection"
      ],
      "page_type": "documentation",
      "code_examples": [
        "import datarobot\nwith UseCase.get(\"2348ac\"):\n    print(f\"The current use case is {dr.Context.use_case}\")",
        "datarobot.enums.SHARING_ROLE.NO_ROLE",
        ">>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_ids = [\"60912e09fd1f04e832a575c1\", \"639ce542862e9b1b1bfa8f1b\", \"63e185e7cd3a5f8e190c6393\"]\n>>> sharing_roles = []\n>>> for user_id in user_ids:\n...     new_sharing_role = SharingRole(\n...         role=SHARING_ROLE.CONSUMER,\n...         share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...         id=user_id,\n...     )\n...     sharing_roles.append(new_sharing_role)\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=sharing_roles)",
        ">>> from datarobot.models.use_cases.use_case import UseCase\n>>> from datarobot.models.sharing import SharingRole\n>>> from datarobot.enums import SHARING_ROLE, SHARING_RECIPIENT_TYPE\n>>>\n>>> user_to_remove = \"[email\u00a0protected]\"\n... remove_sharing_role = SharingRole(\n...     role=SHARING_ROLE.NO_ROLE,\n...     share_recipient_type=SHARING_RECIPIENT_TYPE.USER,\n...     username=user_to_remove,\n... )\n>>> use_case = UseCase.get(use_case_id=\"5f33f1fd9071ae13568237b2\")\n>>> use_case.share(roles=[remove_sharing_role])"
      ],
      "success": true,
      "error": ""
    }
  ],
  "saved_at": 1755969528.679955
}